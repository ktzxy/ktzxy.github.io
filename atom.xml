<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓝桉`Blog</title>
  <icon>https://www.gravatar.com/avatar/368f34bb36f834f13fea068b8db09c17</icon>
  <subtitle>桑榆非晚,柠月如风.</subtitle>
  <link href="https://ktzxy.github.io/atom.xml" rel="self"/>
  
  <link href="https://ktzxy.github.io/"/>
  <updated>2025-07-13T15:45:18.449Z</updated>
  <id>https://ktzxy.github.io/</id>
  
  <author>
    <name>蓝桉</name>
    <email>kt_zxh@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL数据库150道高频面试题</title>
    <link href="https://ktzxy.github.io/posts/a318ca1f.html"/>
    <id>https://ktzxy.github.io/posts/a318ca1f.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.449Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="1-Mysql-索引"><a href="#1-Mysql-索引" class="headerlink" title="1. Mysql 索引"></a>1. Mysql 索引</h2><h3 id="1-1-Mysql如何实现的索引机制？"><a href="#1-1-Mysql如何实现的索引机制？" class="headerlink" title="1.1. Mysql如何实现的索引机制？"></a>1.1. Mysql如何实现的索引机制？</h3><p>MySQL中索引分三类：B+树索引、Hash索引、全文索引</p><h4 id="1-1-1-InnoDB索引与MyISAM索引实现的区别是什么？"><a href="#1-1-1-InnoDB索引与MyISAM索引实现的区别是什么？" class="headerlink" title="1.1.1. InnoDB索引与MyISAM索引实现的区别是什么？"></a>1.1.1. InnoDB索引与MyISAM索引实现的区别是什么？</h4><ul><li>MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的。<ul><li>在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。</li><li>InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址。<ul><li>MyISAM的表在磁盘上存储在以下文件中：  <code>*.sdi（描述表结构）</code>、<code>*.MYD（数据）</code>，<code>*.MYI（索引）</code></li><li>InnoDB的表在磁盘上存储在以下文件中： <code>.ibd（表结构、索引和数据都存在一起）</code></li></ul></li><li>InnoDB的非聚簇索引data域存储相应记录主键的值 ，而MyISAM索引记录的是地址 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。</li><li>MyISAM的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li><li>InnoDB要求表必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</li></ul></li></ul><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103553.png" alt="image-20220709183820796"></p><h4 id="1-1-2-一个表中如果没有创建索引，那么还会创建B-树吗？"><a href="#1-1-2-一个表中如果没有创建索引，那么还会创建B-树吗？" class="headerlink" title="1.1.2. 一个表中如果没有创建索引，那么还会创建B+树吗？"></a>1.1.2. 一个表中如果没有创建索引，那么还会创建B+树吗？</h4><p>会</p><ul><li>如果有主键会创建聚簇索引</li><li>如果没有主键会生成rowid作为隐式主键</li></ul><h3 id="1-2-说一下B-树索引实现原理（数据结构）"><a href="#1-2-说一下B-树索引实现原理（数据结构）" class="headerlink" title="1.2. 说一下B+树索引实现原理（数据结构）"></a>1.2. 说一下B+树索引实现原理（数据结构）</h3><h4 id="1-2-1-讲义"><a href="#1-2-1-讲义" class="headerlink" title="1.2.1. 讲义"></a>1.2.1. 讲义</h4><p>假设有一个表index_demo，表中有2个INT类型的列，1个CHAR(1)类型的列，c1列为主键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> index_demo(c1 <span class="type">INT</span>,c2 <span class="type">INT</span>,c3 <span class="type">CHAR</span>(<span class="number">1</span>),<span class="keyword">PRIMARY KEY</span>(c1)) ;</span><br></pre></td></tr></table></figure><p>index_demo表的简化的行格式示意图如下：</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103554.png" alt="image-20220709071051043"></p><p>我们只在示意图里展示记录的这几个部分：</p><ul><li><code>record_type：</code>表示记录的类型， 0是普通记录、 2是最小记录、 3 是最大记录、1是B+树非叶子节点记录。</li><li><code>next_record：</code>表示下一条记录的相对位置，我们用箭头来表明下一条记录。</li><li><code>各个列的值：</code>这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</li><li><code>其他信息：</code>除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</li></ul><p>将<code>其他信息</code>项暂时去掉并把它竖起来的效果就是这样：</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103555.png" alt="image-20220709071958145"></p><p>把一些记录放到页里的示意图就是（这里一页就是一个磁盘块，代表一次IO）：</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103556.png" alt="image-20220709072138395"></p><p>name age sex</p><p><code>MySQL InnoDB的默认的页大小是16KB</code>，因此数据存储在磁盘中，可能会占用多个数据页。如果各个页中的记录没有规律，我们就不得不依次遍历所有的数据页。<code>如果我们想快速的定位到需要查找的记录在哪些数据页中</code>，我们可以这样做 ：</p><ul><li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</li><li>给所有的页建立目录项</li></ul><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103557.png" alt="image-20220709073749310"></p><p>以<code>页28</code>为例，它对应<code>目录项2</code> ，这个目录项中包含着该页的<code>页号28</code>以及该页中用户记录的<code>最小主键值 5</code>。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键值快速查找某条记录的功能了。<code>比如：查找主键值为 20 的记录，具体查找过程分两步：</code></p><ol><li>先从目录项中根据二分法快速确定出<code>主键值为20的记录在目录项3中</code>（因为 12 ≤ 20 &lt; 209 ），<code>对应页9</code>。 </li><li>再到页9中根据二分法快速定位到主键值为 20 的用户记录。</li></ol><p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为<code>索引</code> 。 </p><h4 id="1-2-2-InnoDB中的索引方案"><a href="#1-2-2-InnoDB中的索引方案" class="headerlink" title="1.2.2. InnoDB中的索引方案"></a>1.2.2. InnoDB中的索引方案</h4><p>我们新分配一个编号为30的页来专门存储<code>目录项记录</code>，页10、28、9、20专门存储<code>用户记录</code>： </p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103558.png" alt="image-20220709073749310"></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103559.png" alt="img"></p><p><code>目录项记录和普通的用户记录的不同点：</code> </p><ul><li>目录项记录 的 record_type 值是1，而 普通用户记录 的 record_type 值是0。</li><li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，包含很多列，另外还有InnoDB自己添加的隐藏列。</li></ul><p><code>现在查找主键值为 20 的记录，具体查找过程分两步：</code></p><ol><li>先到页30中通过二分法快速定位到对应目录项，因为 12 ≤ 20 &lt; 209 ，就是页9。 </li><li>再到页9中根据二分法快速定位到主键值为 20 的用户记录。</li></ol><p><strong>更复杂的情况如下：</strong></p><p>我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用户记录的主键值在 <code>[1, 320)</code> 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的话，就到页32中查找更详细的目录项记录。<strong>这个数据结构，它的名称是 B+树 。</strong></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103560.png" alt="image-20220709080648851"></p><h4 id="1-2-3-聚簇索引与非聚簇索引b-树实现有什么区别？"><a href="#1-2-3-聚簇索引与非聚簇索引b-树实现有什么区别？" class="headerlink" title="1.2.3. 聚簇索引与非聚簇索引b+树实现有什么区别？"></a>1.2.3. 聚簇索引与非聚簇索引b+树实现有什么区别？</h4><h5 id="1-2-3-1-聚簇索引"><a href="#1-2-3-1-聚簇索引" class="headerlink" title="1.2.3.1. 聚簇索引"></a>1.2.3.1. 聚簇索引</h5><p><strong>特点：</strong></p><ul><li><p><code>索引和数据保存在同一个B+树中</code></p></li><li><p><code>页内的记录</code>是按照<code>主键</code>的大小顺序排成一个<code>单向链表</code> 。</p></li><li><code>页和页之间</code>也是根据页中记录的<code>主键</code>的大小顺序排成一个<code>双向链表</code> 。</li><li>非叶子节点存储的是记录的<code>主键+页号</code>。</li><li>叶子节点存储的是<code>完整的用户记录</code>。</li></ul><p><strong>优点：</strong></p><ul><li>数据访问更快 ，因为<code>索引和数据保存在同一个B+树中</code>，因此从聚簇索引中获取数据比非聚簇索引更快。</li><li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快。</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于<code>数据都是紧密相连</code>，数据库可以从更少的数据块中提取数据，<code>节省了大量的IO操作</code> 。</li></ul><p><strong>缺点：</strong></p><ul><li>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code>。</li><li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义<code>主键为不可更新</code>。</li></ul><p><strong>限制：</strong></p><ul><li>只有InnoDB引擎支持聚簇索引，<code>MyISAM不支持聚簇索引</code>。</li><li>由于数据的物理存储排序方式只能有一种，所以<code>每个MySQL的表只能有一个聚簇索引</code>。</li><li>如果没有为表定义主键，InnoDB会选择<code>非空的唯一索引列代替</code>。如果没有这样的列，InnoDB会<code>隐式的定义一个主键</code>作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇特性，InnoDB中表的<code>主键应选择有序的id</code>，不建议使用无序的id，比如UUID、MD5、HASH、字符串作为主键，无法保证数据的顺序增长。</li></ul><h5 id="1-2-3-2-非聚簇索引"><a href="#1-2-3-2-非聚簇索引" class="headerlink" title="1.2.3.2. 非聚簇索引"></a>1.2.3.2. 非聚簇索引</h5><p><strong>（二级索引、辅助索引）</strong></p><p><code>聚簇索引</code>，只能在搜索条件是<code>主键值</code>时才发挥作用，因为B+树中的数据都是按照主键进行排序的，如果我们想以别的列作为搜索条件，那么需要创建<code>非聚簇索引</code>。</p><p><strong>例如，</strong><code>以c2列作为搜索条件</code>，那么需要使<code>用c2列创建一棵B+树</code>，如下所示：</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103561.png" alt="image-20220709130937991"></p><p><strong>这个B+树与聚簇索引有几处不同：</strong></p><ul><li><code>页内的记录</code>是按照从<code>c2列</code>的大小顺序排成一个<code>单向链表</code> 。</li><li><p><code>页和页之间</code>也是根据页中记录的<code>c2列</code>的大小顺序排成一个<code>双向链表</code> 。</p></li><li><p>非叶子节点存储的是记录的<code>c2列+页号</code>。</p></li><li>叶子节点存储的并不是完整的用户记录，而只是<code>c2列+主键</code>这两个列的值。</li></ul><p><strong>一张表可以有多个非聚簇索引：</strong></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103562.png" alt="image-20220709134109900"></p><h4 id="1-2-4-说一下B-树中聚簇索引的查找（匹配）逻辑"><a href="#1-2-4-说一下B-树中聚簇索引的查找（匹配）逻辑" class="headerlink" title="1.2.4. 说一下B+树中聚簇索引的查找（匹配）逻辑"></a>1.2.4. 说一下B+树中聚簇索引的查找（匹配）逻辑</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103560.png" alt="image-20220709080648851"></p><h4 id="1-2-5-说一下B-树中非聚簇索引的查找（匹配）逻辑"><a href="#1-2-5-说一下B-树中非聚簇索引的查找（匹配）逻辑" class="headerlink" title="1.2.5. 说一下B+树中非聚簇索引的查找（匹配）逻辑"></a>1.2.5. 说一下B+树中非聚簇索引的查找（匹配）逻辑</h4><p><strong>例如：</strong>根据c2列的值查找c2=4的记录，查找过程如下：</p><ol><li>根据<code>根页面44</code>定位到<code>页42</code>（因为<code>2 ≤  4 &lt; 9</code>）</li><li>由于<code>c2列没有唯一性约束</code>，所以c2=4的记录可能分布在多个数据页中，又因为 <code>2 ≤ 4  ≤ 4</code>，所以确定实际存储用户记录的页在<code>页34和页35</code>中。</li><li>在页34和35中<code>定位到具体的记录</code>。</li><li>但是这个B+树的叶子节点<code>只存储了c2和c1（主键）</code>两个列，所以我们必须<code>再根据主键值去聚簇索引中再查找</code>一遍完整的用户记录。</li><li>like 张%</li></ol><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103561.png" alt="image-20220709130937991"></p><h4 id="1-2-6-平衡二叉树，红黑树，B树和B-树的区别是什么？都有哪些应用场景？"><a href="#1-2-6-平衡二叉树，红黑树，B树和B-树的区别是什么？都有哪些应用场景？" class="headerlink" title="1.2.6. 平衡二叉树，红黑树，B树和B+树的区别是什么？都有哪些应用场景？"></a>1.2.6. 平衡二叉树，红黑树，B树和B+树的区别是什么？都有哪些应用场景？</h4><p>平衡二叉树</p><ul><li>基础数据结构</li><li>左右平衡</li><li>高度差大于1会自旋</li><li>每个节点记录一个数据</li></ul><p><strong>平衡二叉树（AVL）</strong></p><p>AVL树全称G.M. Adelson-Velsky和E.M. Landis，这是两个人的人名。</p><p>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。</p><p><code>具有以下特点：</code></p><ul><li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1</li><li>并且左右两个子树都是一棵平衡二叉树。</li></ul><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103563.png" alt="image-20220708235509010"></p><p>AVL的生成演示：<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</a></p><p><strong>AVL的问题</strong></p><p>众所周知，IO操作的效率很低，在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐节点加载（一个节点一次IO）。如果我们利用二叉树作为索引结构，<code>那么磁盘的IO次数和索引树的高度是相关的</code>。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103564.png" alt="image-20220708233351509"></p><p>为了提高查询效率，就需要 减少磁盘IO数 。<code>为了减少磁盘IO的次数，就需要尽量降低树的高度</code> ，需要把原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。针对同样的数据，如果我们把二叉树改成 三叉树：</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103565.png" alt="image-20220708235725124"></p><p>上面的例子中，我们将二叉树变成了三叉树，降低了树的高度。如果能够在一个节点中存放更多的数据，我们还可以进一步减少节点的数量，从而进一步降低树的高度。这就是<code>多叉树</code>。</p><p><strong>普通树的问题</strong></p><ul><li>左子树全部为空，从形式上看，更像一个单链表，不能发挥BST的优势。</li><li><code>解决方案：平衡二叉树(AVL)</code> </li></ul><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103566.png" alt="image-20220708231622916"></p><p>红黑树</p><ul><li>hashmap存储</li><li>两次旋转达到平衡</li><li>分为红黑节点</li></ul><p>在这个棵严格的平台树上又进化为“红黑树”{是一个非严格的平衡树 左子树与右子树的高度差不能超过1}，红黑树的长子树只要不超过短子树的两倍即可！</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103567.png" alt="image-20221027154142690"></p><p>当再次插入7的时候，这棵树就会发生旋转</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103568.png" alt="image-20221027154120483"></p><p><strong>B+ 树和 B 树的差异：</strong></p><ul><li>B+树中非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大值（或最小）。</li><li>B+树中非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树中，非叶子节点既保存索引，也保存数据记录。</li><li>B+树中所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ul><h4 id="1-2-7-一个b-树中大概能存放多少条索引记录？"><a href="#1-2-7-一个b-树中大概能存放多少条索引记录？" class="headerlink" title="1.2.7. 一个b+树中大概能存放多少条索引记录？"></a>1.2.7. 一个b+树中大概能存放多少条索引记录？</h4><ul><li><code>真实环境</code>中一个页存放的记录数量是非常大的（默认16KB），假设指针与键值忽略不计（或看做10个字节），数据占 1 kb 的空间：</li><li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 16 条记录。</li><li>如果B+树有2层，最多能存放 <code>1600×16=25600</code> 条记录。</li><li>如果B+树有3层，最多能存放 <code>1600×1600×16=40960000</code> 条记录。</li><li>如果存储千万级别的数据，只需要三层就够了</li></ul><p><code>B+树的非叶子节点不存储用户记录，只存储目录记录，相对B树每个节点可以存储更多的记录，树的高度会更矮胖，IO次数也会更少。</code></p><h4 id="1-2-8-使用B-树存储的索引crud执行效率如何？"><a href="#1-2-8-使用B-树存储的索引crud执行效率如何？" class="headerlink" title="1.2.8. 使用B+树存储的索引crud执行效率如何？"></a>1.2.8. 使用B+树存储的索引crud执行效率如何？</h4><p>c 新增</p><p>O(lognN)</p><p>N = 高度</p><h4 id="1-2-9-什么是自适应哈希索引？"><a href="#1-2-9-什么是自适应哈希索引？" class="headerlink" title="1.2.9. 什么是自适应哈希索引？"></a>1.2.9. 什么是自适应哈希索引？</h4><p>自适应哈希索引是Innodb引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存中基于B-Tree所有之上再创建一个哈希索引，这就让B-Tree索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置</p><p>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINE INNODB STATUS \G ;</span><br></pre></td></tr></table></figure><p>查看INSERT BUFFER AND ADAPTIVE HASH INDEX</p><h4 id="1-2-10-什么是2-3树-2-3-4树？"><a href="#1-2-10-什么是2-3树-2-3-4树？" class="headerlink" title="1.2.10. 什么是2-3树 2-3-4树？"></a>1.2.10. 什么是2-3树 2-3-4树？</h4><p>多叉树（multiway tree）允许<code>每个节点可以有更多的数据项和更多的子节点</code>。2-3树，2-3-4树就是多叉树，多叉树通过<code>重新组织节点，减少节点数量，增加分叉，减少树的高度</code>，能对二叉树进行优化。</p><p><strong>2-3树</strong></p><p>下面2-3树就是一颗多叉树</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103569.png" alt="image-20220709002223882"></p><p>2-3树具有如下特点：</p><ul><li>2-3树的所有叶子节点都在同一层。</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。</li><li>2-3树是由二节点和三节点构成的树。</li><li>对于三节点的子树的值大小仍然遵守 BST 二叉排序树的规则。</li></ul><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103570.png" alt="image-20220709002554341"></p><p><strong>2-3-4树</strong></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103571.png" alt="image-20220709004531952"></p><h3 id="1-3-为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）"><a href="#1-3-为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）" class="headerlink" title="1.3. 为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）"></a>1.3. 为什么官方建议使用自增长主键作为索引？（说一下自增主键和字符串类型主键的区别和影响）</h3><ul><li>自增主键能够维持底层数据顺序写入</li><li>读取可以由b+树的二分查找定位</li><li>支持范围查找，范围数据自带顺序</li></ul><p>字符串无法完成以上操作</p><h4 id="1-3-1-使用int自增主键后-最大id是10，删除id-10和9，再添加一条记录，最后添加的id是几？删除后重启mysql然后添加一条记录最后id是几？"><a href="#1-3-1-使用int自增主键后-最大id是10，删除id-10和9，再添加一条记录，最后添加的id是几？删除后重启mysql然后添加一条记录最后id是几？" class="headerlink" title="1.3.1. 使用int自增主键后 最大id是10，删除id 10和9，再添加一条记录，最后添加的id是几？删除后重启mysql然后添加一条记录最后id是几？"></a>1.3.1. 使用int自增主键后 最大id是10，删除id 10和9，再添加一条记录，最后添加的id是几？删除后重启mysql然后添加一条记录最后id是几？</h4><p>删除之后</p><ul><li>如果重启，会从最大的id开始递增</li><li>如果没重启，会延续删除之前最大的id开始递增</li></ul><h3 id="1-4-索引的优缺点是什么？"><a href="#1-4-索引的优缺点是什么？" class="headerlink" title="1.4. 索引的优缺点是什么？"></a>1.4. 索引的优缺点是什么？</h3><p><strong>优点</strong></p><p>聚簇（主键）索引：</p><ul><li>顺序读写</li><li>范围快速查找</li><li>范围查找自带顺序</li></ul><p>非聚簇索引：</p><ul><li>条件查询避免全表扫描scan</li><li>范围，排序，分组查询返回行id，排序分组后，再回表查询完整数据，有可能利用顺序读写</li><li>覆盖索引不需要回表操作</li></ul><p><strong>索引的代价</strong></p><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：</p><ul><li><strong>空间上的代价</strong></li></ul><p>每建立一个索引都要为它建立一棵B+树，<code>每一棵B+树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间</code>，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p><ul><li><strong>时间上的代价</strong></li></ul><p><code>每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引</code>。而增、删、改操作可能会对节点和记录的排序造成破坏<code>，所以存储引擎需要额外的时间进行一些记录移位、页面分裂、页面回收等操作来维护好节点和记录的排序。</code>如果我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p><p>B 树和 B+ 树都可以作为索引的数据结构，<strong>在 MySQL 中采用的是 B+ 树。</strong></p><p>但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。</p><h4 id="1-4-1-使用索引一定能提升效率吗？"><a href="#1-4-1-使用索引一定能提升效率吗？" class="headerlink" title="1.4.1. 使用索引一定能提升效率吗？"></a>1.4.1. 使用索引一定能提升效率吗？</h4><p>不一定</p><ul><li>少量数据全表扫描也很快，可以直接获取到全量数据</li><li>唯一索引会影响插入速度，但建议使用</li><li>索引过多会影响更新，插入，删除数据速度</li></ul><h4 id="1-4-2-如果是大段文本内容，如何创建（优化）索引？"><a href="#1-4-2-如果是大段文本内容，如何创建（优化）索引？" class="headerlink" title="1.4.2. 如果是大段文本内容，如何创建（优化）索引？"></a>1.4.2. 如果是大段文本内容，如何创建（优化）索引？</h4><p>B 树和 B+ 树都可以作为索引的数据结构，<strong>在 MySQL 中采用的是 B+ 树。</strong></p><p>第一种方式是分表存储，然后创建索引</p><p>第二是使用es为大文本创建索引</p><h3 id="1-5-什么是聚簇索引？"><a href="#1-5-什么是聚簇索引？" class="headerlink" title="1.5. 什么是聚簇索引？"></a>1.5. 什么是聚簇索引？</h3><p>聚簇索引数据和索引存放在一起组成一个b+树</p><p>参考005题</p><h4 id="1-5-1-一个表中可以有多个（非）聚簇索引吗？"><a href="#1-5-1-一个表中可以有多个（非）聚簇索引吗？" class="headerlink" title="1.5.1. 一个表中可以有多个（非）聚簇索引吗？"></a>1.5.1. 一个表中可以有多个（非）聚簇索引吗？</h4><p>聚簇索引只能有一个</p><p>非聚簇索引可以有多个</p><h4 id="1-5-2-聚簇索引与非聚集索引的特点是什么？"><a href="#1-5-2-聚簇索引与非聚集索引的特点是什么？" class="headerlink" title="1.5.2. 聚簇索引与非聚集索引的特点是什么？"></a>1.5.2. 聚簇索引与非聚集索引的特点是什么？</h4><p>参考005题</p><h4 id="1-5-3-CRUD时聚簇索引与非聚簇索引的区别是什么？"><a href="#1-5-3-CRUD时聚簇索引与非聚簇索引的区别是什么？" class="headerlink" title="1.5.3. CRUD时聚簇索引与非聚簇索引的区别是什么？"></a>1.5.3. CRUD时聚簇索引与非聚簇索引的区别是什么？</h4><ul><li>聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多，因为插入要保证主键不能重复</li><li>聚簇索引范围，排序查找效率高，因为是有序的</li><li>非聚簇索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li></ul><h4 id="1-5-4-非聚簇索引为什么不存数据地址值而存储主键？"><a href="#1-5-4-非聚簇索引为什么不存数据地址值而存储主键？" class="headerlink" title="1.5.4. 非聚簇索引为什么不存数据地址值而存储主键？"></a>1.5.4. 非聚簇索引为什么不存数据地址值而存储主键？</h4><p>因为聚簇索引中有时会引发分页操作、重排操作数据有可能会移动</p><h3 id="1-6-什么是回表操作？"><a href="#1-6-什么是回表操作？" class="headerlink" title="1.6. 什么是回表操作？"></a>1.6. 什么是回表操作？</h3><p>id age name sex</p><p>age -&gt; index</p><p>select * from user where age &gt;20 ;</p><p>第一次 取回id，第二次（回表）根据id拿到完整数据</p><p>select * from user where age &gt;20 ;</p><h4 id="1-6-1-什么是覆盖索引？"><a href="#1-6-1-什么是覆盖索引？" class="headerlink" title="1.6.1. 什么是覆盖索引？"></a>1.6.1. 什么是覆盖索引？</h4><p>id age name sex</p><p>age -&gt; index</p><p>select * from user where age &gt;20 ;</p><p>第一次 取回id，第二次（回表）根据id拿到完整数据</p><p>age,name -&gt; index</p><p>select age from user where age &gt;20 and name like”张%” ;</p><p>覆盖索引不会回表查询，查询效率也是比较高的</p><h4 id="1-6-2-非聚集索引一定回表查询吗"><a href="#1-6-2-非聚集索引一定回表查询吗" class="headerlink" title="1.6.2. 非聚集索引一定回表查询吗?"></a>1.6.2. 非聚集索引一定回表查询吗?</h4><p>不一定，只要b+树中包含的字段（创建索引的字段），覆盖（包含）想要select 的字段，那么就不会回表查询了。</p><h4 id="1-6-3-为什么要回表查询？直接存储数据不可以吗？"><a href="#1-6-3-为什么要回表查询？直接存储数据不可以吗？" class="headerlink" title="1.6.3. 为什么要回表查询？直接存储数据不可以吗？"></a>1.6.3. 为什么要回表查询？直接存储数据不可以吗？</h4><p>为了控制非聚簇索引的大小</p><h4 id="1-6-4-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"><a href="#1-6-4-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？" class="headerlink" title="1.6.4. 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"></a>1.6.4. 如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h4><p>不是，InnoDB会生成rowid辅助回表查询</p><h3 id="1-7-什么是联合索引，组合索引，复合索引？"><a href="#1-7-什么是联合索引，组合索引，复合索引？" class="headerlink" title="1.7. 什么是联合索引，组合索引，复合索引？"></a>1.7. 什么是联合索引，组合索引，复合索引？</h3><p><code>为c2和c3列建立联合索引，</code>如下所示：</p><p>c2，c3 - &gt; index</p><p>c3,c2 -&gt; index</p><p>where c3=? </p><p>全职匹配</p><p>最左前缀</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103572.png" alt="image-20220712002627554"></p><h4 id="1-7-1-复合索引创建时字段顺序不一样使用效果一样吗？"><a href="#1-7-1-复合索引创建时字段顺序不一样使用效果一样吗？" class="headerlink" title="1.7.1. 复合索引创建时字段顺序不一样使用效果一样吗？"></a>1.7.1. 复合索引创建时字段顺序不一样使用效果一样吗？</h4><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 <code>c2和c3列</code> 的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>c2</code>列进行排序。</li><li>在记录的<code>c2</code>列相同的情况下，采用<code>c3</code>列进行排序</li><li>B+树叶子节点处的记录由<code>c2列、c3列和主键c1列组成</code></li><li>本质上也是二级索引</li></ul><p><code>create index idx_c2_c3 on user (c2,c3);</code></p><h3 id="1-8-什么是唯一索引？"><a href="#1-8-什么是唯一索引？" class="headerlink" title="1.8. 什么是唯一索引？"></a>1.8. 什么是唯一索引？</h3><ul><li>随表一起创建索引：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> customer (</span><br><span class="line">    </span><br><span class="line">  id <span class="type">INT</span> UNSIGNED AUTO_INCREMENT,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">PRIMARY KEY</span>(id), <span class="comment">-- 主键索引：列设定为主键后会自动建立索引，唯一且不能为空。</span></span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX uk_no (customer_no), <span class="comment">-- 唯一索引：索引列值必须唯一，允许有NULL值，且NULL可能会出现多次。</span></span><br><span class="line">  KEY idx_name (customer_name), <span class="comment">-- 普通索引：既不是主键，列值也不需要唯一，单纯的为了提高查询速度而创建。</span></span><br><span class="line">  KEY idx_no_name (customer_no,customer_name) <span class="comment">-- 复合索引：即一个索引包含多个列。</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>单独建创索引：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> customer1 (</span><br><span class="line">  id <span class="type">INT</span> UNSIGNED,</span><br><span class="line">  customer_no <span class="type">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  customer_name <span class="type">VARCHAR</span>(<span class="number">200</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER TABLE</span> customer1 <span class="keyword">ADD</span> <span class="keyword">PRIMARY KEY</span> customer1(id); <span class="comment">-- 主键索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_no <span class="keyword">ON</span> customer1(customer_no); <span class="comment">-- 唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> customer1(customer_name);  <span class="comment">-- 普通索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_no_name <span class="keyword">ON</span> customer1(customer_no,customer_name); <span class="comment">-- 复合索引</span></span><br></pre></td></tr></table></figure><h4 id="1-8-1-唯一索引是否影响性能？"><a href="#1-8-1-唯一索引是否影响性能？" class="headerlink" title="1.8.1. 唯一索引是否影响性能？"></a>1.8.1. 唯一索引是否影响性能？</h4><p>是</p><h4 id="1-8-2-什么时候使用唯一索引？"><a href="#1-8-2-什么时候使用唯一索引？" class="headerlink" title="1.8.2. 什么时候使用唯一索引？"></a>1.8.2. 什么时候使用唯一索引？</h4><p>业务需求唯一字段的时候，一般不考虑性能问题</p><p>. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生。</p><h3 id="1-9-什么时候适合创建索引，什么时候不适合创建索引？"><a href="#1-9-什么时候适合创建索引，什么时候不适合创建索引？" class="headerlink" title="1.9. 什么时候适合创建索引，什么时候不适合创建索引？"></a>1.9. 什么时候适合创建索引，什么时候不适合创建索引？</h3><p>适合创建索引</p><ul><li><p>频繁作为where条件语句查询字段</p></li><li><p>关联字段需要建立索引</p></li><li><p>排序字段可以建立索引</p></li><li><p>分组字段可以建立索引(因为分组前提是排序)</p></li><li><p>统计字段可以建立索引（如.count(),max()）</p></li></ul><p>不适合创建索引</p><ul><li><p>频繁更新的字段不适合建立索引</p></li><li><p>where，分组，排序中用不到的字段不必要建立索引</p></li><li><p>可以确定表数据非常少不需要建立索引</p></li><li><p>参与mysql函数计算的列不适合建索引</p></li></ul><p>创建索引时避免有如下极端误解：</p><p> 1）宁滥勿缺。认为一个查询就需要建一个索引。 </p><p>2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 </p><p>3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p><h3 id="1-10-什么是索引下推？"><a href="#1-10-什么是索引下推？" class="headerlink" title="1.10. 什么是索引下推？"></a>1.10. 什么是索引下推？</h3><p>5.6之前的版本是没有索引下推这个优化的</p><p><strong>Using index condition：</strong>叫作  <code>Index Condition Pushdown Optimization （索引下推优化）</code></p><ul><li><code>如果没有索引下推（ICP）</code>，那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>主键值进行回表</code>，返回完整的记录给server层，server层再判断其他的搜索条件是否成立。如果成立则保留该记录，否则跳过该记录，然后向存储引擎层要下一条记录。</li><li><code>如果使用了索引下推（ICP</code>），那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>不着急执行回表</code>，而是在这条记录上先判断一下所有关于<code>idx_content1</code>索引中包含的条件是否成立，也就是<code>content1 &gt; &#39;z&#39; AND content1 LIKE &#39;%a&#39;</code>是否成立。如果这些条件不成立，则直接跳过该二级索引记录，去找下一条二级索引记录；如果这些条件成立，则执行回表操作，返回完整的记录给server层。</li></ul><p>总结：</p><p>未开启索引下推：</p><ul><li>根据筛选条件在索引树中筛选第一个条件</li><li>获得结果集后回表操作</li><li>进行其他条件筛选</li><li>再次回表查询</li></ul><p>开启索引下推：在条件查询时，当前索引树如果满足全部筛选条件，可以在当前树中完成全部筛选过滤，得到比较小的结果集再进行回表操作</p><h3 id="1-11-有哪些情况会导致索引失效？"><a href="#1-11-有哪些情况会导致索引失效？" class="headerlink" title="1.11. 有哪些情况会导致索引失效？"></a>1.11. 有哪些情况会导致索引失效？</h3><ul><li>计算、函数导致索引失效</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示查询分析</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name  <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">LEFT</span>(emp.name,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><ul><li>LIKE以%，_ 开头索引失效</li></ul><blockquote><p><strong>拓展：Alibaba《Java开发手册》</strong></p><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%ab%&#x27;</span>; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><ul><li>不等于(!= 或者&lt;&gt;)索引失效</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> ;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> SQL_NO_CACHE <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;abc&#x27;</span> ; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><ul><li>IS NOT NULL 失效 和 IS NULL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>当数据库中的数据的索引列的<code>NULL值达到比较高的比例的时候</code>，即使在IS NOT NULL 的情况下 MySQL的查询优化器会选择使用索引，<code>此时type的值是range（范围查询）</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 id&gt;20000 的数据的 name 值改为 NULL</span></span><br><span class="line"><span class="keyword">UPDATE</span> emp <span class="keyword">SET</span> `name` <span class="operator">=</span> <span class="keyword">NULL</span> <span class="keyword">WHERE</span> `id` <span class="operator">&gt;</span> <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行查询分析，可以发现 IS NOT NULL 使用了索引</span></span><br><span class="line"><span class="comment">-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br></pre></td></tr></table></figure><ul><li>类型转换导致索引失效</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;123&#x27;</span>; </span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> name<span class="operator">=</span> <span class="number">123</span>; <span class="comment">--索引失效</span></span><br></pre></td></tr></table></figure><ul><li>复合索引未用左列字段失效</li><li>如果mysql觉得全表扫描更快时（数据少）;</li></ul><h4 id="1-11-1-为什么LIKE以-开头索引会失效？"><a href="#1-11-1-为什么LIKE以-开头索引会失效？" class="headerlink" title="1.11.1. 为什么LIKE以%开头索引会失效？"></a>1.11.1. 为什么LIKE以%开头索引会失效？</h4><p>id,name,age</p><p>name 创建索引</p><p>select *  from user where  name like ‘%明’</p><p>type=all</p><p>select name,id  from user where  name like ‘%明’</p><p>type=index</p><p>张明</p><p>(name,age)</p><p>其实并不会完全失效，覆盖索引下会出现type=index，表示遍历了索引树，再回表查询，</p><p>覆盖索引没有生效的时会直接type=all</p><p>没有高效使用索引是因为字符串索引会逐个转换成accii码，生成b+树时按首个字符串顺序排序，类似复合索引未用左列字段失效一样，跳过开始部分也就无法使用生成的b+树了</p><h3 id="1-12-一个表有多个索引的时候，能否手动选择使用哪个索引？"><a href="#1-12-一个表有多个索引的时候，能否手动选择使用哪个索引？" class="headerlink" title="1.12. 一个表有多个索引的时候，能否手动选择使用哪个索引？"></a>1.12. 一个表有多个索引的时候，能否手动选择使用哪个索引？</h3><p>不可用手动直接干预，只能通过mysql优化器自动选择</p><h4 id="1-12-1-如何查看一个表的索引？"><a href="#1-12-1-如何查看一个表的索引？" class="headerlink" title="1.12.1. 如何查看一个表的索引？"></a>1.12.1. 如何查看一个表的索引？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> t_emp; <span class="operator">/</span><span class="operator">/</span> 显示表上的索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_emp <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span> 显示可能会用到的索引及最终使用的索引</span><br></pre></td></tr></table></figure><h4 id="1-12-2-能否查看到索引选择的逻辑？是否使用过optimizer-trace？"><a href="#1-12-2-能否查看到索引选择的逻辑？是否使用过optimizer-trace？" class="headerlink" title="1.12.2. 能否查看到索引选择的逻辑？是否使用过optimizer_trace？"></a>1.12.2. 能否查看到索引选择的逻辑？是否使用过optimizer_trace？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> session optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.OPTIMIZER_TRACE;</span><br><span class="line"><span class="keyword">set</span> session optimizer_trace<span class="operator">=</span>&quot;enabled=off&quot;;</span><br></pre></td></tr></table></figure><h4 id="1-12-3-多个索引优先级是如何匹配的？"><a href="#1-12-3-多个索引优先级是如何匹配的？" class="headerlink" title="1.12.3. 多个索引优先级是如何匹配的？"></a>1.12.3. 多个索引优先级是如何匹配的？</h4><ol><li>主键（唯一索引）匹配</li><li>全值匹配（单值匹配）</li><li>最左前缀匹配</li><li>范围匹配</li><li>索引扫描</li><li>全表扫描</li></ol><p> 一般性建议</p><p>Ø 对于单键索引，尽量选择过滤性更好的索引（例如：手机号，邮件，身份证）</p><p>Ø 在选择组合索引的时候，过滤性最好的字段在索引字段顺序中，位置越靠前越好。</p><p>Ø 选择组合索引时，尽量包含where中更多字段的索引</p><p>Ø 组合索引出现范围查询时，尽量把这个字段放在索引次序的最后面</p><p>Ø 尽量避免造成索引失效的情况</p><h3 id="1-13-使用Order-By时能否通过索引排序？"><a href="#1-13-使用Order-By时能否通过索引排序？" class="headerlink" title="1.13. 使用Order By时能否通过索引排序？"></a>1.13. 使用Order By时能否通过索引排序？</h3><p>没有过滤条件不走索引</p><h4 id="1-13-1-通过索引排序内部流程是什么？"><a href="#1-13-1-通过索引排序内部流程是什么？" class="headerlink" title="1.13.1. 通过索引排序内部流程是什么？"></a>1.13.1. 通过索引排序内部流程是什么？</h4><p>select name,id  from user where  name like ‘%明’ order by name；</p><p>select name,id，age  from user where  name like ‘%明’</p><p>关键配置：</p><ul><li>sort_buffer可供排序的内存缓冲区大小</li><li>max_length_for_sort_data 单行所有字段总和限制，超过这个大小启动双路排序</li></ul><ol><li>通过索引检过滤筛选条件索到需要排序的字段+其他字段（如果是符合索引）</li><li>判断索引内容是否覆盖select的字段<ol><li>如果覆盖索引，select的字段和排序都在索引上，那么在内存中进行排序，排序后输出结果</li><li>如果索引没有覆盖查询字段，接下来计算select的字段是否超过max_length_for_sort_data限制，如果超过，启动双路排序，否则使用单路</li></ol></li></ol><h4 id="1-13-2-什么是双路排序和单路排序"><a href="#1-13-2-什么是双路排序和单路排序" class="headerlink" title="1.13.2. 什么是双路排序和单路排序"></a>1.13.2. 什么是双路排序和单路排序</h4><p>单路排序：一次取出所有字段进行排序，内存不够用的时候会使用磁盘</p><p>双路排序：取出排序字段进行排序，排序完成后再次回表查询所需要的其他字段</p><p>如果不在索引列上，filesort有两种算法： mysql就要启动双路排序和单路排序</p><p> <strong>双路排序（慢）</strong></p><p>Select id,age,name from stu order by name;</p><ul><li>MySQL 4.1之前是使用双路排序，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li><li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</li><li>取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</li></ul><p><strong>单路排序（快）</strong></p><p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空间， 因为它把每一行都保存在内存中了。</p><p><strong>结论及引申出的问题</strong></p><p> 但是用单路有问题</p><p>在sort_buffer中，单路比多路要多占用很多空间，因为单路是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取sort_buffer容量大小，再排……从而多次I/O。</p><p>单路本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p><p><strong>优化策略</strong></p><ul><li>增大sort_buffer_size参数的设置</li><li>增大max_length_for_sort_data参数的设置</li><li>减少select 后面的查询的字段。 禁止使用select * </li></ul><p><strong>提高Order By的速度</strong> </p><ol><li>Order by时select * 是一个大忌。只Query需要的字段， 这点非常重要。在这里的影响是：<ul><li>当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。</li><li>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。 </li></ul></li><li>尝试提高 sort_buffer_size<ul><li>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程（connection）的 1M-8M之间调整。 MySQL5.7和8.0，InnoDB存储引擎默认值是1048576字节，1MB。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%sort_buffer_size%&#x27;</span>;</span><br></pre></td></tr></table></figure><ol><li>尝试提高 max_length_for_sort_data<ul><li>提高这个参数， 会增加用改进算法的概率。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_length_for_sort_data%&#x27;</span>; </span><br></pre></td></tr></table></figure><ul><li>5.7默认1024字节</li><li>8.0默认4096字节</li></ul><p>但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。如果需要返回的列的总长度大于max_length_for_sort_data，使用双路算法，否则使用单路算法。1024-8192字节之间调整</p><h4 id="1-13-3-group-by-分组和order-by在索引使用上有什么区别？"><a href="#1-13-3-group-by-分组和order-by在索引使用上有什么区别？" class="headerlink" title="1.13.3. group by 分组和order by在索引使用上有什么区别？"></a>1.13.3. group by 分组和order by在索引使用上有什么区别？</h4><p>group by 使用索引的原则几乎跟order by一致 ，唯一区别：</p><ul><li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li><li>group by没有过滤条件，也可以用上索引。Order By 必须有过滤条件才能使用上索引。</li></ul><h3 id="1-14-如果表中有字段为null，又被经常查询该不该给这个字段创建索引？"><a href="#1-14-如果表中有字段为null，又被经常查询该不该给这个字段创建索引？" class="headerlink" title="1.14. 如果表中有字段为null，又被经常查询该不该给这个字段创建索引？"></a>1.14. 如果表中有字段为null，又被经常查询该不该给这个字段创建索引？</h3><p>应该创建索引，使用的时候尽量使用is null判断。</p><ul><li>IS NOT NULL 失效 和 IS NULL</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM emp WHERE emp.name IS NULL;</span><br><span class="line">EXPLAIN SELECT * FROM emp WHERE emp.name IS NOT NULL; --索引失效</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>当数据库中的数据的索引列的<code>NULL值达到比较高的比例的时候</code>，即使在IS NOT NULL 的情况下 MySQL的查询优化器会选择使用索引，<code>此时type的值是range（范围查询）</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 id&gt;20000 的数据的 name 值改为 NULL</span></span><br><span class="line"><span class="keyword">UPDATE</span> emp <span class="keyword">SET</span> `name` <span class="operator">=</span> <span class="keyword">NULL</span> <span class="keyword">WHERE</span> `id` <span class="operator">&gt;</span> <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行查询分析，可以发现 IS NOT NULL 使用了索引</span></span><br><span class="line"><span class="comment">-- 具体多少条记录的值为NULL可以使索引在IS NOT NULL的情况下生效，由查询优化器的算法决定</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br></pre></td></tr></table></figure><h4 id="1-14-1-有字段为null索引是否会失效？"><a href="#1-14-1-有字段为null索引是否会失效？" class="headerlink" title="1.14.1. 有字段为null索引是否会失效？"></a>1.14.1. 有字段为null索引是否会失效？</h4><p>不一定会失效，每一条sql具体有没有使用索引 可以通过trace追踪一下</p><p>最好还是给上默认值</p><p>数字类型的给0，字符串给个空串“”，</p><p>参考上一题</p><h2 id="2-二-MySQL-内部技术架构"><a href="#2-二-MySQL-内部技术架构" class="headerlink" title="2. 二 MySQL 内部技术架构"></a>2. 二 MySQL 内部技术架构</h2><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103573.png" alt="image-20221028155608009"></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103574.png" alt="img"></p><h3 id="2-1-Mysql内部支持缓存查询吗？"><a href="#2-1-Mysql内部支持缓存查询吗？" class="headerlink" title="2.1. Mysql内部支持缓存查询吗？"></a>2.1. Mysql内部支持缓存查询吗？</h3><p>当MySQL接收到客户端的查询SQL之后，仅仅只需要对其进行相应的权限验证之后，就会通过Query Cache来查找结果，甚至都不需要经过Optimizer模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互</p><p>mysql5.7支持内部缓存，8.0之后就废弃掉了</p><h4 id="2-1-1-mysql8为何废弃掉查询缓存？"><a href="#2-1-1-mysql8为何废弃掉查询缓存？" class="headerlink" title="2.1.1. mysql8为何废弃掉查询缓存？"></a>2.1.1. mysql8为何废弃掉查询缓存？</h4><p>缓存的意义在于快速查询提升系统性能，可以灵活控制缓存的一致性</p><p>mysql缓存的限制</p><ol><li>mysql基本没有手段灵活的管理缓存失效和生效，尤其对于频繁更新的表</li><li>SQL必须完全一致才会导致cache命中</li><li>为了节省内存空间，太大的result set不会被cache (&lt; query_cache_limit)；</li><li>MySQL缓存在分库分表环境下是不起作用的；</li><li>执行SQL里有触发器,自定义函数时，MySQL缓存也是不起作用的；</li><li>在表的结构或数据发生改变时，基于该表相关cache立即全部失效。</li></ol><h4 id="2-1-2-替代方案是什么？"><a href="#2-1-2-替代方案是什么？" class="headerlink" title="2.1.2. 替代方案是什么？"></a>2.1.2. 替代方案是什么？</h4><p>应用层组织缓存，最简单的是使用redis，ehcached等</p><h3 id="2-2-Mysql内部有哪些核心模块组成，作用是什么？"><a href="#2-2-Mysql内部有哪些核心模块组成，作用是什么？" class="headerlink" title="2.2. Mysql内部有哪些核心模块组成，作用是什么？"></a>2.2. Mysql内部有哪些核心模块组成，作用是什么？</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103575.png" alt="image-20220627113443003"></p><p><strong>Connectors（客户端）</strong></p><p>MySQL服务器之外的客户端程序，与具体的语言相关，例如Java中的JDBC，图形用户界面SQLyog等。<code>本质上都是在TCP连接上通过MySQL协议和MySQL服务器进行通信。</code></p><p><strong>MySQL Server（服务器）</strong></p><p><strong>第1层：连接层</strong></p><ul><li>系统（客户端）访问 MySQL 服务器前，做的<code>第一件事就是建立 TCP 连接</code>。</li><li>经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做<code>身份认证、权限获取</code>。<ul><li>用户名或密码不对<code>，会收到一个</code>Access denied for user<code>错误，客户端程序结束执行</code></li><li><code>用户名密码认证通过</code>，会从权限表<code>查出账号拥有的权限</code>与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限</li></ul></li><li>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</li></ul><p><strong>第2层：服务层</strong></p><p><strong>Management Serveices &amp; Utilities： 系统管理和控制工具</strong></p><p><strong>SQL Interface：SQL接口：</strong></p><ul><li><code>接收用户的SQL命令，并且返回用户需要查询的结果。</code>比如SELECT … FROM就是调用SQL Interface </li><li>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</li></ul><p><strong>Parser：解析器：</strong></p><ul><li>在SQL命令传递到解析器的时候会被解析器验证和解析。解析器中SQL 语句进行<code>语法分析、语法解析</code>，并为其创建<code>语法树</code>。</li><li></li></ul><p><strong>语法分析</strong></p><p>语法分析主要是把输入转化成若干个tokens，包含key和非key。</p><p>在分析之后，会得到4个Token，其中有2个key，它们分别是SELECT、FROM。</p><div class="table-container"><table><thead><tr><th>key</th><th>非key</th><th>key</th><th>非key</th></tr></thead><tbody><tr><td>SELECT</td><td>age</td><td>FROM</td><td>user</td></tr></tbody></table></div><ul><li>典型的解析树如下：</li></ul><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103576.png" alt="image-20220702002430362"></p><p><strong>Optimizer：查询优化器：</strong></p><ul><li>SQL语句在语法解析后、查询前会使用查询优化器对查询进行优化，<code>确定SQL语句的执行路径，生成一个执行计划</code>。</li></ul><p><strong>Caches &amp; Buffers： 查询缓存组件：</strong></p><ul><li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、查询优化和执行的整个过程了，直接将结果反馈给客户端。</li><li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li><li>这个查询缓存可以在不同客户端之间共享 。 </li></ul><p><strong>第3层：引擎层</strong></p><p>插件式存储引擎层（ Storage Engines），<code>负责MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信</code>。不同的存储引擎具有的功能不同，管理的表有不同的存储结构，采用的存取算法也不同，这样我们可以根据自己的实际需要进行选取。例如MyISAM引擎和InnoDB引擎。</p><p><strong>存储层</strong></p><p>所有的数据、数据库、表的定义、表的每一行的内容、索引，都是存在<code>文件系统</code> 上，以文件的方式存在，并完成与存储引擎的交互。</p><h3 id="2-3-一条sql发送给mysql后，内部是如何执行的？（说一下-MySQL-执行一条查询语句的内部执行过程？）"><a href="#2-3-一条sql发送给mysql后，内部是如何执行的？（说一下-MySQL-执行一条查询语句的内部执行过程？）" class="headerlink" title="2.3. 一条sql发送给mysql后，内部是如何执行的？（说一下 MySQL 执行一条查询语句的内部执行过程？）"></a>2.3. 一条sql发送给mysql后，内部是如何执行的？（说一下 MySQL 执行一条查询语句的内部执行过程？）</h3><p>1.5、查询流程说明</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103577.png" alt="image-20220627141453944"></p><p><strong>首先，</strong><code>MySQL客户端通过协议与MySQL服务器建连接，通过SQL接口发送SQL语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析。</code>也就是说，在解析查询之前，服务器会先访问查询缓存，如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。</p><p><strong>接下来，</strong><code>MySQL解析器通过关键字将SQL语句进行解析，并生成一棵对应的解析树，</code>解析器使用MySQL语法规则验证和解析SQL语句。例如，它将验证是否使用了错误的关键字，或者使用关键字的顺序是否正确，引号能否前后匹配等；<code>预处理器则根据MySQL规则进一步检查解析树是否合法，</code>例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看是否有歧义等。<code>然后预处理器会进行查询重写，生成一棵新解析树。</code></p><p><strong>接下来，</strong><code>查询优化器将解析树转化成执行计划。</code>MySQL优化程序会对我们的语句做一些优化，如子查询转换为连接、表达式简化等等。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引执行查询，以及表之间的连接顺序是啥样，等等。我们可以使用EXPLAIN语句来查看某个语句的执行计划。</p><p><strong>最后，</strong><code>进入执行器阶段。</code>完成查询优化后，<code>查询执行引擎</code>会按照生成的执行计划调用存储引擎提供的接口执行SQL查询并将结果返回给客户端。在MySQL8以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存，再返回给客户端。</p><p><img src="b44f857a9bdedcd6a2d53a3971fae7db.png" alt="img" /></p><h4 id="2-3-1-MySQL-提示“不存在此列”是执行到哪个节点报出的？"><a href="#2-3-1-MySQL-提示“不存在此列”是执行到哪个节点报出的？" class="headerlink" title="2.3.1. MySQL 提示“不存在此列”是执行到哪个节点报出的？"></a>2.3.1. MySQL 提示“不存在此列”是执行到哪个节点报出的？</h4><p>是在Parser：解析器 分析sql语法的时候检查的列。</p><h3 id="2-4-如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？"><a href="#2-4-如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？" class="headerlink" title="2.4. 如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？"></a>2.4. 如果一张表创建了多个索引，在哪个阶段或模块进行的索引选择？</h3><p>在优化器阶段<strong>Optimizer：查询优化器：</strong></p><h3 id="2-5-MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#2-5-MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="2.5. MySQL 支持哪些存储引擎？默认使用哪个？"></a>2.5. MySQL 支持哪些存储引擎？默认使用哪个？</h3><p>查看MySQL提供什么存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure><p>下面的结果表示MySQL中默认使用的存储引擎是InnoDB，支持事务，行锁，外键，支持分布式事务(XA)，支持保存点(回滚)</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103578.png" alt="image-20220703164220030"></p><p>也可以通过以下语句查看默认的存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%default_storage_engine%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103579.png" alt="image-20220703170334348"></p><h3 id="2-6-Mysql8-0自带哪些存储引擎？分别是做什么的？"><a href="#2-6-Mysql8-0自带哪些存储引擎？分别是做什么的？" class="headerlink" title="2.6. Mysql8.0自带哪些存储引擎？分别是做什么的？"></a>2.6. Mysql8.0自带哪些存储引擎？分别是做什么的？</h3><p><code>1. InnoDB存储引擎</code></p><ul><li><p>InnoDB是MySQL的默认事务型引擎，它被设计用来<code>处理大量的短期(short-lived)事务</code>。可以确保事务的完整提交(Commit)和回滚(Rollback)。</p></li><li><p>除非有非常特别的原因需要使用其他的存储引擎，否则<code>应该优先考虑InnoDB引擎</code>。</p></li><li><p>数据文件结构：</p><ul><li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li></ul></li></ul><ul><li>表名.ibd 存储数据和索引</li></ul><ul><li>InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较 高 ，而且内存大小对性能有决定性的影响。</li></ul><p><code>2. MyISAM存储引擎</code></p><ul><li><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但<code>MyISAM不支持事务和行级锁</code>，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p></li><li><p>优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用。</p></li><li><p>数据文件结构：</p><ul><li>表名.frm 存储表结构</li></ul></li></ul><ul><li>表名.MYD 存储数据</li></ul><ul><li>表名.MYI 存储索引</li></ul><ul><li>MyISAM只缓存索引，不缓存真实数据。</li></ul><p><code>3. Archive引擎</code></p><ul><li><code>Archive档案存储引擎只支持INSERT和SELECT操作</code>。</li><li>Archive表适合日志和数据采集（档案）类应用。</li><li>根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</li></ul><p><code>4. Blackhole引擎</code></p><ul><li><code>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存</code>。</li><li>但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。 </li></ul><p><code>5. CSV引擎</code> </p><ul><li><code>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引</code>。</li><li>CSV引擎可以作为一种数据交换的机制，非常有用。</li><li>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</li></ul><p><code>6. Memory引擎</code></p><ul><li>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。</li><li>Memory表至少比MyISAM表要快一个数量级。</li></ul><p><code>7. Federated引擎</code></p><ul><li><code>Federated引擎是访问其他MySQL服务器的一个代理（跨库关联查询）</code>，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li></ul><h3 id="2-7-MySQL-存储引擎架构了解吗？"><a href="#2-7-MySQL-存储引擎架构了解吗？" class="headerlink" title="2.7. MySQL 存储引擎架构了解吗？"></a>2.7. MySQL 存储引擎架构了解吗？</h3><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html</a></p><p>下面是官方的InnoDB引擎结构图，主要分为内存结构和磁盘结构两大部分。</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103580.png" alt="img"></p><p><strong>内存区域</strong></p><p><strong>Buffer Pool</strong>:在InnoDB访问表记录和索引时会在Buffer Pool的页中缓存，以后使用可以减少磁盘IO操作，提升效率。主要用来缓存热的数据页和索引页。</p><p><strong>Log Buffer</strong>：用来缓存redolog</p><p><strong>Adaptive Hash Index</strong>：自适应哈希索引</p><p><strong>Change Buffer</strong>:它是一种应用在非唯一普通索引页（non-unique secondary index page）不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更（Buffer Changes），等未来数据被读取时，再将数据合并（Merge）恢复到缓冲池中的技术。写缓冲的目的是降低写操作的磁盘IO，提升数据库性能。</p><p><strong>磁盘区域</strong></p><p>磁盘中的结构分为两大类：表空间和重做日志。</p><ul><li>表空间：分为系统表空间(MySQL 目录的 ibdata1 文件)，临时表空间，常规表空间，Undo 表空间以及 file-per-table 表空间(MySQL5.7默认打开file_per_table 配置）。系统表空间又包括了InnoDB数据字典，双写缓冲区(Doublewrite Buffer)，修改缓存(Change Buffer），Undo日志等。</li><li>Redo日志：存储的就是 Log Buffer 刷到磁盘的数据。</li></ul><p>官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html</a></p><h4 id="2-7-1-能否单独为一张表设置存储引擎？"><a href="#2-7-1-能否单独为一张表设置存储引擎？" class="headerlink" title="2.7.1. 能否单独为一张表设置存储引擎？"></a>2.7.1. 能否单独为一张表设置存储引擎？</h4><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p><code>方法1：</code></p><p>设置默认存储引擎：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure><p><code>方法2：</code></p><p>或者修改 my.cnf 文件：vim /etc/my.cnf<br>新增一行：default-storage-engine=MyISAM<br>重启MySQL：systemctl restart mysqld</p><p><code>方法3：</code></p><p>我们可以为 不同的表设置不同的存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名( 建表语句; ) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure><h4 id="2-7-2-阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？"><a href="#2-7-2-阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？" class="headerlink" title="2.7.2. 阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？"></a>2.7.2. 阿里、京东等大厂都有自研的存储引擎，如何开发一套自己的？</h4><p>开发存储引擎并不难，难的是开发出来高效的有意义的存储引擎。</p><p>简单例子可以看一下官方源码中的示例，可以实现一个什么也没做的存储引擎。</p><p>有兴趣可以参考官方文档：<a href="https://dev.mysql.com/doc/dev/mysql-server/latest/">https://dev.mysql.com/doc/dev/mysql-server/latest/</a></p><h3 id="2-8-MyISAM-和-InnoDB-的区别是什么？"><a href="#2-8-MyISAM-和-InnoDB-的区别是什么？" class="headerlink" title="2.8. MyISAM 和 InnoDB 的区别是什么？"></a>2.8. MyISAM 和 InnoDB 的区别是什么？</h3><p>外键 事务 锁</p><div class="table-container"><table><thead><tr><th><strong>对比项</strong></th><th><strong>MyISAM</strong></th><th><strong>InnoDB</strong></th></tr></thead><tbody><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td>行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>关注点</td><td>并发查询，节省资源、消耗少、简单业务</td><td>并发写、事务、多表关系、更大资源</td></tr><tr><td>默认安装</td><td>Y</td><td>Y</td></tr><tr><td>默认使用</td><td>N</td><td>Y</td></tr><tr><td>自带系统表使用</td><td>Y</td><td>N</td></tr></tbody></table></div><h4 id="2-8-1-具体说一下如何做技术选型"><a href="#2-8-1-具体说一下如何做技术选型" class="headerlink" title="2.8.1. 具体说一下如何做技术选型"></a>2.8.1. 具体说一下如何做技术选型</h4><p>除非几乎没有写操作全部都是高频的读操作可以选择MyISAM作为表的存储引擎，其他业务可以一律使用InnoDB。</p><h2 id="3-三-mysql-事务"><a href="#3-三-mysql-事务" class="headerlink" title="3. 三 mysql 事务"></a>3. 三 mysql 事务</h2><h3 id="3-1-什么是数据库事务？事务的特性是什么？"><a href="#3-1-什么是数据库事务？事务的特性是什么？" class="headerlink" title="3.1. 什么是数据库事务？事务的特性是什么？"></a>3.1. 什么是数据库事务？事务的特性是什么？</h3><p><strong>事务</strong>：</p><ul><li><p>是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；</p></li><li><p>这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；</p></li><li><p>事务是一组不可再分割的操作集合（工作逻辑单元）</p></li></ul><p>事务都有 <strong>ACID</strong> 特性</p><h4 id="3-1-1-什么是ACID？"><a href="#3-1-1-什么是ACID？" class="headerlink" title="3.1.1. 什么是ACID？"></a>3.1.1. 什么是ACID？</h4><p><strong>1 、原子性</strong>  atomicity</p><p>过程的保证</p><p><strong>只做一个步骤</strong></p><p>1 给钱</p><p>2 去买</p><p>3 交回来</p><p>事务是数据库的逻辑工作单位，事务中包含的各操作<strong>要么都做，要么都不做</strong> </p><p><strong>2 、一致性</strong>  consistency</p><p>结果的保证</p><p><strong>保证要吃完</strong> 刚张嘴挂了，失去一致性</p><p>事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。<br><strong>3 、隔离性</strong> isolation</p><p>并发事务互相干扰</p><p><strong>不被干扰</strong> 刚张嘴别人塞了东西</p><p>一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。<br><strong>4 、持续性</strong> <strong>永久性</strong> durability</p><p><strong>保存</strong> 吃到肚子里</p><p>也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 </p><h3 id="3-2-并发事务会有哪些问题？"><a href="#3-2-并发事务会有哪些问题？" class="headerlink" title="3.2. 并发事务会有哪些问题？"></a>3.2. 并发事务会有哪些问题？</h3><p>多个事务并发执行一定会产生相互争夺资源的问题</p><h4 id="3-2-1-什么是脏读-丢失修改-不可重复读-幻读"><a href="#3-2-1-什么是脏读-丢失修改-不可重复读-幻读" class="headerlink" title="3.2.1. 什么是脏读 丢失修改 不可重复读 幻读"></a>3.2.1. 什么是脏读 丢失修改 不可重复读 幻读</h4><h4 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h4><p><strong>脏读（Dirty read）</strong></p><p>是一个事务在处理过程中读取了另外一个事务未提交的数据</p><p>当一个事务正在访问数据并且对其进行了修改，但是还没提交事务，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据的修改还没提交到数据库，所以另外一个事务读取的数据就是“<strong>脏数据</strong>”，这种行为就是“<strong>脏读</strong>”，依据“<strong>脏数据</strong>”所做的操作可能是会出现问题的。</p><p><strong>修改丢失（Lost of modify）</strong></p><p><em>是指一个事务读取一个数据时，另外一个数据也访问了该数据，那么在第一个事务修改了这个数据之后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，这种情况就被称为*</em>修改丢失</p><p><strong>不可重复读（Unrepeatableread）</strong></p><p><strong>指在一个事务内多</strong>次读取同一数据<strong>，在这个事务还没结束时，另外一个事务也访问了这个数据并</strong>对这个数据进行了修改<strong>，那么就可能造成第一个事务两次读取的数据不一致，这种情况就被称为</strong>不可重复读。</p><p><strong>幻读（Phantom read）</strong></p><p>是指同一个事务内多次查询返回的结果集总数不一样（比如增加了或者减少了行记录）。</p><p>幻读与不可重复读类似，幻读是指一个事务<strong>读取了几行数据</strong>，这个事务还没结束，接着另外一个事务<strong>插入了一些数据</strong>，在随后的查询中，第一个事务读取到的数据就会<strong>比原本读取到的多</strong>，就好像发生了幻觉一样，所以称为<strong>幻读</strong>。</p><h4 id="3-2-2-不可重复读和幻读有什么区别？"><a href="#3-2-2-不可重复读和幻读有什么区别？" class="headerlink" title="3.2.2. 不可重复读和幻读有什么区别？"></a>3.2.2. 不可重复读和幻读有什么区别？</h4><p>不可重复读 针对的是一份数据的修改</p><p>幻读 针对的是行数修改</p><h3 id="3-3-Mysql是如何避免事务并发问题的？"><a href="#3-3-Mysql是如何避免事务并发问题的？" class="headerlink" title="3.3. Mysql是如何避免事务并发问题的？"></a>3.3. Mysql是如何避免事务并发问题的？</h3><p>避免事务并发问题是需要付出性能代价的，此时和分布式系统设计一样（CAP定理及base理论），为了保证一致性就一定会牺牲性能，要做取舍</p><p>在mysql内部通过加锁的方式实现好了解决方案可供选择，就是配置事务隔离级别</p><h4 id="3-3-1-什么是事务隔离级别？"><a href="#3-3-1-什么是事务隔离级别？" class="headerlink" title="3.3.1. 什么是事务隔离级别？"></a>3.3.1. 什么是事务隔离级别？</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务隔离级别                    脏读     不可重复读(被修改)    幻读（删减）</span><br><span class="line">读未提交（<span class="keyword">read</span>-<span class="keyword">uncommitted</span>）    是        是            是</span><br><span class="line">不可重复读（<span class="keyword">read</span>-<span class="keyword">committed</span>）    否        是            是</span><br><span class="line">可重复读（<span class="keyword">repeatable</span>-<span class="keyword">read</span>）     否        否            是</span><br><span class="line">串行化（<span class="keyword">serializable</span>）          否        否            否</span><br></pre></td></tr></table></figure><h4 id="3-3-2-默认的级别是什么？"><a href="#3-3-2-默认的级别是什么？" class="headerlink" title="3.3.2. 默认的级别是什么？"></a>3.3.2. 默认的级别是什么？</h4><p><code>MySQL InnoDB</code>存储引擎默认的事务隔离级别是<strong>可重复读（REPEATABLE-READ）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySQL 5.7 SELECT @@tx_isolation;</span><br><span class="line">MySQL 8.0 SELECT @@transaction_isolation;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-如何选择事务隔离级别？"><a href="#3-3-3-如何选择事务隔离级别？" class="headerlink" title="3.3.3. 如何选择事务隔离级别？"></a>3.3.3. 如何选择事务隔离级别？</h4><p>隔离级别越低，事务请求的锁越少相应性能也就越高，如没有特殊要求或有错误发生，使用默认的隔离级别即可，如果系统中有高频读写并且对一致性要求高那么就需要比较高的事务隔离级别甚至串行化。</p><h4 id="3-3-4-靠缓存可以提升高事务隔离级别的性能吗？"><a href="#3-3-4-靠缓存可以提升高事务隔离级别的性能吗？" class="headerlink" title="3.3.4. 靠缓存可以提升高事务隔离级别的性能吗？"></a>3.3.4. 靠缓存可以提升高事务隔离级别的性能吗？</h4><p>提升事务级别的目的本质是提供更高的数据一致性，如果前置有缓存，那么缓存只能提供高效读并不能保证数据及时一致性，相反的我们还需要对缓存管理有额外的开销。</p><h3 id="3-4-Mysql事务隔离是如何实现的？"><a href="#3-4-Mysql事务隔离是如何实现的？" class="headerlink" title="3.4. Mysql事务隔离是如何实现的？"></a>3.4. Mysql事务隔离是如何实现的？</h3><p>隔离的实现主要是读写锁和MVCC</p><h4 id="3-4-1-什么是一致性非锁定读和锁定读？"><a href="#3-4-1-什么是一致性非锁定读和锁定读？" class="headerlink" title="3.4.1. 什么是一致性非锁定读和锁定读？"></a>3.4.1. 什么是一致性非锁定读和锁定读？</h4><p><strong>锁定读</strong></p><p>使用到了读写锁</p><p>读写锁是最简单直接的的事务隔离实现方式</p><ul><li>每次读操作需要获取一个共享(读)锁，每次写操作需要获取一个写锁。</li><li>共享锁之间不会产生互斥，共享锁和写锁之间、以及写锁与写锁之间会产生互斥。</li><li>当产生锁竞争时，需要等待其中一个操作释放锁后，另一个操作才能获取到锁。</li></ul><p>锁机制，解决的就是<strong>多个事务同时更新数据</strong>，此时必须要有一个加锁的机制</p><ul><li>行锁（记录锁）：解决的就是<strong>多个事务同时更新一行数据</strong></li><li>间隙锁：解决的就是<strong>多个事务同时更新多行数据</strong></li></ul><p>下列操作属于锁定读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select ... lock in share mode</span><br><span class="line">select ... for update</span><br><span class="line">insert、update、delete</span><br></pre></td></tr></table></figure><p><strong>非锁定读</strong></p><p>v10 -&gt; age=18 </p><p>v11 -&gt;age=19</p><p>v12 -&gt;age=15</p><p>使用mvcc 多版本控制实现</p><h4 id="3-4-2-说一下MVCC内部细节"><a href="#3-4-2-说一下MVCC内部细节" class="headerlink" title="3.4.2. 说一下MVCC内部细节"></a>3.4.2. 说一下MVCC内部细节</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html</a></p><p>Multi-Version Concurrency Control 多版本并发控制，<em>MVCC</em> 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问</p><p>InnoDB是一个多版本的存储引擎。它保存有关已更改行的旧版本的信息，以支持并发和回滚等事务特性。这些信息存储在一个称为回滚段的数据结构中的系统表空间或undo表空间中。参见第14.6.3.4节“撤消表空间”。InnoDB使用回滚段中的信息来执行事务回滚所需的撤消操作。它还使用这些信息构建行的早期版本，以实现一致的读取</p><p>MVCC 的实现依赖于：隐藏字段、Read View、undo log</p><p><strong>隐藏字段</strong></p><ul><li>A 6-byte <code>DB_TRX_ID</code> 用来标识最近一次对本行记录做修改 (insert 、update) 的事务的标识符 ，即最后一次修改本行记录的事务 id。 如果是 delete 操作， 在 InnoDB 存储引擎内部也属于一次 update 操作，即更新行中的一个特殊位 ，将行标识为己删除，并非真正删除。</li><li>A 7-byte <code>DB_ROLL_PTR</code> 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空.</li><li>A 6-byte <code>DB_ROW_ID</code> 如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引.</li></ul><p><strong>Read View</strong></p><p>不同的事务隔离级别中，当有事物在执行过程中修改了数据（更新版本号），在并发事务时需要判断一下版本链中的哪个版本是当前事务可见的。为此InnoDB有了ReadView的概念，使用ReadView来记录和隔离不同事务并发时此记录的哪些版本是对当前访问事物可见的。</p><p><strong>undo log</strong></p><p>除了用来回滚数据，还可以读取可见版本的数据。以此实现非锁定读</p><h4 id="3-4-3-Mysql事务一致性，原子性是如何实现的？"><a href="#3-4-3-Mysql事务一致性，原子性是如何实现的？" class="headerlink" title="3.4.3. Mysql事务一致性，原子性是如何实现的？"></a>3.4.3. Mysql事务一致性，原子性是如何实现的？</h4><p>首先是通过锁和mvcc实现了执行过程中的一致性和原子性</p><p>其次是在灾备方面通过Redo log实现，Redo log会把事务在执行过程中对数据库所做的所有修改都记录下来，在之后系统崩溃重启后可以把事务所做的任何修改都恢复出来。</p><h4 id="3-4-4-Mysql事务的持久性是如何实现的？"><a href="#3-4-4-Mysql事务的持久性是如何实现的？" class="headerlink" title="3.4.4. Mysql事务的持久性是如何实现的？"></a>3.4.4. Mysql事务的持久性是如何实现的？</h4><p>使用Redo log保证了事务的持久性。当事务提交时，必须先将事务的所有日志写入日志文件进行持久化，就是我们常说的WAL(write ahead log)机制，如果出现断电重启便可以从redolog中恢复，如果redolog写入失败那么也就意味着修改失败整个事务也就直接回滚了。</p><h4 id="3-4-5-表级锁和行级锁有什么区别？"><a href="#3-4-5-表级锁和行级锁有什么区别？" class="headerlink" title="3.4.5. 表级锁和行级锁有什么区别？"></a>3.4.5. 表级锁和行级锁有什么区别？</h4><p> 表级锁：串行化（serializable）时，整表加锁，事务访问表数据时需要申请锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用</p><p>行级锁：除了串行化（serializable）时 InnoDB使用的都是行级锁，只锁一行数据，其他行数据不影响，并发能力强。</p><h4 id="3-4-6-什么是行级锁？Mysql如何完成的？"><a href="#3-4-6-什么是行级锁？Mysql如何完成的？" class="headerlink" title="3.4.6. 什么是行级锁？Mysql如何完成的？"></a>3.4.6. 什么是行级锁？Mysql如何完成的？</h4><p>行级锁实现比较复杂不是单纯锁住一行数据，是由mvcc完成的。</p><h4 id="3-4-7-什么是共享锁（读锁）？"><a href="#3-4-7-什么是共享锁（读锁）？" class="headerlink" title="3.4.7. 什么是共享锁（读锁）？"></a>3.4.7. 什么是共享锁（读锁）？</h4><p>共享锁或S锁，其它事务可以继续加共享锁，但不能加排它锁</p><h4 id="3-4-8-什么是排它锁（写锁-独占锁）？"><a href="#3-4-8-什么是排它锁（写锁-独占锁）？" class="headerlink" title="3.4.8. 什么是排它锁（写锁/独占锁）？"></a>3.4.8. 什么是排它锁（写锁/独占锁）？</h4><p>排它锁或X锁，在进行写操作之前要申请并获得，其它事务不能再获得任何锁。</p><h4 id="3-4-9-什么是意向锁？"><a href="#3-4-9-什么是意向锁？" class="headerlink" title="3.4.9. 什么是意向锁？"></a>3.4.9. 什么是意向锁？</h4><p>它分为意向共享锁（IS）和意向排他锁（IX）</p><p>一个事务对一张表的某行添加共享锁前，必须获得对该表一个IS锁或者优先级更高的锁。<br>一个事务对一张表的某行添加排他锁之前，它必须对该表获取一个IX锁。</p><p>意向锁属于表锁，它不与innodb中的行锁冲突，任意两个意向锁之间也不会产生冲突，但是会与表锁（S锁和X锁）产生冲突</p><h4 id="3-4-10-InnoDB支持哪几种锁？"><a href="#3-4-10-InnoDB支持哪几种锁？" class="headerlink" title="3.4.10. InnoDB支持哪几种锁？"></a>3.4.10. InnoDB支持哪几种锁？</h4><p>表锁，行锁，间隙锁，Next-Key锁等</p><p>在Serializable中读加共享锁，写加排他锁，读写互斥</p><p>两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）</p><h4 id="3-4-11-当前读和快照读分别是什么？"><a href="#3-4-11-当前读和快照读分别是什么？" class="headerlink" title="3.4.11. 当前读和快照读分别是什么？"></a>3.4.11. 当前读和快照读分别是什么？</h4><p>当前读 ：在锁定读（使用锁隔离事物）的时候读到的是最新版本的数据</p><p>快照读：可重复读（repeatable-read）下 mvcc生效读取的是数据的快照，并不是最新版本的数据（未提交事物的数据）</p><h3 id="3-5-什么是XA协议？"><a href="#3-5-什么是XA协议？" class="headerlink" title="3.5. 什么是XA协议？"></a>3.5. 什么是XA协议？</h3><p><a href="https://dev.mysql.com/doc/refman/8.0/en/xa.html">https://dev.mysql.com/doc/refman/8.0/en/xa.html</a></p><p>涉及的角色：</p><ul><li>AP（Application Program）：应用程序，定义事务边界（定义事务开始和结束）并访问事务边界内的资源。</li><li>RM（Resource Manger）资源管理器: 管理共享资源并提供外部访问接口。供外部程序来访问数据库等共享资源。此外，RM还具有事务的回滚能力。</li><li>TM（Transaction Manager）事务管理器：TM是分布式事务的协调者，TM与每个RM进行通信，负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</li></ul><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103581.png" alt=""></p><p>具体处理流程：</p><ul><li>应用程序AP向事务管理器TM发起事务请求</li><li>TM调用xa_open()建立同资源管理器的会话</li><li>TM调用xa_start()标记一个事务分支的开头</li><li>AP访问资源管理器RM并定义操作，比如插入记录操作</li><li>TM调用xa_end()标记事务分支的结束</li><li>TM调用xa_prepare()通知RM做好事务分支的提交准备工作。其实就是二阶段提交的提交请求阶段。</li><li>TM调用xa_commit()通知RM提交事务分支，也就是二阶段提交的提交执行阶段。</li><li>TM调用xa_close管理与RM的会话。<ul><li>这些接口一定要按顺序执行，比如xa_start接口一定要在xa_end之前。此外，这里千万要注意的是事务管理器只是标记事务分支并不执行事务，事务操作最终是由应用程序通知资源管理器完成的。另外，我们来总结下XA的接口</li></ul></li><li>xa_start:负责开启或者恢复一个事务分支，并且管理XID到调用线程</li><li>xa_end:负责取消当前线程与事务分支的关系</li><li>xa_prepare:负责询问RM 是否准备好了提交事务分支 xa_commit:通知RM提交事务分支</li><li>xa_rollback:通知RM回滚事务分支</li></ul><h4 id="3-5-1-什么是mysql-xa事务？"><a href="#3-5-1-什么是mysql-xa事务？" class="headerlink" title="3.5.1. 什么是mysql xa事务？"></a>3.5.1. 什么是mysql xa事务？</h4><p>mysql的xa事务分为两部分：</p><ol><li>InnoDB内部本地普通事务操作协调数据写入与log写入两阶段提交</li><li>外部分布式事务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.7 SHOW VARIABLES LIKE &#x27;%innodb_support_xa%&#x27;;</span><br><span class="line">8.0 默认开启无法关闭</span><br></pre></td></tr></table></figure><p>XA 事务语法示例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XA START &#x27;自定义事务id&#x27;;</span><br><span class="line"></span><br><span class="line">SQL语句...</span><br><span class="line"></span><br><span class="line">XA END &#x27;自定义事务id&#x27;;</span><br><span class="line">XA PREPARE &#x27;自定义事务id&#x27;;</span><br><span class="line">XA COMMIT\ROLLBACK &#x27;自定义事务id&#x27;;</span><br></pre></td></tr></table></figure><p>XA PREPARE 执行成功后，事务信息将被持久化。即使会话终止甚至应用服务宕机，只要我们将【自定义事务id】记录下来，后续仍然可以使用它对事务进行 rollback 或者 commit。</p><h4 id="3-5-2-xa事务与普通事务区别是什么？"><a href="#3-5-2-xa事务与普通事务区别是什么？" class="headerlink" title="3.5.2. xa事务与普通事务区别是什么？"></a>3.5.2. xa事务与普通事务区别是什么？</h4><p>xa事务可以跨库或跨服务器，属于分布式事务，同时xa事务还支撑了InnoDB内部日志两阶段记录</p><p>普通事务只能在单库中执行</p><h4 id="3-5-3-什么是2pc-3pc？"><a href="#3-5-3-什么是2pc-3pc？" class="headerlink" title="3.5.3. 什么是2pc 3pc？"></a>3.5.3. 什么是2pc 3pc？</h4><p>两阶段提交协议与3阶段提交协议，额外增加了参与的角色保证分布式事务完成更完善</p><h3 id="3-6-是否使用过select-for-update？会产生哪些操作？"><a href="#3-6-是否使用过select-for-update？会产生哪些操作？" class="headerlink" title="3.6. 是否使用过select for update？会产生哪些操作？"></a>3.6. 是否使用过select for update？会产生哪些操作？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查询库存 = 100  0 扣减库存  = -1 99</span><br><span class="line">记录日志 = log</span><br><span class="line">提交  commit</span><br></pre></td></tr></table></figure><p>select本身是一个查询语句，查询语句是不会产生冲突的一种行为，一般情况下是没有锁的，用select for update 会让select语句产生一个排它锁(X), 这个锁和update的效果一样，会使两个事务无法同时更新一条记录。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-locks-set.html</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/select.html">https://dev.mysql.com/doc/refman/8.0/en/select.html</a></p><ul><li><p>for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。</p></li><li><p>在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。</p></li><li><strong>InnoDB默认是行级别的锁，在筛选条件中当有明确指定主键或唯一索引列的时候，是行级锁。否则是表级别。</strong></li></ul><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> … <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> column_list][WAIT n<span class="operator">|</span>NOWAIT][<span class="keyword">SKIP</span> LOCKED];</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">for</span> <span class="keyword">update</span> 会等待行锁释放之后，返回查询结果。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">for</span> <span class="keyword">update</span> nowait 不等待行锁释放，提示锁冲突，不返回结果</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">for</span> <span class="keyword">update</span> wait <span class="number">5</span> 等待<span class="number">5</span>秒，若行锁仍未释放，则提示锁冲突，不返回结果</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">skip</span> locked 查询返回查询结果，但忽略有行锁的记录</span><br></pre></td></tr></table></figure><h3 id="3-7-说一下mysql死锁的原因和处理方法"><a href="#3-7-说一下mysql死锁的原因和处理方法" class="headerlink" title="3.7. 说一下mysql死锁的原因和处理方法"></a>3.7. 说一下mysql死锁的原因和处理方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">事务 a</span><br><span class="line"></span><br><span class="line">表 t  id=100 更新  加行锁</span><br><span class="line">表 t  id=200 更新  已加锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">事务 b</span><br><span class="line"></span><br><span class="line">表 t  id=200 更新 加行锁</span><br><span class="line">表 t  id=100 更新 已加锁</span><br></pre></td></tr></table></figure><ul><li>死锁与锁等待是两个概念<ul><li>如未开启事务，多个客户端执行的insert操作</li></ul></li><li>当多个事务同时持有和请求同一资源上的锁而产生循环依赖的时候就产生了死锁。</li></ul><p>排查：</p><ul><li>正在运行的任务<ul><li>show full processlist;  找到卡主的进程</li></ul></li><li>解开死锁<ul><li>UNLOCK TABLES ；</li></ul></li><li>查看当前运行的事务<ul><li>SELECT * FROM information_schema.INNODB_TRX;</li></ul></li><li>当前出现的锁<ul><li>SELECT * FROM information_schema.INNODB_LOCKS;</li></ul></li><li>观察错误日志</li><li>查看InnoDB锁状态<ul><li><code>show status like &quot;innodb_row_lock%&quot;;</code></li></ul></li></ul><p>lnnodb_row_lock_current_waits:当前正在等待锁定的数量;<br>lnnodb_row_lock_time :从系统启动到现在锁定的总时间长度，单位ms;<br>Innodb_row_lock_time_avg :每次等待所花平均时间;<br>Innodb_row_lock_time_max:从系统启动到现在等待最长的一次所花的时间;<br>lnnodb_row_lock_waits :从系统启动到现在总共等待的次数。</p><ul><li>kill  id 杀死进程</li></ul><p>解决：</p><ul><li><p>死锁无法避免，上线前要进行严格的压力测试</p></li><li><p>快速失败</p><ul><li>innodb_lock_wait_timeout 行锁超时时间</li></ul></li><li>拆分sql，严禁大事务</li><li>充分利用索引，优化索引，尽量把有风险的事务sql使用上覆盖索，优化where条件前缀匹配，提升查询速度，引减少表锁</li><li>无法避免时：<ul><li>操作多张表时，尽量以相同的顺序来访问避免形成等待环路</li><li>单张表时先排序再操作</li><li>使用排它锁 比如 for update</li></ul></li></ul><h3 id="3-8-Mysql会产生几种日志？"><a href="#3-8-Mysql会产生几种日志？" class="headerlink" title="3.8. Mysql会产生几种日志？"></a>3.8. Mysql会产生几种日志？</h3><ul><li><strong>错误日志（error log）</strong></li></ul><p>error log主要记录MySQL在启动、关闭或者运行过程中的错误信息，在MySQL的配置文件my.cnf中，可以通过log-error=/var/log/mysqld.log 执行mysql错误日志的位置。</p><ul><li><strong>慢查询日志（slow query log）</strong></li></ul><p>0.1秒</p><ul><li>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 </li><li>long_query_time的默认值为10，意思是运行10秒以上的语句。 </li><li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</li><li>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</li><li>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询<strong>日志支持将日志记录写入文件</strong>。</li></ul><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。</p><ul><li><strong>一般查询日志（general log）</strong></li></ul><p>general log 记录了客户端连接信息以及执行的SQL语句信息，通过MySQL的命令</p><ul><li><strong>重写日志（redo log）</strong></li><li><strong>回滚日志（undo log）</strong></li><li><strong>二进制日志（bin log）</strong></li></ul><h4 id="3-8-1-bin-log作用是什么？"><a href="#3-8-1-bin-log作用是什么？" class="headerlink" title="3.8.1. bin log作用是什么？"></a>3.8.1. bin log作用是什么？</h4><p>MySQL的bin log日志是用来记录MySQL中增删改时的记录日志。</p><p>当你的一条sql操作对数据库中的内容进行了更新，就会增加一条bin log日志。查询操作不会记录到bin log中。</p><p>bin log最大的用处就是进行<strong>主从复制，以及数据库的恢复。</strong></p><h4 id="3-8-2-redo-log作用是什么？"><a href="#3-8-2-redo-log作用是什么？" class="headerlink" title="3.8.2. redo log作用是什么？"></a>3.8.2. redo log作用是什么？</h4><p>redo log是一种基于磁盘的数据结构，用来在MySQL宕机情况下将不完整的事务执行数据纠正，redo日志记录事务执行后的状态。</p><p>当事务开始后，redo log就开始产生，并且随着事务的执行不断写入redo log file中。redo log file中记录了xxx页做了xx修改的信息，我们都知道数据库的更新操作会在内存中先执行，最后刷入磁盘。</p><p>redo log就是为了恢复更新了内存但是由于宕机等原因没有刷入磁盘中的那部分数据。</p><h4 id="3-8-3-undo-log作用是什么？"><a href="#3-8-3-undo-log作用是什么？" class="headerlink" title="3.8.3. undo log作用是什么？"></a>3.8.3. undo log作用是什么？</h4><p>undo log主要用来回滚到某一个版本，是一种逻辑日志。</p><p>undo log记录的是修改之前的数据，比如：当delete一条记录时，undolog中会记录一条对应的insert记录，从而保证能恢复到数据修改之前。在执行事务回滚的时候，就可以通过undo log中的记录内容并以此进行回滚。</p><p>undo log还可以提供多版本并发控制下的读取（MVCC）。</p><h3 id="3-9-Mysql日志是否实时写入磁盘？-097-bin-log刷盘机制是如何实现的？098-redo-log刷盘机制是如何实现的？-099-undo-log刷盘机制是如何实现的？"><a href="#3-9-Mysql日志是否实时写入磁盘？-097-bin-log刷盘机制是如何实现的？098-redo-log刷盘机制是如何实现的？-099-undo-log刷盘机制是如何实现的？" class="headerlink" title="3.9. Mysql日志是否实时写入磁盘？ 097  bin log刷盘机制是如何实现的？098  redo log刷盘机制是如何实现的？  099  undo log刷盘机制是如何实现的？"></a>3.9. Mysql日志是否实时写入磁盘？ 097  bin log刷盘机制是如何实现的？098  redo log刷盘机制是如何实现的？  099  undo log刷盘机制是如何实现的？</h3><p>磁盘写入固然是比较慢的。</p><p>参数：sync_binlog</p><p>binlog 写入策略：</p><p><strong>1、sync_binlog=0</strong> 的时候，表示每次提交事务binlog不会马上写入到磁盘，而是先写到page cache,相对于磁盘写入来说写page cache要快得多,不过在Mysql 崩溃的时候会有丢失日志的风险。</p><p><strong>2、sync_binlog=1</strong> 的时候，表示每次提交事务都会执行 fsync 写入到磁盘 ；</p><p><strong>3、sync_binlog的值大于1</strong> 的时候，表示每次提交事务都 先写到page cach，只有等到积累了N个事务之后才fsync 写入到磁盘，同样在此设置下Mysql 崩溃的时候会有丢失N个事务日志的风险。</p><p>很显然三种模式下，sync_binlog=1 是强一致的选择，选择0或者N的情况下在极端情况下就会有丢失日志的风险，具体选择什么模式还是得看系统对于一致性的要求。</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103580.png" alt="img"></p><p><strong>innodb_flush_log_at_trx_commit</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">取值0：每秒（一秒钟内提交的事务）写入磁盘  每秒触发一次缓存日志回写磁盘操作，并调用操作系统fsync刷新IO缓存。</span><br><span class="line">取值1：有事务提交就立即刷盘     每次提交事务都立即调用操作系统fsync刷新IO缓存。</span><br><span class="line">取值2：每次事务提交 都写给操作系统 由系统接管什么时候写入磁盘   每次都把redo log写到系统的page cache中，由系统接管什么时候写入磁盘</span><br></pre></td></tr></table></figure><p>时机顺序： </p><ul><li>1 开启事务</li><li>2 查询数据库中需要更新的字段，加载到内存中 形成数据<strong>脏页</strong></li><li>3 记录undo log到内存缓冲区（用于回滚和mvcc）并关联redo log   -&gt; 可刷盘</li><li>4 记录 redo log到内存缓冲区 （用于失败重放）准备提交事务           -&gt; 可刷盘</li><li>5 修改内存中的脏页数据</li><li>6 提交事务触发redolog刷盘</li><li>7 undo log 和脏页 刷盘</li><li>8 事务成功</li></ul><p><strong>redo log 与 binlog 的两阶段提交</strong></p><p>redo log 的写入拆成了两个步骤：prepare 和 commit</p><ul><li><strong>prepare</strong>：redolog写入log buffer，并fsync持久化到磁盘，在redolog事务中记录2PC的XID，在redolog事务打上prepare标识</li><li><strong>commit</strong>：binlog写入log buffer，并fsync持久化到磁盘，在binlog事务中记录2PC的XID，同时在redolog事务打上commit标识</li></ul><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103582.jpg" alt="img"></p><h3 id="3-10-MySQL的binlog有有几种录入格式？分别有什么区别？"><a href="#3-10-MySQL的binlog有有几种录入格式？分别有什么区别？" class="headerlink" title="3.10. MySQL的binlog有有几种录入格式？分别有什么区别？"></a>3.10. MySQL的binlog有有几种录入格式？分别有什么区别？</h3><p>logbin格式：</p><ul><li>binlog_format=STATEMENT（默认）：数据操作的时间，同步时不一致 每一条会修改数据的sql语句会记录到binlog中。优点是并不需要记录每一 条sql语句和每一行的 数据变化，减少了binlog日志量，节约IO，提高性能。缺点是在某些情况下会导致 master-slave 中的数据不一致( 如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会 出    现 问题)</li><li>binlog_format=ROW：批量数据操作时，效率低   不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样 了。而且不会出 现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的 问题。缺 点是会产生大量的日志，尤其是alter table的时候会让日志暴涨。</li><li>binlog_format=MIXED：是以上两种level的混合使用，有函数用ROW，没函数用STATEMENT，但是无法识别系统变量</li></ul><h3 id="3-11-Mysql集群同步时为什么使用binlog？优缺点是什么？"><a href="#3-11-Mysql集群同步时为什么使用binlog？优缺点是什么？" class="headerlink" title="3.11. Mysql集群同步时为什么使用binlog？优缺点是什么？"></a>3.11. Mysql集群同步时为什么使用binlog？优缺点是什么？</h3><ul><li>binlog是mysql提供的日志，所有存储引擎都可用。</li><li>支持增量同步</li><li>binlog还可以供其他中间件读取，比如同步到hdfs中</li><li>如果复制表数据：<ul><li>不支持某个阶段回放</li><li>直接复制数据过程中一旦中断复制（比如断网），很难确定复制的offset</li></ul></li></ul><h2 id="4-四-Mysql开发"><a href="#4-四-Mysql开发" class="headerlink" title="4. 四 Mysql开发"></a>4. 四 Mysql开发</h2><h3 id="4-1-可以使用MySQL直接存储文件吗？"><a href="#4-1-可以使用MySQL直接存储文件吗？" class="headerlink" title="4.1. 可以使用MySQL直接存储文件吗？"></a>4.1. 可以使用MySQL直接存储文件吗？</h3><p>可以使用 BLOB (binary large object)，用来存储二进制大对象的字段类型。</p><p>TinyBlob 255 值的长度加上用于记录长度的1个字节(8位)<br>Blob 65K值的长度加上用于记录长度的2个字节(16位)<br>MediumBlob 16M值的长度加上用于记录长度的3个字节(24位)<br>LongBlob 4G 值的长度加上用于记录长度的4个字节(32位)。</p><h4 id="4-1-1-什么时候存，什么时候不存？"><a href="#4-1-1-什么时候存，什么时候不存？" class="headerlink" title="4.1.1. 什么时候存，什么时候不存？"></a>4.1.1. 什么时候存，什么时候不存？</h4><p>存：需要高效查询并且文件很小的时候</p><p>不存：文件比较大，数据量多或变更频繁的时候</p><h4 id="4-1-2-存储的时候有遇到过什么问题吗？"><a href="#4-1-2-存储的时候有遇到过什么问题吗？" class="headerlink" title="4.1.2. 存储的时候有遇到过什么问题吗？"></a>4.1.2. 存储的时候有遇到过什么问题吗？</h4><ol><li>上传数据过大sql执行失败 调整max_allowed_packet</li><li>主从同步数据时比较慢</li><li>应用线程阻塞</li><li>占用网络带宽</li><li>高频访问的图片无法使用浏览器缓存</li></ol><h4 id="4-1-3-Emoji乱码怎么办？"><a href="#4-1-3-Emoji乱码怎么办？" class="headerlink" title="4.1.3. Emoji乱码怎么办？"></a>4.1.3. Emoji乱码怎么办？</h4><p>使用utf8mb4</p><p>MySQL在5.5.3之后增加了这个utf8mb4的编码，mb4就是most bytes 4的意思，专门用来兼容四字节的unicode。好在utf8mb4是utf8的超集，除了将编码改为utf8mb4外不需要做其他转换。当然，一般情况下使用utf8也就够了。</p><h3 id="4-2-如何存储ip地址？"><a href="#4-2-如何存储ip地址？" class="headerlink" title="4.2. 如何存储ip地址？"></a>4.2. 如何存储ip地址？</h3><ol><li>使用字符串</li><li>使用无符号整型</li></ol><ul><li>4个字节即解决问题</li><li>可以支持范围查询</li><li><strong>INET_ATON()</strong> 和 <strong>INET_NTOA()</strong> ipv6 使用 <strong>INET6_ATON()</strong> 和 <strong>INET6_NTOA()</strong></li></ul><h3 id="4-3-长文本如何存储？"><a href="#4-3-长文本如何存储？" class="headerlink" title="4.3. 长文本如何存储？"></a>4.3. 长文本如何存储？</h3><p>可以使用Text存储</p><p><strong>TINYTEXT(255长度)</strong></p><p><strong>TEXT(65535)</strong></p><p><strong>MEDIUMTEXT（int最大值16M）</strong></p><p><strong>LONGTEXT(long最大值4G)</strong></p><h4 id="4-3-1-大段文本如何设计表结构？"><a href="#4-3-1-大段文本如何设计表结构？" class="headerlink" title="4.3.1. 大段文本如何设计表结构？"></a>4.3.1. 大段文本如何设计表结构？</h4><ol><li>或将大段文本同时存储到搜索引擎</li><li>分表存储</li><li>分表后多段存储</li></ol><h4 id="4-3-2-大段文本查找时如何建立索引？"><a href="#4-3-2-大段文本查找时如何建立索引？" class="headerlink" title="4.3.2. 大段文本查找时如何建立索引？"></a>4.3.2. 大段文本查找时如何建立索引？</h4><ol><li>全文检索，模糊匹配最好存储到搜索引擎中</li><li>指定索引长度</li><li>分段存储后创建索引</li></ol><h4 id="4-3-3-有没有在开发中使用过TEXT-BLOB-数据类型"><a href="#4-3-3-有没有在开发中使用过TEXT-BLOB-数据类型" class="headerlink" title="4.3.3. 有没有在开发中使用过TEXT,BLOB 数据类型"></a>4.3.3. 有没有在开发中使用过TEXT,BLOB 数据类型</h4><p> BLOB 之前做ERP的时候使用过，互联网项目一般不用BLOB </p><p>TEXT  文献，文章，小说类，新闻，会议内容 等</p><h3 id="4-4-日期，时间如何存取？"><a href="#4-4-日期，时间如何存取？" class="headerlink" title="4.4. 日期，时间如何存取？"></a>4.4. 日期，时间如何存取？</h3><ol><li>使用 TIMESTAMP，DATETIME</li><li>使用字符串</li></ol><h4 id="4-4-1-TIMESTAMP，DATETIME-的区别是什么？"><a href="#4-4-1-TIMESTAMP，DATETIME-的区别是什么？" class="headerlink" title="4.4.1. TIMESTAMP，DATETIME 的区别是什么？"></a>4.4.1. TIMESTAMP，DATETIME 的区别是什么？</h4><p>跨时区的业务使用 TIMESTAMP，TIMESTAMP会有时区转换</p><p>1、两者的存储方式不一样:</p><ul><li>对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。</li><li>而对于DATETIME，不做任何改变，基本上是原样输入和输出。</li></ul><p>2、存储字节大小不同</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>MySQL 5.6.4之前需要存储</th><th>MySQL 5.6.4之后需要存储</th></tr></thead><tbody><tr><td>DATETIME</td><td>8 bytes</td><td>5 bytes + 小数秒存储</td></tr><tr><td>TIMESTAMP</td><td>4 bytes</td><td>4 bytes + 小数秒存储</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>分秒数精度</th><th>存储字节大小</th></tr></thead><tbody><tr><td>0</td><td>0 bytes</td></tr><tr><td>1,2</td><td>1 bytes</td></tr><tr><td>3,4</td><td>2 bytes</td></tr><tr><td>5,6</td><td>3 bytes</td></tr></tbody></table></div><p> 3、两者所能存储的时间范围不一样:</p><ul><li>timestamp 所能存储的时间范围为：’1970-01-01 00:00:01.000000’ 到 ‘2038-01-19 03:14:07.999999’。</li><li>datetime 所能存储的时间范围为：’1000-01-01 00:00:00.000000’ 到 ‘9999-12-31 23:59:59.999999’。</li></ul><h4 id="4-4-2-为什么不使用字符串存储日期？"><a href="#4-4-2-为什么不使用字符串存储日期？" class="headerlink" title="4.4.2. 为什么不使用字符串存储日期？"></a>4.4.2. 为什么不使用字符串存储日期？</h4><p>字符串无法完成数据库内部的范围筛选</p><p>在大数据量存储优化索引时，查询必须加上时间范围</p><h4 id="4-4-3-如果需要使用时间戳-timestamp和int该如何选择？"><a href="#4-4-3-如果需要使用时间戳-timestamp和int该如何选择？" class="headerlink" title="4.4.3. 如果需要使用时间戳 timestamp和int该如何选择？"></a>4.4.3. 如果需要使用时间戳 timestamp和int该如何选择？</h4><p><strong>int</strong> 存储空间小，运算查询效率高，不受时区影响，精度低</p><p><strong>timestamp</strong> 存储空间小，可以使用数据库内部时间函数比如更新，精度高，需要注意时区转换，timestamp更易读</p><p>一般选择timestamp，两者性能差异不明显，本质上存储都是使用的int</p><h3 id="4-5-char与varchar的区别？如何选择？"><a href="#4-5-char与varchar的区别？如何选择？" class="headerlink" title="4.5. char与varchar的区别？如何选择？"></a>4.5. char与varchar的区别？如何选择？</h3><p>1.char的优点是存储空间固定（最大255），没有碎片，尤其更新比较频繁的时候，方便数据文件指针的操作，所以存储读取速度快。缺点是空间冗余，对于数据量大的表，非固定长度属性使用char字段，空间浪费。</p><p>2.varchar字段，存储的空间根据存储的内容变化，空间长度为L+size，存储内容长度加描述存储内容长度信息，优点就是空间节约，缺点就是读取和存储时候，需要读取信息计算下标，才能获取完整内容。</p><h3 id="4-6-财务计算有没有出现过错乱？"><a href="#4-6-财务计算有没有出现过错乱？" class="headerlink" title="4.6. 财务计算有没有出现过错乱？"></a>4.6. 财务计算有没有出现过错乱？</h3><p>第一类：锁包括多线程，数据库，UI展示后超时提交等</p><p>第二类：应用与数据库浮点运算精度丢失</p><ol><li>应用开发问题：多线程共享数据读写，</li><li>之前有过丢失精度的问题，使用decimal解决</li><li>使用乘法替换除法</li><li>使用事务保证acid特性</li><li>更新时使用悲观锁 SELECT … FOR UPDATE</li><li>数据只有标记删除</li><li>记录详细日志方便溯源</li></ol><h4 id="4-6-1-117-decimal与float-double的区别是什么？"><a href="#4-6-1-117-decimal与float-double的区别是什么？" class="headerlink" title="4.6.1. 117 decimal与float,double的区别是什么？"></a>4.6.1. 117 decimal与float,double的区别是什么？</h4><p>float：浮点型，4字节，32bit。</p><p>double：双精度实型，8字节，64位</p><p>decimal：数字型，128bit，不存在精度损失</p><p>对于声明语法DECIMAL(M,D)，自变量的值范围如下：</p><ul><li>M是最大位数（精度），范围是1到65。可不指定，默认值是10。</li><li>D是小数点右边的位数（小数位）。范围是0到30，并且不能大于M，可不指定，默认值是0。</li></ul><p>例如字段 salary DECIMAL(5,2)，能够存储具有五位数字和两位小数的任何值，因此可以存储在salary列中的值的范围是从-999.99到999.99。</p><h4 id="4-6-2-118-浮点类型如何选型？为什么？"><a href="#4-6-2-118-浮点类型如何选型？为什么？" class="headerlink" title="4.6.2. 118 浮点类型如何选型？为什么？"></a>4.6.2. 118 浮点类型如何选型？为什么？</h4><ul><li><p>需要不丢失精度的计算使用DECIMAL</p></li><li><p>仅用于展示没有计算的小数存储可以使用字符串存储</p></li><li>低价值数据允许计算后丢失精度可以使用float double</li><li>整型记录不会出现小数的不要使用浮点类型</li></ul><h3 id="4-7-119-预编译sql是什么？"><a href="#4-7-119-预编译sql是什么？" class="headerlink" title="4.7. 119   预编译sql是什么？"></a>4.7. 119   预编译sql是什么？</h3><p>完整解释：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/prepare.html">https://dev.mysql.com/doc/refman/8.0/en/prepare.html</a></p><p>PreparedStatement</p><h4 id="4-7-1-120-预编译sql有什么好处？"><a href="#4-7-1-120-预编译sql有什么好处？" class="headerlink" title="4.7.1. 120 预编译sql有什么好处？"></a>4.7.1. 120 预编译sql有什么好处？</h4><ul><li>预编译sql会被mysql缓存下来</li><li>作用域是每个session，对其他session无效，重新连接也会失效</li><li>提高安全性防止 sql 注入<ul><li>select * from user where id =?</li><li>“1;delete from user where id = 1”;</li></ul></li><li>编译语句有可能被重复调用，也就是说sql相同参数不同在同一session中重复查询执行效率明显比较高</li><li>mysql 5,8 支持服务器端的预编译</li></ul><h3 id="4-8-121-子查询与join哪个效率高？"><a href="#4-8-121-子查询与join哪个效率高？" class="headerlink" title="4.8. 121    子查询与join哪个效率高？"></a>4.8. 121    子查询与join哪个效率高？</h3><p>子查询虽然很灵活，但是执行效率并不高。</p><h4 id="4-8-1-122-为什么子查询效率低？"><a href="#4-8-1-122-为什么子查询效率低？" class="headerlink" title="4.8.1. 122 为什么子查询效率低？"></a>4.8.1. 122 为什么子查询效率低？</h4><p>在执行子查询的时候，MYSQL创建了临时表，查询完毕后再删除这些临时表</p><p>子查询的速度慢的原因是多了一个创建和销毁临时表的过程。<br>而join 则不需要创建临时表 所以会比子查询快一点</p><h4 id="4-8-2-123-join查询可以无限叠加吗？Mysql对join查询有什么限制吗？"><a href="#4-8-2-123-join查询可以无限叠加吗？Mysql对join查询有什么限制吗？" class="headerlink" title="4.8.2. 123 join查询可以无限叠加吗？Mysql对join查询有什么限制吗？"></a>4.8.2. 123 join查询可以无限叠加吗？Mysql对join查询有什么限制吗？</h4><p>建议join不超过3张表关联，mysql对内存敏感，关联过多会占用更多内存空间，使性能下降</p><p>Too many tables; MySQL can only use 61 tables in a join；</p><p>系统限制最多关联61个表</p><h4 id="4-8-3-124-join-查询算法了解吗？"><a href="#4-8-3-124-join-查询算法了解吗？" class="headerlink" title="4.8.3. 124  join 查询算法了解吗？"></a>4.8.3. 124  join 查询算法了解吗？</h4><ul><li>Simple Nested-Loop Join：SNLJ，简单嵌套循环连接</li><li>Index Nested-Loop Join：INLJ，索引嵌套循环连接</li><li>Block Nested-Loop Join：BNLJ，缓存块嵌套循环连接</li></ul><h4 id="4-8-4-125-如何优化过多join查询关联？"><a href="#4-8-4-125-如何优化过多join查询关联？" class="headerlink" title="4.8.4. 125 如何优化过多join查询关联？"></a>4.8.4. 125 如何优化过多join查询关联？</h4><ul><li>适当使用冗余字段减少多表关联查询</li><li>驱动表和被驱动表（小表join大表）</li><li>业务允许的话 尽量使用inner join 让系统帮忙自动选择驱动表</li><li>关联字段一定创建索引</li><li>调整JOIN BUFFER大小</li></ul><h3 id="4-9-126-是否有过mysql调优经验？"><a href="#4-9-126-是否有过mysql调优经验？" class="headerlink" title="4.9. 126    是否有过mysql调优经验？"></a>4.9. 126    是否有过mysql调优经验？</h3><p>调优：</p><ol><li>sql调优</li><li>表（结构）设计调优</li><li>索引调优</li><li>慢查询调优</li><li>操作系统调优</li><li>数据库参数调优</li></ol><h4 id="4-9-1-127-开发中使用过哪些调优工具？"><a href="#4-9-1-127-开发中使用过哪些调优工具？" class="headerlink" title="4.9.1. 127 开发中使用过哪些调优工具？"></a>4.9.1. 127 开发中使用过哪些调优工具？</h4><p>官方自带：</p><ul><li>EXPLAIN </li><li>mysqldumpslow</li><li>show profiles 时间</li><li>optimizer_trace</li></ul><p>第三方：性能诊断工具，参数扫描提供建议，参数辅助优化</p><h4 id="4-9-2-128-如何监控线上环境中执行比较慢的sql？-129-如何分析一条慢sql？"><a href="#4-9-2-128-如何监控线上环境中执行比较慢的sql？-129-如何分析一条慢sql？" class="headerlink" title="4.9.2. 128 如何监控线上环境中执行比较慢的sql？ 129 如何分析一条慢sql？"></a>4.9.2. 128 如何监控线上环境中执行比较慢的sql？ 129 如何分析一条慢sql？</h4><p>开启慢查询日志，收集sql</p><ul><li>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</li><li>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询<strong>日志支持将日志记录写入文件</strong>。</li></ul><p><strong>查看及开启</strong></p><ol><li>默认关闭</li></ol><p><code>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</code></p><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的， </p><p>​                               </p><ol><li>开启：<code>set global     slow_query_log=1;</code> 只对窗口生效，重启服务失效</li></ol><ol><li>慢查询日志记录long_query_time时间</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br></pre></td></tr></table></figure><p>l 全局变量设置，对所有客户端有效。但，必须是设置后进行登录的客户端。</p><p>SET GLOBAL long_query_time=0.1;</p><p>l 对当前会话连接立即生效，对其他客户端无效。</p><p>SET SESSION long_query_time=0.1; #session可省略</p><p>假如运行时间正好等于long_query_time的情况，并不会被记录下来。也就是说，</p><p>在mysql源码里是判断大于long_query_time，而非大于等于。</p><ol><li><p>永久生效</p></li><li><ul><li>修改配置文件my.cnf（其它系统变量也是如此） </li><li>[mysqld]下增加或修改参数</li><li>slow_query_log 和slow_query_log_file后，然后重启MySQL服务器。也即将如下两行配置进my.cnf文件 </li></ul></li></ol><p>slow_query_log =1</p><p>slow_query_log_file=/var/lib/mysql/localhost-slow.log</p><p>long_query_time=3</p><p>log_output=FILE</p><ol><li><ul><li>关于慢查询的参数slow_query_log_file，它指定慢查询日志文件的存放路径，如果不设置，系统默认文件：[host_name]-slow.log</li></ul></li></ol><p><strong>case</strong></p><ul><li>记录慢SQL并后续分析</li></ul><p>SELECT * FROM emp;</p><p>SELECT * FROM emp WHERE deptid &gt; 1;</p><ul><li>查询当前系统中有多少条慢查询记录或者直接看慢查询日志</li></ul><p>/var/lib/mysql/localhost-slow.log</p><p>SHOW GLOBAL STATUS LIKE ‘%Slow_queries%’; </p><p><strong>日志分析工具mysqldumpslow</strong></p><ol><li><p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。</p></li><li><p>查看mysqldumpslow的帮助信息</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a)   mysqldumpslow --help</span><br><span class="line"></span><br><span class="line">·    -a: 将数字抽象成N，字符串抽象成S</span><br><span class="line"></span><br><span class="line">·    -s: 是表示按照何种方式排序；</span><br><span class="line"></span><br><span class="line"> c: 访问次数</span><br><span class="line"></span><br><span class="line"> l: 锁定时间</span><br><span class="line"></span><br><span class="line"> r: 返回记录</span><br><span class="line"></span><br><span class="line"> **t:** **查询时间**</span><br><span class="line"></span><br><span class="line"> al:平均锁定时间</span><br><span class="line"></span><br><span class="line"> ar:平均返回记录数</span><br><span class="line"></span><br><span class="line"> at:平均查询时间</span><br><span class="line"></span><br><span class="line">·    -t: 即为返回前面多少条的数据；</span><br><span class="line"></span><br><span class="line">·    -g: 后边搭配一个正则匹配模式，大小写不敏感的；</span><br><span class="line"></span><br><span class="line">  得到返回记录集最多的10个SQL  mysqldumpslow  -s r -t 10 /var/lib/mysql/localhost-slow.log  得到访问次数最多的10个SQL  mysqldumpslow  -s c -t 10 /var/lib/mysql/localhost-slow.log  得到按照时间排序的前10条里面含有左连接的查询语句  mysqldumpslow  -s t -t 10 -g  &quot;left join&quot;  /var/lib/mysql/localhost-slow.log  另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况  mysqldumpslow  -s r -t 10 /var/lib/mysql/localhost-slow.log | more  </span><br></pre></td></tr></table></figure><h4 id="4-9-3-130-如何查看当前sql使用了哪个索引？"><a href="#4-9-3-130-如何查看当前sql使用了哪个索引？" class="headerlink" title="4.9.3. 130 如何查看当前sql使用了哪个索引？"></a>4.9.3. 130 如何查看当前sql使用了哪个索引？</h4><p>可以使用EXPLAIN，选择索引过程可以使用 optimizer_trace</p><h4 id="4-9-4-131-索引如何进行分析和调优？"><a href="#4-9-4-131-索引如何进行分析和调优？" class="headerlink" title="4.9.4. 131 索引如何进行分析和调优？"></a>4.9.4. 131 索引如何进行分析和调优？</h4><h4 id="4-9-5-132-EXPLAIN关键字中的重要指标有哪些？"><a href="#4-9-5-132-EXPLAIN关键字中的重要指标有哪些？" class="headerlink" title="4.9.5. 132 EXPLAIN关键字中的重要指标有哪些？"></a>4.9.5. 132 EXPLAIN关键字中的重要指标有哪些？</h4><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h3 id="4-10-EXPLAIN是什么"><a href="#4-10-EXPLAIN是什么" class="headerlink" title="4.10. EXPLAIN是什么"></a>4.10. EXPLAIN是什么</h3><p>使用EXPLAIN关键字可以<code>模拟优化器执行SQL查询语句</code>，从而知道MySQL是如何处理你的SQL语句的。<code>分析你的查询语句或是表结构的性能瓶颈</code>。</p><h3 id="4-11-EXPLAIN的用法"><a href="#4-11-EXPLAIN的用法" class="headerlink" title="4.11. EXPLAIN的用法"></a>4.11. EXPLAIN的用法</h3><p><strong>用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="operator">+</span> <span class="keyword">SQL</span>语句</span><br></pre></td></tr></table></figure><p><strong>数据准备：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USE atguigudb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE TABLE</span> t1(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT, content <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, <span class="keyword">PRIMARY KEY</span> (id));</span><br><span class="line"><span class="keyword">CREATE TABLE</span> t2(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT, content <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, <span class="keyword">PRIMARY KEY</span> (id));</span><br><span class="line"><span class="keyword">CREATE TABLE</span> t3(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT, content <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, <span class="keyword">PRIMARY KEY</span> (id));</span><br><span class="line"><span class="keyword">CREATE TABLE</span> t4(id <span class="type">INT</span>(<span class="number">10</span>) AUTO_INCREMENT, content1 <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, content2 <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NULL</span>, <span class="keyword">PRIMARY KEY</span> (id));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_content1 <span class="keyword">ON</span> t4(content1);  <span class="comment">-- 普通索引</span></span><br><span class="line"></span><br><span class="line"># 以下新增<span class="keyword">sql</span>多执行几次，以便演示</span><br><span class="line"><span class="keyword">INSERT INTO</span> t1(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t1_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br><span class="line"><span class="keyword">INSERT INTO</span> t2(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t2_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br><span class="line"><span class="keyword">INSERT INTO</span> t3(content) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t3_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br><span class="line"><span class="keyword">INSERT INTO</span> t4(content1, content2) <span class="keyword">VALUES</span>(CONCAT(<span class="string">&#x27;t4_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)), CONCAT(<span class="string">&#x27;t4_&#x27;</span>,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">1000</span>)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-12-各字段解释"><a href="#4-12-各字段解释" class="headerlink" title="4.12. 各字段解释"></a>4.12. 各字段解释</h3><h4 id="4-12-1-table"><a href="#4-12-1-table" class="headerlink" title="4.12.1. table"></a>4.12.1. table</h4><ul><li><strong>单表：</strong>显示这一行的数据是关于哪张表的</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103583.png" alt="image-20220710101402666"></p><ul><li><strong>多表关联：</strong>t1为驱动表，t2为被驱动表。</li></ul><p><code>注意：</code>内连接时，MySQL性能优化器会自动判断哪个表是驱动表，哪个表示被驱动表，和书写的顺序无关</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103584.png" alt="image-20220711122444380"></p><h4 id="4-12-2-id"><a href="#4-12-2-id" class="headerlink" title="4.12.2. id"></a>4.12.2. id</h4><p>表示查询中执行select子句或操作表的顺序</p><ul><li><strong>id相同：</strong>执行顺序由上至下</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2, t3;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103585.png" alt="image-20220710000757241"></p><ul><li><strong>id不同：</strong>如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> t1.id <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> t1.id <span class="operator">=</span>(</span><br><span class="line">  <span class="keyword">SELECT</span> t2.id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> t2.id <span class="operator">=</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> t3.id <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> t3.content <span class="operator">=</span> <span class="string">&#x27;t3_434&#x27;</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103586.png" alt="image-20220710000950098"></p><p><code>注意：</code>查询优化器可能对涉及子查询的语句进行优化，<code>转为连接查询</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="keyword">IN</span> (<span class="keyword">SELECT</span> content <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> content <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103587.png" alt="image-20220711123408605"></p><ul><li><strong>id为NULL：</strong>最后执行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103588.png" alt="image-20220710001512891"></p><p><strong>小结：</strong></p><ul><li>id如果相同，可以认为是一组，从上往下顺序执行</li><li>在所有组中，id值越大，优先级越高，越先执行</li><li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li></ul><h4 id="4-12-3-select-type"><a href="#4-12-3-select-type" class="headerlink" title="4.12.3. select_type"></a>4.12.3. select_type</h4><p>查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p><ul><li><strong>SIMPLE：</strong>简单查询。查询中不包含子查询或者UNION。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103589.png" alt="image-20220710001930811"></p><ul><li><strong>PRIMARY：</strong>主查询。查询中若包含子查询，则最外层查询被标记为PRIMARY。</li><li><strong>SUBQUERY：</strong>子查询。在SELECT或WHERE列表中包含了子查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> id <span class="operator">=</span> ( <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> content<span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103590.png" alt="image-20220710002145309"></p><ul><li><strong>DEPENDENT SUBQUREY：</strong>如果包含了子查询，并且查询语句不能被优化器转换为连接查询，并且子查询是<code>相关子查询（子查询基于外部数据列）</code>，则子查询就是DEPENDENT SUBQUREY。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> id <span class="operator">=</span> ( <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> content <span class="operator">=</span> t3.content);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103591.png" alt="image-20220710002444782"></p><ul><li><strong>UNCACHEABLE SUBQUREY：</strong>表示这个subquery的查询要受到外部系统变量的影响</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t3 </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> ( <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> content <span class="operator">=</span> @<span class="variable">@character_set_server</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103592.png" alt="image-20220710002604613"></p><ul><li><strong>UNION：</strong>对于包含UNION或者UNION ALL的查询语句，除了最左边的查询是PRIMARY，其余的查询都是UNION。</li><li><strong>UNION RESULT：</strong>UNION会对查询结果进行查询去重，MYSQL会使用临时表来完成UNION查询的去重工作，针对这个临时表的查询就是”UNION RESULT”。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">UNION</span>  </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103593.png" alt="image-20220710003049587"></p><ul><li><strong>DEPENDENT UNION：</strong>子查询中的UNION或者UNION ALL，除了最左边的查询是DEPENDENT SUBQUREY，其余的查询都是DEPENDENT UNION。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> content <span class="keyword">FROM</span> t2 </span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> content <span class="keyword">FROM</span> t3</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103594.png" alt="image-20220710110732730"></p><ul><li><strong>DERIVED：</strong>在包含<code>派生表（子查询在from子句中）</code>的查询中，MySQL会递归执行这些子查询，把结果放在临时表里。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (</span><br><span class="line">   <span class="keyword">SELECT</span> content, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> c <span class="keyword">FROM</span> t1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> content</span><br><span class="line">) <span class="keyword">AS</span> derived_t1 <span class="keyword">WHERE</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>&lt;derived2&gt;</code>就是在id为2的查询中产生的派生表。</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103595.png" alt="image-20220710153504037"></p><p><strong>补充：</strong>MySQL在处理带有派生表的语句时，优先尝试把派生表和外层查询进行合并，如果不行，再把派生表<code>物化掉（执行子查询，并把结果放入临时表）</code>，然后执行查询。下面的例子就是就是将派生表和外层查询进行合并的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="operator">=</span> <span class="string">&#x27;t1_832&#x27;</span>) <span class="keyword">AS</span> derived_t1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103596.png" alt="image-20220710153921679"></p><ul><li><strong>MATERIALIZED：</strong>优化器对于包含子查询的语句，<code>如果选择将子查询物化后再与外层查询连接查询</code>，该子查询的类型就是MATERIALIZED。如下的例子中，查询优化器先将子查询转换成物化表，然后将t1和物化表进行连接查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="keyword">IN</span> (<span class="keyword">SELECT</span> content <span class="keyword">FROM</span> t2);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103597.png" alt="image-20220710155650935"></p><h4 id="4-12-4-partitions"><a href="#4-12-4-partitions" class="headerlink" title="4.12.4. partitions"></a>4.12.4. partitions</h4><p>代表分区表中的命中情况，非分区表，该项为NULL</p><h4 id="4-12-5-type-☆"><a href="#4-12-5-type-☆" class="headerlink" title="4.12.5. type ☆"></a>4.12.5. type <strong>☆</strong></h4><blockquote><p><strong>说明：</strong></p><p>结果值从最好到最坏依次是： </p><p><code>system &gt; const &gt; eq_ref &gt; ref</code> &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <code>range &gt; index &gt; ALL</code> </p><p><code>比较重要的包含：system、const 、eq_ref 、ref、range &gt; index &gt; ALL</code></p><p>SQL 性能优化的目标：至少要达到 <code>range</code> 级别，要求是 <code>ref</code> 级别，最好是 <code>consts</code>级别。（阿里巴巴<br>开发手册要求）</p></blockquote><ul><li><strong>ALL：</strong>全表扫描。Full Table Scan，将遍历全表以找到匹配的行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103598.png" alt="image-20220712065946659"></p><ul><li><strong>index：</strong>当使用<code>覆盖索引</code>，但需要扫描全部的索引记录时</li></ul><p><code>覆盖索引：</code>如果能通过读取索引就可以得到想要的数据，那就不需要读取用户记录，或者不用再做回表操作了。一个索引包含了满足查询结果的数据就叫做覆盖索引。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只需要读取聚簇索引部分的非叶子节点，就可以得到id的值，不需要查询叶子节点</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103599.png" alt="image-20220712065815768"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只需要读取二级索引，就可以在二级索引中获取到想要的数据，不需要再根据叶子节点中的id做回表操作</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, deptId <span class="keyword">FROM</span> t_emp;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103600.png" alt="image-20220712065922882"></p><ul><li><strong>range：</strong>只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103601.png" alt="image-20220712070042666"></p><ul><li><strong>ref：</strong>通过普通二级索引列与常量进行等值匹配时</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103602.png" alt="image-20220712070727963"></p><ul><li><strong>eq_ref：</strong>连接查询时通过主键或不允许NULL值的唯一二级索引列进行等值匹配时</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.id;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103603.png" alt="image-20220712070851089"></p><ul><li><strong>const：</strong>根据<code>主键</code>或者<code>唯一二级索引</code>列与<code>常数</code>进行匹配时</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103604.png" alt="image-20220712070944090"></p><ul><li><strong>system：</strong>MyISAM引擎中，当表中只有一条记录时。<code>（这是所有type的值中性能最高的场景）</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> t(i <span class="type">int</span>) Engine<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="keyword">INSERT INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103605.png" alt="image-20220711125730163"></p><p><strong>其他不太常见的类型（了解）：</strong></p><ul><li><strong>index_subquery</strong>：利用<code>普通索引</code>来关联子查询，针对包含有IN子查询的查询语句。<code>content1是普通索引字段</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> content <span class="keyword">IN</span> (<span class="keyword">SELECT</span> content1 <span class="keyword">FROM</span> t4 <span class="keyword">WHERE</span> t1.content <span class="operator">=</span> t4.content2) <span class="keyword">OR</span> content <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103606.png" alt="image-20220712071057817"></p><ul><li><strong>unique_subquery</strong>：类似于index_subquery，利用<code>唯一索引</code>来关联子查询。<code>t2的id是主键，也可以理解为唯一的索引字段</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> t1.content <span class="operator">=</span> t2.content) <span class="keyword">OR</span> content <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103607.png" alt="image-20220712071138320"></p><ul><li><strong>index_merge</strong>：在查询过程中需要<code>多个索引组合使用</code>，通常出现在有 or 的关键字的sql中。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103608.png" alt="image-20220711132125501"></p><ul><li><strong>ref_or_null</strong>：当对普通二级索引进行等值匹配，且该索引列的值也可以是NULL值时。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> deptId <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103609.png" alt="image-20220711131831315"></p><ul><li><strong>fulltext：</strong>全文索引。<code>一般通过搜索引擎实现，这里我们不展开。</code></li></ul><h4 id="4-12-6-possible-keys-和-keys-☆"><a href="#4-12-6-possible-keys-和-keys-☆" class="headerlink" title="4.12.6. possible_keys 和 keys ☆"></a>4.12.6. possible_keys 和 keys <strong>☆</strong></h4><ul><li><p><code>possible_keys</code>表示执行查询时可能用到的索引，一个或多个。 查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong>。</p></li><li><p><code>keys</code>表示实际使用的索引。如果为NULL，则没有使用索引。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103610.png" alt="image-20220710142152514"></p><h4 id="4-12-7-key-len-☆"><a href="#4-12-7-key-len-☆" class="headerlink" title="4.12.7. key_len ☆"></a>4.12.7. key_len <strong>☆</strong></h4><p>表示索引使用的字节数，根据这个值可以判断索引的使用情况，<code>检查是否充分利用了索引，针对联合索引值越大越好。</code></p><p><strong>如何计算：</strong></p><ol><li>先看索引上字段的类型+长度。比如：int=4 ; varchar(20) =20 ; char(20) =20 </li><li>如果是varchar或者char这种字符串字段，视字符集要乘不同的值，比如utf8要乘 3，如果是utf8mb4要乘4，GBK要乘2</li><li>varchar这种动态字符串要加2个字节</li><li>允许为空的字段要加1个字节 </li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_age_name <span class="keyword">ON</span> t_emp(age, `name`);</span><br><span class="line"><span class="comment">-- 测试1</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> `name` <span class="operator">=</span> <span class="string">&#x27;ab%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 测试2</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103611.png" alt="image-20220710130548971"></p><h4 id="4-12-8-ref"><a href="#4-12-8-ref" class="headerlink" title="4.12.8. ref"></a>4.12.8. ref</h4><p>显示与key中的索引进行比较的列或常量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ref=atguigudb.t1.id   关联查询时出现，t2表和t1表的哪一列进行关联</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ref=const  与索引列进行等值比较的东西是啥，const表示一个常数</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103612.png" alt="image-20220709211819944"></p><h4 id="4-12-9-rows-☆"><a href="#4-12-9-rows-☆" class="headerlink" title="4.12.9. rows ☆"></a>4.12.9. rows <strong>☆</strong></h4><p>MySQL认为它执行查询时必须检查的行数。值越小越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果是全表扫描，rows的值就是表中数据的估计行数</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> empno <span class="operator">=</span> <span class="string">&#x27;10001&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果是使用索引查询，rows的值就是预计扫描索引记录行数</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103613.png" alt="image-20220710131916240"></p><h4 id="4-12-10-filtered"><a href="#4-12-10-filtered" class="headerlink" title="4.12.10. filtered"></a>4.12.10. filtered</h4><p>最后查询出来的数据占所有服务器端检查行数（rows）的<code>百分比</code>。值越大越好。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先根据二级索引deptId找到数据的主键，有3条记录满足条件，</span></span><br><span class="line"><span class="comment">-- 再根据主键进行回表，最终找到3条记录，有100%的记录满足条件</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> deptId <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这个例子如果name列是索引列则 filtered = 100 否则filtered = 10(全表扫描)</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;风清扬&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103614.png" alt="image-20220709212722601"></p><h4 id="4-12-11-Extra-☆"><a href="#4-12-11-Extra-☆" class="headerlink" title="4.12.11. Extra ☆"></a>4.12.11. Extra <strong>☆</strong></h4><p>包含不适合在其他列中显示但十分重要的额外信息。通过这些额外信息来<code>理解MySQL到底将如何执行当前的查询语句</code>。MySQL提供的额外信息有好几十个，这里只挑介绍比较重要的介绍。</p><ul><li><strong>Impossible WHERE</strong>：where子句的值总是false</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">!=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103615.png" alt="image-20220709231638201"></p><ul><li><strong>Using where：</strong>使用了where，但在where上有字段没有创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp <span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;风清扬&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103616.png" alt="image-20220709215122017"></p><ul><li><strong>Using temporary：</strong>使了用临时表保存中间结果</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> content <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103617.png" alt="image-20220710181100102"></p><ul><li><strong>Using filesort：</strong></li></ul><p>在对查询结果中的记录进行排序时，是可以使用索引的，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103618.png" alt="image-20220710172607190"></p><p>如果排序操作无法使用到索引，只能在内存中（记录较少时）或者磁盘中（记录较多时）进行排序（filesort），如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> content;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103619.png" alt="image-20220710172926396"></p><ul><li><strong>Using index：</strong>使用了覆盖索引，表示直接访问索引就足够获取到所需要的数据，不需要通过索引回表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id, content1 <span class="keyword">FROM</span> t4;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103620.png" alt="image-20220712071716131"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103621.png" alt="image-20220712072055566"></p><ul><li><strong>Using index condition：</strong>叫作  <code>Index Condition Pushdown Optimization （索引下推优化）</code><ul><li><code>如果没有索引下推（ICP）</code>，那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>主键值进行回表</code>，返回完整的记录给server层，server层再判断其他的搜索条件是否成立。如果成立则保留该记录，否则跳过该记录，然后向存储引擎层要下一条记录。</li><li><code>如果使用了索引下推（ICP</code>），那么MySQL在存储引擎层找到满足<code>content1 &gt; &#39;z&#39;</code>条件的第一条二级索引记录。<code>不着急执行回表</code>，而是在这条记录上先判断一下所有关于<code>idx_content1</code>索引中包含的条件是否成立，也就是<code>content1 &gt; &#39;z&#39; AND content1 LIKE &#39;%a&#39;</code>是否成立。如果这些条件不成立，则直接跳过该二级索引记录，去找下一条二级索引记录；如果这些条件成立，则执行回表操作，返回完整的记录给server层。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- content1列上有索引idx_content1</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t4 <span class="keyword">WHERE</span> content1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> content1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103622.png" alt="image-20220710180257692"></p><p><strong>注意：</strong>如果这里的查询条件<code>只有content1 &gt; &#39;z&#39;</code>，那么找到满足条件的索引后也会进行一次索引下推的操作，判断content1 &gt; ‘z’是否成立（这是源码中为了编程方便做的冗余判断）</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103623.png" alt="image-20220712012108900"></p><ul><li><strong>Using join buffer：</strong>在连接查询时，当被驱动表不能有效的利用索引时，MySQL会为其分配一块名为连接缓冲区（join buffer）的内存来加快查询速度</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.content <span class="operator">=</span> t2.content;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103624.png" alt="image-20220710182356817"></p><p>下面这个例子就是被驱动表使用了索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_emp, t_dept <span class="keyword">WHERE</span> t_dept.id <span class="operator">=</span> t_emp.deptId;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103625.png" alt="image-20220710182524371"></p><h3 id="4-13-133-MySQL数据库cpu飙升的话你会如何分析"><a href="#4-13-133-MySQL数据库cpu飙升的话你会如何分析" class="headerlink" title="4.13. 133 MySQL数据库cpu飙升的话你会如何分析"></a>4.13. 133 MySQL数据库cpu飙升的话你会如何分析</h3><p>重点是定位问题。</p><p>先</p><p><strong>1 使用top观察mysqld的cpu利用率</strong></p><ol><li><p>切换到常用的数据库</p></li><li><p>使用show full processlist;查看会话</p></li><li><p>观察是哪些sql消耗了资源，其中重点观察state指标</p></li><li><p>定位到具体sql</p></li></ol><p><strong>2 pidstat</strong> </p><ol><li>定位到线程</li><li>在PERFORMANCE_SCHEMA.THREADS中记录了thread_os_id 找到线程执行的sql</li><li>根据操作系统id可以到processlist表找到对应的会话</li><li>在会话中即可定位到问题sql</li></ol><p><strong>3 使用show profile观察sql各个阶段耗时</strong></p><p><strong>4 服务器上是否运行了其他程序</strong></p><p><strong>5 检查一下是否有慢查询</strong></p><p><strong>6 pref top</strong></p><p>使用pref 工具分析哪些函数引发的cpu过高来追踪定位</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103626.png" alt="image-20221106160437906"></p><h3 id="4-14-134-有没有进行过分库分表？"><a href="#4-14-134-有没有进行过分库分表？" class="headerlink" title="4.14. 134 有没有进行过分库分表？"></a>4.14. 134 有没有进行过分库分表？</h3><h4 id="4-14-1-135-什么是分库分表？"><a href="#4-14-1-135-什么是分库分表？" class="headerlink" title="4.14.1. 135     什么是分库分表？"></a>4.14.1. 135     什么是分库分表？</h4><p><strong>垂直分库</strong></p><p>一个数据库由很多表的构成，每个表对应着<strong>不同的业务</strong>，垂直切分是指按照业务将表进行分类，分布到不同 的数据库上面，这样也就将数据或者说压力分担到不同的库上面，如下图：       </p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103627.jpg" alt="">   </p><p>系统被切分成了，用户，订单交易，支付几个模块。</p><p><strong>水平分表</strong></p><p>把一张表里的内容按照不同的规则 写到不同的库里</p><p>相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分 到一个数据库，而另外的某些行又切分到其他的数据库中，如图： </p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103628.jpg" alt=""></p><h4 id="4-14-2-136-什么时候进行分库分表？有没有配合es使用经验？"><a href="#4-14-2-136-什么时候进行分库分表？有没有配合es使用经验？" class="headerlink" title="4.14.2. 136     什么时候进行分库分表？有没有配合es使用经验？"></a>4.14.2. 136     什么时候进行分库分表？有没有配合es使用经验？</h4><ol><li>能不分就不分</li><li>单机性能下降明显的时候</li><li>增加缓存（通常查询量比较大），细分业务</li><li>首先尝试主被集群，读写分离</li><li>尝试分库</li><li>尝试分表 -&gt; 冷热数据分离</li></ol><p>大数据量下可以配合es完成高效查询</p><h4 id="4-14-3-说一下实现分库分表工具的实现思路"><a href="#4-14-3-说一下实现分库分表工具的实现思路" class="headerlink" title="4.14.3. 说一下实现分库分表工具的实现思路"></a>4.14.3. 说一下实现分库分表工具的实现思路</h4><ol><li>伪装成mysql服务器，代理用户请求转发到真实服务器</li><li>基于本地aop实现，拦截sql，改写，路由和结果归集处理。</li></ol><h4 id="4-14-4-用过哪些分库分表工具？"><a href="#4-14-4-用过哪些分库分表工具？" class="headerlink" title="4.14.4. 用过哪些分库分表工具？"></a>4.14.4. 用过哪些分库分表工具？</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103629.png" alt="img"></p><h4 id="4-14-5-分库分表后可能会有哪些问题？"><a href="#4-14-5-分库分表后可能会有哪些问题？" class="headerlink" title="4.14.5. 分库分表后可能会有哪些问题？"></a>4.14.5. 分库分表后可能会有哪些问题？</h4><p>经典的问题</p><ol><li>执行效率明显降低</li><li>表结构很难再次调整</li><li>引发分布式id问题</li><li>产生跨库join</li><li>代理类中间件网络io成为瓶颈</li></ol><h4 id="4-14-6-说一下读写分离常见方案？"><a href="#4-14-6-说一下读写分离常见方案？" class="headerlink" title="4.14.6. 说一下读写分离常见方案？"></a>4.14.6. 说一下读写分离常见方案？</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103630.png" alt="image-20221106171251532"></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251103631.png" alt="image-20221106171945037"></p><h3 id="4-15-为什么要使用视图？-什么是视图？"><a href="#4-15-为什么要使用视图？-什么是视图？" class="headerlink" title="4.15. 为什么要使用视图？ 什么是视图？"></a>4.15. 为什么要使用视图？ 什么是视图？</h3><p>视图定义：<br>1、视图是一个虚表，是从一个或几个基本表（或视图）导出的表。<br>2、只存放视图的定义，不存放视图对应的数据。<br>3、基表中的数据发生变化，从视图中查询出的数据也随之改变。<br>视图的作用：<br>1、视图能够简化用户的操作<br>2、视图使用户能以多种角度看待同一数据<br>3、视图对重构数据库提供了一定程度的逻辑独立性<br>4、视图能够对机密数据提供安全保护<br>5、适当的利用视图可以更清晰的表达查询</p><h3 id="4-16-什么是存储过程？有没有使用过？"><a href="#4-16-什么是存储过程？有没有使用过？" class="headerlink" title="4.16. 什么是存储过程？有没有使用过？"></a>4.16. 什么是存储过程？有没有使用过？</h3><p>项目中禁止使用存储过程，存储过程难以调试和扩展，更没有移植性</p><h3 id="4-17-有没有使用过外键？有什么需要注意的地方？"><a href="#4-17-有没有使用过外键？有什么需要注意的地方？" class="headerlink" title="4.17. 有没有使用过外键？有什么需要注意的地方？"></a>4.17. 有没有使用过外键？有什么需要注意的地方？</h3><p>不得使用外键与级联，一切外键概念必须在应用层解决。 </p><p>说明：以学生和成绩的关系为例，学生表中的 student_id是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为 级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻 塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p><h3 id="4-18-用过processlist吗？"><a href="#4-18-用过processlist吗？" class="headerlink" title="4.18. 用过processlist吗？"></a>4.18. 用过processlist吗？</h3><p>关键的就是state列，mysql列出的状态主要有以下几种：</p><ul><li>Checking table<br>正在检查数据表（这是自动的）。</li><li>Closing tables<br>正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，就应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中。</li><li>Connect Out<br>复制从服务器正在连接主服务器。</li><li>Copying to tmp table on disk<br>由于临时结果集大于tmp_table_size，正在将临时表从内存存储转为磁盘存储以此节省内存。</li><li>Creating tmp table<br>正在创建临时表以存放部分查询结果。</li><li>deleting from main table<br>服务器正在执行多表删除中的第一部分，刚删除第一个表。</li><li>deleting from reference tables<br>服务器正在执行多表删除中的第二部分，正在删除其他表的记录。</li><li>Flushing tables<br>正在执行FLUSH TABLES，等待其他线程关闭数据表。</li><li>Killed<br>发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志位，不过有些情况下该线程可能会过一小段才能死掉。如果该线程程被其他线程锁住了，那么kill请求会在锁释放时马上生效。</li><li>Locked<br>被其他查询锁住了。</li><li>Sending data<br>正在处理Select查询的记录，同时正在把结果发送给客户端。Sending data”状态的含义，原来这个状态的名称很具有误导性，所谓的“Sending data”并不是单纯的发送数据，而是包括“收集 + 发送 数据”。</li><li>Sorting for group<br>正在为GROUP BY做排序。</li><li>Sorting for order<br>正在为ORDER BY做排序。</li><li>Opening tables<br>这个过程应该会很快，除非受到其他因素的干扰。例如，在执Alter TABLE或LOCK TABLE语句行完以前，数据表无法被其他线程打开。正尝试打开一个表。</li><li>Removing duplicates<br>正在执行一个Select DISTINCT方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此，MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。</li><li>Reopen table<br>获得了对一个表的锁，但是必须在表结构修改之后才能获得这个锁。已经释放锁，关闭数据表，正尝试重新打开数据表。</li><li>Repair by sorting<br>修复指令正在排序以创建索引。</li><li>Repair with keycache<br>修复指令正在利用索引缓存一个一个地创建新索引。它会比Repair by sorting慢些。</li><li>Searching rows for update<br>正在讲符合条件的记录找出来以备更新。它必须在Update要修改相关的记录之前就完成了。</li><li>Sleeping<br>正在等待客户端发送新请求.</li><li>System lock<br>正在等待取得一个外部的系统锁。如果当前没有运行多个mysqld服务器同时请求同一个表，那么可以通过增加—skip-external-locking参数来禁止外部系统锁。</li><li>Upgrading lock<br>Insert DELAYED正在尝试取得一个锁表以插入新记录。=</li><li>Updating<br>正在搜索匹配的记录，并且修改它们。</li><li>User Lock<br>正在等待GET_LOCK()。</li><li>Waiting for tables<br>该线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。然后，为了能的重新打开数据表，必须等到所有其他线程关闭这个表。以下几种情况下会产生这个通知：FLUSH TABLES tbl_name, Alter TABLE, RENAME TABLE, REPAIR TABLE, ANALYZE TABLE,或OPTIMIZE TABLE。</li><li>waiting for handler insert<br>Insert DELAYED已经处理完了所有待处理的插入操作，正在等待新的请求。</li></ul><h3 id="4-19-145-某个表有数千万数据，查询比较慢，如何优化？说一下思路"><a href="#4-19-145-某个表有数千万数据，查询比较慢，如何优化？说一下思路" class="headerlink" title="4.19. 145 某个表有数千万数据，查询比较慢，如何优化？说一下思路"></a>4.19. 145 某个表有数千万数据，查询比较慢，如何优化？说一下思路</h3><ol><li>前端优化 减少查询<ol><li>合并请求:多个请求需要的数据尽量一条sql拿出来</li><li>会话保存：和用户会话相关的数据尽量一次取出重复使用</li><li>避免无效刷新</li></ol></li><li>多级缓存 不要触及到数据库<ol><li>应用层热点数据高速查询缓存（低一致性缓存）</li><li>高频查询大数据量镜像缓存（双写高一致性缓存）</li><li>入口层缓存（几乎不变的系统常量）</li></ol></li><li>使用合适的字段类型，比如varchar换成char</li><li>一定要高效使用索引。<ol><li>使用explain 深入观察索引使用情况</li><li>检查select 字段最好满足索引覆盖</li><li>复合索引注意观察key_len索引使用情况</li><li>有分组，排序，注意file sort，合理配置相应的buffer大小</li></ol></li><li>检查查询是否可以分段查询，避免一次拿出过多无效数据</li><li>多表关联查询是否可以设置冗余字段，是否可以简化多表查询或分批查询</li><li>分而治之：把服务拆分成更小力度的微服务</li><li>冷热数据分库存储</li><li>读写分离，主被集群 然后再考虑分库分表</li><li>等</li></ol><h3 id="4-20-count-列名-和-count-有什么区别？"><a href="#4-20-count-列名-和-count-有什么区别？" class="headerlink" title="4.20. count(列名)和 count(*)有什么区别？"></a>4.20. count(列名)和 count(*)有什么区别？</h3><p>count(<em>)是 SQL92 定义的<br>标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br>说明：count(</em>)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p><h3 id="4-21-如果有超大分页改怎么处理？"><a href="#4-21-如果有超大分页改怎么处理？" class="headerlink" title="4.21. 如果有超大分页改怎么处理？"></a>4.21. 如果有超大分页改怎么处理？</h3><ul><li><p><code>select name from user limit 10000,10;</code>在 使用的时候并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行</p></li><li><p>通过索引优化的方案：</p><ul><li>如果主键自增可以 <code>select name from user where id &gt; 10000 limit 10;</code></li><li>延迟关联</li><li>需要order by时<ul><li>一定注意增加筛选条件，避免全表排序<ul><li>where  -》 order by -》 limit</li></ul></li><li>减少select字段</li><li>优化相关参数避免filesort</li></ul></li></ul></li><li><p>一般大分页情况比较少（很少有人跳转到几百万页去查看数据），实际互联网业务中多数还是按顺序翻页，可以使用缓存提升前几页的查询效率，实际上大多数知名互联网项目也都是这么做的</p></li></ul><p>在阿里巴巴《Java开发手册》中的建议：</p><p>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过 特定阈值的页数进行 SQL 改写。 正例：先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p><h3 id="4-22-mysql服务器毫无规律的异常重启如何排查问题？"><a href="#4-22-mysql服务器毫无规律的异常重启如何排查问题？" class="headerlink" title="4.22. mysql服务器毫无规律的异常重启如何排查问题？"></a>4.22. mysql服务器毫无规律的异常重启如何排查问题？</h3><p>首先是查看mysql和系统日志来定位错误</p><p><strong>最常见的是关闭swap分区后OOM问题：</strong></p><p>mysql 分为应用进程和守护进程</p><p>当应用进程内存占用过高的时候操作系统可能会kill掉进程，此时守护进程又帮我们重启了应用进程，运行一段时间后又出现OOM如此反复</p><p>可以排查以下几个关键点</p><ul><li>运行时内存占用率</li><li>mysql buffer相关参数</li><li>mysql 网络连接相关参数</li></ul><p><strong>异常关机或kill -9 mysql 后导致表文件损坏</strong></p><ul><li>直接使用备份</li><li>配置 innodb_force_recovery 跳过启动恢复过程</li></ul><h4 id="4-22-1-mysql-线上修改表结构有哪些风险"><a href="#4-22-1-mysql-线上修改表结构有哪些风险" class="headerlink" title="4.22.1. mysql 线上修改表结构有哪些风险?"></a>4.22.1. mysql 线上修改表结构有哪些风险?</h4><p>针对ddl命令，有以下几种方式</p><ul><li>copy table  锁原表，创建临时表并拷贝数据</li><li>inplace 针对索引修改删除的优化，不需要拷贝所有数据</li><li><p>Online DDL 细分DDL命令来决定是否锁表</p></li><li><p>可能会锁表，导致无法读写</p></li><li>ORM中的映射失效</li><li>索引失效</li></ul><p>建议：建个新表，导入数据后重命名</p><h3 id="4-23-什么是mysql多实例部署？"><a href="#4-23-什么是mysql多实例部署？" class="headerlink" title="4.23. 什么是mysql多实例部署？"></a>4.23. 什么是mysql多实例部署？</h3><p>指的是在一台主机上部署多个实例</p><p>主要目的是压榨服务器性能</p><p>缺点是互相影响</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;1-Mysql-索引&quot;&gt;&lt;a href=&quot;#1-Mysql-索引&quot; class=&quot;headerlink&quot; title=&quot;1. Mysql 索引&quot;&gt;&lt;/a&gt;1. Mysql 索引&lt;/h2&gt;&lt;h3 id=&quot;1-1-Mysql如何实现的索引机制</summary>
      
    
    
    
    <category term="数据库" scheme="https://ktzxy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://ktzxy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>技术同学必会的MySQL设计规约</title>
    <link href="https://ktzxy.github.io/posts/8f9b37aa.html"/>
    <id>https://ktzxy.github.io/posts/8f9b37aa.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.457Z</updated>
    
    <content type="html"><![CDATA[<p>在我们对数据库技术方案设计的时候，我们是否有自己的设计理念或者原则，还是更多的依据自己的直觉去设计，是否曾经懊悔线上发生过的一次低级故障，可能稍微注意点就可以避免，是否想过怎么才能很好的避免，下面规范的价值正是我们工作的检查清单，需要我们不断从错误中积累有效经验来指导未来的工作。以下规范在大型互联网公司经过了充分的验证，尤其适用于并发量大、数据量大的业务场景。先介绍的是安全规范，因为安全无小事，很多公司都曾经因为自己的数据泄露导致用户的惨痛损失，所以将安全规范放到了第一位。﻿</p><h1 id="一、安全规范"><a href="#一、安全规范" class="headerlink" title="一、安全规范"></a>一、安全规范</h1><p>1.【强制】禁止在数据库中存储明文密码，需把密码加密后存储</p><p><strong>说明：</strong>对于加密操作建议由公司的中间件团队基于如mybatis的扩展，提供统一的加密算法及密钥管理，避免每个业务线单独开发一套，同时也与具体的业务进行了解耦</p><p>2.【强制】禁止在数据库中明文存储用户敏感信息，如手机号等</p><p><strong>说明：</strong>对于手机号建议公司搭建统一的手机号查询服务，避免在每个业务线单独存储</p><p>3.【强制】禁止开发直接给业务同学导出或者查询涉及到用户敏感信息的数据，如需要需上级领导审批</p><p>4.【强制】涉及到导出数据功能的操作，如包含敏感字段都需加密或脱敏</p><p>5.【强制】跟数据库交互涉及的敏感数据操作都需有审计日志，必要时要做告警</p><p>6.【强制】对连接数据库的IP需设置白名单功能，杜绝非法IP接入</p><p>7.【强制】对重要sql（如订单信息的查询）的访问频率或次数要做历史趋势监控，及时发现异常行为</p><p>8.【推荐】线上连接数据库的用户名、密码建议定期进行更换</p><h1 id="二、基础规范"><a href="#二、基础规范" class="headerlink" title="二、基础规范"></a>二、基础规范</h1><p>1.【推荐】尽量不在数据库做运算，复杂运算需移到业务应用里完成</p><p>2.【推荐】拒绝大sql语句、拒绝大事务、拒绝大批量，可转化到业务端完成</p><p><strong>说明：</strong>大批量操作可能会造成严重的主从延迟，binlog日志为row格式会产生大量的日志</p><p>3.【推荐】避免使用存储过程、触发器、函数等，容易造成业务逻辑与DB耦合</p><p><strong>说明：</strong>数据库擅长存储与索引、要解放数据库CPU，将计算转移到服务层、也具备更好的扩展性</p><p>4.【强制】数据表、数据字段必须加入中文注释</p><p><strong>说明：</strong>后续维护的同学看到后才清楚表是干什么用的</p><p>5.【强制】不在数据库中存储图片、文件等大数据</p><p><strong>说明：</strong>大文件和图片需要储在文件系统</p><p>6.【推荐】对于程序连接数据库账号，遵循权限最小原则</p><p>7.【推荐】数据库设计时，需要问下自己是否对以后的扩展性进行了考虑</p><p>8.【推荐】利用 pt-query-digest 定期分析slow query log并进行优化</p><p>9.【推荐】使用内网域名而不是ip连接数据库</p><p>10.【推荐】如果数据量或数据增长在前期规划时就较大，那么在设计评审时就应加入分表策略</p><p>11.【推荐】要求所有研发SQL关键字全部是小写，每个词只允许有一个空格﻿</p><h1 id="三、命名规范"><a href="#三、命名规范" class="headerlink" title="三、命名规范"></a>三、命名规范</h1><p>1.【强制】库名、表名、字段名要小写，下划线风格，不超过32个字符，必须见名知意，建议使用名词而不是动词，词义与业务、产品线等相关联，禁止拼音英文混用</p><p>2.【强制】普通索引命名格式：<code>idx_表名_索引字段名</code>（如果以首个字段名为索引有多个，可以加上第二个字段名，太长可以考虑缩写）；唯一索引命名格式：<code>uk_表名_索引字段名</code>（索引名必须全部小写，长度太长可以利用缩写）；主键索引命名：<code>pk_字段名</code></p><p>3.【强制】库名、表名、字段名禁止使用MySQL保留字</p><p>4.【强制】临时库表名必须以<code>tmp</code>为前缀，并以日期为后缀</p><p>5.【强制】备份库表必须以<code>bak</code>为前缀，并以日期为后缀</p><p>6.【推荐】用HASH进行散表，表名后缀使用16进制数，下标从0开始</p><p>7.【推荐】按日期时间分表需符合<code>YYYY[MM][DD][HH]</code>格式</p><p>8.【推荐】散表如果使用md5（或者类似的hash算法）进行散表，表名后缀使用16进制，比如user_ff</p><p>9.【推荐】使用CRC32求余（或者类似的算术算法）进行散表，表名后缀使用数字，数字必须从0开始并等宽，比如散100张表，后缀从00-99</p><p>10.【推荐】使用时间散表，表名后缀必须使用特定格式，比如按日散表user_20110209、按月散表user_201102</p><p>11.【强制】表达是与否概念的字段，使用 is _ xxx 的方式进行命名﻿</p><h1 id="四、库设计规范"><a href="#四、库设计规范" class="headerlink" title="四、库设计规范"></a>四、库设计规范</h1><p>1.【推荐】数据库使用InnoDB存储引擎</p><p><strong>说明：</strong>支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p><p>2.【推荐】数据库和表的字符集统一使用UTF8</p><p><strong>说明：</strong>utf8号称万国码，其无需转码、无乱码风险且节省空间。若是有字段需要存储emoji表情之类的，则将表或字段设置成utf8mb4，utf8mb4向下兼容utf8。</p><p>3.【推荐】不同业务，使用不同的数据库，避免互相影响</p><p>4.【强制】所有线上业务库均必须搭建MHA高可用架构，避免单点问题</p><h1 id="五、表设计规范"><a href="#五、表设计规范" class="headerlink" title="五、表设计规范"></a>五、表设计规范</h1><p>1.【推荐】建表规范示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `student_info` (    </span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,    </span><br><span class="line">    `stu_name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,    </span><br><span class="line">    `stu_score` <span class="type">smallint</span>(<span class="number">5</span>) unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;总分&#x27;</span>,    </span><br><span class="line">    `stu_num` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,    </span><br><span class="line">    `gmt_create` <span class="type">timestamp</span> <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,    </span><br><span class="line">    `gmt_modified` <span class="type">timestamp</span> <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,    </span><br><span class="line">    `status` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;1代表记录有效，0代表记录无效&#x27;</span>,      </span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`id`),      </span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `uk_student_info_stu_num` (`stu_num`) <span class="keyword">USING</span> BTREE,    </span><br><span class="line">    KEY `idx_student_info_stu_name` (`stu_name`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;学生信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>2.【强制】禁止使用外键，如果有外键完整性约束，需要应用程序控制</p><p>3.【强制】每个Innodb 表必须有一个主键</p><p><strong>说明：</strong>Innodb 是一种索引组织表，其数据存储的逻辑顺序和索引的顺序是相同的。每张表可以有多个索引，但表的存储顺序只能有一种，Innodb 是按照主键索引的顺序来组织表的，因此不要使用更新频繁的列如UUID、MD5、HASH和字符串列作为主键，这些列无法保证数据的顺序增长，主键建议使用自增ID 值。</p><p>4.【推荐】单表列数目最好小于50</p><p>5.【强制】禁止使用分区表</p><p><strong>说明：</strong>分区表在物理上表现为多个文件，在逻辑上表现为一个表，谨慎选择分区键，跨分区查询效率可能更低，建议采用物理分表的方式管理大数据</p><p>6.【推荐】拆分大字段和访问频率低的字段，分离冷热数据</p><p>7.【推荐】采用合适的分库分表策略，例如千库十表、十库百表等（建议表大小控制在2G）</p><p>8.【推荐】单表不超过50个int字段；不超过20个char字段，不超过2个text字段</p><p>9.【推荐】表默认设置创建时间戳和更改时间戳字段</p><p>10.【推荐】日志类型的表可以考虑按创建时间水平切割，定期归档历史数据</p><p>11.【强制】禁止使用order by rand()</p><p><strong>说明：</strong>order by rand()会为表增加一个伪列，然后用rand()函数为每一行数据计算出rand()值，基于该行排序，这通常都会生成磁盘上的临时表，因此效率非常低。</p><p>12.【参考】可以结合使用hash、range、lookup table进行散表</p><p>13.【推荐】每张表数据量建议控制在500w以下，超过500w可以使用历史数据归档或分库分表来实现（500万行并不是MySQL数据库的限制。过大对于修改表结构，备份，恢复都会有很大问题。MySQL没有对存储有限制，取决于存储设置和文件系统）</p><p>14.【强制】禁止在表中建立预留字段</p><p><strong>说明：</strong>预留字段的命名很难做到见名识义，预留字段无法确认存储的数据类型，所以无法选择合适的类型；对预留字段类型的修改，会对表进行锁定</p><h1 id="六、字段设计规范"><a href="#六、字段设计规范" class="headerlink" title="六、字段设计规范"></a>六、字段设计规范</h1><p>1.【强制】必须把字段定义为NOT NULL并且提供默认值</p><p><strong>说明：</strong>NULL字段很难查询优化，NULL字段的索引需要额外空间，NULL字段的复合索引无效</p><p>2.【强制】禁止使用ENUM，可使用TINYINT代替</p><p>3.【强制】禁止使用TEXT、BLOB类型(如果表的记录数在万级以下可以考虑)</p><p>4.【强制】必须使用varchar(20)存储手机号</p><p>5.【强制】禁止使用小数存储国币、使用“分”作为单位，这样数据库里就是整数了</p><p>6.【强制】用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</p><p>7.【推荐】使用UNSIGNED存储非负整数</p><p><strong>说明：</strong>同样的字节数，存储的数值范围更大</p><p>8.【推荐】建议使用INT UNSIGNED存储IPV4</p><p><strong>说明：</strong>用UNSINGED INT存储IP地址占用4字节，CHAR(15)则占用15字节。另外，计算机处理整数类型比字符串类型快。使用INT UNSIGNED而不是CHAR(15)来存储IPV4地址，通过MySQL函数inet_ntoa和inet_aton来进行转化。IPv6地址目前没有转化函数，需要使用DECIMAL或两个BIGINT来存储。例如:</p><p>SELECT INET_ATON(‘192.168.172.3’); 3232279555 SELECT INET_NTOA(3232279555); 192.168.172.3</p><p>9.【推荐】字段长度尽量按实际需要进行分配，不要随意分配一个很大的容量</p><p>10.【推荐】核心表字段数量尽可能地少，有大字段要考虑拆分</p><p>11.【推荐】适当考虑一些反范式的表设计，增加冗余字段，减少JOIN</p><p>12.【推荐】资金字段考虑统一*100处理成整型，避免使用decimal浮点类型存储</p><p>13.【推荐】使用VARBINARY存储大小写敏感的变长字符串或二进制内容</p><p><strong>说明：</strong>VARBINARY默认区分大小写，没有字符集概念，速度快</p><p>14.【参考】INT类型固定占用4字节存储</p><p><strong>说明：</strong>INT(4)仅代表显示字符宽度为4位，不代表存储长度。数值类型括号后面的数字只是表示宽度而跟存储范围没有关系，比如INT(3)默认显示3位，空格补齐，超出时正常显示，Python、Java客户端等不具备这个功能</p><p>15.【参考】区分使用DATETIME和TIMESTAMP</p><p><strong>说明：</strong>存储年使用YEAR类型、存储日期使用DATE类型、存储时间(精确到秒)建议使用TIMESTAMP类型。</p><p>DATETIME和TIMESTAMP都是精确到秒，优先选择TIMESTAMP，因为TIMESTAMP只有4个字节，而DATETIME8个字节，同时TIMESTAMP具有自动赋值以及⾃自动更新的特性。</p><p>补充：如何使用TIMESTAMP的自动赋值属性?</p><p>自动初始化，而且自动更新：column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATECURRENT_TIMESTAMP 只是自动初始化：column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP 自动更新，初始化的值为0：column1 TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP 初始化的值为0：column1 TIMESTAMP DEFAULT 0</p><p>16.【推荐】将大字段、访问频率低的字段拆分到单独的表中存储，分离冷热数据</p><p><strong>说明：</strong>有利于有效利用缓存，防⽌读入无用的冷数据，较少磁盘IO，同时保证热数据常驻内存提⾼高缓存命中率</p><p>17.【参考】VARCHAR(N)，N表示的是字符数不是字节数，比如VARCHAR(255)，可以最大可存储255个汉字，需要根据实际的宽度来选择N</p><p>18.【参考】VARCHAR(N)，N尽可能小，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节，进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存</p><p>19.【推荐】VARCHAR(N)，N&gt;5000时，使用BLOB类型</p><p>20.【推荐】使用短数据类型，比如取值范围为0~80时，使用TINYINT UNSIGNED</p><p>21.【强制】存储状态，性别等，用TINYINT</p><p>22.【强制】所有存储相同数据的列名和列类型必须一致（在多个表中的字段如user_id，它们类型必须一致）</p><p>23.【推荐】优先选择符合存储需要的最小数据类型</p><p>24.【推荐】如果存储的字符串长度几乎相等，使用 char 定长字符串类型</p><h1 id="七、索引设计规范"><a href="#七、索引设计规范" class="headerlink" title="七、索引设计规范"></a>七、索引设计规范</h1><p>1.【推荐】单表索引建议控制在5个以内</p><p><strong>说明：</strong>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率，所以不是越多越好</p><p>2.【强制】禁止在更新十分频繁，区分度不高的属性上建立索引</p><p>3.【强制】建立组合索引必须把区分度高的字段放在前面</p><p>4.【推荐】对字符串使用索引，如果字符串定义长度超过128的，可以考虑前缀索引</p><p>5.【强制】表必须有主键，并且是auto_increment及not null的，根据表的实际情况定义无符号的tinyint,smallint,int,bigint</p><p>6.【强制】禁止更新频繁的列作为主键</p><p>7.【强制】禁止字符串列作为主键</p><p>8.【强制】禁止UUID MD5 HASH这些作为主键(数值太离散了)</p><p>9.【推荐】默认使用非空的唯一键作为主键</p><p>10.【推荐】主键建议选择自增或发号器</p><p>11.【推荐】核心SQL优先考虑覆盖索引</p><p>12.【参考】避免冗余和重复索引</p><p>13.【参考】索引要综合评估数据密度和分布以及考虑查询和更新比例</p><p>14.【强制】不在索引列进行数学运算和函数运算</p><p>15.【推荐】研发要经常使用explain，如果发现索引选择性差，必须要学会使用hint</p><p>16.【推荐】能使用唯一索引就要使用唯一索引，提高查询效率</p><p>17.【推荐】多条字段重复的语句，要修改语句条件字段的顺序，为其建立一条联合索引，减少索引数量</p><p>18.【强制】索引字段要保证不为NULL，考虑default value进去。NULL也是占空间，而且NULL非常影响索引的查询效率</p><p>19.【强制】新建的唯一索引不能和主键重复</p><p>20.【推荐】尽量不使用外键、外键用来保护参照完整性，可在业务端实现</p><p><strong>说明：</strong>避免对父表和子表的操作会相互影响，降低可用性</p><p>21.【强制】字符串不应做主键</p><p>22.【强制】表必须有无符号int型自增主键，对应表中id字段</p><p><strong>说明：</strong>必须得有主键的原因：采用RBR模式复制，无主键的表删除，会导致备库夯住 ；使用自增的原因：</p><p>数据写入可以提高插入性能，避免page分裂，减少表碎片</p><p>23.【推荐】对长度过长的VARCHAR字段建立索引时，添加crc32或者MD5 Hash字段，对Hash字段建立索引</p><p><strong>说明：</strong>下面的表增加一列url_crc32，然后对url_crc32建立索引，减少索引字段的长度，提高效率</p><p>CREATE TABLE url(  …  url VARCHAR(255) NOT NULL DEFAULT 0,  url_crc32 INT UNSIGNED NOT NULL DEFAULT 0,  …  index idx_url(url_crc32) ）</p><p>24.【推荐】WHERE条件中的非等值条件（IN、BETWEEN、&lt;、&lt;=、&gt;、&gt;=）会导致后面的条件使用不了索引</p><p>25.【推荐】索引字段的顺序需要考虑字段值去重之后的个数，个数多的放在前面</p><p>26.【推荐】ORDER BY，GROUP BY，DISTINCT的字段需要添加在索引的后面</p><p>27.【参考】合理创建联合索引（避免冗余），如(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)</p><p>28.【推荐】复合索引中的字段数建议不超过5个</p><p>29.【强制】不在选择性低的列上建立索引，例如”性别”, “状态”， “类型”</p><p>30.【推荐】对于单独条件如果走不了索引，可以使用force –index强制指定索引</p><p>31.【强制】禁止给表中的每一列都建立单独的索引</p><p>32.【推荐】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可﻿</p><h1 id="八、SQL使用规范"><a href="#八、SQL使用规范" class="headerlink" title="八、SQL使用规范"></a>八、SQL使用规范</h1><p>1.【强制】禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</p><p><strong>说明：</strong>按需获取可以减少网络带宽消耗，能有效利用覆盖索引，表结构变更对程序基本无影响。</p><p>2.【强制】禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</p><p>3.【强制】WHERE条件中必须使用合适的类型，避免MySQL进行隐式类型转化</p><p><strong>说明：</strong>因为MySQL进行隐式类型转化之后，可能会将索引字段类型转化成=号右边值的类型，导致使用不到索引，原因和避免在索引字段中使用函数是类似的，例子 select uid from t_user where phone=15855550101（phone为 varchat 类型，此时查询中使用数字查询，会导致索引失效）</p><p>4.【强制】禁止在WHERE条件的属性上使用函数或者表达式</p><p>5.【强制】禁止负向查询，以及%开头的模糊查询</p><p>6.【强制】应用程序必须捕获SQL异常，并有相应处理</p><p>7.【推荐】sql语句尽可能简单、大的sql想办法拆成小的sql语句</p><p><strong>说明：</strong>简单的SQL容易使用到MySQL的querycache、减少锁表时间特别是MyISAM、可以使用多核cpu</p><p>8.【推荐】事务要简单，整个事务的时间长度不要太长</p><p>9.【强制】避免在数据库中进行数学运算或者函数运算(MySQL不擅长数学运算和逻辑判断，也容易将业务逻辑和DB耦合在一起)</p><p>10.【推荐】sql中使用到OR的改写为用IN()  (or的效率没有in的效率高)</p><p>11.【参考】SQL语句中IN包含的值不应过多，里面数字的个数建议控制在1000个以内</p><p>12.【推荐】limit分页注意效率。Limit越大，效率越低。可以改写limit</p><p><strong>说明：</strong>改写例子：</p><p>1）改写方法一</p><p>延迟回表写法 select xx,xx from t t1, (select id from t where ….  limit 10000,10) t2 where t1.id = t2.id</p><p>2）改写方法二</p><p>select id from t limit 10000, 10; 应该改为 =&gt; select id from t where id &gt; 10000 limit 10;</p><p>13.【推荐】尽量使用union all替代union</p><p>14.【参考】避免使用大表JOIN</p><p>15.【推荐】对数据的更新要打散后批量更新，不要一次更新太多数据</p><p>16.【推荐】使用合理的SQL语句减少与数据库的交互次数</p><p>17.【参考】注意使用性能分析工具 Sql explain  / showprofile  /  mysqlsla</p><p>18.【推荐】能不用NOT IN就不用NOT IN，坑太多了，会把空和NULL给查出来</p><p>19.【推荐】关于分页查询，程序里建议合理使用分页来提高效率，limit、offset较大要配合子查询使用</p><p>20.【强制】禁止在数据库中跑大查询</p><p>21.【强制】禁止单条SQL语句同时更新多个表</p><p>22.【推荐】统计表中记录数时使用COUNT(*)，而不是COUNT(primary_key)和COUNT(1)</p><p><strong>说明：</strong><code>count( * )</code> 会统计值为 NULL 的行，而 <code>count( 列名 )</code> 不会统计此列为 NULL 值的行</p><p>23.【推荐】INSERT语句使用batch提交（INSERT INTO tableVALUES(),(),()……），values的个数不应过多</p><p>24.【推荐】获取大量数据时，建议分批次获取数据，每次获取数据少于2000条，结果集应小于1M</p><p>25.【推荐】在做开发时建议使用数据库框架(如 mybatis) 或 prepared statement，可以提升性能并避免 SQL 注入</p><p>26.【强制】禁止跨库查询（为数据迁移和分库分表留出余地，降低耦合度，降低风险）</p><p>27.【推荐】尽量避免使用子查询，可以把子查询优化为join操作（子查询的结果集无法使用索引，子查询会产生临时表操作，如果子查询数据量大会影响效率，消耗过多的CPU及IO资源）</p><p>28.【强制】超过三个表禁止 join。（需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。即使双表 join 也要注意表索引、SQL 性能。）</p><p>29.【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts最好</p><p>30.【推荐】尽量不要使用物理删除（即直接删除，如果要删除的话提前做好备份），而是使用逻辑删除，使用字段delete_flag做逻辑删除，类型为tinyint，0表示未删除，1表示已删除</p><p>31.【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句</p><p>32.【强制】程序连接不同的数据库要使用不同的账号</p><p>33.【推荐】使用 ISNULL()来判断是否为 NULL 值﻿</p><h1 id="九、行为规范"><a href="#九、行为规范" class="headerlink" title="九、行为规范"></a>九、行为规范</h1><p>1.【强制】禁止使用应用程序配置文件内的帐号手工访问线上数据库</p><p>2.【强制】禁止非DBA对线上数据库进行写操作，修改线上数据需要提交工单，由DBA执行，提交的SQL语句必须经过测试</p><p>3.【强制】禁止在线上做数据库压力测试</p><p>4.【强制】禁止从测试、开发环境直连线上数据库</p><p>5.【强制】禁止在主库进行后台统计操作，避免影响业务，可以在离线从库上执行后台统计﻿</p><h1 id="十、流程规范"><a href="#十、流程规范" class="headerlink" title="十、流程规范"></a>十、流程规范</h1><p>1.【强制】所有的建表操作需要提前告知该表涉及的查询sql</p><p>2.【强制】所有的建表需要确定建立哪些索引后才可以建表上线</p><p>3.【强制】所有的改表结构、加索引操作都需要将涉及到所改表的查询sql发出来告知DBA等相关人员</p><p>4.【强制】在建新表加字段之前，要求至少要提前3天邮件出来，给dba们评估、优化和审核的时间</p><p>5.【强制】批量导入、导出数据需要DBA进行审查，并在执行过程中观察服务</p><p>6.【强制】禁止有super权限的应用程序账号存在</p><p>7.【强制】推广活动或上线新功能必须提前通知DBA进行流量评估</p><p>8.【强制】不在业务高峰期批量更新、查询数据库</p><p>9.【强制】隔离线上线下环境（开发测试程序禁止访问线上数据库）</p><p>10.【强制】在对大表做表结构变更时，如修改字段属性会造成锁表，并会造成从库延迟，从而影响线上业务，必须在凌晨后业务低峰期执行，另统一用工具pt-online-schema-change避免锁表且降低延迟执行时间</p><p>11.【强制】核心业务数据库变更需在凌晨执行</p><p>12.【推荐】汇总库开启Audit审计日志功能，出现问题时方可追溯</p><p>13.【强制】给业务方开权限时，密码要用MD5加密，至少16位。权限如没有特殊要求，均为select查询权限，并做库表级限制</p><p>14.【推荐】如果出现业务部门人为误操作导致数据丢失，需要恢复数据，请在第一时间通知DBA，并提供准确时间，误操作语句等重要线索。</p><p>15.【强制】批量更新数据，如update,delete 操作，需要DBA进行审查，并在执行过程中观察服务</p><p>16.【强制】业务部门程序出现bug等影响数据库服务的问题，请及时通知DBA便于维护服务稳定</p><p>17.【强制】线上数据库的变更操作必须提供对应的回滚方案</p><p>18.【强制】批量清洗数据，需要开发和DBA共同进行审查，应避开业务高峰期时段执行，并在执行过程中观察服务状态</p><p>19.【强制】数据订正如删除和修改记录时，要先 select ，确认无误才能执行更新语句，避免出现误删除</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们对数据库技术方案设计的时候，我们是否有自己的设计理念或者原则，还是更多的依据自己的直觉去设计，是否曾经懊悔线上发生过的一次低级故障，可能稍微注意点就可以避免，是否想过怎么才能很好的避免，下面规范的价值正是我们工作的检查清单，需要我们不断从错误中积累有效经验来指导未来的</summary>
      
    
    
    
    <category term="数据库" scheme="https://ktzxy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://ktzxy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库概述</title>
    <link href="https://ktzxy.github.io/posts/dfdfdf4.html"/>
    <id>https://ktzxy.github.io/posts/dfdfdf4.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据库技术"><a href="#1-数据库技术" class="headerlink" title="1. 数据库技术"></a>1. 数据库技术</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h3><p>数据库（DB）是一个以某种组织方式存储在磁盘上的数据的集合。简单理解就是用来存储数据的仓库。</p><ul><li>数据库 DataBase（DB）：存储数据的仓库，数据是有组织的进行存储。</li><li>数据库管理系统 DataBase Management System (DBMS)：操纵和管理数据库的大型软件。</li></ul><h3 id="1-2-数据库的分类"><a href="#1-2-数据库的分类" class="headerlink" title="1.2. 数据库的分类"></a>1.2. 数据库的分类</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202408251443884.jpg" alt=""></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202408251443254.jpg" alt=""></p><h3 id="1-3-不同的数据存储方式"><a href="#1-3-不同的数据存储方式" class="headerlink" title="1.3. 不同的数据存储方式"></a>1.3. 不同的数据存储方式</h3><p>数据存储在集合（内存）中</p><ul><li>优点：读写速度快</li><li>缺点：不能永久存储</li></ul><p>数据存储在文件中</p><ul><li>优点：可以永久存储</li><li>缺点：频繁的IO操作效率低，查询数据很不方便。</li></ul><p>数据存储在数据库中</p><ul><li>优点：可以永久存储。查询速度快，查询数据很方便</li><li>缺点：要使用 SQL 语言执行增删改查操作</li></ul><h2 id="2-关系型数据库"><a href="#2-关系型数据库" class="headerlink" title="2. 关系型数据库"></a>2. 关系型数据库</h2><blockquote><p><a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/8999831">关系型数据库 - 百度百科</a></p></blockquote><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1. 概念"></a>2.1. 概念</h3><p>关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数据库就是由二维表及其之间的关系组成的一个数据组织。</p><h3 id="2-2-SQL-语言"><a href="#2-2-SQL-语言" class="headerlink" title="2.2. SQL 语言"></a>2.2. SQL 语言</h3><p>SQL (Structured Query Language)：操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准</p><h3 id="2-3-常见的关系型数据库管理系统"><a href="#2-3-常见的关系型数据库管理系统" class="headerlink" title="2.3. 常见的关系型数据库管理系统"></a>2.3. 常见的关系型数据库管理系统</h3><ul><li>MySQL：开源免费的中小型数据库，后来 Sun 公司收购了 MySQL，而 Oracle 又收购了Sun公司。从 MySQL 6.x 版本开始推出了收费版本，但也提供了免费的社区版本。</li><li>Oracle：收费的大型数据库，Oracle 公司的产品。Oracle 收购 SUN 公司，收购 MYSQL。</li><li>DB2：IBM公司的大型数据库产品，收费的。常应用在银行系统中.</li><li>SQL Server：MicroSoft 公司收费的中型的数据库。C#、.net 等语言常使用。</li><li>PostgreSQL：开源免费的功能最强大的中小型开源数据库</li><li>SyBase：已经淡出历史舞台。提供了一个非常专业数据建模的工具 PowerDesigner。</li><li>SQLite：嵌入式的微型数据库，应用在手机端。Android 内置的数据库采用的就是该数据库。</li><li>MariaDB：开源免费的中小型数据库。是 MySQL 数据库的另外一个分支、另外一个衍生产品，与 MySQL 数据库有很好的兼容性。</li></ul><p>Java 目前应用最多的数据库是：MySQL，Oracle。不论使用以上哪一个关系型数据库，最终在操作时，都是使用 SQL 语言来进行统一操作，因为 SQL 语言，是操作关系型数据库的<strong>统一标准</strong>。例如学习 MySQL，同样可以应用到别的关系型数据库，如：Oracle、DB2、SQLServer。</p><h2 id="3-NoSQL-数据库"><a href="#3-NoSQL-数据库" class="headerlink" title="3. NoSQL 数据库"></a>3. NoSQL 数据库</h2><h3 id="3-1-什么是-NoSQL"><a href="#3-1-什么是-NoSQL" class="headerlink" title="3.1. 什么是 NoSQL"></a>3.1. 什么是 NoSQL</h3><p>NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p><p>关系型数据库指的是，表与表之间有主外键，这种表之间有关系的数据，我们叫做关系型数据库。</p><h3 id="3-2-为什么需要-NoSQL"><a href="#3-2-为什么需要-NoSQL" class="headerlink" title="3.2. 为什么需要 NoSQL"></a>3.2. 为什么需要 NoSQL</h3><p>随着互联网 web 2.0 网站的兴起，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速。而传统的关系数据库在应付 web 2.0 网站，特别是超大规模和高并发的 SNS 类型的 web 2.0 纯动态网站已经显得力不从心，暴露了很多难以克服的问题，例如：</p><ol><li><strong>High performance - 对数据库高并发读写的需求</strong>：web 2.0 网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次 SQL 查询还勉强顶得住，但是应付上万次 SQL 写数据请求，硬盘 IO 就已经无法承受了。其实对于普通的 BBS 网站，往往也存在对高并发写请求的需求，例如网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。</li><li><strong>Huge Storage - 对海量数据的高效率存储和访问的需求</strong>：类似 Facebook，Twitter，Friendfeed 这样的 SNS 网站，每天用户产生海量的用户动态，以 Friendfeed 为例，一个月就达到了 2.5 亿条用户动态，对于关系数据库来说，在一张 2.5 亿条记录的表里面进行 SQL 查询，效率是极其低下乃至不可忍受的。再例如大型 web 网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。</li><li><strong>High Scalability &amp;&amp; High Availability - 对数据库的高可扩展性和高可用性的需求</strong>：在基于 web 的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像 web server 和 app server 那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供 24 小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？</li></ol><p><strong>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类</strong>带来的挑战，尤其是大数据应用难题。</p><h3 id="3-3-主流-NoSQL-产品分类"><a href="#3-3-主流-NoSQL-产品分类" class="headerlink" title="3.3. 主流 NoSQL 产品分类"></a>3.3. 主流 NoSQL 产品分类</h3><p>NoSQL 数据库的四大分类如下：</p><p><strong>键值(Key-Value)存储数据库</strong>、</p><ul><li>相关产品： Tokyo Cabinet/Tyrant、<strong>Redis</strong>、Voldemort、Berkeley DB</li><li>典型应用： 内容缓存，主要用于处理大量数据的高访问负载。</li><li>数据模型： 一系列键值对</li><li>优势： 快速查询</li><li>劣势： 存储的数据缺少结构化</li></ul><p><strong>列存储数据库</strong></p><ul><li>相关产品：Cassandra, HBase, Riak</li><li>典型应用：分布式的文件系统</li><li>数据模型：以列簇式存储，将同一列数据存在一起</li><li>优势：查找速度快，可扩展性强，更容易进行分布式扩展</li><li>劣势：功能相对局限</li></ul><p><strong>文档型数据库</strong></p><ul><li>相关产品：CouchDB、<strong>MongoDB</strong></li><li>典型应用：Web应用（与Key-Value类似，Value是结构化的）</li><li>数据模型： 一系列键值对</li><li>优势：数据结构要求不严格</li><li>劣势： 查询性能不高，而且缺乏统一的查询语法</li></ul><p><strong>图形(Graph)数据库</strong></p><ul><li>相关数据库：Neo4J、InfoGrid、Infinite Graph</li><li>典型应用：社交网络</li><li>数据模型：图结构</li><li>优势：利用图结构相关算法。</li><li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</li></ul><h3 id="3-4-NoSQL-特点"><a href="#3-4-NoSQL-特点" class="headerlink" title="3.4. NoSQL 特点"></a>3.4. NoSQL 特点</h3><p>在大数据存取上具备关系型数据库无法比拟的性能优势，例如：</p><ol><li>易扩展。NoSQL 数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</li><li>大数据量，高性能。NoSQL 数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。</li><li>灵活的数据模型。NoSQL 无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。这点在大数据量的 Web2.0 时代尤其明显。</li><li>高可用。NoSQL 在不太影响性能的情况，就可以方便的实现高可用的架构。比如 Cassandra，HBase 模型，通过复制模型也能实现高可用。</li></ol><p>综上所述，NoSQL 的非关系特性使其成为了后 Web2.0 时代的宠儿，助力大型 Web2.0 网站的再次起飞，是一项全新的数据库革命性运动。</p><h2 id="4-关系型数据库表设计规范化"><a href="#4-关系型数据库表设计规范化" class="headerlink" title="4. 关系型数据库表设计规范化"></a>4. 关系型数据库表设计规范化</h2><h3 id="4-1-数据库设计步骤"><a href="#4-1-数据库设计步骤" class="headerlink" title="4.1. 数据库设计步骤"></a>4.1. 数据库设计步骤</h3><ol><li>收集信息：与该系统有关人员进行交流、座谈，充分了解用户需求，理解数据库需要完成的任务</li><li>标识实体（Entity）：标识数据库要管理的关键对象或实体，实体一般是名词</li><li>标识每个实体的属性（Attribute）</li><li>标识实体之间的关系（Relationship）</li></ol><h3 id="4-2-什么是范式-NF"><a href="#4-2-什么是范式-NF" class="headerlink" title="4.2. 什么是范式(NF)"></a>4.2. 什么是范式(NF)</h3><p>良好的表结构设计是高性能的基石，应该根据系统将要执行的业务查询来设计，这往往需要权衡各种因素。糟糕的表结构设计，直接影响到数据库的性能，并需要花费大量不必要的优化时间，往往还没有什么效果。在数据库表设计上有个很重要的设计准则，称为<strong>范式设计</strong>。</p><p>范式来自英文 Normal Form，简称 NF，是一套用来设计数据库的规则，在关系型数据库中这些规则就称为范式。好的数据库设计对数据的存储性能和后期的程序开发，都会产生重要的影响。建立科学的，规范的数据库就需要满足一些规则来优化数据的设计和存储。</p><p>要想设计—个好的关系，必须使关系满足一定的约束条件，此约束已经形成了规范，分成几个等级，一级比一级要求得严格。满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入(insert)、删除(delete)和更新(update)操作异常。</p><h3 id="4-3-范式分类"><a href="#4-3-范式分类" class="headerlink" title="4.3. 范式分类"></a>4.3. 范式分类</h3><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p><p>满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。<strong>一般说来，数据库只需满足第三范式(3NF）就行了</strong>。</p><h4 id="4-3-1-第一范式-1NF"><a href="#4-3-1-第一范式-1NF" class="headerlink" title="4.3.1. 第一范式(1NF)"></a>4.3.1. 第一范式(1NF)</h4><ul><li>第一范式是数据库设计最基本的要求。</li><li>要求数据库表的每一列都是不可再分割的原子性数据项。</li><li><strong>第一范式每一列不可再拆分，称为原子性</strong>。</li></ul><p>不能是集合、数组、记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中每个列的值只能是表的一个属性或一个属性的一部分。</p><h4 id="4-3-2-第二范式-2NF"><a href="#4-3-2-第二范式-2NF" class="headerlink" title="4.3.2. 第二范式(2NF)"></a>4.3.2. 第二范式(2NF)</h4><p>要先满足第一范式前提下，表中必须有主键，其他非主键列要完全依赖于主键，而不能只依赖于一部分。简单来说，<strong>一张表只描述一件事情</strong>。</p><p>第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。例如在员工表中的身份证号码即可实现每个员工的区分，该身份证号码即为候选键，任何一个候选键都可以被选作主键。在找不到候选键时，可额外增加属性以实现区分。</p><p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。<strong>简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键</strong>。</p><h4 id="4-3-3-第三范式-3NF"><a href="#4-3-3-第三范式-3NF" class="headerlink" title="4.3.3. 第三范式(3NF)"></a>4.3.3. 第三范式(3NF)</h4><p><strong>在满足第二范式的前提下，表中的每一列都直接依赖于主键，而不是通过其它的列来间接依赖于主键（不存在传递依赖）</strong>。</p><p>所谓传递依赖是指如果存在“A(主键字段) -&gt; B(非主键字段) -&gt; C(非主键字段)”的决定关系，则C依赖A。</p><p><strong>第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。</strong></p><p>例如：存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。</p><p><strong>简而言之，第三范式就是属性不依赖于其它非主键属性，也就是在满足 2NF 的基础上，任何非主属性不得传递依赖于主属性</strong>。</p><p>像：a -&gt; b -&gt; c  属性之间含有这样的关系，是不符合第三范式的。</p><h3 id="4-4-范式说明"><a href="#4-4-范式说明" class="headerlink" title="4.4. 范式说明"></a>4.4. 范式说明</h3><p>真正的数据库范式定义上，相当难懂，比如第二范式（2NF）的定义“若某关系 R 属于第一范式，且每一个非主属性完全函数依赖于任何一个候选码，则关系 R 属于第二范式。”，这里面有着大堆专业术语的堆叠，比如“函数依赖”、“码”、“非主属性”、与“完全函数依赖”等等，而且有完备的公式定义，深入研究可参考书籍：《数据库系统概念（第5版）》</p><h3 id="4-5-反范式设计"><a href="#4-5-反范式设计" class="headerlink" title="4.5. 反范式设计"></a>4.5. 反范式设计</h3><h4 id="4-5-1-反范式化设计概念"><a href="#4-5-1-反范式化设计概念" class="headerlink" title="4.5.1. 反范式化设计概念"></a>4.5.1. 反范式化设计概念</h4><p>反范式化就是为了性能和读取效率得考虑，而适当得对数据库设计范式得要求进行违反，允许存在少量得冗余。即反范式化就是使用空间来换取时间。</p><h4 id="4-5-2-反范式实际应用示例"><a href="#4-5-2-反范式实际应用示例" class="headerlink" title="4.5.2. 反范式实际应用示例"></a>4.5.2. 反范式实际应用示例</h4><h5 id="4-5-2-1-性能提升-缓存和汇总"><a href="#4-5-2-1-性能提升-缓存和汇总" class="headerlink" title="4.5.2.1. 性能提升-缓存和汇总"></a>4.5.2.1. 性能提升-缓存和汇总</h5><p>最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。</p><p>缓存衍生值也是有用的。如果需要显示每个用户发了多少消息，可以每次执行一个对用户发送消息进行<code>count</code>的子查询来计算并显示它，也可以在<code>user</code>表用户中建一个消息发送数目的专门列，每当用户发新消息时更新这个值。</p><p>有需要时创建一张完全独立的汇总表或缓存表也是提升性能的好办法。“缓存表”来表示存储那些可以比较简单地从其他表获取（但是每次获取的速度比较慢）数据的表（例如，逻辑上冗余的数据)。而“汇总表”时,则保存的是使用<code>GROUP BY</code>语句聚合数据的表。</p><p>在使用缓存表和汇总表时，有个关键点是如何维护缓存表和汇总表中的数据，常用的有两种方式，实时维护数据和定期重建，这个取决于应用程序，不过一般来说，缓存表用实时维护数据更多点，往往在一个事务中同时更新数据本表和缓存表，汇总表则用定期重建更多，使用定时任务对汇总表进行更新。</p><h5 id="4-5-2-2-性能提升-计数器表"><a href="#4-5-2-2-性能提升-计数器表" class="headerlink" title="4.5.2.2. 性能提升-计数器表"></a>4.5.2.2. 性能提升-计数器表</h5><p>比如网站点击数、用户的朋友数、文件下载次数等。对于高并发下的处理，首先可以创建一张独立的表存储计数器，这样可使计数器表小且快，并且可以使用一些更高级的技巧。</p><p>比如假设有一个计数器表，只有一行数据，记录网站的点击次数，网站的每次点击都会导致对计数器进行更新，问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁(mutex)。这会使得这些事务只能串行执行，会严重限制系统的并发能力。</p><p><strong>改进方案：可以将计数器保存在多行中，每次随机选择一行进行更新。在具体实现上，可以增加一个槽（slot)字段，然后预先在这张表增加 100 行或者更多数据，当对计数器更新时，选择一个随机的槽（slot)进行更新即可</strong>。</p><p><font color=red><strong>这种解决思路其实就是写热点的分散，在 JDK 的 JDK1.8 中新的原子类<code>LongAdder</code>也是这种处理方式</strong></font>，而在实际的缓冲中间件Redis等的使用、架构设计中，可以采用这种写热点的分散的方式，当然架构设计中对于写热点还有削峰填谷的处理方式，这种在 MySQL 的实现中也有体现</p><h5 id="4-5-2-3-反范式设计-分库分表中的查询"><a href="#4-5-2-3-反范式设计-分库分表中的查询" class="headerlink" title="4.5.2.3. 反范式设计-分库分表中的查询"></a>4.5.2.3. 反范式设计-分库分表中的查询</h5><p>例如，用户购买了商品，需要将交易记录保存下来，那么如果按照买家的纬度分表，则每个买家的交易记录都被保存在同一表中，这样可以很快、很方便地査到某个买家的购买情况，但是某个商品被购买的交易数据很有可能分布在多张表中，査找起来比较麻烦。反之，按照商品维度分表，则可以很方便地査找到该商品的购买情况，但若要査找到买家的交易记录，则会比较麻烦</p><p>常见的解决方式如下：</p><ol><li>在多个分片表查询后合并数据集，这种方式的效率很低</li><li>记录两份数据，一份按照买家纬度分表，一份按照商品维度分表</li><li>通过搜索引擎解决，但如果实时性要求很高，就需要实现实时搜索</li></ol><p>在某电商交易平台下，可能有买家査询自己在某一时间段的订单，也可能有卖家査询自已在某一时间段的订单，如果使用了分库分表方案，则这两个需求是难以满足的</p><p>因此通用的解决方案是，在交易生成时生成一份按照买家分片的数据副本和一份按照卖家分片的数据副本，查询时分别满足之前的两个需求，因此，查询的数据和交易的数据可能是分别存储的，并从不同的系统提供接口</p><h3 id="4-6-数据库设计小结"><a href="#4-6-数据库设计小结" class="headerlink" title="4.6. 数据库设计小结"></a>4.6. 数据库设计小结</h3><p>三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。</p><p>如果有特殊情况，当然要特殊对待，<font color=red><strong>数据库设计最重要的是看需求跟性能，需求 &gt; 性能 &gt; 表结构</strong></font>。所以不能一味的去追求范式建立数据库。</p><ul><li>1NF:字段不可分（<em>原子性 字段不可再分</em>）;</li><li>2NF:有主键，非主键字段依赖主键（<em>唯一性 一个表只说明一个事物</em>）;</li><li>3NF:非主键字段不能相互依赖（<em>每列都与主键有直接关系，不存在传递依赖</em>）;</li></ul><p><strong>范式化设计优点</strong>：</p><ul><li>范式化的更新操作通常比反范式化要快</li><li>当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据</li><li>范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快</li><li>很少有多余的数据意味着检索列表数据时更少需要<code>DISTINCT</code>或者<code>GROUP BY</code>语句。在非范式化的结构中必须使用<code>DISTINCT</code>或者<code>GROUP BY</code>才能获得一份唯一的列表，但是如果是一张单独的表，很可能则只需要简单的查询这张表就行了</li></ul><p><strong>范式化设计缺点</strong>：</p><ul><li>通常需要关联表查询。稍微复杂一些的查询语句在符合范式的表上都可能需要至少一次关联，也许更多</li><li>可能使一些索引策略无效</li></ul><p><strong>反范式化设计优点</strong>：</p><ul><li>反范式设计可以减少表的关联</li><li>可以更好的进行索引优化</li></ul><p><strong>反范式化设计缺点</strong>：</p><ul><li>存在数据冗余及数据维护异常</li><li>对数据的修改需要更多的成本</li></ul><h2 id="5-关系型数据库、表、字段等命名规则"><a href="#5-关系型数据库、表、字段等命名规则" class="headerlink" title="5. 关系型数据库、表、字段等命名规则"></a>5. 关系型数据库、表、字段等命名规则</h2><h3 id="5-1-数据库命名规则"><a href="#5-1-数据库命名规则" class="headerlink" title="5.1. 数据库命名规则"></a>5.1. 数据库命名规则</h3><p>根据项目的实际意思来命名。</p><h3 id="5-2-数据表命名规则"><a href="#5-2-数据表命名规则" class="headerlink" title="5.2. 数据表命名规则"></a>5.2. 数据表命名规则</h3><ol><li>数据表的命名大部分都是以名词的复数形式并且都为小写；</li><li>尽量使用前缀 <code>table_</code>；</li><li>如果数据表的表名是由多个单词组成，则尽量用下划线连接起来；但是不要超过30个字符，一旦超过30个字符，则使用缩写来缩短表名的长度；</li><li>具备统一前缀，对相关功能的表应当使用相同前缀，如 <code>acl_xxx</code>，<code>house_xxx</code>，<code>ppc_xxx</code>；其中前缀通常为这个表的模块或依赖主实体对象的名字，通常来讲表名为：<code>业务_动作_类型</code>，或是<code>业务_类型</code>；</li><li>数据表必须有主键，且建议均使用 <code>auto_increment</code> 的 id 作为主键（与业务无关），和业务相关的要做为唯一索引；</li></ol><h3 id="5-3-字段命名规则"><a href="#5-3-字段命名规则" class="headerlink" title="5.3. 字段命名规则"></a>5.3. 字段命名规则</h3><ol><li>首先命名字段尽量采用小写，并且是采用有意义的单词；</li><li>使用前缀，前缀尽量用 <code>表的前四个字母+下划线</code> 组成”；</li><li>如果字段名由多个单词组成，则使用下划线来进行连接，一旦超过30个字符，则用缩写来缩短字段名的长度；</li></ol><h3 id="5-4-视图命名规则"><a href="#5-4-视图命名规则" class="headerlink" title="5.4. 视图命名规则"></a>5.4. 视图命名规则</h3><ol><li>尽量使用前缀 <code>view_</code>；</li><li>如果创建的视图牵扯多张数据表，则一定列出所有表名，如果长度超过30个字符时可以简化表名，中间用下划线来连接；</li></ol><h3 id="5-5-主键命名规则"><a href="#5-5-主键命名规则" class="headerlink" title="5.5. 主键命名规则"></a>5.5. 主键命名规则</h3><ol><li>主键用 <code>pk_</code> 开头，后面跟上该主键所在的表名；</li><li>不能超过30个字符，尽量使用小写英文单词；</li></ol><h2 id="6-参考资源"><a href="#6-参考资源" class="headerlink" title="6. 参考资源"></a>6. 参考资源</h2><ul><li><a href="https://github.com/wx-chevalier/Database-Notes">Database Series（数据库·实践笔记）</a> - 深入浅出数据库存储：数据库理论、关系型数据库、文档型数据库、键值型数据库、New SQL、搜索引擎、数据仓库与 OLAP、大数据与数据中台。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-数据库技术&quot;&gt;&lt;a href=&quot;#1-数据库技术&quot; class=&quot;headerlink&quot; title=&quot;1. 数据库技术&quot;&gt;&lt;/a&gt;1. 数据库技术&lt;/h2&gt;&lt;h3 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="数据库" scheme="https://ktzxy.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://ktzxy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>24工厂模式俗话解释</title>
    <link href="https://ktzxy.github.io/posts/490575ab.html"/>
    <id>https://ktzxy.github.io/posts/490575ab.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="01-工厂方法"><a href="#01-工厂方法" class="headerlink" title="01 工厂方法"></a>01 工厂方法</h3><p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。<br>消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p><h3 id="02-建造者模式"><a href="#02-建造者模式" class="headerlink" title="02 建造者模式"></a>02 建造者模式</h3><p>MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。<br>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p><h3 id="03-抽象工厂"><a href="#03-抽象工厂" class="headerlink" title="03 抽象工厂"></a>03 抽象工厂</h3><p>请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。<br>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p><h3 id="04-原型模式"><a href="#04-原型模式" class="headerlink" title="04 原型模式"></a>04 原型模式</h3><p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）<br>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p><h3 id="05-单态模式"><a href="#05-单态模式" class="headerlink" title="05 单态模式"></a>05 单态模式</h3><p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)<br>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。</p><h3 id="06-适配器模式"><a href="#06-适配器模式" class="headerlink" title="06 适配器模式"></a>06 适配器模式</h3><p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)<br>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p><h3 id="07-桥梁模式"><a href="#07-桥梁模式" class="headerlink" title="07 桥梁模式"></a>07 桥梁模式</h3><p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了<br>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。</p><h3 id="08-合成模式"><a href="#08-合成模式" class="headerlink" title="08 合成模式"></a>08 合成模式</h3><p>Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？<br>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p><h3 id="09-装饰模式"><a href="#09-装饰模式" class="headerlink" title="09 装饰模式"></a>09 装饰模式</h3><p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？<br>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p><h3 id="10-门面模式"><a href="#10-门面模式" class="headerlink" title="10 门面模式"></a>10 门面模式</h3><p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。<br>门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p><h3 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11 享元模式"></a>11 享元模式</h3><p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。<br>享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。<br>将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p><h3 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12 代理模式"></a>12 代理模式</h3><p>跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。<br>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。<br>客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p><h3 id="13-责任链模式"><a href="#13-责任链模式" class="headerlink" title="13 责任链模式"></a>13 责任链模式</h3><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！<br>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p><h3 id="14-命令模式"><a href="#14-命令模式" class="headerlink" title="14 命令模式"></a>14 命令模式</h3><p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”<br>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p><h3 id="15-解释器模式"><a href="#15-解释器模式" class="headerlink" title="15 解释器模式"></a>15 解释器模式</h3><p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。<br>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。<br>在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p><h3 id="16-迭代模式"><a href="#16-迭代模式" class="headerlink" title="16 迭代模式"></a>16 迭代模式</h3><p>我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”<br>迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。<br>迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p><h3 id="17-调停者模式"><a href="#17-调停者模式" class="headerlink" title="17 调停者模式"></a>17 调停者模式</h3><p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。<br>当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p><h3 id="18-备忘录模式"><a href="#18-备忘录模式" class="headerlink" title="18 备忘录模式"></a>18 备忘录模式</h3><p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。<br>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p><h3 id="19-观察者模式"><a href="#19-观察者模式" class="headerlink" title="19 观察者模式"></a>19 观察者模式</h3><p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。<br>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。关注微信订阅号码匠笔记回复设计模式还有视频版本哦</p><h3 id="20-状态模式"><a href="#20-状态模式" class="headerlink" title="20 状态模式"></a>20 状态模式</h3><p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。<br>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。<br>状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p><h3 id="21-策略模式"><a href="#21-策略模式" class="headerlink" title="21 策略模式"></a>21 策略模式</h3><p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。<br>策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p><h3 id="22-模板方法模式"><a href="#22-模板方法模式" class="headerlink" title="22 模板方法模式"></a>22 模板方法模式</h3><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；<br>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p><h3 id="23-访问者模式"><a href="#23-访问者模式" class="headerlink" title="23 访问者模式"></a>23 访问者模式</h3><p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；<br>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。<br>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;01-工厂方法&quot;&gt;&lt;a href=&quot;#01-工厂方法&quot; class=&quot;headerlink&quot; title=&quot;01 工厂方法&quot;&gt;&lt;/a&gt;01 工厂方法&lt;/h3&gt;&lt;p&gt;追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管</summary>
      
    
    
    
    <category term="设计模式" scheme="https://ktzxy.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://ktzxy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://ktzxy.github.io/posts/364ea8cc.html"/>
    <id>https://ktzxy.github.io/posts/364ea8cc.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p><ul><li><p>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</p></li><li><p>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</p></li><li><p>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</p></li></ul><p>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思</p><p>每个代理模式的代码都必须自己手动完成一遍。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><p>工厂模式分为简单工厂模式，工厂模式，抽象工厂模式</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<strong>本质就是使用工厂方法代替new操作。</strong></p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;兰州拉面&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">noodle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LanZhouNoodle</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;兰州拉面&quot;</span>+noodle+<span class="string">&quot;出锅啦&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;黄焖鸡&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">Food</span> <span class="variable">chicken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuangMenChicken</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;黄焖鸡&quot;</span>+ chicken +<span class="string">&quot;出锅啦&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不知道你做的什么哦~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> FoodFactory.makeFood(<span class="string">&quot;黄焖鸡&quot;</span>);</span><br><span class="line">        FoodFactory.makeFood(<span class="string">&quot;jaja&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单地说，<strong>简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</strong></p><blockquote><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p></blockquote><p>在此例中可以看出，Cook 类在使用 FoodFactory 时就不需要 new 任何一个对象，这就是简单工厂模式的好处，封装了 new 的部分，做到的代码易用性。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line">    Food <span class="title function_">makeFood</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title class_">FoodFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">makeFood</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanFoodB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        <span class="type">FoodFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChineseFoodFactory</span>();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        <span class="type">Food</span> <span class="variable">food</span> <span class="operator">=</span> factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然都是调用 makeFood(“A”) 制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p><p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p><p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。 一个经典的例子是造一台电脑 。</p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，图 1 所示的是海尔工厂和 TCL 工厂所生产的电视机与空调对应的关系图。</p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202408221615566.gif" alt="电器工厂的产品等级与产品族"></p><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p>使用抽象工厂模式一般要满足以下条件。</p><ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li></ul><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li></ul><p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p><p>getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。</p><p><strong>特点</strong></p><ul><li>类构造器私有</li><li>持有自己类型的属性</li><li>对外提供获取实例的静态方法</li></ul><p><strong>饿汉式写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">   private static Singleton instance = new Singleton();  </span><br><span class="line">   private Singleton ()&#123;&#125;  </span><br><span class="line">   public static Singleton getInstance() &#123;  </span><br><span class="line">   return instance;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弊端：因为类加载的时候就会创建对象，所以有的时候还不需要使用对象，就会创建对象，造成内存的浪费；</p><p><strong>饱汉模式最容易出错：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    // 首先，也是先堵死 new Singleton() 这条路</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span><br><span class="line">    private static volatile Singleton instance = null;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            // 加锁</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                // 这一次判断也是必须的，不然会有并发问题</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双重检查，指的是两次检查 instance 是否为 null。</p><p>volatile 在这里是需要的，希望能引起读者的关注。</p><p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p></blockquote><p>嵌套类最经典，以后大家就用它吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span><br><span class="line">    private static class Holder &#123;</span><br><span class="line">        private static Singleton instance = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p></blockquote><p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p><p><strong>TODO:</strong></p><p>建造者模式</p><p>原型模式</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。 下面上代码理解。 代理接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//要有一个代理接口让实现类和代理实现类来实现。</span><br><span class="line">public interface FoodService &#123;</span><br><span class="line">    Food makeChicken();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被代理的实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FoodServiceImpl implements FoodService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Food makeChicken() &#123;</span><br><span class="line">        Food f = new Chicken();</span><br><span class="line">        f.setChicken(&quot;1kg&quot;);</span><br><span class="line">        f.setSpicy(&quot;1g&quot;);</span><br><span class="line">        f.setSalt(&quot;3g&quot;);</span><br><span class="line">        System.out.println(&quot;鸡肉加好佐料了&quot;);</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被代理实现类就只需要做自己该做的事情就好了，不需要管别的。</p><p>代理实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class FoodServiceProxy implements FoodService &#123;</span><br><span class="line">    // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span><br><span class="line">    private FoodService foodService = new FoodServiceImpl();</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Food makeChicken() &#123;</span><br><span class="line">        System.out.println(&quot;开始制作鸡肉&quot;);</span><br><span class="line">        </span><br><span class="line">        // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span><br><span class="line">        // 代理只是在核心代码前后做些“无足轻重”的事情</span><br><span class="line">        Food food = foodService.makeChicken();</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;鸡肉制作完成啦，加点胡椒粉&quot;);</span><br><span class="line">        food.addCondiment(&quot;pepper&quot;);</span><br><span class="line">        System.out.println(&quot;上锅咯&quot;);</span><br><span class="line">        return food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用，注意，我们要用代理来实例化接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 这里用代理类来实例化</span><br><span class="line">FoodService foodService = new FoodServiceProxy();</span><br><span class="line">foodService.makeChicken();</span><br></pre></td></tr></table></figure><p>所谓代理模式，<strong>就是对被代理方法包装或者叫增强， 在面向切面编程（AOP）中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</strong></p><p>待续。。。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p><p><strong>父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现</strong></p><p>模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p><p>好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好</p><p>缺点： 每一个不同的实现都需要一个子类来实现，导致类个数增加，使系统更加庞大</p><p><strong>模板模式的关键点：</strong></p><p>　　　　1、使用抽象类定义模板类，并在其中定义所有的基本方法、模板方法，钩子方法，不限数量，以实现功能逻辑为主。其中基本方法使用final修饰，其中要调用基本方法和钩子方法，基本方法和钩子方法可以使用protected修饰，表明可被子类修改。</p><p>　　　　2、定义实现抽象类的子类，重写其中的模板方法，甚至钩子方法，完善具体的逻辑。</p><p>　　使用场景：</p><p>　　　　1、在多个子类中拥有相同的方法，而且逻辑相同时，可以将这些方法抽出来放到一个模板抽象类中。</p><p>　　　　2、程序主框架相同，细节不同的情况下，也可以使用模板方法。</p><h4 id="架构方法介绍"><a href="#架构方法介绍" class="headerlink" title="架构方法介绍"></a>架构方法介绍</h4><p>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。其主要分为两大类：模版方法和基本方法，而基本方法又分为：抽象方法（Abstract Method），具体方法（Concrete Method），钩子方法（Hook Method）。</p><p>四种方法的基本定义（前提：在抽象类中定义）：</p><p>（1）抽象方法：由抽象类声明，由具体子类实现，并以abstract关键字进行标识。</p><p>（2）具体方法：由抽象类声明并且实现，子类并不实现或者做覆盖操作。其实质就是普遍适用的方法，不需要子类来实现。</p><p>（3）钩子方法：由抽象类声明并且实现，子类也可以选择加以扩展。通常抽象类会给出一个空的钩子方法，也就是没有实现的扩展。<strong>它和具体方法在代码上没有区别，不过是一种意识的区别</strong>；而它和抽象方法有时候也是没有区别的，就是在子类都需要将其实现的时候。而不同的是抽象方法必须实现，而钩子方法可以不实现。也就是说钩子方法为你在实现某一个抽象类的时候提供了可选项，<strong>相当于预先提供了一个默认配置。</strong></p><p>（4）模板方法：定义了一个方法，其中定义了整个逻辑的基本骨架。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractTemplate &#123;</span><br><span class="line">    // 这就是模板方法</span><br><span class="line">    public void templateMethod() &#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); // 这个是重点</span><br><span class="line">        end(); // 可以作为钩子方法</span><br><span class="line">    &#125;</span><br><span class="line">//这是具体方法</span><br><span class="line">    protected void init() &#123;</span><br><span class="line">        System.out.println(&quot;init 抽象层已经实现，子类也可以选择覆写&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 这是抽象方法，留给子类实现</span><br><span class="line">    protected abstract void apply();</span><br><span class="line">//这是钩子方法，可定义一个默认操作，或者为空</span><br><span class="line">    protected void end() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h</summary>
      
    
    
    
    <category term="设计模式" scheme="https://ktzxy.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://ktzxy.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="https://ktzxy.github.io/posts/154d371b.html"/>
    <id>https://ktzxy.github.io/posts/154d371b.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a></h4><p>难度中等1772</p><p>运用你所掌握的数据结构，设计和实现一个 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存机制</a> 。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p><strong>进阶</strong>：你是否可以在 <code>O(1)</code> 时间复杂度内完成这两种操作？</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul><li>节点用双向节点</li><li>用一个Map去存放Node，这样就不需要遍历链表</li><li>要注意方法的封装可以使逻辑更清晰不容易出错（在头部添加节点、删除尾部的节点、移动节点到头部、删除节点）</li><li>头节点和尾结点用一个空的虚拟节点，这样就可以省去很多麻烦的边界条件判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Integer, Node&gt; checkMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Node head;</span><br><span class="line"><span class="keyword">private</span> Node tail;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node prev;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, Node prev, Node next)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> checkMap.get(key);</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> checkMap.get(key);</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">        addToHead(node);</span><br><span class="line">        <span class="keyword">if</span>(checkMap.size() &gt; capacity)&#123;</span><br><span class="line">            removeTail();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">        moveToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeTail</span><span class="params">()</span>&#123;</span><br><span class="line">    removeNode(tail.prev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    removeNode(node);</span><br><span class="line">    addToHead(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == head)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.prev.next = node.next;</span><br><span class="line">    node.next.prev = node.prev;</span><br><span class="line">    node.prev = <span class="literal">null</span>;</span><br><span class="line">    node.next = <span class="literal">null</span>;</span><br><span class="line">    checkMap.remove(node.key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    head.next.prev = node;</span><br><span class="line">    node.next = head.next;</span><br><span class="line">    node.prev = head;</span><br><span class="line">    head.next = node;</span><br><span class="line">    checkMap.put(node.key, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;146-LRU-缓存机制&quot;&gt;&lt;a href=&quot;#146-LRU-缓存机制&quot; class=&quot;headerlink&quot; title=&quot;146. LRU 缓存机制&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cac</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>三数之和</title>
    <link href="https://ktzxy.github.io/posts/632d79b2.html"/>
    <id>https://ktzxy.github.io/posts/632d79b2.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p>定义三个指针，第一个指针从头开始遍历，第二个指针从末尾开始遍历，第三个指针从第一个指针的下一个开始遍历。前两个指针每次遍历的时候要判断当前遍历到的元素是否和前一个遍历到的元素相同，如果相同的话就跳过这次循环不然就会出现重复的结果。第三个指针从末尾开始遍历如果遍历到的元素和第二个元素之和大于第一个元素的相反数并且指针的值大于第二个指针就继续遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>; first &lt; length; first++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>; second &lt; length; second++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(third &gt; second &amp;&amp; nums[second] + nums[third] &gt; -nums[first])&#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(second == third)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[second] + nums[third] == -nums[first])&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[first], nums[second], nums[third]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三数之和&quot;&gt;&lt;a href=&quot;#三数之和&quot; class=&quot;headerlink&quot; title=&quot;三数之和&quot;&gt;&lt;/a&gt;三数之和&lt;/h1&gt;&lt;p&gt;给你一个包含 &lt;code&gt;n&lt;/code&gt; 个整数的数组 &lt;code&gt;nums&lt;/code&gt;，判断 &lt;code&gt;nums&lt;/</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>下一个排列</title>
    <link href="https://ktzxy.github.io/posts/2f1f1a21.html"/>
    <id>https://ktzxy.github.io/posts/2f1f1a21.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><p>难度中等1421收藏分享切换为英文接收动态反馈</p><p>实现获取 <strong>下一个排列</strong> 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须<strong><a href="https://baike.baidu.com/item/原地算法"> 原地 </a></strong>修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,5]</span><br><span class="line">输出：[1,5,1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p>要想找到当前排列的下一个排列，那么就需要找到比当前排列略大一点的排列，要领就是将靠左边一个略小的数替换成右边一个比这个数略大的数，之后再将这个左边这个数的右边部分反转就能得到当前排列的下一个排列。</p><ul><li>从数组后面向前遍历，找到第一个打破升序的数，比如：4，8， 6， 5，2，1那么4就是我们要找的数。</li><li>再次从数组后面向前遍历，找到第一个比上一步找到的数大的数，在这里就是5，将这两个数交换位置得到5 8 6 4 2 1</li><li>那么左边找到数的位置其右边的数就是安装降序排列的，我们要把它改成升序就能得到下一个排列</li></ul><p>注意 ： 如果原来数组就是降序，那么就直接反转这个数组（题目要求）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> start, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;31-下一个排列&quot;&gt;&lt;a href=&quot;#31-下一个排列&quot; class=&quot;headerlink&quot; title=&quot;31. 下一个排列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/next-permutation/&quot;&gt;</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="https://ktzxy.github.io/posts/d3748a3d.html"/>
    <id>https://ktzxy.github.io/posts/d3748a3d.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h4><p>难度中等1423收藏分享切换为英文接收动态反馈</p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202408261716135.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] G = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">// n</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;= i; j++)&#123;</span><br><span class="line">                <span class="comment">// i</span></span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;不同的二叉搜索树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-binary-search</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>不同路径</title>
    <link href="https://ktzxy.github.io/posts/a42081a0.html"/>
    <id>https://ktzxy.github.io/posts/a42081a0.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h4><p>难度中等1193收藏分享切换为英文接收动态反馈</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202408261717991.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划的解题技巧：</p><ul><li>先把状态转移方程写出来</li><li>把所有已知的信息写出来</li><li>根据状态转移方程直接写代码，梭哈</li></ul><p>f(i, j) = f(i - 1, j) + f(i, j - 1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            ans[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ans[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                ans[i][j] = ans[i - <span class="number">1</span>][j] + ans[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;不同路径&quot;&gt;&lt;a href=&quot;#不同路径&quot; class=&quot;headerlink&quot; title=&quot;不同路径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot;&gt;不同路径&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="https://ktzxy.github.io/posts/d98ef1d2.html"/>
    <id>https://ktzxy.github.io/posts/d98ef1d2.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h1 id="Hash-O-n-O-n"><a href="#Hash-O-n-O-n" class="headerlink" title="Hash O(n) O(n)"></a>Hash O(n) O(n)</h1><p>定义一个hashMap，key存放遍历到的元素，value存放这个元素的下标。每遍历到一个元素就判断target减去这个元素在map里面有没有key，如果有就直接返回那个元素的下标和当前元素的下标。没有就将当前元素放到map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h1&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>两数相加</title>
    <link href="https://ktzxy.github.io/posts/b6465ced.html"/>
    <id>https://ktzxy.github.io/posts/b6465ced.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></h4><p>难度中等6157收藏分享切换为英文接收动态反馈</p><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="原地算法"><a href="#原地算法" class="headerlink" title="原地算法"></a>原地算法</h2><ul><li>将L1作为最后的返回链表。</li><li>将两个链表从首位开始相加，记录相加进位的值，将相加所得的个位的值放到L1链表的当前位置，相加的时候要考虑进位。</li><li>L1长度不够了就新增节点。</li><li>最后判断一下进位标记是否不为0，如果不是0就新增一个节点到L1链表的末尾。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> (v1 + v2 + temp) % <span class="number">10</span>;</span><br><span class="line">            temp = (v1 + v2 + temp) / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="literal">null</span>)&#123;</span><br><span class="line">                p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">                l1 = p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l1.val = val;</span><br><span class="line">            &#125;</span><br><span class="line">            p = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2 == <span class="literal">null</span> ? <span class="literal">null</span> : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp != <span class="number">0</span>)&#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;两数相加&quot;&gt;&lt;a href=&quot;#两数相加&quot; class=&quot;headerlink&quot; title=&quot;两数相加&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/&quot;&gt;两数相加&lt;/a&gt;&lt;/h4&gt;&lt;</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>乘积最大子数组</title>
    <link href="https://ktzxy.github.io/posts/8213ce87.html"/>
    <id>https://ktzxy.github.io/posts/8213ce87.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h4><p>难度中等1393收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>注意每次循环的时候不光要记录当前的最大值，还有记录当前的最小值，因为负负得正。</p><p>maxF(i) = max( maxF(i - 1) <em> nums[i] , max( minF() </em> nums[i], nums[i] ) )</p><p>minF(i) = min( minF(i - 1) <em> nums[i] , min( maxF() </em> nums[i], nums[i] ) )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPrev</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minPrev</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            temp = Math.max(maxPrev * nums[i], Math.max(minPrev * nums[i], nums[i]));</span><br><span class="line">            minPrev = Math.min(minPrev * nums[i], Math.min(maxPrev * nums[i], nums[i]));</span><br><span class="line">            maxPrev = temp;</span><br><span class="line">            max = Math.max(maxPrev, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;152-乘积最大子数组&quot;&gt;&lt;a href=&quot;#152-乘积最大子数组&quot; class=&quot;headerlink&quot; title=&quot;152. 乘积最大子数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-pr</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>买股票的最佳时机</title>
    <link href="https://ktzxy.github.io/posts/4542a6d3.html"/>
    <id>https://ktzxy.github.io/posts/4542a6d3.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：</p><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p><p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>设置当前天数的持有股票的收益为hold，不持有股票的收益为noHold。那么状态转移方程就是：</p><ul><li>noHold = Math.max(noHold, hold + prices[i]);</li><li>hold = Math.max(hold, -prices[i]);</li><li>第一天持有：hold = -prices[0];</li><li>第一天不持有：noHold = 0;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hold</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">noHold</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            noHold = Math.max(noHold, hold + prices[i]);</span><br><span class="line">            hold = Math.max(hold, -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> noHold;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>从数组的头部开始遍历，用min遍历记录数组中遍历过的元素的最小值。取当前元素减去历史最小元素的最大值就是最大的利润。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            pro = Math.max(prices[i] - min, pro);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pro;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;买卖股票的最佳时机&quot;&gt;&lt;/a&gt;买卖股票的最佳时机&lt;/h1&gt;&lt;p&gt;给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>买股票的最佳时机含冷冻期</title>
    <link href="https://ktzxy.github.io/posts/bdbc6cb9.html"/>
    <id>https://ktzxy.github.io/posts/bdbc6cb9.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h4><p>难度中等981收藏分享切换为英文接收动态反馈</p><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>由题意可知：每天的状态有三种：持有股票、冷冻期、不持有股票也不是冷冻期</p><p>状态转移方程如下：</p><p>dpHold[i] = max(dpNothing[i - 1] - prices[i], dpHold[i - 1]);</p><p>dpCold[i] = dpHold[i - 1] + prices[i];</p><p>dpNothing[i] = max(dpCold[i - 1], dpNothing[i - 1]);</p><p>使用滚动数组可以降低空间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpHold</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpCold</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpNothing</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">tempHold</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            tempHold = dpHold;</span><br><span class="line">            dpHold = Math.max(dpNothing - prices[i], dpHold);</span><br><span class="line">            dpNothing = Math.max(dpCold, dpNothing);</span><br><span class="line">            dpCold = tempHold + prices[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dpCold, dpNothing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;309-最佳买卖股票时机含冷冻期&quot;&gt;&lt;a href=&quot;#309-最佳买卖股票时机含冷冻期&quot; class=&quot;headerlink&quot; title=&quot;309. 最佳买卖股票时机含冷冻期&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树中第K小的元素</title>
    <link href="https://ktzxy.github.io/posts/66181fbd.html"/>
    <id>https://ktzxy.github.io/posts/66181fbd.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第K小的元素</a></h4><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h2 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h2><ul><li>递归中序遍历，将结果放到list中。</li><li>返回数组中k-1下标位置的元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root, list);</span><br><span class="line">        <span class="keyword">return</span> list.get(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(node.left, list);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        inorder(node.right, list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="栈DFS-（更好）"><a href="#栈DFS-（更好）" class="headerlink" title="栈DFS    （更好）"></a>栈DFS    （更好）</h2><ul><li>使用栈进行DFS。</li><li>当弹出元素个数等于k时就返回这个元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                deque.offerFirst(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = deque.poll();</span><br><span class="line">            <span class="keyword">if</span>(--k == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.val;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二叉搜索树中第K小的元素&quot;&gt;&lt;a href=&quot;#二叉搜索树中第K小的元素&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树中第K小的元素&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/kth-smal</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的层序遍历</title>
    <link href="https://ktzxy.github.io/posts/d1080f68.html"/>
    <id>https://ktzxy.github.io/posts/d1080f68.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回其层序遍历结果：</p><p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//获取当前队列的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">//存放当前层次节点值的数组</span></span><br><span class="line">            List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//将本层的所有节点遍历</span></span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将当前的节点的值放到list</span></span><br><span class="line">                itemList.add(node.val);</span><br><span class="line">                <span class="comment">//将当前节点的左右子节点依次放到队尾</span></span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前层次节点值数组不为空就放到总的数组中</span></span><br><span class="line">            <span class="keyword">if</span>(!itemList.isEmpty())&#123;</span><br><span class="line">                list.add(itemList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, TreeNode node, <span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果当前节点的深度大于总数组的大小表示当前节点在新的层次</span></span><br><span class="line">    <span class="comment">//这里就需要新增一个层次的数组放到总数组里面</span></span><br><span class="line">        <span class="keyword">if</span>(level &gt;= list.size())&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//从总数组中获取当前节点对应层次的数组，将当前节点的值放到数组</span></span><br><span class="line">        list.get(level).add(node.val);</span><br><span class="line">    <span class="comment">//递归当前节点的左节点并将层次+1</span></span><br><span class="line">        levelOrder(list, node.left, level + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//递归当前节点的右节点并将层次+1</span></span><br><span class="line">        levelOrder(list, node.right, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        levelOrder(list, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的层序遍历&quot;&gt;&lt;/a&gt;二叉树的层序遍历&lt;/h1&gt;&lt;p&gt;给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="https://ktzxy.github.io/posts/fd4c32db.html"/>
    <id>https://ktzxy.github.io/posts/fd4c32db.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h4><p>难度中等1423收藏分享切换为英文接收动态反馈</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202408261722736.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202408261722063.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><p>当前节点如果满足：inCurrent &amp;&amp; (inLeft || inRight) || inLeft &amp;&amp; inRight  那么这个节点就是指定两个节点的最近公共祖先节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode node, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inCurrent</span> <span class="operator">=</span> node == p || node == q;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inLeft</span> <span class="operator">=</span> dfs(node.left, p, q);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inRight</span> <span class="operator">=</span> dfs(node.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(inCurrent &amp;&amp; (inLeft || inRight) || inLeft &amp;&amp; inRight)&#123;</span><br><span class="line">            ans = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inCurrent || inLeft || inRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;236-二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#236-二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;236. 二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/l</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的直径</title>
    <link href="https://ktzxy.github.io/posts/46778f77.html"/>
    <id>https://ktzxy.github.io/posts/46778f77.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h4><p>难度简单851收藏分享切换为英文接收动态反馈</p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> max - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right);</span><br><span class="line">        max = Math.max(max,  left + right + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;543-二叉树的直径&quot;&gt;&lt;a href=&quot;#543-二叉树的直径&quot; class=&quot;headerlink&quot; title=&quot;543. 二叉树的直径&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/diameter-of-b</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的锯齿形层序遍历</title>
    <link href="https://ktzxy.github.io/posts/efdadadb.html"/>
    <id>https://ktzxy.github.io/posts/efdadadb.html</id>
    <published>2025-07-09T17:28:46.000Z</published>
    <updated>2025-07-13T15:45:18.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的锯齿形层次遍历"><a href="#二叉树的锯齿形层次遍历" class="headerlink" title="二叉树的锯齿形层次遍历"></a>二叉树的锯齿形层次遍历</h1><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>3</code></pre><p>   / \<br>  9  20<br>    /  \<br>   15   7<br>返回锯齿形层序遍历如下：</p><p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>和常规的层序遍历一样，但是存储单层节点的值的时候，奇数层就从右往左，偶数层就从左往右。这里可以使用双端队列Deque，分别对应的是offerLast和offerFirst方法。从队首拿出节点是offer方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offerLast(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">offerLeft</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            Deque&lt;Integer&gt; valDeque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                <span class="keyword">if</span>(offerLeft)&#123;</span><br><span class="line">                    valDeque.offerLast(node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    valDeque.offerFirst(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    deque.offerLast(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    deque.offerLast(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            offerLeft = !offerLeft;</span><br><span class="line">            resList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(valDeque));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的锯齿形层次遍历&quot;&gt;&lt;a href=&quot;#二叉树的锯齿形层次遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的锯齿形层次遍历&quot;&gt;&lt;/a&gt;二叉树的锯齿形层次遍历&lt;/h1&gt;&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右</summary>
      
    
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/categories/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="力扣笔记" scheme="https://ktzxy.github.io/tags/%E5%8A%9B%E6%89%A3%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础-网络编程 | 蓝桉`Blog</title><meta name="author" content="蓝桉,kt_zxh@163.com"><meta name="copyright" content="蓝桉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 网络编程概述在计算机领域中，网络是信息传输、接收、共享的虚拟平台，将各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络编程的作用：解决计算机与计算机数据传输的问题。 网络体系大致分为三种：OSI七层模型、TCP&#x2F;IP四层模型和五层模型。  Tips: 一般面试的时候考察比较多的是五层模型。  1.1. 网络通讯三要素1.1.1. IP地址IP 是每台电脑在互联网上的唯一标识符。一个">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础-网络编程">
<meta property="og:url" content="https://ktzxy.github.io/posts/4e9c3100.html">
<meta property="og:site_name" content="蓝桉&#96;Blog">
<meta property="og:description" content="1. 网络编程概述在计算机领域中，网络是信息传输、接收、共享的虚拟平台，将各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络编程的作用：解决计算机与计算机数据传输的问题。 网络体系大致分为三种：OSI七层模型、TCP&#x2F;IP四层模型和五层模型。  Tips: 一般面试的时候考察比较多的是五层模型。  1.1. 网络通讯三要素1.1.1. IP地址IP 是每台电脑在互联网上的唯一标识符。一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ktzxy.github.io/bg/Image00026.webp">
<meta property="article:published_time" content="2025-07-09T17:28:45.000Z">
<meta property="article:modified_time" content="2025-07-13T15:45:18.463Z">
<meta property="article:author" content="蓝桉">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ktzxy.github.io/bg/Image00026.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础-网络编程",
  "url": "https://ktzxy.github.io/posts/4e9c3100.html",
  "image": "https://ktzxy.github.io/bg/Image00026.webp",
  "datePublished": "2025-07-09T17:28:45.000Z",
  "dateModified": "2025-07-13T15:45:18.463Z",
  "author": [
    {
      "@type": "Person",
      "name": "蓝桉",
      "url": "https://ktzxy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ktzxy.github.io/posts/4e9c3100.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础-网络编程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/windmill/windmill.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/meting/music_lanan.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="蓝桉`Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/bg.webp);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/bg/Image00026.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">蓝桉`Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础-网络编程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java基础-网络编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-09T17:28:45.000Z" title="发表于 2025-07-09 17:28:45">2025-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-13T15:45:18.463Z" title="更新于 2025-07-13 15:45:18">2025-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-网络编程概述"><a href="#1-网络编程概述" class="headerlink" title="1. 网络编程概述"></a>1. 网络编程概述</h2><p>在计算机领域中，网络是信息传输、接收、共享的虚拟平台，将各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络编程的作用：解决计算机与计算机数据传输的问题。</p>
<p>网络体系大致分为三种：<strong>OSI七层模型</strong>、<strong>TCP/IP四层模型</strong>和<strong>五层模型</strong>。</p>
<blockquote>
<p>Tips: 一般面试的时候考察比较多的是五层模型。</p>
</blockquote>
<h3 id="1-1-网络通讯三要素"><a href="#1-1-网络通讯三要素" class="headerlink" title="1.1. 网络通讯三要素"></a>1.1. 网络通讯三要素</h3><h4 id="1-1-1-IP地址"><a href="#1-1-1-IP地址" class="headerlink" title="1.1.1. IP地址"></a>1.1.1. IP地址</h4><p>IP 是每台电脑在互联网上的<strong>唯一标识符</strong>。一个 IPV4 的地址是由四段 0—255 的数字组成：<code>192.168.0.100</code>，每一段的取值范围由8位二进制数据组成。</p>
<p>IPv6 使用 16 个字节表示 IP 地址，它所拥有的地址容量约是 IPv4 的 8×10<sup>28</sup>倍，达到 2<sup>128</sup>个。</p>
<blockquote>
<p>Notes: </p>
<ul>
<li><strong><code>127.0.0.1</code> 为本地主机地址(本地回环地址)</strong>，与 localhost 类似，均代表本机地址</li>
<li><code>xxx.xxx.xxx.255</code> 广播地址，即该网段下所有用户均可以被通知到</li>
</ul>
</blockquote>
<p>例如在 windows 系统中，可以通过以下命令来获取 ip 与网络相关内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>
<ul>
<li>用于DOS获取计算机IP设置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping ip地址</span><br></pre></td></tr></table></figure>
<ul>
<li>用于判断两台计算机连接是否通畅</li>
</ul>
<h4 id="1-1-2-端口号"><a href="#1-1-2-端口号" class="headerlink" title="1.1.2. 端口号"></a>1.1.2. 端口号</h4><p><strong>端口号</strong>是一个十进制整数，是<strong>进程的唯一标识</strong>。在计算机中，不同的应用程序是通过端口号区分的。通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。</p>
<p>端口号是用两个字节（16位的二进制数）表示的，它的取值范围是<strong>0~65535</strong>。其中，<strong>0~1023之间的端口号是系统保留使用的</strong>，开发人员需要使用 1024 以上的端口号，从而避免端口号被另外一个应用或服务所占用。</p>
<h4 id="1-1-3-通讯协议"><a href="#1-1-3-通讯协议" class="headerlink" title="1.1.3. 通讯协议"></a>1.1.3. 通讯协议</h4><p><strong>通讯协议的作用</strong>：确定数据如何传输。TCP/IP 协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能：</p>
<ul>
<li><strong>链路层</strong>：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li>
<li><strong>网络层</strong>：网络层是整个 TCP/IP 协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</li>
<li><strong>传输层</strong>：主要使网络程序进行通信，在进行网络通信时，可以采用 TCP 协议，也可以采用 UDP 协议。</li>
<li><strong>应用层</strong>：主要负责应用程序的协议，例如 HTTP 协议、FTP 协议等。</li>
</ul>
<h4 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4. 小结"></a>1.1.4. 小结</h4><font color=red>**网络通讯三要素小结：通过IP找主机，通过端口找程序，通过协议确定如何传输数据。**</font>

<h3 id="1-2-OSI-七层网络模型"><a href="#1-2-OSI-七层网络模型" class="headerlink" title="1.2. OSI 七层网络模型"></a>1.2. OSI 七层网络模型</h3><p>OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型，这样所有的公司都按照统一的标准来指定自己的网络，就可以互通互联了。</p>
<p>网络的七层模型<strong>从上到下</strong>主要包括：</p>
<ol>
<li><strong>应用层</strong>：主要是一些基于网络构建的终端应用，例如：FTP（各种文件上传下载服务）、WEB（网页浏览）、Telnet服务、HTTP服务、DNS服务、SNMP邮件服务、QQ 等等。<em>可以理解成电脑系统中需要网络的软件都是终端应用</em>。</li>
<li><strong>表示层</strong>：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等，也就是把计算机能够识别的内容转换成人能够能识别的内容（如图片、声音等）。</li>
<li><strong>会话层</strong>：通过传输层（端口号：传输端口与接收端口）建立数据传输的连接和管理会话，主要是在系统之间发起会话或者接受会话请求，具体包括登录验证、断点续传、数据粘包与分包等。设备之间需要互相识别，依据的可以是 IP、MAC 或者主机名。</li>
<li><strong>传输层</strong>：定义了一些传输数据的协议和端口号（WWW 端口 80 等），主要是将从下层接收的数据进行<strong>分段</strong>、<strong>传输</strong>，到达目的地址后再进行<strong>重组</strong>。常把这一层数据叫做<strong>段</strong>。在这一层工作的协议有 TCP 和 UDP：<ul>
<li>TCP（传输控制协议）：传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据。比如支付宝转账使用的就是 TCP</li>
<li>UDP（用户数据报协议）：与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据、抖音等视频服务就使用了 UDP</li>
</ul>
</li>
<li><strong>网络层</strong>：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解析。常把这一层的数据叫做<strong>数据包</strong>，在这一层工作的设备是路由器、交换机、防火墙等。</li>
<li><strong>数据链路层</strong>：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解析。常把这一层的数据叫做<strong>帧</strong>。在这一层工作的设备是网卡、网桥、交换机，数据通过交换机来传输。</li>
<li><strong>物理层</strong>：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是<strong>传输比特流</strong>（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做<strong>比特</strong>。</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039816.png" alt=""></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039817.png" alt=""></p>
<h3 id="1-3-TCP-IP-四层网络模型"><a href="#1-3-TCP-IP-四层网络模型" class="headerlink" title="1.3. TCP/IP 四层网络模型"></a>1.3. TCP/IP 四层网络模型</h3><p>TCP/IP 是指因特网的整个 TCP/IP 协议簇。从协议分层模型方面来讲，TCP/IP 由 4 个层次组成：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039818.png" alt=""></p>
<p>TCP/IP 中网络接口层、网络层、传输层和应用层的具体工作职责：</p>
<ul>
<li>网络接口层（Network Access Layer）：定义了主机间网络连通的协议，具体包括 Echernet、FDDI、ATM 等通信协议。</li>
<li>网络层（Internet Layer）：主要用于数据的传输、路由及地址的解析，以保障主机可以把数据发送给任何网络上的目标。数据经过网络传输，发送的顺序和到达的顺序可能发生变化。在网络层使用 IP（Internet Protocol）和地址解析协议（ARP）。</li>
<li>传输层（Transport Layer）：使源端和目的端机器上的对等实体可以基于会话相互通信。在这一层定义了两个端到端的协议 TCP 和 UDP。<ul>
<li>TCP 是面向连接的协议，提供可靠的报文传输和对上层应用的连接服务，除了基本的数据传输，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。</li>
<li>UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。</li>
</ul>
</li>
<li>应用层（Application Layer）：负责具体应用层协议的定义，包括以下协议：<ul>
<li>Telnet（TELecommunications NETwork，虚拟终端协议）</li>
<li>FTP（File Transfer Protocol，文件传输协议）</li>
<li>SMTP（Simple Mail Transfer Protocol，电子邮件传输协议）</li>
<li>DNS（Domain Name Service，域名服务）</li>
<li>NNTP（Net News Transfer Protocol，网上新闻传输协议）</li>
<li>HTTP（HyperText Transfer Protocol，超文本传输协议）</li>
</ul>
</li>
</ul>
<h4 id="1-3-1-TCP-IP-网络模型与-OSI-网络模型对比"><a href="#1-3-1-TCP-IP-网络模型与-OSI-网络模型对比" class="headerlink" title="1.3.1. TCP/IP 网络模型与 OSI 网络模型对比"></a>1.3.1. TCP/IP 网络模型与 OSI 网络模型对比</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039819.png" alt=""></p>
<h3 id="1-4-五层模型"><a href="#1-4-五层模型" class="headerlink" title="1.4. 五层模型"></a>1.4. 五层模型</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039820.png" alt=""></p>
<p>五层模型：应用层、传输层、网络层、数据链路层、物理层。</p>
<ul>
<li><strong>应用层</strong>：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统 DNS、HTTP 协议、SMTP 协议等。</li>
<li><strong>传输层</strong>：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议 TCP 和用户数据协议 UDP。</li>
<li><strong>网络层</strong>：选择合适的路由和交换结点，确保数据及时传送。主要包括 IP 协议。</li>
<li><strong>数据链路层</strong>：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</li>
<li><strong>物理层</strong>：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。</li>
</ul>
<h2 id="2-Socket"><a href="#2-Socket" class="headerlink" title="2. Socket"></a>2. Socket</h2><h3 id="2-1-Socket-简介"><a href="#2-1-Socket-简介" class="headerlink" title="2.1. Socket 简介"></a>2.1. Socket 简介</h3><p>网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket 通常用来实现客户方和服务方的连接。Socket 连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的。</p>
<p>Socket 是 TCP/IP 协议的一个十分流行的编程界面，一个 Socket 由一个 IP 地址和一个端口号唯一确定。</p>
<p>但是，Socket 所支持的协议种类也不光 TCP/IP、UDP，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于 TCP/IP 协议的网络编程。Socket 偏向于底层。一般很少直接使用 Socket 来编程，框架底层使用 Socket 比较多。</p>
<h3 id="2-2-Socket-所属网络模型的层级"><a href="#2-2-Socket-所属网络模型的层级" class="headerlink" title="2.2. Socket 所属网络模型的层级"></a>2.2. Socket 所属网络模型的层级</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039821.png" alt=""></p>
<p>Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 就是一个外观模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</p>
<h3 id="2-3-Socket-通讯的过程"><a href="#2-3-Socket-通讯的过程" class="headerlink" title="2.3. Socket 通讯的过程"></a>2.3. Socket 通讯的过程</h3><ul>
<li><strong>基于 TCP</strong>：服务器端先初始化 Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用 accept 阻塞，等待客户端连接。在这时如果有个客户端初始化一个 Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</li>
<li><strong>基于 UDP</strong>：UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。客户端只需要发送，不管服务端是否接收成功。</li>
</ul>
<h2 id="3-UDP-通信"><a href="#3-UDP-通信" class="headerlink" title="3. UDP 通信"></a>3. UDP 通信</h2><h3 id="3-1-UDP-协议概述"><a href="#3-1-UDP-协议概述" class="headerlink" title="3.1. UDP 协议概述"></a>3.1. UDP 协议概述</h3><p>UDP 是 User Datagram Protocol 的简称，称为用户数据报协议。传输层的两个重要的高级协议之一。是一个<strong>面向无连接的协议</strong>，它提供<u>不可靠</u>的数据传输。</p>
<p>在 UDP 通信中，发送端在发送数据之前不确定接收端是否存在，也不需要与对方建立连接，数据被封装成数据包，直接发送给接收方。UDP 不提供数据校验、确认机制和拥塞控制，因此传输速度较快，但容易发生数据丢失。</p>
<p>在 UDP 协议中，有一个IP地址称为<strong>广播地址</strong>，只要给广播地址发送消息，那么同一个网段的所有用户都可以接收到消息。IP 地址格式：<code>网络号(前3段)+主机号(最后1段)</code>。如，<code>192.168.113.68</code></p>
<blockquote>
<p>Tips: <strong>如果主机号是255，则该 IP 地址就是广播地址</strong></p>
</blockquote>
<h4 id="3-1-1-UDP-协议的特点"><a href="#3-1-1-UDP-协议的特点" class="headerlink" title="3.1.1. UDP 协议的特点"></a>3.1.1. UDP 协议的特点</h4><ul>
<li>面向无连接的协议。即在数据传输时，数据的发送端和接收端不建立逻辑连接。</li>
<li>不管对方是否能收到数据。对方收到数据之后也不会给一个反馈给发送端。</li>
<li>发送的数据限制在64k以内。</li>
<li>基于数据包来传输：将数据以及源和目的地封装到一个数据包中。</li>
<li>UDP的面向无连接性，不能保证数据的完整性，但效率高。是不可靠的协议。</li>
</ul>
<h4 id="3-1-2-UDP-协议使用场景"><a href="#3-1-2-UDP-协议使用场景" class="headerlink" title="3.1.2. UDP 协议使用场景"></a>3.1.2. UDP 协议使用场景</h4><p>UDP 协议适用于实时传输要求较高的应用。</p>
<ul>
<li>即时通讯</li>
<li>在线视频</li>
<li>网络语音电话</li>
</ul>
<h3 id="3-2-DatagramPacket-类（数据报对象）"><a href="#3-2-DatagramPacket-类（数据报对象）" class="headerlink" title="3.2. DatagramPacket 类（数据报对象）"></a>3.2. DatagramPacket 类（数据报对象）</h3><h4 id="3-2-1-作用"><a href="#3-2-1-作用" class="headerlink" title="3.2.1. 作用"></a>3.2.1. 作用</h4><p>用于在 UDP 通信中封装发送端的数据或接收端的数据。</p>
<h4 id="3-2-2-构造方法"><a href="#3-2-2-构造方法" class="headerlink" title="3.2.2. 构造方法"></a>3.2.2. 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DatagramPacket</span><span class="params">(<span class="type">byte</span>[] buf, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建 <code>DatagramPacket</code> 对象时，指定了封装数据的字节数组和数据的大小，没有指定 IP 地址和端口号。<strong><u>只能用于接收端，不能用于发送端</u></strong>。因为发送端一定要明确指出数据的目的地(ip 地址和端口号)，而接收端不需要明确知道数据的来源，只需要接收到数据即可<ul>
<li>参数<code>buf</code>：要接收的数据数组</li>
<li>参数<code>length</code>：发送数据的长度，单位：字节</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DatagramPacket</span><span class="params">(<span class="type">byte</span>[] buf, <span class="type">int</span> length, InetAddress address, <span class="type">int</span> port)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用该构造方法在创建 <code>DatagramPacket</code> 对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标 IP 地址（addr）和端口号（port）。<strong><u>该对象通常用于发送端</u></strong>，因为在<strong>发送数据时必须指定接收端的IP地址和端口号</strong>。<ul>
<li>参数<code>buf</code>：要发送的数据数组</li>
<li>参数<code>length</code>：发送数据的长度，单位：字节</li>
<li>参数<code>address</code>：接收端的IP地址对象</li>
<li>参数<code>port</code>：接收端的端口号</li>
</ul>
</li>
</ul>
<h4 id="3-2-3-常用方法"><a href="#3-2-3-常用方法" class="headerlink" title="3.2.3. 常用方法"></a>3.2.3. 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InetAddress <span class="title function_">getAddress</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回某台机器的 IP 地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回某台远程主机的端口号</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getData()</span><br></pre></td></tr></table></figure>
<ul>
<li>返回数据缓冲区。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回将要发送或接收到的数据的长度。</li>
</ul>
<h3 id="3-3-DatagramSocket-类（数据发送对象）"><a href="#3-3-DatagramSocket-类（数据发送对象）" class="headerlink" title="3.3. DatagramSocket 类（数据发送对象）"></a>3.3. DatagramSocket 类（数据发送对象）</h3><h4 id="3-3-1-作用"><a href="#3-3-1-作用" class="headerlink" title="3.3.1. 作用"></a>3.3.1. 作用</h4><p>用来负责发送和接收数据包对象。</p>
<h4 id="3-3-2-构造方法"><a href="#3-3-2-构造方法" class="headerlink" title="3.3.2. 构造方法"></a>3.3.2. 构造方法</h4><ul>
<li><code>public DatagramSocket() throws SocketException</code><ul>
<li>该构造方法用于<strong>创建发送端的DatagramSocket对象</strong>，在创建DatagramSocket对象时，<strong>并没有指定端口号</strong>，此时，<strong>系统会分配一个没有被其它网络程序所使用的端口号</strong>。</li>
<li>API:构造数据报套接字并将其绑定到本地主机上任何可用的端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</li>
</ul>
</li>
<li><code>public DatagramSocket(int port) throws SocketException</code><ul>
<li>该构造方法既可用于<strong>创建接收端的DatagramSocket对象</strong>，又<strong>可以创建发送端的DatagramSocket对象</strong>，在<strong>创建接收端的DatagramSocket对象时，必须要指定一个端口号</strong>，这样就可以监听指定的端口。</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-常用方法"><a href="#3-3-3-常用方法" class="headerlink" title="3.3.3. 常用方法"></a>3.3.3. 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(DatagramPacket p)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="comment">// 从此套接字发送数据报包。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(DatagramPacket p)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="comment">// 从此套接字接收数据报包。具有线程阻塞效果，运行后等待接收</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 关闭此数据报套接字。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-UDP-网络程序实现步骤"><a href="#3-4-UDP-网络程序实现步骤" class="headerlink" title="3.4. UDP 网络程序实现步骤"></a>3.4. UDP 网络程序实现步骤</h3><h4 id="3-4-1-UDP-发送端的实现步骤"><a href="#3-4-1-UDP-发送端的实现步骤" class="headerlink" title="3.4.1. UDP 发送端的实现步骤"></a>3.4.1. UDP 发送端的实现步骤</h4><ol>
<li>创建DatagramPacket对象，并封装数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定端口port</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DatagramPacket</span><span class="params">(<span class="type">byte</span>[] buf, <span class="type">int</span> length, InetAddress address, <span class="type">int</span> port)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>创建DatagramSocket对象，使用无参构造即可</li>
<li>发送数据，调用send方法发送数据包</li>
<li>释放流资源（关闭DatagramSocket对象）。<em>注：如果是抛异常只需抛 IOException 即可</em></li>
</ol>
<h4 id="3-4-2-UDP-接收端的实现步骤"><a href="#3-4-2-UDP-接收端的实现步骤" class="headerlink" title="3.4.2. UDP 接收端的实现步骤"></a>3.4.2. UDP 接收端的实现步骤</h4><ol>
<li>创建 <code>DatagramPacket</code> 对象。接收数据存储到 <code>DatagramPacket</code> 对象中，创建字节数组，接收发来的数据。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DatagramPacket</span><span class="params">(<span class="type">byte</span>[] buf, <span class="type">int</span> length)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>创建 <code>DatagramSocket</code> 对象，<strong>绑定端口号，要和发送端端口号一致。</strong>s</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DatagramSocket</span><span class="params">(<span class="type">int</span> port)</span></span><br></pre></td></tr></table></figure>
<ol>
<li>调用 <code>DatagramSocket</code> 对象 <code>receive</code> 方法，接收数据，数据放到数据包中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">receive(DatagramPacket dp);</span><br></pre></td></tr></table></figure>
<ol>
<li>拆包，获取 <code>DatagramPacket</code> 对象的内容<ul>
<li>发送的 IP 地址对象</li>
<li>接收到字节数组内容</li>
<li>接收到的字节个数</li>
<li>发送方的端口号(<strong>不重要，由系统分配的。</strong>)</li>
</ul>
</li>
<li>释放流资源（关闭 <code>DatagramSocket</code> 对象）</li>
</ol>
<h4 id="3-4-3-UDP-发送端与接收端的基础示例"><a href="#3-4-3-UDP-发送端与接收端的基础示例" class="headerlink" title="3.4.3. UDP 发送端与接收端的基础示例"></a>3.4.3. UDP 发送端与接收端的基础示例</h4><h5 id="3-4-3-1-UDP-发送端"><a href="#3-4-3-1-UDP-发送端" class="headerlink" title="3.4.3.1. UDP 发送端"></a>3.4.3.1. UDP 发送端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	实现UDP发送端（试验发送给自己）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonZero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="string">&quot;试试UDP&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自己的IP地址对象，封装自己的IP地址（使用本地回环地址，目的方便日后修改成其他主机IP）</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建数据包对象，封装要发送的数据，接收端IP，端口</span></span><br><span class="line">        <span class="comment">// public DatagramPacket(byte[] buf, int length, InetAddress address, int port)</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(arr, arr.length, inet, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建DatagramSocket对象，用来发送数据包,只用发送，无参构造即可</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用发送的方法,</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-4-3-2-UDP-接收端"><a href="#3-4-3-2-UDP-接收端" class="headerlink" title="3.4.3.2. UDP 接收端"></a>3.4.3.2. UDP 接收端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	实现UDP接收端（试验发送给自己）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建DatagramSocket对象，绑定端口号，端口号要一致</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6000</span>);</span><br><span class="line">        <span class="comment">// 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 创建数据包对我，传递字节数据,该构造方法只用接收端</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(arr, arr.length);</span><br><span class="line">        <span class="comment">// 调用Socket方法接收传递过来的数据包</span></span><br><span class="line">        ds.receive(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆包</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的数据是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(),<span class="number">0</span>,dp.getLength()));</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的数据长度是：&quot;</span> + dp.getLength());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送端的IP地址是：&quot;</span> + dp.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送端的名称是：&quot;</span> + dp.getAddress().getHostName());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送端的端口号是：&quot;</span> + dp.getPort());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-4-3-3-测试效果"><a href="#3-4-3-3-测试效果" class="headerlink" title="3.4.3.3. 测试效果"></a>3.4.3.3. 测试效果</h5><p>先运行接收端：具有线程阻塞效果，会等待发送端的数据</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039822.jpg" alt="UDP通信测试1"></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039823.jpg" alt="UDP通信测试2"></p>
<p>再运行发送端：（注：发送端与接收对象定义的端口不是一样的）</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039824.jpg" alt="UDP通信测试3"></p>
<h3 id="3-5-UDP-键盘录入发送和接收示例"><a href="#3-5-UDP-键盘录入发送和接收示例" class="headerlink" title="3.5. UDP 键盘录入发送和接收示例"></a>3.5. UDP 键盘录入发送和接收示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	实现UDP发送端（试验发送给自己）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonZero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 获取自己的IP地址对象，封装自己的IP地址（使用本地回环地址，目的方便日后修改成其他主机IP）</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建DatagramSocket对象，用来发送数据包,只用发送，无参构造即可</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line">            <span class="comment">// 创建字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] arr = s.getBytes();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建数据包对象，封装要发送的数据，接收端IP，端口</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(arr, arr.length, inet, <span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用发送的方法,</span></span><br><span class="line">            ds.send(dp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	实现UDP接收端（试验发送给自己）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceive</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建DatagramSocket对象，绑定端口号，端口号要一致</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">6000</span>);</span><br><span class="line">        <span class="comment">// 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 创建数据包对象，传递字节数据,该构造方法只用接收端</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(arr, arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用Socket方法接收传递过来的数据包</span></span><br><span class="line">            ds.receive(dp);</span><br><span class="line">            <span class="comment">// 拆包</span></span><br><span class="line">            System.out.print(<span class="string">&quot;接收到的数据是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>, dp.getLength()));</span><br><span class="line">            System.out.println(<span class="string">&quot;-----&quot;</span> + dp.getAddress().getHostAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039825.jpg" alt="UDP键盘录入发送和接收测试"></p>
<h2 id="4-TCP-通信"><a href="#4-TCP-通信" class="headerlink" title="4. TCP 通信"></a>4. TCP 通信</h2><h3 id="4-1-TCP-协议"><a href="#4-1-TCP-协议" class="headerlink" title="4.1. TCP 协议"></a>4.1. TCP 协议</h3><h4 id="4-1-1-概述"><a href="#4-1-1-概述" class="headerlink" title="4.1.1. 概述"></a>4.1.1. 概述</h4><p>TCP 是 Transmission Control Protocol 的简称，称为传输控制协议。传输层的两个重要的高级协议之一。TCP 协议是面向连接的通信协议，即在传输数据前先在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输，保证传输数据的安全性。</p>
<p>在 TCP 通信中，数据被分成多个小片段，每个片段都会被编号和校验，确保数据完整性。TCP 使用确认机制，确保数据的可靠性，如果发送方没有收到确认信息，会重新发送数据。TCP 还处理拥塞控制，根据网络条件动态调整数据传输的速率。</p>
<h4 id="4-1-2-特点"><a href="#4-1-2-特点" class="headerlink" title="4.1.2. 特点"></a>4.1.2. 特点</h4><ul>
<li><strong>面向连接的运输层协议</strong>，因为面向连接，效率低，可靠的协议。</li>
<li><strong>点对点</strong>，每一条 TCP 连接只能有两个端点</li>
<li>通过 3 次握手建立连接，形成数据传输通道，开始传输。</li>
<li>通过 4 次挥手断开连接。</li>
<li>发送的数据没有大小限制</li>
<li>基于 IO 流进行数据传输</li>
<li>TCP 提供<strong>全双工通信</strong></li>
<li>面向字节流</li>
</ul>
<h4 id="4-1-3-TCP-协议使用场景"><a href="#4-1-3-TCP-协议使用场景" class="headerlink" title="4.1.3. TCP 协议使用场景"></a>4.1.3. TCP 协议使用场景</h4><p>TCP 适用于需要保证数据完整性和可靠性的应用。例如：</p>
<ul>
<li>文件上传和下载</li>
<li>发送电子邮件</li>
<li>远程登陆</li>
</ul>
<h4 id="4-1-4-TCP-和-UDP-协议的区别"><a href="#4-1-4-TCP-和-UDP-协议的区别" class="headerlink" title="4.1.4. TCP 和 UDP 协议的区别"></a>4.1.4. TCP 和 UDP 协议的区别</h4><ul>
<li><strong>连接机制不同</strong>：TCP 是面向连接，发送数据前客户端和服务器之间需要建立连接，然后再进行数据传输；而 UDP 是无连接的，发送数据之前不需要建立连接，数据包可以直接发送给目标主机。</li>
<li><strong>数据传输方式不同</strong>：TCP 采用可靠的数据传输方式，即在传输过程中使用序号、确认号和重传机制等控制手段来保证数据的可靠传输；而 UDP 采用不可靠的数据传输方式，数据包可能会丢失或重复，不提供数据可靠性保障。</li>
<li><strong>数据传输效率不同</strong>：由于 TCP 需要进行连接、序号确认等额外的数据包传输，因此在数据传输效率方面相对于 UDP 要低一些。</li>
<li><strong>数据大小限制不同</strong>：TCP 对数据包的大小有限制，最大只能传输 64KB 的数据，而 UDP 的数据包大小没有限制。</li>
<li><strong>应用场景不同</strong>：TCP 适用于要求数据传输可靠性高的场景，如网页浏览、文件下载、电子邮件等；而 UDP 适用于实时性要求较高的场景，如视频会议、在线游戏等。</li>
<li>TCP 面向字节流，把数据看成一连串无结构的字节流；而 UDP 是面向报文的。</li>
<li>TCP 有拥塞控制；而 UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。</li>
<li>TCP 每一条连接只能是点到点的；而 UDP 支持一对一、一对多、多对一、多对多等通信方式。</li>
<li>TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节。</li>
<li>TCP 协议是没有发送端和接收端的概念，分为客户端和服务器端；而 UDP 协议是区分发送端和接收端。</li>
<li>TCP 协议通讯必须由客户端主动发消息给服务器端。</li>
</ul>
<p>总结：TCP 是可靠的、有序的、面向连接的传输协议；而 UDP 是简单的、不可靠的、无连接的传输协议。选择 TCP 还是 UDP 要根据具体的应用需求来确定。</p>
<h3 id="4-2-TCP-三次握手-四次挥手"><a href="#4-2-TCP-三次握手-四次挥手" class="headerlink" title="4.2. TCP 三次握手/四次挥手"></a>4.2. TCP 三次握手/四次挥手</h3><p>TCP 在传输之前建立连接会进行 3 次沟通，一般称为“三次握手”，在数据传输完成断开连接的时候要进行 4 次沟通，一般称为“四次挥手”。</p>
<h4 id="4-2-1-TCP-数据包结构"><a href="#4-2-1-TCP-数据包结构" class="headerlink" title="4.2.1. TCP 数据包结构"></a>4.2.1. TCP 数据包结构</h4><p>TCP 包的数据结构如下：</p>
<ol>
<li>源端口号（ 16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。</li>
<li>目的端口号（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。这两个值加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接。</li>
<li>序列号 seq（ 32 位）：用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的序列号。如果将字节流看作在两个应用程序间的单向流动，则 TCP 用序列号对每个字节进行计数。序号是 32bit 的无符号数，序号到达 2<sup>32</sup> － 1 后又从 0 开始。当建立一个新的连接时，SYN 标志变 1 ，序列号字段包含由这个主机选择的该连接的初始序列号 ISN （Initial Sequence Number）。</li>
<li>确认号 ack（ 32 位）：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1。只有 ACK 标志为 1 时确认序号字段才有效。TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。</li>
<li>TCP 报头长度（ 4 位）：给出报头中 32bit 字的数目，它实际上指明数据从哪里开始。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节。</li>
<li>保留位（ 6 位）：保留给将来使用，目前必须置为 0 。</li>
<li>控制位（ control flags ，6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设置为 1 。依次为：<ul>
<li>URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。</li>
<li>ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。</li>
<li>PSH ：为 1 表示是带有 PUSH 标志的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</li>
<li>RST ：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。</li>
<li>SYN ：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步（ synchronize ）。</li>
<li>FIN ：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。</li>
</ul>
</li>
<li>窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。</li>
<li>校验和（ 16 位）：此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。</li>
<li>紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</li>
<li>选项：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，它指明本端所能接收的最大长度的报文段。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数。</li>
<li>数据：TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039826.png" alt="数据包说明"></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039827.png" alt=""></p>
<h4 id="4-2-2-三次握手"><a href="#4-2-2-三次握手" class="headerlink" title="4.2.2. 三次握手"></a>4.2.2. 三次握手</h4><p>TCP 是因特网的传输层协议，使用三次握手协议建立连接。在客户端主动发出 SYN 连接请求后，等待服务端回答 SYN+ACK，并最终对服务端的 SYN 执行 ACK 确认。这种建立连接的方式可以防止产生错误的连接，TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p>
<p>TCP 三次握手的过程如下：</p>
<ol>
<li>第一次握手：当客户端向服务端发起建立连接请求，客户端A会随机生成一个起始序列号x，然后客户端A会发送包含标志位 <code>SYN＝1</code>，序列号 <code>seq = x</code>(随机产生) 的数据包到服务端B，此时客户端A并进入 <code>SYN-SEND</code> 状态（第一次握手前客户端A的状态为<code>CLOSE</code>），服务端B的状态为 <code>LISTEN</code>。</li>
<li>第二次握手： 服务端B 收到客户端A请求报文后要确认联机信息，服务端B 由 <code>SYN=1</code> 可知，客户端A 要求建立联机。服务端B 会随机生成一个服务端的起始序列号<code>y</code>，向客户端A发送报文，其中包括标识位 <code>SYN=1</code>, <code>ACK=1</code>, 序列号 <code>seq=y</code>(随机产生), 确认号 <code>ack=(客户端A的seq+1)</code> 的数据包（<em>注：其中 <code>SYN=1</code> 表示要和客户端建立一个连接，<code>ACK=1</code> 表示确认序号有效</em>），此时服务端B进入 <code>SYN-RCVD</code> 状态（第二次握手前服务端B 的状态为 <code>LISTEN</code>，客户端A 的状态为 <code>SYN-SENT</code>）。</li>
<li>第三次握手：客户端A 收到服务端B 发来的报文后，会检查 ack 是否正确（即第一次发送的<code>seq+1</code>），以及标识位 ACK 是否为 1。若正确，客户端A 会再向服务端B 发送报文，其中包含 <code>ACK=1</code>, 序列号 <code>seq=x+1</code>, 确认号 <code>ack=(服务端B的seq+1)</code>，第三次握手后客户端和服务端的状态都进入 <code>ESTABLISHED</code> 状态（第三次握手前客户端A 的状态为 <code>SYN-SENT</code>）。在服务端B 收到后确认 seq 值与 ack=1 则连接建立成功。</li>
</ol>
<p>在三次握手完成后，TCP 客户端和服务器端成功建立连接，可以进行数据传输。具体流程图：</p>
<blockquote>
<p>TODO: 待使用 draw.io 重新画图</p>
</blockquote>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039828.png" alt=""></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039829.png" alt=""></p>
<h4 id="4-2-3-四次挥手"><a href="#4-2-3-四次挥手" class="headerlink" title="4.2.3. 四次挥手"></a>4.2.3. 四次挥手</h4><p>TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的（即数据可在两个方向上同时传递），所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫<strong>半关闭</strong>。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。</p>
<p><strong>TCP 断开连接既可以是由客户端发起，也可以是由服务器端发起</strong>。如果由客户端发起断开连接操作，则称客户端主动断开连接；如果由服务器端发起断开连接操作，则称服务端主动断开连接。下面以客户端发起关闭连接请求为例，说明 TCP 四次挥手断开连接的过程：</p>
<ol>
<li>客户端 A 应用进程调用断开连接的请求，向其 TCP 服务器 B 发送一个连接释放报文，其中包含终止标志位 <code>FIN=1, seq=u</code> 的消息，表示在客户端关闭链路前要发送的数据已经安全发送完毕并停止再发送数据，可以开始主动关闭 TCP 链路操作。此时客户端处于 <code>FIN-WAIT-1</code>（终止等待1）状态，然后等待服务器 B 确认关闭客户端到服务器的链路的操作。</li>
<li>服务器 B 收到这个 FIN (连接释放)报文段后，返回一个确认报文段 <code>ACK=1，ack=u+1, seq=v</code> 的消息给客户端 A，表示接收到客户端断开链路的操作请求。此时 TCP 服务器端进程通知高层应用进程释放客户端到服务器端的链路，服务器 B 处于 <code>CLOSE-WAIT</code> 状态，即<strong>半关闭状态</strong>（即 A 不可以发送给 B，但是 B 可以发送给 A。）。</li>
<li>客户端 A 在收到服务端 B 的确认释放信息后，处于 <code>FIN-WAIT-2</code>（终止等待2）状态，等待服务端 B 发送完数据与再次发出的连接释放报文段。</li>
<li>服务器端 B 将关闭链路前，再给客户端 A 进行最后的数据传送。在等待该数据发送完成后，会再次发送一个连接释放报文段，包含终止标志位 <code>FIN=1, ACK=1, seq=w, ack=u+1</code> 的消息给客户端 A，表示关闭链路前服务器需要向客户端发送的消息已经发送完毕，请求客户端确认关闭从服务器到客户端的链路操作。此时服务器端B 处于 <code>LAST-ACK</code> （最后确认）状态，等待客户端 A 最终确认断开链路。</li>
<li>客户端 A 在接收到这个最终 FIN 连接释放报文段后，会发送一个确认报文段 <code>ACK=1, seq=u+1, ack=w+1</code> 的消息给服务器端 B，表示接收到服务器端 A 的断开连接请求并准备断开服务器端 B 到客户端 A 的链路。此时客户端 A 处于 <code>TIME-WAIT</code>（时间等待）状态，但此时 TCP 连接还未释放，需要经过等待计时器设置的时间（2MSL，最大报文段生存时间）后，客户端 A 将进入 <code>CLOSE</code> 状态。服务器端 B 收到客户端 A 发出的确认报文段后关闭连接，若没收到客户端 A 发出的确认报文段，则服务器端 B 就会重传连接释放报文段。</li>
</ol>
<p>TCP 四次挥手流程图：</p>
<blockquote>
<p>TODO: 待使用 draw.io 重新画图</p>
</blockquote>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039830.png" alt=""></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039831.png" alt=""></p>
<h4 id="4-2-4-相关面试题"><a href="#4-2-4-相关面试题" class="headerlink" title="4.2.4. 相关面试题"></a>4.2.4. 相关面试题</h4><h5 id="4-2-4-1-为什么不能两次握手就可以建立连接"><a href="#4-2-4-1-为什么不能两次握手就可以建立连接" class="headerlink" title="4.2.4.1. 为什么不能两次握手就可以建立连接"></a>4.2.4.1. 为什么不能两次握手就可以建立连接</h5><p>第三次握手主要为了<u><strong>防止已失效的连接请求报文段突然又传输到了服务端</strong></u>，导致产生问题。</p>
<p>比如客户端 A 发出连接请求，可能因为网络阻塞原因，A 没有收到确认报文，于是 A 再重传一次连接请求。连接成功，等待数据传输完毕后，就释放了连接。然后可能 A 发出的第一个连接请求等到连接释放以后，某个时间才到达服务端 B，此时 B 误认为 A 又发出一次新的连接请求，于是就向 A 发出确认报文段。</p>
<p>如果不采用三次握手，只要服务端 B 发出确认，就建立新的连接了，<u><strong>此时客户端 A 不会响应服务端 B 的确认且不发送数据，则服务端 B 一直等待客户端 A 发送数据</strong></u>，造成资源的浪费。</p>
<h5 id="4-2-4-2-第四次挥手时客户端-TIME-WAIT-状态为什么要等待-2MSL"><a href="#4-2-4-2-第四次挥手时客户端-TIME-WAIT-状态为什么要等待-2MSL" class="headerlink" title="4.2.4.2. 第四次挥手时客户端 TIME_WAIT 状态为什么要等待 2MSL"></a>4.2.4.2. 第四次挥手时客户端 TIME_WAIT 状态为什么要等待 2MSL</h5><ul>
<li><strong>保证 A 发送的最后一个 ACK 报文段能够到达 B</strong>。<code>ACK</code> 报文段有可能丢失，B 收不到该确认报文，就会超时重传连接释放报文段，然后 A 可以在 2MSL 时间内收到这个重传的连接释放报文段，接着 A 重传一次确认，重新启动 2MSL 计时器，确保最后 A 和 B 都进入到 <code>CLOSED</code> 状态；若 A 在 <code>TIME-WAIT</code> 状态不等待一段时间，而是发送完 ACK 报文段后立即释放连接，则无法收到 B 重传的连接释放报文段，所以不会再发送一次确认报文段，B 就无法正常进入到 <code>CLOSED</code> 状态。</li>
<li><strong>防止已失效的连接请求报文段出现在本连接中</strong>。A 在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以使这个连接所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现旧的连接请求报文段。</li>
</ul>
<h5 id="4-2-4-3-为什么释放连接时需要四次挥手"><a href="#4-2-4-3-为什么释放连接时需要四次挥手" class="headerlink" title="4.2.4.3. 为什么释放连接时需要四次挥手"></a>4.2.4.3. 为什么释放连接时需要四次挥手</h5><p>在请求连接时，当 Server 端收到 Client 端的 <code>SYN</code> 连接请求报文后，可以直接发送 <code>SYN+ACK</code> 报文。但是在关闭连接时，当 Server 端收到 Client 端发出的连接释放报文时，很可能并不会立即关闭 SOCKET，所以 Server 端先回复一个 ACK 报文，告诉 Client 端已收到连接释放报文了。只有等到 Server 端所有的报文都发送完了，这时 Server 端才能发送连接释放报文，之后两边才会真正的断开连接，因此需要四次挥手。</p>
<p>因此四次挥手，目的是为了确保释放连接前所有数据全部发送完毕。</p>
<h3 id="4-3-TCP-编程"><a href="#4-3-TCP-编程" class="headerlink" title="4.3. TCP 编程"></a>4.3. TCP 编程</h3><p>在 JDK 中提供了两个类用于实现 TCP 程序，<strong>一个是 <code>ServerSocket</code> 类，用于表示服务器端，一个是 <code>Socket</code> 类，用于表示客户端</strong></p>
<p>通信时，首先创建代表服务器端的 <code>ServerSocket</code> 对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的 <code>Socket</code> 对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。</p>
<h4 id="4-3-1-ServerSocket-类"><a href="#4-3-1-ServerSocket-类" class="headerlink" title="4.3.1. ServerSocket 类"></a>4.3.1. ServerSocket 类</h4><h5 id="4-3-1-1-构造方法"><a href="#4-3-1-1-构造方法" class="headerlink" title="4.3.1.1. 构造方法"></a>4.3.1.1. 构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ServerSocket</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>根据端口号创建服务器端。<blockquote>
<p>API:创建绑定到特定端口的服务器套接字。</p>
</blockquote>
</li>
</ul>
<h5 id="4-3-1-2-常用方法"><a href="#4-3-1-2-常用方法" class="headerlink" title="4.3.1.2. 常用方法"></a>4.3.1.2. 常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Socket <span class="title function_">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>等待客户端连接并获得客户端的 Socket 对象。注意：此方法是<strong>同步的，即一直等待客户端连接，直到连接成功才能执行后续的代码</strong>。<blockquote>
<p>API: 侦听并接受到此套接字的连接。此方法在连接传入之前一直阻塞。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InetAddress <span class="title function_">getInetAddress</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回此服务器套接字的本地地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭此套接字</li>
</ul>
<h4 id="4-3-2-Socket-类"><a href="#4-3-2-Socket-类" class="headerlink" title="4.3.2. Socket 类"></a>4.3.2. Socket 类</h4><h5 id="4-3-2-1-Scoket-套接字"><a href="#4-3-2-1-Scoket-套接字" class="headerlink" title="4.3.2.1. Scoket 套接字"></a>4.3.2.1. Scoket 套接字</h5><p>Socket 就是为网络编程提供的一种机制，又叫<strong>套接字编程</strong>。对于 Socket 需要理解以下几点内容：</p>
<ul>
<li>通信的两端都有 Socket。</li>
<li>网络通信其实就是 Socket 间的通信。</li>
<li>数据在两个 Socket 间通过 IO 传输。</li>
</ul>
<h5 id="4-3-2-2-构造方法"><a href="#4-3-2-2-构造方法" class="headerlink" title="4.3.2.2. 构造方法"></a>4.3.2.2. 构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Socket</span><span class="params">(String host, <span class="type">int</span> port)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用该构造方法在创建 Socket 对象时，需要传递服务器字符串的IP地址和端口号。会根据参数去连接在指定地址和端口上运行的服务器程序，其中参数host接收的是一个字符串类型的IP地址。<strong>注意：构造方法只要运行，就会和服务器进行连接，如果服务器没有开启则抛出异常。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Socket</span><span class="params">(InetAddress address, <span class="type">int</span> port)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个流套接字并将其连接到指定 IP 地址的指定端口号。参数 <code>InetAddress address</code> 用于接收一个 <code>InetAddress</code> 类型的对象，该对象用于封装一个IP地址。</li>
</ul>
<h5 id="4-3-2-3-常用方法"><a href="#4-3-2-3-常用方法" class="headerlink" title="4.3.2.3. 常用方法"></a>4.3.2.3. 常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPort</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该方法返回一个 <code>int</code> 类型对象，该对象是 <code>Socket</code> 对象与服务器端连接的端口号。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InetAddress <span class="title function_">getInetAddress</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取客户端对象绑定的IP地址，返回套接字连接的地址。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InetAddress <span class="title function_">getLocalAddress</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>该方法用于获取 <code>Socket</code> 对象绑定的本地IP地址，并将IP地址封装成 <code>InetAddress</code> 类型的对象返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>该方法用于关闭 <code>Socket</code> 连接，结束本次通信。在关闭 <code>Socket</code> 之前，应将与 <code>Socket</code> 相关的所有的输入/输出流全部关闭，这是因为一个良好的程序应该在执行完毕时释放所有的资源 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>该方法返回一个 <code>InputStream</code> 类型的字节输入流对象，如果该对象是由服务器端的 <code>Socket</code> 返回，就用于读取客户端发送的数据，反之，用于读取服务器端发送的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OutputStream <span class="title function_">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>该方法返回一个 <code>OutputStream</code> 类型的字节输出流对象，如果该对象是由服务器端的 <code>Socket</code> 返回，就用于向客户端发送数据，反之，用于向服务器端发送数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdownOutput</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>向服务器写一个结束标记。禁用此套接字的输出流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdownInput</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>此套接字的输入流置于“流的末尾”。</li>
</ul>
<h3 id="4-4-TCP-网络程序实现步骤"><a href="#4-4-TCP-网络程序实现步骤" class="headerlink" title="4.4. TCP 网络程序实现步骤"></a>4.4. TCP 网络程序实现步骤</h3><p><strong>客户端服务器数据交换，必须使用套接字对象 Socket 中的获取的 IO 流，不能使用自己 new IO流的对象。</strong></p>
<h4 id="4-4-1-TCP-客户端实现步骤"><a href="#4-4-1-TCP-客户端实现步骤" class="headerlink" title="4.4.1. TCP 客户端实现步骤"></a>4.4.1. TCP 客户端实现步骤</h4><ol>
<li>创建客户端 Socket 对象，<strong>指定要连接的服务器地址与端口号</strong></li>
<li>调用 socket 对象的<code>getOutputStream()</code>方法获得字节输出流对象</li>
<li>通过字节输出流对象向服务器发送数据。</li>
<li>调用 socket 对象的<code>getInputStream()</code>方法获得字节输入流对象</li>
<li>通过字节输入流对象读取服务器响应的数据</li>
<li>关闭流资源 Socket</li>
</ol>
<h4 id="4-4-2-TCP-服务器端实现步骤"><a href="#4-4-2-TCP-服务器端实现步骤" class="headerlink" title="4.4.2. TCP 服务器端实现步骤"></a>4.4.2. TCP 服务器端实现步骤</h4><ol>
<li>创建服务器 ServerSocket 对象，<strong>并指定服务器端口号</strong></li>
<li>调用 ServerSocket 对象的<code>accept()</code>方法等待客户端连接并获得客户端的 Socket 对象</li>
<li>调用 socket 对象的<code>getInputStream()</code>方法获得字节输入流对象</li>
<li>通过字节输入流对象获得客户端发送的数据</li>
<li>调用 socket 对象的<code>getOutputStream()</code>方法获得字节输出流对象</li>
<li>通过字节输出流对象向客户端发送数据</li>
<li>关闭流资源 Socket</li>
</ol>
<h4 id="4-4-3-TCP模拟客户端与服务器代码案例"><a href="#4-4-3-TCP模拟客户端与服务器代码案例" class="headerlink" title="4.4.3. TCP模拟客户端与服务器代码案例"></a>4.4.3. TCP模拟客户端与服务器代码案例</h4><p>客户端上传文件到服务器 code demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP模拟客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建客户端Socket对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建上传的到服务器的字节输出流对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">ops</span> <span class="operator">=</span> sock.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建读取本地图片的字节输入流对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\download\\Java学习路线图1.jpg&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一次读取一个数组的方式将文件复制到服务器中</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            ops.write(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给服务器写终止序列</span></span><br><span class="line">        sock.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Socket对象获取字节输入流对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">ips</span> <span class="operator">=</span> sock.getInputStream();</span><br><span class="line">        <span class="comment">// 控制台输出接收的结果</span></span><br><span class="line">        <span class="keyword">while</span> ((len = ips.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流对象</span></span><br><span class="line">        sock.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP模拟服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建ServerSocket对象,要与客户端的端口一致</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取客户端端口</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Socket对象获取字节输入对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">ips</span> <span class="operator">=</span> sock.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建服务器复制文件的目标文件路径对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\upload&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果没有该文件夹就创建</span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(file.isDirectory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建字节输出流对象，输出文件到服务器目标文件路径</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(file, <span class="string">&quot;001.jpg&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一次读取一个字节数组进行复制文件</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = ips.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制成功后，返回客户端消息“上传成功”</span></span><br><span class="line">        <span class="comment">// 使用Socket对象获取字节输出流对象</span></span><br><span class="line">        sock.getOutputStream().write(<span class="string">&quot;上传成功！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭流资源</span></span><br><span class="line">        ss.close();</span><br><span class="line">        sock.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-4-TCP服务端案例2"><a href="#4-4-4-TCP服务端案例2" class="headerlink" title="4.4.4. TCP服务端案例2"></a>4.4.4. TCP服务端案例2</h4><p>编写一个 TCP 的服务端，可以接受多个客户端的连接，当接收到用户的连接请求以后，就要把一张图片传回给客户端。</p>
<p>增加功能：先判断客户是否要下载图片，选择后服务器端才传给客户端图片。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day16.test03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * day16训练案例3</span></span><br><span class="line"><span class="comment"> * 编写一个 TCP 的服务端，可以接受多个客户端的连接，</span></span><br><span class="line"><span class="comment"> * 	当接收到用户的连接请求以后，就要把一张图片传回给客户端。</span></span><br><span class="line"><span class="comment"> * 		增加功能：先判断客户是否要下载图片，选择后服务器端才传给客户端图片。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端正在启动中........&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            <span class="comment">// 提示用户登陆成功</span></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端成功启动！&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建键盘录入对象</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请选择你要的操作(1:下载资源，2:退出)：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.nextLine();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 让客户选择是否下载资源，如果不下载，服务器端不需要开启线程。</span></span><br><span class="line">                <span class="keyword">switch</span> (s.trim()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        <span class="comment">// 创建客户端Socket对象</span></span><br><span class="line">                        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">                        <span class="comment">// 创建字符输出流对象</span></span><br><span class="line">                        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">                        bw.write(s);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;正在下载资源&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                            System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 创建字节输出流，将文件保存在本机</span></span><br><span class="line">                        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\Java学习路线图&quot;</span> + System.currentTimeMillis() + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">                        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 创建字节输入流对象</span></span><br><span class="line">                        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span> ((len = in.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            bos.write(arr, <span class="number">0</span>, len);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;\n图片下载成功到E盘中！&quot;</span>);</span><br><span class="line">                        <span class="comment">// 关闭流资源</span></span><br><span class="line">                        bos.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                        input.close();</span><br><span class="line">                        System.exit(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                        <span class="comment">// 关闭流资源</span></span><br><span class="line">                        input.close();</span><br><span class="line">                        System.exit(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">&quot;你输入的信息错误，请重新输入！&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day16.test03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * day16训练案例3</span></span><br><span class="line"><span class="comment"> * 编写一个 TCP 的服务端，可以接受多个客户端的连接，</span></span><br><span class="line"><span class="comment"> * 	当接收到用户的连接请求以后，就要把一张图片传回给客户端。</span></span><br><span class="line"><span class="comment"> * 		增加功能：先判断客户是否要下载图片，选择后服务器端才传给客户端图片。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建服务器端对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用循环接受客户端的连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 接收客户端Socket对象</span></span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                <span class="comment">// 开启下载线程</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TCPServerThread</span>(socket).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day16.test03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * day16训练案例3</span></span><br><span class="line"><span class="comment"> * 编写一个 TCP 的服务端，可以接受多个客户端的连接，</span></span><br><span class="line"><span class="comment"> * 	当接收到用户的连接请求以后，就要把一张图片传回给客户端。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 创建集合存放ip地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TCPServerThread</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端线程</span></span><br><span class="line">    <span class="comment">// 重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建字节输入流对象读取服务器的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\Java学习路线图1.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">            <span class="comment">// 获取客户端的字节输出流对象，将文件输出到客户端</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(arr)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(arr, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 给客户端写终止序列</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜 &quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot; 同学，下载成功！！ 当前下载的人数是：&quot;</span> + ++count);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放流资源</span></span><br><span class="line">            bis.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-滑动窗口机制（了解）"><a href="#4-5-滑动窗口机制（了解）" class="headerlink" title="4.5. 滑动窗口机制（了解）"></a>4.5. 滑动窗口机制（了解）</h3><p><strong>TCP 利用滑动窗口实现流量控制</strong>。流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 会话的双方都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制。发送窗口则取决于对端通告的接收窗口。</p>
<p>接收方发送的确认报文中的 window 字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将接收方的确认报文window字段设置为 0，则发送方不能发送数据。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039832.png" alt=""></p>
<p>TCP 头包含 window 字段，16bit 位，它代表的是窗口的字节容量，最大为 65535。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。接收窗口的大小是约等于发送窗口的大小。</p>
<h3 id="4-6-TCP-相关问题"><a href="#4-6-TCP-相关问题" class="headerlink" title="4.6. TCP 相关问题"></a>4.6. TCP 相关问题</h3><h4 id="4-6-1-socket-分包的原因与造成问题"><a href="#4-6-1-socket-分包的原因与造成问题" class="headerlink" title="4.6.1. socket 分包的原因与造成问题"></a>4.6.1. socket 分包的原因与造成问题</h4><p>粘包、拆包发生的原因：</p>
<ol>
<li>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</li>
<li>待发送数据大于MSS（最大报文长度），TCP 在传输前将进行拆包。</li>
<li>要发送的数据小于TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据、将发生粘包。</li>
</ol>
<p>socket 分包的情况会造成以下问题：</p>
<ol>
<li>数据缺失：如果接收方无法完整地接收到一个完整的数据包，就会导致数据缺失。这可能会导致应用程序出现错误或异常行为。</li>
<li>数据重组：如果接收方接收到了多个分包，就需要将它们组合在一起才能得到完整的数据。这个过程可能会非常复杂，尤其是在数据包非常大或复杂的情况下。</li>
<li>数据混淆：如果数据包被分成了多个分包并以不同的顺序到达接收方，就会导致数据混淆。这可能会导致数据被错误地解释或处理，从而导致应用程序出现错误或异常行为。</li>
<li>性能下降：如果数据包被分成多个分包并且接收方需要进行数据重组，就会导致性能下降。这可能会导致应用程序的响应时间变长，从而影响用户体验。</li>
</ol>
<h2 id="5-网络编程模型"><a href="#5-网络编程模型" class="headerlink" title="5. 网络编程模型"></a>5. 网络编程模型</h2><h3 id="5-1-阻塞-I-O-模型"><a href="#5-1-阻塞-I-O-模型" class="headerlink" title="5.1. 阻塞 I/O 模型"></a>5.1. 阻塞 I/O 模型</h3><p>阻塞 I/O 模型是最常见的 I/O 模型，在读写数据时客户端会发生阻塞。阻塞 I/O 模型的工作流程是：</p>
<ol>
<li>在用户线程发出 I/O 请求之后，内核会检查数据是否就绪，此时用户线程一直阻塞等待内存数据就绪。</li>
<li>在内存数据就绪后，内核将数据复制到用户线程中，并返回 I/O 执行结果到用户线程，此时用户线程才解除阻塞状态并开始处理数据。</li>
</ol>
<blockquote>
<p>典型的阻塞 I/O 模型的例子为 <code>socket.read()</code>，如果内核数据没有就绪，Socket 线程就会一直阻塞在 <code>read()</code> 中等待内核数据就绪。</p>
</blockquote>
<h3 id="5-2-非阻塞-I-O-模型"><a href="#5-2-非阻塞-I-O-模型" class="headerlink" title="5.2. 非阻塞 I/O 模型"></a>5.2. 非阻塞 I/O 模型</h3><p>非阻塞 I/O 模型指用户线程在发起－个 I/O 操作后，无须阻塞便可以马上得到内核返回的一个结果。如果内核返回的结果为 false，则表示内核数据还没准备好，需要稍后再发起 I/O 操作。期间用户线程需要不断询问内核数据是否就绪，在内存数据还未就绪时，用户线程可以处理其他任务。一旦内核中的数据准备好了，并且再次收到用户线程的请求，内核就会立刻将数据复制到用户线程中并将复制的结果通知用户线程。</p>
<h3 id="5-3-多路复用-I-O-模型"><a href="#5-3-多路复用-I-O-模型" class="headerlink" title="5.3. 多路复用 I/O 模型"></a>5.3. 多路复用 I/O 模型</h3><p>多路复用 I/O 模型是多线程并发编程用得较多的模型，Java NIO 就是基于多路复用 I/O 模型实现的。 在多路复用 I/O 模型中会有一个被称为 Selector 的线程不断轮询多个 Socket 的状态，只有在 Socket 有读写事件时，才会通知用户线程进行 I/O 读写操作。其模型有如下优势：</p>
<ul>
<li>阻塞 I/O 模型和非阻塞 I/O 模型需要为每个 Socket 都建立一个单独的线程处理数据；而多路复用 I/O 模型中只需一个线程就可以管理多个 Socket，并且在真正有 Socket 读写事件时才会使用操作系统的 I/O 资源，大大节约了系统资源。</li>
<li>非阻塞 I/O 模型在每个用户线程中都进行 Socket 状态检查；而在多路复用 I/O 模型中 是在系统内核中进行 Socket 状态检查的</li>
</ul>
<p>多路复用 I/O 模型通过在一个 Selector 线程上以轮询方式检测在多个 Socket 上是否有事件到达，并逐个进行事件处理和响应。因此如果事件响应体（消息体）很大时，Selector 线程就可能出现性能瓶颈的问题，导致后续的事件处理很慢。<strong>在实际应用中，在多路复用方法体内一般不建议做复杂逻辑运算，只做数据的接收和转发，将具体的业务操作转发给后面的业务线程处理</strong>。</p>
<h3 id="5-4-信号驱动-I-O-模型"><a href="#5-4-信号驱动-I-O-模型" class="headerlink" title="5.4. 信号驱动 I/O 模型"></a>5.4. 信号驱动 I/O 模型</h3><p>在信号驱动 I/O 模型中，在用户线程发起一个 I/O 请求操作时，系统会为该请求对应的 Socket 注册一个信号函数，然后用户线程可以继续执行其他业务逻辑；在内核数据就绪时，系统会发送一个信号到用户线程，用户线程在接收到该信号后，会在信号函数中调用对应的 I/O 读写操作完成实际的 I/O 请求操作。</p>
<h3 id="5-5-异步-I-O-模型"><a href="#5-5-异步-I-O-模型" class="headerlink" title="5.5. 异步 I/O 模型"></a>5.5. 异步 I/O 模型</h3><p>异步 I/O 需要操作系统的底层支持，在 Java 7 中提供了 Asynchronous I/O 操作。</p>
<p>在异步 I/O 模型中，用户线程会发起一个 asynchronous read 操作到内核，内核在接收到 synchronous read 请求后会立刻返回一个状态，用于说明请求是否成功发起，在此过程中用户线程不会发生任何阻塞。然后内核会等待数据准备完成并将数据复制到用户线程中，在数据复制完成后内核会发送一个信号到用户线程，通知用户线程 asynchronous 读操作已完成。</p>
<p>输入与输出操作的两个阶段（请求的发起、数据的读取）都是在内核中自动完成的，用户线程只需发起一个请求，内核最终发送一个信号告知用户线程 I/O 操作已经完成。在接收到内核返回的成功或失败信号时即说明 I/O 操作已经完成，用户直接使用内存写好的数据即可，不需要再次调用 I/O 函数进行具体的读写操作，因此在整个过程中用户线程不会发生阻塞。</p>
<p>异步 I/O 模型与 信号驱动 I/O 模型的区别是：</p>
<ul>
<li>信号驱动模型，用户线程接收到信号便表示数据已经就绪，需要用户线程调用 I/O 函数进行实际的 I/O 读写操作，将数据读取到用户线程；</li>
<li>异步 I/O 模型，用户线程接收到信号便表示 I/O 操作已经完成（数据己经被复制到用户线程），用户可以开始使用该数据了 。</li>
</ul>
<h2 id="6-网络编程相关-API"><a href="#6-网络编程相关-API" class="headerlink" title="6. 网络编程相关 API"></a>6. 网络编程相关 API</h2><h3 id="6-1-InetAddress-类"><a href="#6-1-InetAddress-类" class="headerlink" title="6.1. InetAddress 类"></a>6.1. InetAddress 类</h3><h4 id="6-1-1-概述"><a href="#6-1-1-概述" class="headerlink" title="6.1.1. 概述"></a>6.1.1. 概述</h4><p>Java 中可以使用 InetAddress 类表示互联网协议（IP）地址。一个 InetAddress 对象就对应一个 IP 地址。</p>
<h4 id="6-1-2-常用方法"><a href="#6-1-2-常用方法" class="headerlink" title="6.1.2. 常用方法"></a>6.1.2. 常用方法</h4><h5 id="6-1-2-1-静态方法"><a href="#6-1-2-1-静态方法" class="headerlink" title="6.1.2.1. 静态方法"></a>6.1.2.1. 静态方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getLocalHost</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取本地主机IP地址对象。直接输出：“主机名/ip地址”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getByName</span><span class="params">(String host)</span>;</span><br><span class="line"><span class="comment">// 依据主机名（IP地址字符串/域名）获取主机IP地址对象。</span></span><br></pre></td></tr></table></figure>
<h5 id="6-1-2-2-非静态方法"><a href="#6-1-2-2-非静态方法" class="headerlink" title="6.1.2.2. 非静态方法"></a>6.1.2.2. 非静态方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getHostName</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取主机名称</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getHostAddress</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取主机字符串形式的IP</span></span><br></pre></td></tr></table></figure>
<h4 id="6-1-3-InetAddress-类-Code-Demo"><a href="#6-1-3-InetAddress-类-Code-Demo" class="headerlink" title="6.1.3. InetAddress 类 Code Demo"></a>6.1.3. InetAddress 类 Code Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	Inetaddress 类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonZero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">// 获取本机IP地址值对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">// 获取本机名称和IP地址</span></span><br><span class="line">        System.out.println(inet); <span class="comment">// Zero/192.168.83.21</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> inet.getHostName();</span><br><span class="line">        System.out.println(name); <span class="comment">// Zero</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> inet.getHostAddress();</span><br><span class="line">        System.out.println(ip); <span class="comment">// 192.168.83.21</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以主机的名称获取其他主机的对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inetOther</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;2011-20120210FQ&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取其他主机的名称和IP地址</span></span><br><span class="line">        System.out.println(inetOther); <span class="comment">// 2011-20120210FQ/192.168.83.64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-InetSocketAddress"><a href="#6-2-InetSocketAddress" class="headerlink" title="6.2. InetSocketAddress"></a>6.2. InetSocketAddress</h3><h4 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1. 概述"></a>6.2.1. 概述</h4><p>在使用 Socket 来连接服务器时最简单的方式就是直接使用 IP 和端口，但 Socket 类中并未提供这种方式，可以使用 <code>SocketAddress</code> 的子类 <code>java.net.InetSocketAddress</code> 来实现<code>IP 地址+端口号</code>的创建，不依赖任何协议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetSocketAddress</span> <span class="keyword">extends</span> <span class="title class_">SocketAddress</span></span><br></pre></td></tr></table></figure>
<h2 id="7-网络协议"><a href="#7-网络协议" class="headerlink" title="7. 网络协议"></a>7. 网络协议</h2><h3 id="7-1-动图解释-8-种热门网络协议"><a href="#7-1-动图解释-8-种热门网络协议" class="headerlink" title="7.1. 动图解释 8 种热门网络协议"></a>7.1. 动图解释 8 种热门网络协议</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251039833.gif" alt=""></p>
<ol>
<li>HTTP（超文本传输协议）：是用于获取 HTML 等资源的协议，它使用 TCP 协议作为底层的支撑协议，它是 Web 上任何数据交换的基础，是一种客户端-服务器协议。使用场景：浏览器。</li>
<li>HTTP/3：是 HTTP 的第三个版本，它使用QUIC作为底层的支撑协议，QUIC 是一种为移动互联网使用而设计的新传输协议。它依赖于 UDP 而不是 TCP，这使得网页响应速度更快，可以实现虚拟现实应用，用更多的带宽来渲染虚拟场景的复杂细节。使用场景：物联网（IOT）、虚拟现实。</li>
<li>HTTPS（超文本传输协议安全版）：是 HTTP 协议的安全版本，扩展了 HTTP，并使用加密进行安全通信，主打一个「安全」。使用场景：浏览器、网上银行、网上支付。</li>
<li>WebSocket：是一种基于 TCP 协议的全双工通信协议，与传统的 HTTP 通信不同，WebSocket 允许服务器主动向客户端推送数据，而不需要等待客户端的请求。使用场景：实时聊天、视频会议、股票行情。</li>
<li>TCP（传输控制协议）：是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是互联网的基础，用于在互联网上传输各种类型的数据，包括文本、图像、音频、视频等，许多应用层协议都建立在 TCP 之上。使用场景：浏览器、文件传输、邮件。</li>
<li>UDP（用户数据报协议）：是一种面向无连接的、不可靠的、基于数据报的传输层通信协议。UDP 是 TCP 的补充，UDP 提高了数据传输的速度，但是可能会丢失某些数据，用于那些对可靠性要求不高的应用场景。使用场景：视频流媒体、网络游戏、实时监控。</li>
<li>SMTP（简单邮件传输协议）：是一个标准协议，是电子邮件传递的基础，用于在互联网上发送和接收电子邮件。使用场景：电子邮件。</li>
<li>FTP（文件传输协议）：是文件传输协议，用于在客户端和服务器之间传输计算机文件，FTP 是文件传输的基础，用于在不同计算机之间共享文件。使用场景：文件传输。</li>
</ol>
<h3 id="7-2-TCP-或-UDP-的应用层协议"><a href="#7-2-TCP-或-UDP-的应用层协议" class="headerlink" title="7.2. TCP 或 UDP 的应用层协议"></a>7.2. TCP 或 UDP 的应用层协议</h3><p><strong>基于 TCP 的协议</strong>：</p>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。</li>
<li>FTP（File Transfer Protocol，文件传输协议），用于文件传输。</li>
<li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li>
<li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<p><strong>基于 UDP 的协议</strong>：</p>
<ul>
<li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li>
<li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p><strong>基于 TCP 和 UDP 的协议</strong>：</p>
<ul>
<li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。</li>
<li>ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。</li>
<li>SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
<li>ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io">蓝桉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io/posts/4e9c3100.html">https://ktzxy.github.io/posts/4e9c3100.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ktzxy.github.io" target="_blank">蓝桉`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/bg/Image00026.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src="/img/wechat.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src="/img/alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/78003030.html" title="MyBatisPlus快速入门"><img class="cover" src="/bg/Image00020.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MyBatisPlus快速入门</div></div><div class="info-2"><div class="info-item-1">MyBatisPlus快速入门  需要的基础：  MyBatis Spring SpringMVC    是什么？  MyBatis 本来就是简化 JDBC 操作的！  官网：https://mp.baomidou.com/ MyBatis Plus，==简化 MyBatis==      1.MyBatisPlus概述 MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。    愿景   是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。   特性   无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错...</div></div></div></a><a class="pagination-related" href="/posts/a4522265.html" title="Python3Notes2"><img class="cover" src="/bg/Image00009.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Python3Notes2</div></div><div class="info-2"><div class="info-item-1">Python 教程 (2)这个教程根据廖雪峰的Python3教程所写. 从模块开始的高级部分. [TOC] 模块在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。 为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点这里查看Python的所有内置函数。 为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为包（Package）。引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。 请注意，每一个包目录下面都会有一个init.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。init.py可以是空文件，也可以有Python代码...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/2af7de89.html" title="Day-0-IDEA简单学习"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-0-IDEA简单学习</div></div><div class="info-2"><div class="info-item-1">﻿# Day-0-IDEA简单学习 1.设置主题 2.编辑区的字体变大或者变小：（ctrl+鼠标滚轮） 3.鼠标悬浮在代码上有提示： 4.自动导包和优化多余的包：手动导包：快捷键：alt+enter自动导包和优化多余的包：  5.显示行号 ，  方法和方法间的分隔符： 6.忽略大小写，进行提示： 7.修改代码中注释的字体颜色： 8.修改类头的文档注释信息：注意：对新建的类才有效/**  @Auther: XXX @Date: ${DATE} - ${MONTH} - ${DAY} - ${TIME}  @Description: ${PACKAGE_NAME} @version: 1.0*/   8.自动编译： 9.常用快捷键【1】创建内容：alt+insert 【2】main方法：psvm 【3】输出语句：sout 【4】复制行：ctrl+d 【5】删除行：ctrl+y 【6】代码向上/下移动：Ctrl + Shift + Up / Down 【7】搜索类：  ctrl+n 【8】生成代码  ：alt + Insert（如构造函数等，getter,setter,hashCode...</div></div></div></a><a class="pagination-related" href="/posts/72ba03f7.html" title="Day-02-java基础语法"><img class="cover" src="/bg/Image00027.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-02-java基础语法</div></div><div class="info-2"><div class="info-item-1">﻿ Day-02-java基础语法快捷键操作 psvm —&gt;快速生成public static void main(String[] args) {} sout —&gt;快速生成System.out.println();  可能会遇到的问题  每个单词的大小不能出现问题，==Java是大小写敏感的==； 尽量使用英文； 文件名和类名必须保证一致，并且首字母大写； 符号使用的了中文。   Java运行机制  编译型 解释型    注释：Java中的注释有三种： 12345678910注释：    单行注释：    //我是单行注释    多行注释      /*我是多行注释*/    文档注释    /**    *@description  HelloWrold    *@Author 作者    */ 标识符：关键字 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 标识符注意点 所有的标识符都应该以字母(A-Z或者a-z),美元符（$)、数字或者下划线(_)开始首字符之后可以是字母（A-Z或者a-z),美元符（$)、下划线(_)或数字的任何字符...</div></div></div></a><a class="pagination-related" href="/posts/369b2118.html" title="Day-03-java流程控制"><img class="cover" src="/bg/Image00020.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-03-java流程控制</div></div><div class="info-2"><div class="info-item-1">﻿ Day-03-java流程控制Scanner对象java.util.Scanner是Java5的新特性，我们可以通过Scanner类来获取用户的输入。 基本语法 1Scanner s = new Scanner(System.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext() 与hasNextLine()判断是否还有输入的数据。 12345678910111213public static void main(String[] args) &#123;    //创建一个扫描对象，用于接受键盘数据    Scanner scanner = new Scanner(System.in);    System.out.println(&quot;使用next方式接受：&quot;);    //判断用户有没有输入字符串    if (scanner.hasNext())&#123;        //使用next方式接受        String str = scanner.next();     ...</div></div></div></a><a class="pagination-related" href="/posts/bbaa91bf.html" title="Day-04-java方法详解"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-04-java方法详解</div></div><div class="info-2"><div class="info-item-1">﻿ Day-04-java方法详解何谓方法？​    System.out.println(),那么它是什么呢? ​    调用系统类里的标准输出对象out中的方法println ​    Java方法是语句的集合，它们在一起执行一个功能。 ​    方法是解决一类问题的步骤的有序组合 ​    方法包含于类或对象中，方法和方法是并列的关系，所以我们定义的方法不能写到main方法中 ​    方法在程序中被创建，在其他地方被引用 ​    设计方法的原则:方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。 方法的定义Java的方法类似争其它语言的函数,是一段用来完成特定功能的代码片段，一股情况卜，定义一个方法包含以下语法: 方法包含一个方法头和一个方法体。 下面是一个方法的所有部分: 修饰符:修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型∶方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。...</div></div></div></a><a class="pagination-related" href="/posts/cccc6599.html" title="Day-06-java面向对象"><img class="cover" src="/bg/Image00022.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-06-java面向对象</div></div><div class="info-2"><div class="info-item-1">﻿ Day-06-java面向对象什么是面向对象面向对象编程(Object-Oriented Programming, OOP) 面向对象编程的本质就是:==以类的方式组织代码，以对象的组织(封装)数据。== 抽象 三大特性: ​        封装 ​        继承 ​        多态从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象 从代码运行角度考虑是先有类后有对象。类是对象的模板。 回顾方法及加深方法的定义 修饰符 返回类型 ==break: 跳出switch，结束循环和return的区别方法名== 参数列表 异常抛出 方法的调用        静态方法 ​        非静态方法 ​        形参和实参 ​        值传递和引用传递 ​        this关键字 12345678910111213141516171819202122232425//demo1  类public class demo1 &#123;    //main方法    public static void main(String[] a...</div></div></div></a><a class="pagination-related" href="/posts/8ba586d.html" title="Day-07-java异常"><img class="cover" src="/bg/Image00013.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-07-java异常</div></div><div class="info-2"><div class="info-item-1">﻿ Day-07-java异常什么是异常 实际工作中，遇到的情况不可能是非常完美的。比如:你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或硬盘可能满了。等等。 软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是:Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。 异常指程序运行中出现的不期而至的各种状况,如:文件找不到、网络连接失败、非法参数等。异常发生在程序运行期间,它影响了正常的程序执行流程。 简单分类要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常: 检查性异常:最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常:运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误:错误不是异常，而是脱离程序员控制的问题。...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">蓝桉</div><div class="author-info-description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">生活、学习、技术</b>相关的问题和看法，还有<b style="color:#fff">文章教程</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ktzxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/ktzxy" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2251511764@qq.com" target="_blank" title="Email"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-RSS"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/496148176" target="_blank" title="BiliBili"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QX-BILIBILI"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2251511764&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. 网络编程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 网络通讯三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-IP%E5%9C%B0%E5%9D%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1. IP地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2. 端口号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3. 通讯协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.1.4. 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-OSI-%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. OSI 七层网络模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-TCP-IP-%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. TCP&#x2F;IP 四层网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-TCP-IP-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E-OSI-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1. TCP&#x2F;IP 网络模型与 OSI 网络模型对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. 五层模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Socket"><span class="toc-number">2.</span> <span class="toc-text">2. Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Socket-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. Socket 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Socket-%E6%89%80%E5%B1%9E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. Socket 所属网络模型的层级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Socket-%E9%80%9A%E8%AE%AF%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. Socket 通讯的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-UDP-%E9%80%9A%E4%BF%A1"><span class="toc-number">3.</span> <span class="toc-text">3. UDP 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-UDP-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. UDP 协议概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-UDP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1. UDP 协议的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-UDP-%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2. UDP 协议使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-DatagramPacket-%E7%B1%BB%EF%BC%88%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. DatagramPacket 类（数据报对象）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. 作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3. 常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-DatagramSocket-%E7%B1%BB%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. DatagramSocket 类（数据发送对象）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1. 作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3. 常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-UDP-%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. UDP 网络程序实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-UDP-%E5%8F%91%E9%80%81%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. UDP 发送端的实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-UDP-%E6%8E%A5%E6%94%B6%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2. UDP 接收端的实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-UDP-%E5%8F%91%E9%80%81%E7%AB%AF%E4%B8%8E%E6%8E%A5%E6%94%B6%E7%AB%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3. UDP 发送端与接收端的基础示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-1-UDP-%E5%8F%91%E9%80%81%E7%AB%AF"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">3.4.3.1. UDP 发送端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-2-UDP-%E6%8E%A5%E6%94%B6%E7%AB%AF"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">3.4.3.2. UDP 接收端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-3-%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C"><span class="toc-number">3.4.3.3.</span> <span class="toc-text">3.4.3.3. 测试效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-UDP-%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.5.</span> <span class="toc-text">3.5. UDP 键盘录入发送和接收示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-TCP-%E9%80%9A%E4%BF%A1"><span class="toc-number">4.</span> <span class="toc-text">4. TCP 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-TCP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. TCP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E7%89%B9%E7%82%B9"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2. 特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-TCP-%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3. TCP 协议使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-TCP-%E5%92%8C-UDP-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4. TCP 和 UDP 协议的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. TCP 三次握手&#x2F;四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-TCP-%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1. TCP 数据包结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2. 三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3. 四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4. 相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">4.2.4.1. 为什么不能两次握手就可以建立连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4-2-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E5%AE%A2%E6%88%B7%E7%AB%AF-TIME-WAIT-%E7%8A%B6%E6%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%AD%89%E5%BE%85-2MSL"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">4.2.4.2. 第四次挥手时客户端 TIME_WAIT 状态为什么要等待 2MSL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E6%97%B6%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">4.2.4.3. 为什么释放连接时需要四次挥手</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-TCP-%E7%BC%96%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. TCP 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-ServerSocket-%E7%B1%BB"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1. ServerSocket 类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">4.3.1.1. 构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">4.3.1.2. 常用方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-Socket-%E7%B1%BB"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2. Socket 类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-1-Scoket-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">4.3.2.1. Scoket 套接字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">4.3.2.2. 构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">4.3.2.3. 常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-TCP-%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. TCP 网络程序实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-TCP-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1. TCP 客户端实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-TCP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2. TCP 服务器端实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-TCP%E6%A8%A1%E6%8B%9F%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3. TCP模拟客户端与服务器代码案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%88%E4%BE%8B2"><span class="toc-number">4.4.4.</span> <span class="toc-text">4.4.4. TCP服务端案例2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. 滑动窗口机制（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-TCP-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.</span> <span class="toc-text">4.6. TCP 相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-socket-%E5%88%86%E5%8C%85%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E9%80%A0%E6%88%90%E9%97%AE%E9%A2%98"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1. socket 分包的原因与造成问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">5. 网络编程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E9%98%BB%E5%A1%9E-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 阻塞 I&#x2F;O 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 非阻塞 I&#x2F;O 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 多路复用 I&#x2F;O 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. 信号驱动 I&#x2F;O 模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%BC%82%E6%AD%A5-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 异步 I&#x2F;O 模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3-API"><span class="toc-number">6.</span> <span class="toc-text">6. 网络编程相关 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-InetAddress-%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. InetAddress 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2. 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2-1-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">6.1.2.1. 静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-2-2-%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">6.1.2.2. 非静态方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-InetAddress-%E7%B1%BB-Code-Demo"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.1.3. InetAddress 类 Code Demo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-InetSocketAddress"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. InetSocketAddress</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1. 概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.</span> <span class="toc-text">7. 网络协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%8A%A8%E5%9B%BE%E8%A7%A3%E9%87%8A-8-%E7%A7%8D%E7%83%AD%E9%97%A8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. 动图解释 8 种热门网络协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-TCP-%E6%88%96-UDP-%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. TCP 或 UDP 的应用层协议</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img src="/bg/Image00018.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库150道高频面试题"/></a><div class="content"><a class="title" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题">MySQL数据库150道高频面试题</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术同学必会的MySQL设计规约"/></a><div class="content"><a class="title" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约">技术同学必会的MySQL设计规约</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dfdfdf4.html" title="数据库概述"><img src="/bg/Image00002.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库概述"/></a><div class="content"><a class="title" href="/posts/dfdfdf4.html" title="数据库概述">数据库概述</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/490575ab.html" title="24工厂模式俗话解释"><img src="/bg/Image00024.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24工厂模式俗话解释"/></a><div class="content"><a class="title" href="/posts/490575ab.html" title="24工厂模式俗话解释">24工厂模式俗话解释</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/364ea8cc.html" title="设计模式"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/364ea8cc.html" title="设计模式">设计模式</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2020 - 2025 By 蓝桉</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8152976493" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat/cat.js"></script><script async data-pjax src="/js/meting/music_lanan.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/day/lunar.js"></script><script defer src="/js/day/day.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '10a7db1c41b6489db9c830c668a18304';
  var gaud_map_key = '82a64bc994fb6494830f157f319f9f69';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime/runtime.min.js"></script><script async src="/js/font/ali_font_all.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>
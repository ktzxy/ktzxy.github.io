<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL-性能优化 | 蓝桉`Blog</title><meta name="author" content="蓝桉,kt_zxh@163.com"><meta name="copyright" content="蓝桉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 性能优化总论 上图显示，越往上走，难度越来越高，收益却是越来越小的。 比如硬件和 OS 调优，需要对硬件和 OS 有着非常深刻的了解，仅仅就磁盘一项来说，一般非 DBA 能想到的调整就是 SSD 盘比用机械硬盘更好，但其实它至少包括了，使用什么样的磁盘阵列（RAID）级别、是否可以分散磁盘 IO、是否使用裸设备存放数据，使用哪种文件系统（目前比较推荐的是 XFS），操作系统的磁盘调度算法（目">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-性能优化">
<meta property="og:url" content="https://ktzxy.github.io/posts/e582bf51.html">
<meta property="og:site_name" content="蓝桉&#96;Blog">
<meta property="og:description" content="1. 性能优化总论 上图显示，越往上走，难度越来越高，收益却是越来越小的。 比如硬件和 OS 调优，需要对硬件和 OS 有着非常深刻的了解，仅仅就磁盘一项来说，一般非 DBA 能想到的调整就是 SSD 盘比用机械硬盘更好，但其实它至少包括了，使用什么样的磁盘阵列（RAID）级别、是否可以分散磁盘 IO、是否使用裸设备存放数据，使用哪种文件系统（目前比较推荐的是 XFS），操作系统的磁盘调度算法（目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ktzxy.github.io/bg/Image00013.webp">
<meta property="article:published_time" content="2025-07-09T17:28:46.000Z">
<meta property="article:modified_time" content="2025-07-13T15:45:18.451Z">
<meta property="article:author" content="蓝桉">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ktzxy.github.io/bg/Image00013.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL-性能优化",
  "url": "https://ktzxy.github.io/posts/e582bf51.html",
  "image": "https://ktzxy.github.io/bg/Image00013.webp",
  "datePublished": "2025-07-09T17:28:46.000Z",
  "dateModified": "2025-07-13T15:45:18.451Z",
  "author": [
    {
      "@type": "Person",
      "name": "蓝桉",
      "url": "https://ktzxy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ktzxy.github.io/posts/e582bf51.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL-性能优化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/windmill/windmill.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/meting/music_lanan.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="蓝桉`Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/bg.webp);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/bg/Image00013.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">蓝桉`Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL-性能优化</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySQL-性能优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-13T15:45:18.451Z" title="更新于 2025-07-13 15:45:18">2025-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-性能优化总论"><a href="#1-性能优化总论" class="headerlink" title="1. 性能优化总论"></a>1. 性能优化总论</h2><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028464.jpg" alt=""></p>
<p>上图显示，越往上走，难度越来越高，收益却是越来越小的。</p>
<p>比如硬件和 OS 调优，需要对硬件和 OS 有着非常深刻的了解，仅仅就磁盘一项来说，一般非 DBA 能想到的调整就是 SSD 盘比用机械硬盘更好，但其实它至少包括了，使用什么样的磁盘阵列（RAID）级别、是否可以分散磁盘 IO、是否使用裸设备存放数据，使用哪种文件系统（目前比较推荐的是 XFS），操作系统的磁盘调度算法（目前比较推荐 deadline，对机械硬盘和 SSD 都比较合适。从内核 2.5开始，默认的 I/O 调度算法是 Deadline，之后默认 I/O 调度算法为 Anticipatory，直到内核 2.6.17 为止，从内核 2.6.18 开始，CFQ 成为默认的 IO 调度算法，但CFQ 并不推荐作为数据库服务器的磁盘调度算法。）选择，是否需要调整操作系统文件管理方面比如 atime 属性等等。</p>
<blockquote>
<p>TIPS：裸设备(raw device)，也叫裸分区（原始分区），是一种没有经过格式化，不被 Unix 通过文件系统来读取的特殊块设备文件。由应用程序负责对它进行读写操作。不经过文件系统的缓冲。它是不被操作系统直接管理的设备。这种设备少了操作系统这一层，I/O 效率更高。</p>
</blockquote>
<p>查看磁盘调度算法：永久地修改 IO 调度算法，需要修改内核引导参数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dmesg <span class="operator">|</span>grep <span class="operator">-</span>i scheduler</span><br><span class="line">df <span class="operator">-</span>m</span><br><span class="line">more <span class="operator">/</span>sys<span class="operator">/</span>block<span class="operator">/</span>vda<span class="operator">/</span>queue<span class="operator">/</span>scheduler</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028465.png" alt=""></p>
<p>在进行优化时，首先需要关注和优化的应该是架构，对于架构调优，在系统设计时首先需要充分考虑业务的实际情况，是否可以把不适合数据库做的事情放到数据仓库、搜索引擎或者缓存中去做；然后考虑写的并发量有多大，是否需要采用分布式；最后考虑读的压力是否很大，是否需要读写分离。对于核心应用或者金融类的应用，需要额外考虑数据安全因素，数据是否不允许丢失。</p>
<p>作为金字塔的底部的架构调优，采用更适合业务场景的架构能最大程度地提升系统的扩展性和可用性。在设计中进行垂直拆分能尽量解耦应用的依赖，对读压力比较大的业务进行读写分离能保证读性能线性扩展，而对于读写并发压力比较大的业务在 MySQL 上也有采用读写分离的大量案例。</p>
<p>作为金字塔的底部，在底层硬件系统、SQL 语句和参数都基本定型的情况下，单个 MySQL 数据库能提供的性能、扩展性等就基本定型了。但是通过架构设计和优化，却能承载几倍、几十倍甚至百倍于单个 MySQL 数据库能力的业务请求能力。</p>
<p>对于 MySQL 调优，需要确认业务表结构设计是否合理，SQL 语句优化是否足够，该添加的索引是否都添加了，是否可以剔除多余的索引等等。</p>
<p>最后确定系统、硬件有哪些地方需要优化，系统瓶颈在哪里，哪些系统参数需要调整优化，进程资源限制是否提到足够高；在硬件方面是否需要更换为具有更高 I/O 性能的存储硬件，是否需要升级内存、CPU、网络等。</p>
<p>如果在设计之初架构就不合理，比如没有进行读写分离，那么后期的 MySQL 和硬件、系统优化的成本就会很高，并且还不一定能最终解决问题。如果业务性能的瓶颈是由于索引等 MySQL 层的优化不够导致的，那么即使配置再高性能的I/O存储硬件或者 CPU 也无法支撑业务的全表扫描。</p>
<p>所以重点关注 MySQL 方面的调优，特别是索引。SQL/索引调优要求对业务和数据流非常清楚。在阿里巴巴内部，有三分之二的 DBA 是业务 DBA，从业务需求讨论到表结构审核、SQL 语句审核、上线、索引更新、版本迭代升级，甚至哪些数据应该放到非关系型数据库中，哪些数据放到数据仓库、搜索引擎或者缓存中，都需要这些 DBA 跟踪和复审。他们甚至可以称为数据架构师（Data Architecher）。</p>
<h2 id="2-MySQL数据库优化准备工作"><a href="#2-MySQL数据库优化准备工作" class="headerlink" title="2. MySQL数据库优化准备工作"></a>2. MySQL数据库优化准备工作</h2><h3 id="2-1-慢查询的定义与作用"><a href="#2-1-慢查询的定义与作用" class="headerlink" title="2.1. 慢查询的定义与作用"></a>2.1. 慢查询的定义与作用</h3><p>慢查询日志，是指 mysql 记录所有执行超过 <code>long_query_time</code> 参数设定的时间阈值的 SQL 语句的日志。该日志能为 SQL 语句的优化带来很好的帮助。默认情况下，慢查询日志是关闭的。</p>
<h3 id="2-2-慢查询基础-优化数据访问"><a href="#2-2-慢查询基础-优化数据访问" class="headerlink" title="2.2. 慢查询基础-优化数据访问"></a>2.2. 慢查询基础-优化数据访问</h3><p>查询性能低下最基本的原因是访问的数据太多。大部分性能低下的查询都可以通过减少访问的数据量的方式进行优化。对于低效的查询，一般通过下面两个步骤来分析总是很有效：</p>
<ol>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。</li>
<li>确认 MySQL 服务器层是否在分析大量超过需要的数据行。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ol>
<h4 id="2-2-1-请求了不需要的数据"><a href="#2-2-1-请求了不需要的数据" class="headerlink" title="2.2.1. 请求了不需要的数据"></a>2.2.1. 请求了不需要的数据</h4><p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给 MySQL 服务器带来额外的负担，并增加网络开销，另外也会消耗应用服务器的 CPU 和内存资源。</p>
<ul>
<li><strong>查询不需要的记录</strong>：大数开发者使用习惯，先使用 SELECT 语句查询大量的结果，然后获取前面的 N 行后关闭结果集。认为 MySQL 会执行查询并只返回所需要的 N 条数据，然后停止查询。实际情况是 MySQL 会查询出全部的结果集，客户端的应用程序会接收全部的结果集数据，然后抛弃其中大部分数据。最简单有效的解决方法就是在这样的查询后面加上 <code>LIMIT</code>。</li>
<li><strong>总是取出全部列</strong>：使用 <code>SELECT *</code> 的时候，MySQL 会取出全部列，会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的 I/O、内存和 CPU 的消耗。有时可以允许查询返回超过需要的数据。如果这种做法可以简化开发，能提高相同代码片段的复用性，这种做法也是值得考虑的。如果应用程序使用了某种缓存机制，或者有其他考虑，获取超过需要的数据也可能有其好处，但不要忘记这样做的代价是什么。获取并缓存所有的列的查询，相比多个独立的只获取部分列的查询可能就更有好处。</li>
<li><strong>重复查询相同的数据</strong>：不断地重复执行相同的查询，然后每次都返回完全相同的数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。</li>
</ul>
<h4 id="2-2-2-是否在扫描额外的记录"><a href="#2-2-2-是否在扫描额外的记录" class="headerlink" title="2.2.2. 是否在扫描额外的记录"></a>2.2.2. 是否在扫描额外的记录</h4><p>对于 MySQL，最简单的衡量查询开销的三个指标：<strong>响应时间、扫描的行数、返回的行数</strong></p>
<ul>
<li><strong>响应时间</strong>：是两个部分之和，分别是<strong>服务时间</strong>和<strong>排队时间</strong>。<ul>
<li>服务时间是指数据库处理这个查询真正花了多长时间。</li>
<li>排队时间是指服务器因为等待某些资源而没有真正执行查询的时间（<em>可能是等 I/O 操作完成，也可能是等待行锁等。</em>）</li>
</ul>
</li>
</ul>
<p>当看到一个查询的响应时间的时候，首先需要审视这个响应时间是否是一个合理的值。概括地说，了解这个查询需要哪些索引以及它的执行计划是什么，然后计算大概需要多少个顺序和随机 I/O，再用其乘以在具体硬件条件下一次 I/O 的消耗时间。最后把这些消耗都加起来，就可以获得一个大概参考值来判断当前响应时间是不是一个合理的值。</p>
<ul>
<li><strong>扫描的行数和返回的行数</strong></li>
</ul>
<p>分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。</p>
<p>理想情况下扫描的行数和返回的行数应该是相同的。实际这种情况很少出现，扫描的行数对返回的行数的比率通常很小，一般在 1:1 和 10:1 之间，不过有时候这个值也可能非常非常大。</p>
<ul>
<li><strong>扫描的行数和访问类型</strong></li>
</ul>
<p>评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySQL 有好几种访问方式可以查找并返回一行结果。有些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无须扫描就能返回结果。</p>
<p>在 EXPLAIN 语句中的 type 列反映了查询的访问类型。如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引，为什么索引对于查询优化如此重要了。索引让 MySQL 以最高效、扫描行数最少的方式找到需要的记录。</p>
<p>一般 MySQL 能够使用如下三种方式应用 <code>WHERE</code> 条件，从好到坏依次为：</p>
<ol>
<li>在索引中使用 WHERE 条件来过滤不匹配的记录。这是在存储引擎层完成。</li>
<li>使用索引覆盖扫描（在 Extra 列中出现了 Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在 MySQL 服务器层完成的，但无须再回表查询记录。</li>
<li>从数据表中返回数据，然后过滤不满足条件的记录（在 Extra 列中出现 Using Where）。这在 MySQL 服务器层完成，MySQL 需要先从数据表读出记录然后过滤。</li>
</ol>
<p>好的索引可以让查询使用合适的访问类型，尽可能地只扫描需要的数据行。如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：</p>
<ol>
<li>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。</li>
<li>改变库表结构。例如使用单独的汇总表。</li>
<li>重写这个复杂的查询，让 MySQL 优化器能够以更优化的方式执行这个查询。</li>
</ol>
<h3 id="2-3-重构查询的方式"><a href="#2-3-重构查询的方式" class="headerlink" title="2.3. 重构查询的方式"></a>2.3. 重构查询的方式</h3><p>优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果。有时候，可以将查询转换一种写法让其返回一样的结果，但是性能更好。也可以通过修改应用代码，用另一种方式完成查询，最终达到一样的目的。</p>
<h4 id="2-3-1-一个复杂查询还是多个简单查询"><a href="#2-3-1-一个复杂查询还是多个简单查询" class="headerlink" title="2.3.1. 一个复杂查询还是多个简单查询"></a>2.3.1. 一个复杂查询还是多个简单查询</h4><p>设计查询时需要考虑是否需要将一个复杂的查询分成多个简单的查询。</p>
<p>MySQL 从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。现代的网络速度比以前要快很多，无论是带宽还是延迟。在某些版本的 MySQL 上，即使在一个通用服务器上，也能够运行每秒超过 10 万的查询，即使是一个千兆网卡也能轻松满足每秒超过 2000 次的查询。所以运行多个小查询现在已经不是大问题了。</p>
<p>MySQL 内部每秒能够扫描内存中上百万行数据，相比之下，MySQL 响应数据给客户端就慢得多了。在其他条件都相同的时候，使用尽可能少的查询当然是更好的。但是有时候，将一个大查询分解为多个小查询是很有必要的。</p>
<p>在应用设计的时候，如果一个查询能够胜任时还写成多个独立查询是不明智的。例如，应用对一个数据表做 10 次独立的查询来返回 10 行数据，每个查询返回一条结果，查询 10 次。</p>
<h4 id="2-3-2-切分查询"><a href="#2-3-2-切分查询" class="headerlink" title="2.3.2. 切分查询"></a>2.3.2. 切分查询</h4><p>将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p>
<p>删除旧的数据就是一个很好的例子。定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的 DELETE 语句切分成多个较小的查询可以尽可能小地影响 MySQL 性能，同时还可以减少 MySQL 复制的延迟。</p>
<p>一次删除一万行数据一般来说是一个比较高效而且对服务器影响也最小的做法。同时需要注意的是，如果每次删除数据后，都暂停一会儿再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间。</p>
<h4 id="2-3-3-分解关联查询"><a href="#2-3-3-分解关联查询" class="headerlink" title="2.3.3. 分解关联查询"></a>2.3.3. 分解关联查询</h4><p>很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。用分解关联查询的方式重构查询有如下的优势：</p>
<ul>
<li>让<strong>缓存的效率更高</strong>。许多应用程序可以方便地缓存单表查询对应的结果对象。将查询分解后，执行单个查询<strong>可以减少锁的竞争</strong>。</li>
<li>在应用层做关联，可以更容易对数据库进行拆分，<strong>更容易做到高性能和可扩展</strong>。查询本身效率也可能会有所提升。</li>
<li>可以<strong>减少冗余记录的查询</strong>。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。</li>
</ul>
<p>这样相当于<strong>在应用中实现了哈希关联</strong>，而不是使用 MySQL 的嵌套循环关联。某些场景哈希关联的效率要高很多。</p>
<p>在很多场景下，通过重构查询将关联放到应用程序中将会更加高效，这样的场景有很多，比如：当应用能够方便地缓存单个查询的结果的时候、当可以将数据分布到不同的 MySQL 服务器上的时候、当能够使用<code>IN()</code>的方式代替关联查询的时候、当查询中使用同一个数据表的时候。</p>
<h3 id="2-4-SQL-执行效率查询"><a href="#2-4-SQL-执行效率查询" class="headerlink" title="2.4. SQL 执行效率查询"></a>2.4. SQL 执行效率查询</h3><p>MySQL 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以查询服务器状态信息，查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 的访问频次：</p>
<p>通过上述指令，可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。如果是以增删改为主，可以考虑不对其进行索引的优化。如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p>
<h4 id="2-4-1-查看当前会话统计结果"><a href="#2-4-1-查看当前会话统计结果" class="headerlink" title="2.4.1. 查看当前会话统计结果"></a>2.4.1. 查看当前会话统计结果</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> session status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Com_binlog    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_commit    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_delete    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_insert    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_repair    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_revoke    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_select    <span class="operator">|</span> <span class="number">7</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_signal    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_update    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_xa_end    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure>
<p>重要指标说明：</p>
<ul>
<li>Com_delete: 删除次数</li>
<li>Com_insert: 插入次数</li>
<li>Com_select: 查询次数</li>
<li>Com_update: 更新次数</li>
</ul>
<h4 id="2-4-2-查看自数据库上次启动至今统计结果"><a href="#2-4-2-查看自数据库上次启动至今统计结果" class="headerlink" title="2.4.2. 查看自数据库上次启动至今统计结果"></a>2.4.2. 查看自数据库上次启动至今统计结果</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Com_binlog    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_commit    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_delete    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_insert    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_repair    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_revoke    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_select    <span class="operator">|</span> <span class="number">18</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_signal    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_update    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Com_xa_end    <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-查看针对Innodb引擎的统计结果"><a href="#2-4-3-查看针对Innodb引擎的统计结果" class="headerlink" title="2.4.3. 查看针对Innodb引擎的统计结果"></a>2.4.3. 查看针对Innodb引擎的统计结果</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name        <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_deleted  <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_inserted <span class="operator">|</span> <span class="number">650</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_read     <span class="operator">|</span> <span class="number">847</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_rows_updated  <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-------+</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-慢查询日志配置"><a href="#2-5-慢查询日志配置" class="headerlink" title="2.5. 慢查询日志配置"></a>2.5. 慢查询日志配置</h3><h4 id="2-5-1-查询慢查询日志相关参数"><a href="#2-5-1-查询慢查询日志相关参数" class="headerlink" title="2.5.1. 查询慢查询日志相关参数"></a>2.5.1. 查询慢查询日志相关参数</h4><p>当查询超过一定的时间没有返回结果的时候，才会记录到慢查询日志中。<strong>默认不开启</strong>，采样的时候手工开启。可以帮助找出执行慢的sql语句</p>
<ul>
<li>查看慢SQL日志是否启用（on表示启用）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>MySQL 中可以设定一个阈值，将运行时间超过该值的所有SQL 语句都记录到慢查询日志中。<code>long_query_time</code> 参数就是这个阈值。默认值为10（10秒）。查看执行慢于多少秒的SQL会记录到日志文件中</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于没有运行的 SQL 语句没有使用索引，则 MySQL 数据库也可以将这条 SQL 语句记录到慢查询日志文件，控制参数是：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;%log_queries_not_using_indexes%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于产生的慢查询日志，可以指定输出的位置，通过参数<code>log_output</code>来控制，可以输出到 <code>[TABLE][FILE][FILE,TABLE]</code>。默认是输出到文件，可以配置把慢查询输出到表，不过一般不推荐输出到表。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;log_output&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用模糊搜索，查看所有含有query的变量信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%query%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-开启慢查询日志方式1-修改mysql配置参数"><a href="#2-5-2-开启慢查询日志方式1-修改mysql配置参数" class="headerlink" title="2.5.2. 开启慢查询日志方式1 - 修改mysql配置参数"></a>2.5.2. 开启慢查询日志方式1 - 修改mysql配置参数</h4><p>mysql 配置文件名称是：<code>my.ini</code>（Linux 系统下的文件名为<code>/etc/my.cnf</code>）</p>
<p>window 下可以通过打开【服务】，右键点击 mysql 服务，查询【属性】。里面有<code>--defaults-file=&quot;D:\development\MySQL\MySQL Server 5.5\my.ini&quot;</code>，可以查看 mysql 配置文件的位置</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028466.jpg" alt=""></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028467.jpg" alt=""></p>
<p>修改配置文件，<strong>1代表on，0做表off</strong>。(<em>注：如果mysql5.5版本，配置文件是没有慢日志的配置，而5.7版本的配置文件里是默认有慢日志的配置。所以5.5需要自己手动增加</em>)：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="comment"># ====== 5.5版本需要手动增加，5.7以上版本默认有慢日志配置 ======</span></span><br><span class="line"></span><br><span class="line"><span class="attr">log_slow_queries</span>=<span class="string">ON</span></span><br><span class="line"><span class="comment"># 是否开启慢查询日志</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">ON</span></span><br><span class="line"><span class="comment"># 指定保存路径及文件名，默认为数据文件目录</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">&quot;slow-query.log&quot;</span></span><br><span class="line"><span class="comment"># 指定多少秒返回查询结果为慢查询</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">2</span></span><br><span class="line"><span class="comment"># 记录所有没有使用到索引的查询语句</span></span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span>=<span class="string">ON</span></span><br><span class="line"><span class="comment"># 记录那些由于查找了多于1000次而引发的慢查询</span></span><br><span class="line"><span class="attr">min_examined_row_limit</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"># 记录那些慢的optimize table, analyze table和alter table语句</span></span><br><span class="line"><span class="attr">log_slow_admin_statements</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"># 记录由slave所产生的慢查询</span></span><br><span class="line"><span class="attr">log_slow_slave_statements</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># The TCP/IP Port the MySQL Server will listen on</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">3306</span></span><br></pre></td></tr></table></figure>
<p>修改配置文件后需要重启mysql服务才能生效</p>
<h4 id="2-5-3-开启慢查询日志方式2-命令行修改慢查询配置"><a href="#2-5-3-开启慢查询日志方式2-命令行修改慢查询配置" class="headerlink" title="2.5.3. 开启慢查询日志方式2 - 命令行修改慢查询配置"></a>2.5.3. 开启慢查询日志方式2 - 命令行修改慢查询配置</h4><p><strong>命令行修改配置方式不需要重启即可生效，但如果重启之后会自动失效</strong>。因为mysql数据库每次启动，都是读取本身的my.ini配置文件，以配置文件的参数为准</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启动停止慢查询日志</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 指定慢查询日志得存储路径及文件（默认和数据文件放一起）</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log_file<span class="operator">=</span>&quot;slow-query.log&quot;;</span><br><span class="line"><span class="comment">--  指定记录慢查询日志 SQL 执行时间得伐值（单位：秒，默认 10 秒）</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 是否记录未使用索引的 SQL</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_queries_not_using_indexes<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> min_examined_row_limit<span class="operator">=</span><span class="number">1000</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_slow_admin_statements<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_slow_slave_statements<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 指定日志输出的位置，日志存放的地方可以是[TABLE][FILE][FILE,TABLE]</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output<span class="operator">=</span><span class="string">&#x27;FILE,TABLE&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果需要修改其他参数，可以通过以下命令查阅</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%query%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-4-慢查询日志保存位置"><a href="#2-5-4-慢查询日志保存位置" class="headerlink" title="2.5.4. 慢查询日志保存位置"></a>2.5.4. 慢查询日志保存位置</h4><p>windows 与 linux 系统的慢查询日志默认是和数据文件放一起。linux 系统默认数据文件存储位置是 <code>/var/lib/mysql/</code>，可以通过查看 <code>/etc/my.cnf</code> 配置文件确认日志与数据的保存位置。</p>
<h3 id="2-6-查询缓存"><a href="#2-6-查询缓存" class="headerlink" title="2.6. 查询缓存"></a>2.6. 查询缓存</h3><h4 id="2-6-1-查询缓存状态"><a href="#2-6-1-查询缓存状态" class="headerlink" title="2.6.1. 查询缓存状态"></a>2.6.1. 查询缓存状态</h4><p>Query Cache 会缓存 select 查询，安装 mysql 时默认是开启。但是如果对表进行了 insert, update, delete, truncate, alter table, drop table, or drop database 等操作时，之前的缓存会无效并且删除，这样一定程度上会影响数据库的性能。所以对一些频繁变动表的情况开启缓存是不明智的。还有一种情况是在测试数据库性能的时候也需要关闭缓存，避免缓存对于测试数据的影响。</p>
<p>查询缓存的启用状态，query_cache_type 字段是 <code>on</code> 的时候，代表开启缓存。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%cache%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-2-关闭缓存"><a href="#2-6-2-关闭缓存" class="headerlink" title="2.6.2. 关闭缓存"></a>2.6.2. 关闭缓存</h4><p>关闭缓存有两种方式：一种是临时关闭，一种是永久关闭</p>
<ol>
<li>临时关闭，直接在命令行执行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一般建议缓存的大小为32M (33554432)</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> query_cache_size<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 如果配置文件中为关闭缓存的话，不能通过命令开启缓存</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> query_cache_type<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>永久关闭，修改配置文件my.cnf(my.ini)，添加以下配置</li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置缓存的大小</span></span><br><span class="line"><span class="attr">query_cache_size</span>=<span class="number">0</span></span><br><span class="line"><span class="comment"># 设置关闭缓存</span></span><br><span class="line"><span class="attr">query_cache_type</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="2-6-3-sql-no-cache-关键字禁用缓存"><a href="#2-6-3-sql-no-cache-关键字禁用缓存" class="headerlink" title="2.6.3. sql_no_cache 关键字禁用缓存"></a>2.6.3. sql_no_cache 关键字禁用缓存</h4><p>可以使用<code>sql_no_cache</code>关键字在 sql 语句中直接禁用缓存。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定当前查询不使用缓存</span></span><br><span class="line"><span class="keyword">select</span> sql_no_cache <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> test_table;</span><br><span class="line"><span class="comment">-- 指定当前查询使用缓存（其实不需要加此关键字，因为默认缓存已经开启了）</span></span><br><span class="line"><span class="keyword">select</span> sql_cache <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> test_table;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-评估表数据体量"><a href="#2-7-评估表数据体量" class="headerlink" title="2.7. 评估表数据体量"></a>2.7. 评估表数据体量</h3><p>可以从<strong>表容量、磁盘空间、实例容量</strong>三方面评估数据体量。</p>
<h4 id="2-7-1-表容量"><a href="#2-7-1-表容量" class="headerlink" title="2.7.1. 表容量"></a>2.7.1. 表容量</h4><p>表容量主要从表的记录数、平均长度、增长量、读写量、总大小量进行评估。一般对于 OLTP 的表，建议单表不要超过 2000W 行数据量，总大小 15G 以内。访问量，单表读写量在 1600/s 以内。</p>
<p>一般查询表有多少数据时用到的经典 <code>count</code> 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>
<p>但是当数据量过大的时候，以上查询就可能会超时，所以要换一种查询方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use 库名;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> <span class="string">&#x27;表名&#x27;</span>;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> <span class="string">&#x27;表名&#x27;</span>\G;</span><br></pre></td></tr></table></figure>
<p>上述方法不仅可以查询表的数据，还可以输出表的详细信息，加 <code>\G</code> 参加可以格式化输出。包括表名、存储引擎、版本、行数、每行的字节数等等。</p>
<h4 id="2-7-2-磁盘空间"><a href="#2-7-2-磁盘空间" class="headerlink" title="2.7.2. 磁盘空间"></a>2.7.2. 磁盘空间</h4><p><strong>查看所有数据库容量大小</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	table_schema <span class="keyword">AS</span> <span class="string">&#x27;数据库&#x27;</span>,</span><br><span class="line">	table_name <span class="keyword">AS</span> <span class="string">&#x27;表名&#x27;</span>,</span><br><span class="line">	table_rows <span class="keyword">AS</span> <span class="string">&#x27;记录数&#x27;</span>,</span><br><span class="line">	<span class="keyword">TRUNCATE</span> ( data_length <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>,</span><br><span class="line">	<span class="keyword">TRUNCATE</span> ( index_length <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;索引容量(MB)&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.TABLES </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	data_length <span class="keyword">DESC</span>,</span><br><span class="line">	index_length <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p><strong>查询单个库中所有表磁盘占用大小</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	table_schema <span class="keyword">AS</span> <span class="string">&#x27;数据库&#x27;</span>,</span><br><span class="line">	table_name <span class="keyword">AS</span> <span class="string">&#x27;表名&#x27;</span>,</span><br><span class="line">	table_rows <span class="keyword">AS</span> <span class="string">&#x27;记录数&#x27;</span>,</span><br><span class="line">	<span class="keyword">TRUNCATE</span> ( data_length <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;数据容量(MB)&#x27;</span>,</span><br><span class="line">	<span class="keyword">TRUNCATE</span> ( index_length <span class="operator">/</span> <span class="number">1024</span> <span class="operator">/</span> <span class="number">1024</span>, <span class="number">2</span> ) <span class="keyword">AS</span> <span class="string">&#x27;索引容量(MB)&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	information_schema.TABLES </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	table_schema <span class="operator">=</span> <span class="string">&#x27;mysql&#x27;</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	data_length <span class="keyword">DESC</span>,</span><br><span class="line">	index_length <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>建议数据量占磁盘使用率的70%以内。同时，对于一些数据增长较快，可以考虑使用大的慢盘进行数据归档。</p>
<h4 id="2-7-3-实例容量"><a href="#2-7-3-实例容量" class="headerlink" title="2.7.3. 实例容量"></a>2.7.3. 实例容量</h4><p>MySQL 是基于线程的服务模型，因此在一些并发较高的场景下，单实例并不能充分利用服务器的 CPU 资源，吞吐量反而会卡在 MySQL 层，可以根据业务考虑相应的实例模式。</p>
<h2 id="3-SQL-语句性能分析"><a href="#3-SQL-语句性能分析" class="headerlink" title="3. SQL 语句性能分析"></a>3. SQL 语句性能分析</h2><h3 id="3-1-定位低效率执行的-SQL"><a href="#3-1-定位低效率执行的-SQL" class="headerlink" title="3.1. 定位低效率执行的 SQL"></a>3.1. 定位低效率执行的 SQL</h3><p>可以通过以下两种方式定位执行效率较低的 SQL 语句。</p>
<ul>
<li>通过慢查询日志定位那些执行效率较低的 SQL 语句。</li>
<li>通过 <code>EXPLAIN</code> 执行计划分析</li>
<li>使用 <code>show processlist</code> 命令查看当前 MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li>
<li>使用 profile 详情分析</li>
</ul>
<h3 id="3-2-慢查询解读分析"><a href="#3-2-慢查询解读分析" class="headerlink" title="3.2. 慢查询解读分析"></a>3.2. 慢查询解读分析</h3><h4 id="3-2-1-慢日志格式"><a href="#3-2-1-慢日志格式" class="headerlink" title="3.2.1. 慢日志格式"></a>3.2.1. 慢日志格式</h4><p>一条完整的日志包括：时间、主机信息、执行信息、执行时间、执行内容。示例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">Time</span>: <span class="number">2021</span><span class="number">-04</span><span class="number">-24</span>T00:<span class="number">22</span>:<span class="number">49.818178</span>Z</span><br><span class="line"># <span class="keyword">User</span><span class="variable">@Host</span>: root[root] @ localhost [<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>]</span><br><span class="line"># Query_time: <span class="number">0.011991</span>  Lock_time: <span class="number">0.000000</span> Rows_sent: <span class="number">10374</span>  Rows_examined: <span class="number">14376</span></span><br><span class="line"><span class="keyword">SET</span> <span class="type">timestamp</span><span class="operator">=</span><span class="number">1554258810</span>;</span><br><span class="line"><span class="keyword">SELECT</span> t.id,t.a_ids <span class="keyword">FROM</span> t_main t <span class="keyword">WHERE</span> t.a_ids <span class="keyword">LIKE</span> <span class="string">&#x27;%,%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>从慢查询日志里面摘选一条慢查询日志，数据组成如下：</p>
<ul>
<li><code>Time: 2021-04-24T00:22:49.818178Z</code>：查询执行时间</li>
<li><code>User@Host: root[root] @ localhost [127.0.0.1]</code>：用户名、用户的 IP 信息、线程 ID 号</li>
<li><code>Query_time: 0.011991</code>：执行花费的时长【单位：毫秒】<ul>
<li><code>Lock_time: 0.000000</code>：执行获得锁的时长</li>
<li><code>Rows_sent: 10374</code>：获得的结果行数</li>
<li><code>Rows_examined: 14376</code>：扫描的数据行数</li>
</ul>
</li>
<li><code>SET timestamp=1554258810;</code>：这 SQL 执行的具体时间</li>
<li>最后一行：执行的 SQL 语句</li>
</ul>
<h4 id="3-2-2-分析工具-了解"><a href="#3-2-2-分析工具-了解" class="headerlink" title="3.2.2. 分析工具(了解)"></a>3.2.2. 分析工具(了解)</h4><h5 id="3-2-2-1-Mysqldumpslow"><a href="#3-2-2-1-Mysqldumpslow" class="headerlink" title="3.2.2.1. Mysqldumpslow"></a>3.2.2.1. Mysqldumpslow</h5><p>mysqldumpslow 是 mysql 自带的用来分析慢查询的工具，基于 perl 开发。常用的慢查询日志分析工具，汇总除查询条件外其他完全相同的 SQL，并将分析结果按照参数中所指定的顺序输出。语法格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 slow-mysql.log</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-s order (c,t,l,r,at,al,ar)</span><br><span class="line">    c:总次数</span><br><span class="line">    t:总时间</span><br><span class="line">    l:锁的时间</span><br><span class="line">    r:获得的结果行数</span><br><span class="line">    at,al,ar :指 t,l,r 平均数【例如：at = 总时间/总次数】</span><br><span class="line">-s 对结果进行排序，怎么排，根据后面所带的 (c,t,l,r,at,al,ar)，缺省为 at</span><br><span class="line">-t NUM just show the top n queries：仅显示前 n 条查询</span><br><span class="line">-g PATTERN grep: only consider stmts that include this string：通过 grep 来筛选语句。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqldumpslow -s t -t 10 /home/mysql/mysql57/data/iZwz9j203ithc4gu1uvb2wZ-slow.log</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028468.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysqldumpslow -s t -t 10 /home/mysql/mysql57/data/iZwz9j203ithc4gu1uvb2wZ-slow.log -g <span class="keyword">select</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028469.png" alt=""></p>
<blockquote>
<p>Windows 下需要下载安装 perl 编译器，下载地址：<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1i3GLKAp">http://pan.baidu.com/s/1i3GLKAp</a></p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/moss_tan_jun/p/8025504.html">https://www.cnblogs.com/moss_tan_jun/p/8025504.html</a></p>
</blockquote>
<h5 id="3-2-2-2-Mysqlsla"><a href="#3-2-2-2-Mysqlsla" class="headerlink" title="3.2.2.2. Mysqlsla"></a>3.2.2.2. Mysqlsla</h5><p>Mysqlsla 是 daniel-nichter 用 perl 写的一个脚本，专门用于处理分析 Mysql 的日志而存在。通过 Mysql 的日志主要分为：General log，slow log，binary log 三种。通过 query 日志，可以分析业务的逻辑，业务特点。通过 slow log，可以找到服务器的瓶颈。通过 binary log，可以恢复数据。Mysqlsla 可以处理其中的任意日志。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/59260">https://yq.aliyun.com/articles/59260</a></p>
<h5 id="3-2-2-3-pt-query-digest"><a href="#3-2-2-3-pt-query-digest" class="headerlink" title="3.2.2.3. pt-query-digest"></a>3.2.2.3. pt-query-digest</h5><p>pt-query-digest 是用于分析 mysql 慢查询的一个工具，它可以分析 binlog、General log、slowlog，也可以通过 SHOWPROCESSLIST 或者通过 tcpdump 抓取的 MySQL 协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/seteor/article/details/24017913">https://blog.csdn.net/seteor/article/details/24017913</a></p>
<h2 id="4-EXPLAIN-执行计划"><a href="#4-EXPLAIN-执行计划" class="headerlink" title="4. EXPLAIN 执行计划"></a>4. EXPLAIN 执行计划</h2><h3 id="4-1-explain-简介"><a href="#4-1-explain-简介" class="headerlink" title="4.1. explain 简介"></a>4.1. explain 简介</h3><p>一条查询语句在经过 MySQL 查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。</p>
<p>MySQL 数据库的 <code>explain</code> 关键字显示了 MySQL 如何使用索引来处理 select 语句以及连接表，<code>explain</code> 可以帮助分析 select 语句，知道查询效率低下的原因，从而改进查询语句，让查询优化器能够更好的工作。总体来说，通过 <code>EXPLAIN</code> 关键字可以了解以下信息：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<h3 id="4-2-执行计划的语法"><a href="#4-2-执行计划的语法" class="headerlink" title="4.2. 执行计划的语法"></a>4.2. 执行计划的语法</h3><p>在SQL查询语句前加上<code>EXPLAIN</code>关键字即可。 <strong><code>EXPLAIN</code>后面即是要分析的SQL语句</strong>。示例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>     <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> order_exp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10311</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了以 <code>SELECT</code> 开头的查询语句，其余的 <code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句前面都可以加上 <code>EXPLAIN</code>，用来查看这些语句的执行计划。</p>
</blockquote>
<h3 id="4-3-字段类型汇总表"><a href="#4-3-字段类型汇总表" class="headerlink" title="4.3. 字段类型汇总表"></a>4.3. 字段类型汇总表</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td>查询中执行 <code>select</code> 子句或操作表的顺序，每个<code>SELECT</code>关键字都对应一个唯一的id</td>
</tr>
<tr>
<td style="text-align:center">select_type</td>
<td>所使用的SELECT查询类型，<em>常见类型详见各列说明章节</em></td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td>所使用的的数据表的名字</td>
</tr>
<tr>
<td style="text-align:center">partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td>表示 MySQL 在表中找到所需行的方式，又称“访问类型”。<em>取值与优劣排序详见各列说明章节</em></td>
</tr>
<tr>
<td style="text-align:center">possible_keys</td>
<td>可能使用哪个索引在表中找到记录</td>
</tr>
<tr>
<td style="text-align:center">key</td>
<td>实际使用的索引</td>
</tr>
<tr>
<td style="text-align:center">key_len</td>
<td>索引中使用的字节数长度</td>
</tr>
<tr>
<td style="text-align:center">ref</td>
<td>当使用索引列等值查询时，显示哪个与索引列进行等值匹配的对象信息被使用了</td>
</tr>
<tr>
<td style="text-align:center">rows</td>
<td>估算的找到所需的记录所需要读取的行数</td>
</tr>
<tr>
<td style="text-align:center">filtered</td>
<td>通过条件过滤出后剩余行数的百分比估计值</td>
</tr>
<tr>
<td style="text-align:center">extra</td>
<td>包含不适合在其他列中显示但十分重要的额外信息</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-4-id-列"><a href="#4-4-id-列" class="headerlink" title="4.4. id 列"></a>4.4. id 列</h3><p>选定的执行计划中查询的序列号。<strong>表示查询中执行 select 子句或操作表的顺序，<font color=red>id 值越大优先级越高</font>，越先被执行。id 相同，执行顺序由上至下</strong>。</p>
<h4 id="4-4-1-单-SELECT-关键字"><a href="#4-4-1-单-SELECT-关键字" class="headerlink" title="4.4.1. 单 SELECT 关键字"></a>4.4.1. 单 SELECT 关键字</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-连接查询"><a href="#4-4-2-连接查询" class="headerlink" title="4.4.2. 连接查询"></a>4.4.2. 连接查询</h4><p>对于连接查询来说，一个<code>SELECT</code>关键字后边的<code>FROM</code>子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的 id 值都是相同的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (Block Nested Loop) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-3-包含子查询"><a href="#4-4-3-包含子查询" class="headerlink" title="4.4.3. 包含子查询"></a>4.4.3. 包含子查询</h4><p>对于包含子查的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的 id 值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type            <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>             <span class="operator">|</span> idx_order_no  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> unique_subquery <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> func <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>需要特别注意，查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。所以如果想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划即可</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+----------------------+---------+---------+--------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys        <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>          <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+----------------------+---------+---------+--------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>              <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>,idx_order_no <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> tempdb.s1.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+----------------------+---------+---------+--------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然示例的查询语句是一个子查询，但是执行计划中 s1 和 s2 表对应的记录的 id 值全部是 1，这就表明了查询优化器将子查询转换为了连接查询</p>
</blockquote>
<h4 id="4-4-4-包含-UNION-子句"><a href="#4-4-4-包含-UNION-子句" class="headerlink" title="4.4.4. 包含 UNION 子句"></a>4.4.4. 包含 UNION 子句</h4><p>包含 <code>UNION</code> 子句的查询语句，<code>UNION</code> 子句会把多个查询的结果集合并起来并对结果集中的记录进行去重。MySQL 使用的是内部的临时表来实现去重。在查询计划中，在内部创建了一个名为 <code>&lt;union1,2&gt;</code> 的临时表（就是执行计划第三条记录的 table 列的名称)，id 为 NULL 表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>
<p>跟 <code>UNION</code> 对比起来，<code>UNION ALL</code> 不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含 <code>UNION ALL</code> 子句的查询的执行计划中，就没有那个 id 为 NULL 的记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>       <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-select-type-列"><a href="#4-5-select-type-列" class="headerlink" title="4.5. select_type 列"></a>4.5. select_type 列</h3><p>表示所使用 select 查询类型，MySQL 为每一个 <code>SELECT</code> 关键字代表的小查询都定义了一个称之为 <code>select_type</code> 的属性。通过某个小查询的 <code>select_type</code> 属性值，即可知道该小查询在整个大查询中扮演了一个什么角色。常见类型汇总如下：</p>
<ul>
<li><code>SIMPLE</code>：简单的 select 查询，SQL 中不包含子查询或者 UNION。</li>
<li><code>PRIMARY</code>：最外层的 select 查询，查询中包含复杂的子查询部分，最外层查询被标记为 PRIMARY。</li>
<li><code>UNION</code>：UNION 中的第二个或随后的 select 查询，不依赖于外部查询的结果集。</li>
<li><code>UNION RESULT</code>：从 UNION 表获取结果集的 SELECT 查询被标记为 UNION RESULT。</li>
<li><code>SUBQUERY</code>：子查询中的第一个 select 查询，不依赖于外部查询的结果集。</li>
<li><code>DEPENDENT UNION</code>：UNION 中的第二个或随后的 select 查询，依赖于外部查询的结果集。</li>
<li><code>DEPENDENT SUBQUERY</code>：子查询中的第一个 select 查询，依赖于外部查询的结果集。</li>
<li><code>DERIVED</code>（衍生）：用来表示包含在 from 子句中的子查询的 select 语句。若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为 DERIVED。mysql 会递归执行并将结果放到一个临时表中。服务器内部称为”派生表”，因为该临时表是从子查询中派生出来。</li>
<li><code>MATERIALIZED</code>：物化子查询。</li>
<li><code>UNCACHEABLE SUBQUERY</code>：结果集不能被缓存的子查询，必须重新为外层查询的每一行进行评估，极少出现。</li>
<li><code>UNCACHEABLE UNION</code>：UNION 中的第二个或随后的select查询，属于不可缓存的子查询，极少出现。</li>
<li><code>DEPENDENT</code>：意味着 select 依赖于外层查询中发现的数据。</li>
<li><code>UNCACHEABLE</code>：意味着 select 中的某些特性阻止结果被缓存于一个 item_cache 中。</li>
</ul>
<h4 id="4-5-1-SIMPLE-类型"><a href="#4-5-1-SIMPLE-类型" class="headerlink" title="4.5.1. SIMPLE 类型"></a>4.5.1. SIMPLE 类型</h4><p>简单的 select 查询，查询中不包含子查询或者 UNION</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<p>连接查询也算是 SIMPLE 类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (Block Nested Loop) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="4-5-2-PRIMARY-类型"><a href="#4-5-2-PRIMARY-类型" class="headerlink" title="4.5.2. PRIMARY 类型"></a>4.5.2. PRIMARY 类型</h4><p>对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> <span class="keyword">UNION</span>        <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span> <span class="operator">|</span> <span class="operator">&lt;</span>union1,<span class="number">2</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="4-5-3-UNION-类型"><a href="#4-5-3-UNION-类型" class="headerlink" title="4.5.3. UNION 类型"></a>4.5.3. UNION 类型</h4><p>对于包含 <code>UNION</code> 或者 <code>UNION ALL</code> 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的查询的 <code>select_type</code> 值就是 <code>UNION</code>。（<em>参考上面<code>PRIMARY</code>的示例</em>）</p>
<h4 id="4-5-4-UNION-RESULT-类型"><a href="#4-5-4-UNION-RESULT-类型" class="headerlink" title="4.5.4. UNION RESULT 类型"></a>4.5.4. UNION RESULT 类型</h4><p>MySQL 选择使用临时表来完成 <code>UNION</code> 查询的去重工作，针对该临时表的查询的 <code>select_type</code> 就是 <code>UNION RESULT</code>。（<em>参考上面<code>PRIMARY</code>的示例</em>）</p>
<h4 id="4-5-5-SUBQUERY-类型"><a href="#4-5-5-SUBQUERY-类型" class="headerlink" title="4.5.5. SUBQUERY 类型"></a>4.5.5. SUBQUERY 类型</h4><p>如果包含子查询的查询语句不能够转为对应的 <code>semi-join</code> 的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个 <code>SELECT</code> 关键字代表的那个查询的 <code>select_type</code> 就是 <code>SUBQUERY</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2) <span class="keyword">OR</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type            <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>             <span class="operator">|</span> idx_order_no  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> unique_subquery <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> func <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，由于 <code>select_type</code> 为 <code>SUBQUERY</code> 的子查询由于会被物化，所以只需要执行一遍。</p>
<blockquote>
<p>涉及相关名词解释：</p>
<ul>
<li><strong>semi-join</strong>：半连接优化技术，本质上是把子查询上拉到父查询中，与父查询的表做 join 操作。关键词是“上拉”。对于子查询，其子查询部分相对于父表的每个符合条件的元组，都要把子查询执行一轮。效率低下。用半连接操作优化子查询，是把子查询上拉到父查询中，这样子查询的表和父查询中的表是并列关系，父表的每个符合条件的元组，只需要在子表中找符合条件的元组即可。简单来说，就是通过将子查询上拉对父查询中的数据进行筛选，以使获取到最少量的足以对父查询记录进行筛选的信息就足够了。</li>
<li><strong>子查询物化</strong>：子查询的结果通常缓存在内存或临时表中。</li>
<li><strong>关联/相关子查询</strong>：子查询的执行依赖于外部查询。多数情况下是子查询的<code>WHERE</code>子句中引用了外部查询的表。自然“非关联/相关子查询”的执行则不依赖与外部的查询。</li>
</ul>
</blockquote>
<h4 id="4-5-6-DEPENDENT-UNION、DEPENDENT-SUBQUERY-类型"><a href="#4-5-6-DEPENDENT-UNION、DEPENDENT-SUBQUERY-类型" class="headerlink" title="4.5.6. DEPENDENT UNION、DEPENDENT SUBQUERY 类型"></a>4.5.6. DEPENDENT UNION、DEPENDENT SUBQUERY 类型</h4><p>在包含 <code>UNION</code> 或者 <code>UNION ALL</code> 的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的 <code>select_type</code> 的值就是 <code>DEPENDENT UNION</code>。例如以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> DEPENDENT <span class="keyword">UNION</span>    <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span>       <span class="operator">|</span> <span class="operator">&lt;</span>union2,<span class="number">3</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+------------+------------+-------+---------------+---------+---------+-------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例查询比较复杂，大查询里包含了一个子查询，子查询里又是由<code>UNION</code>连起来的两个小查询。从执行计划中可以看出来，<code>SELECT id FROM s2 WHERE id = 3</code>这个小查询由于是子查询中第一个查询，所以它的<code>select_type</code>是<code>OEPENDENTSUBOUERY</code>，而<code>SELECT id FROM s1 WHERE id = 1</code>这个查询的<code>select_type</code>就是<code>DEPENDENT UNION</code>。</p>
</blockquote>
<p>MySQL 优化器对<code>IN</code>操作符的优化会将<code>IN</code>中的非关联子查询优化成一个关联子查询。我们可以在执行上面那个执行计划后，马上执行<code>show warnings\G</code>，可以看到MySQL对SQL语句的大致改写情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">716</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">718</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+------------+------------+-------+---------------+---------+---------+-------+-------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+------------+------------+-------+---------------+---------+---------+-------+-------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> const <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> DEPENDENT <span class="keyword">UNION</span>    <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> const <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">UNION</span> <span class="keyword">RESULT</span>       <span class="operator">|</span> <span class="operator">&lt;</span>union2,<span class="number">3</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------------------+------------+------------+-------+---------------+---------+---------+-------+-------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028470.png" alt=""></p>
<h4 id="4-5-7-DERIVED-类型"><a href="#4-5-7-DERIVED-类型" class="headerlink" title="4.5.7. DERIVED 类型"></a>4.5.7. DERIVED 类型</h4><p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> c <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> id) <span class="keyword">AS</span> derived_s1 <span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+-------------------------------------------------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys                                         <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+-------------------------------------------------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>                                                  <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">50.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">PRIMARY</span>,u_idx_day_status,idx_order_no,idx_insert_time <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+-------+-------------------------------------------------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>上面示例id为2的记录就代表子查询的执行方式，该子查询是以物化的方式执行的。id 为 1 的记录代表外层查询，注意到它的 table 列显示的是<code>&lt;derived2&gt;</code>，表示该查询是针对将派生表物化之后的表进行查询的。</p>
<h4 id="4-5-8-MATERIALIZED-类型"><a href="#4-5-8-MATERIALIZED-类型" class="headerlink" title="4.5.8. MATERIALIZED 类型"></a>4.5.8. MATERIALIZED 类型</h4><p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的 <code>select_type</code> 属性就是 <code>MATERIALIZED</code>，例如以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_no <span class="keyword">FROM</span> s2);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type  <span class="operator">|</span> <span class="keyword">table</span>       <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys       <span class="operator">|</span> key                 <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> s1          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> idx_order_no        <span class="operator">|</span> <span class="keyword">NULL</span>                <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE       <span class="operator">|</span> <span class="operator">&lt;</span>subquery2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>auto_distinct_key<span class="operator">&gt;</span> <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> tempdb.s1.order_no <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> MATERIALIZED <span class="operator">|</span> s2          <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> idx_order_no        <span class="operator">|</span> idx_order_no        <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">10621</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+-------------+------------+--------+---------------------+---------------------+---------+--------------------+-------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>执行计划的id值为2的第三条记录，说明查询优化器是要把子查询先转换成物化表。</p>
<p>执行计划的前两条记录的id值都为1，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的<code>table</code>列的值是<code>&lt;subquery2&gt;</code>，说明该表其实就是id为2对应的子查询执行之后产生的物化表，然后将 s1和该物化表进行连接查询</p>
<h4 id="4-5-9-UNCACHEABLE-SUBQUERY、UNCACHEABLE-UNION-类型"><a href="#4-5-9-UNCACHEABLE-SUBQUERY、UNCACHEABLE-UNION-类型" class="headerlink" title="4.5.9. UNCACHEABLE SUBQUERY、UNCACHEABLE UNION 类型"></a>4.5.9. UNCACHEABLE SUBQUERY、UNCACHEABLE UNION 类型</h4><p>极少出现，示例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> id <span class="operator">=</span> ( <span class="keyword">select</span> id <span class="keyword">from</span> s2 <span class="keyword">where</span> order_no<span class="operator">=</span>@<span class="variable">@sql_log_bin</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type          <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>              <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">no</span> matching <span class="type">row</span> <span class="keyword">in</span> const <span class="keyword">table</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> UNCACHEABLE SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>    <span class="number">50.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------------+</span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-table-列"><a href="#4-6-table-列" class="headerlink" title="4.6. table 列"></a>4.6. table 列</h3><p>不论查询语句有多复杂，里边包含了多少个表，到最后也是需要对每个表进行单表访问。MySQL 规定 EXPLAIN 语句输出的每条记录都对应着某个单表的访问方式，该条记录的 table 列代表着该表的表名，是显示这一行的数据所使用的数据表的名字，是按被读取的先后顺序排列。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                          <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10621</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由示例可以看出：只涉及对 s1 表的单表查询，所以 EXPLAIN 输出中只有一条记录，其中的 table 列的值是 s1，而连接查询的执行计划中有两条记录，这两条记录的 table 列分别是 s1 和 s2。</p>
</blockquote>
<h3 id="4-7-partitions-列"><a href="#4-7-partitions-列" class="headerlink" title="4.7. partitions 列"></a>4.7. partitions 列</h3><p>和分区表有关，一般情况下查询语句的执行计划的 <code>partitions</code> 列的值都是 <code>NULL</code>。</p>
<h3 id="4-8-type-列"><a href="#4-8-type-列" class="headerlink" title="4.8. type 列"></a>4.8. type 列</h3><p>type 列用于显示连接使用了何种类型，<font color=red><strong>此列是分析执行计划重要的指标</strong></font>。连接类型结果值从最好到最差的排序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure>
<p>实际开发中出现比较多的是 <code>system | const | eq_ref | ref | range | index | ALL</code>。<font color=red><strong>一般来说，保证查询至少达到 range 级别，最好能达到 ref 级别</strong></font>。</p>
<h4 id="4-8-1-type-列常见的类型汇总"><a href="#4-8-1-type-列常见的类型汇总" class="headerlink" title="4.8.1. type 列常见的类型汇总"></a>4.8.1. type 列常见的类型汇总</h4><ul>
<li><code>all</code>：full table scan，MySQL 将遍历全表以找到匹配的行；全表扫描从磁盘中获取数据百万级别的数据 ALL 类型的数据尽量优化。</li>
<li><code>index</code>：Full index scan，扫描遍历索引树(扫描全表的索引，从索引中获取数据)。index 和 all 的区别在于 index 类型只遍历索引。</li>
<li><code>range</code>：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，只检索给定范围的行，使用一个索引来选择行。此时对应 key 列显示使用了哪个索引。<blockquote>
<p>一般在 WHERE 语句中出现<code>between</code>、<code>&lt;</code>、<code>&gt;</code>、<code>in</code>等查询，这种给定范围扫描比全表扫描要好。因为它只需要开始于索引的某一点，结束于另一点，不用扫描全部索引。</p>
</blockquote>
</li>
<li><code>index_subquery</code>：该联接类型类似于 unique_subquery。可以替换 IN 子查询，但只适合下列形式的子查询中的非唯一索引：<code>value IN (SELECT key_column FROM single_table WHERE some_expr)</code>。</li>
<li><code>unique_subquery</code>：此类型是一个索引查找函数，可以完全替换子查询，效率更高。该类型替换了下面形式的 <code>IN</code> 子查询的 ref：<code>value IN (SELECT primary_key FROM single_table WHERE some_expr)</code>。</li>
<li><code>index_merge</code>：该联接类型表示使用了索引合并优化方法。</li>
<li><code>ref_or_null</code>：该联接类型如同 ref，但是添加了 MySQL 可以专门搜索包含 NULL 值的行。</li>
<li><code>fulltext</code>：全文索引。</li>
<li><code>ref</code>：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；本质上是一种索引访问，它返回所有匹配某个单独值的行，就是说它可能会找到多条符合条件的数据，所以它是查找与扫描的混合体。</li>
<li><code>eq_ref</code>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描。</li>
<li><code>const</code>：当 MySQL 对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。通过索引一次查到数据，该类型主要用于比较 primary key 或者 unique 索引，因为只匹配一行数据，所以很快；如果将主键置于 WHERE 语句后面，MySQL 就能将该查询转换为一个常量。</li>
<li><code>system</code>：表只有一条记录(等于系统表)，这是 const 类型的特例，平时业务中不会出现。</li>
<li><code>NULL</code>：MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</li>
</ul>
<h4 id="4-8-2-system-类型"><a href="#4-8-2-system-类型" class="headerlink" title="4.8.2. system 类型"></a>4.8.2. system 类型</h4><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，那么对该表的访问方式就是 <code>system</code> 级别。比如 MyISAM、Memory 之类：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028471.png" alt=""></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> test_myisam;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_myisam;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------------+------------+--------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>       <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------------+------------+--------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> test_myisam <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">system</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">100.00</span>   <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------------+------------+--------+---------------+------+---------+------+-------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<font color=red>**注意：只有在 MyISAM 这种存储引擎中，才会精确统计数据，如果改成使用 InnoDB 存储引擎，因为该引擎的统计非精确的，所以使用 `select * from table` 的话，会进行全表扫描（即 `all` 类型）**</font>

</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> city;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> city  <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">4035</span> <span class="operator">|</span> <span class="number">100.00</span>   <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<h4 id="4-8-3-const-类型"><a href="#4-8-3-const-类型" class="headerlink" title="4.8.3. const 类型"></a>4.8.3. const 类型</h4><p>当根据主键或者唯一的二级索引列与常数进行等值匹配，来定位一条记录，对单表的访问的类型被 MySQL 定义为<code>const</code>（<em>意思是常数级别的，代价是可以忽略不计的</em>）。如果主键或者唯一的二级索引是<u><strong>由多个列</strong></u>构成的话，<u><strong>组成索引的每一个列都是与常数进行等值比较</strong></u>时，此时访问方式才是 <code>const</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<p>B+树叶子节点中的记录是按照索引列排序的，对于的聚簇索引来说，它对应的 B+树叶子节点中的记录就是按照 id 列排序的。B+树矮胖，所以这样根据主键值定位一条记录的速度很快。同样，根据唯一联合索引列来定位一条记录的速度也很快，MySQL 会分两步执行，首先在唯一联合索引对应的 B+树中，根据索引列与常数的等值比较条件定位到一条联合索引记录，然后再根据该记录的 id 值到聚簇索引中获取到完整的行记录。</p>
<p><u>值得注意的是：对于唯一的二级索引来说，<font color=red><strong>查询该列包含为 NULL 值的情况比较特殊，在 MySQL 中认为每一个 null 都是独一无二的，并且会将所有为 null 值的行数据索引的叶子结点的最前面</strong></font>。而唯一的二级索引列并不限制 NULL 值的数量，所以可能会访问到多条记录，也就是说 <code>is null</code> 不可以使用 <code>const</code> 类型访问方法来执行。</u></p>
<h4 id="4-8-4-eq-ref-类型"><a href="#4-8-4-eq-ref-类型" class="headerlink" title="4.8.4. eq_ref 类型"></a>4.8.4. eq_ref 类型</h4><p>在连接查询时，如果被驱动表是通过主键或者唯一的二级索引列等值匹配的方式进行访问的（如果该主键或者唯一的二级索引是联合索引的话，需要所有的索引列都必须进行等值比较），则对该被驱动表的访问类型就是 <code>eq_ref</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">on</span> s1.id <span class="operator">=</span> s2.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+--------------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>          <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+--------------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> tempdb.s1.id <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+--------------+-------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>涉及相关名词解释，<strong>驱动表与被驱动表</strong>：A表和B表<code>join</code>连接查询，如果通过A表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到B表中查询数据，然后合并结果。那么称A表为驱动表，B表为被驱动表。</p>
<p>以上示例，MySQL 打算将 s2 作为驱动表，s1 作为被驱动表，重点关注 s1 的访问方法是<code>eq_ref</code>，表明在访问 s1 表的时候可以通过主键的等值匹配来进行访问。</p>
</blockquote>
<h4 id="4-8-5-ref-类型"><a href="#4-8-5-ref-类型" class="headerlink" title="4.8.5. ref 类型"></a>4.8.5. ref 类型</h4><p>当通过普通的二级索引列与常量进行等值匹配来查询某个表，那么这种采用二级索引来执行查询该表的访问类型就可能是 <code>ref</code>。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行，所以它属于查找和扫描的混合体。</p>
<p>由于普通二级索引并不限制索引列值的唯一性，所以通过普通的二级索引进行等值比较后，可能匹配到对应多条连续的记录，也就是说使用普通二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。因为普通二级索引不是像主键或者唯一二级索引那样最多只能匹配 1 条记录，所以这种 <code>ref</code> 访问类型比 <code>const</code> 要差些。</p>
<p>普通二级索引等值匹配时，如果匹配的记录较少，则回表的代价还是比较低的，效率还行，所以 MySQL 可能选择使用索引而不是全表扫描的方式来执行查询；但如果记录太多那么回表的成本就变得很大，此时 MySQL 可能会直接选择全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上示例的查询，可以选择全表扫描来逐一对比搜索条件是否满足要求，也可以先使用二级索引找到对应记录的 id 值，然后再回表到聚簇索引中查找完整的行记录。</p>
</blockquote>
<p>需要注意以下两种情况：</p>
<ol>
<li>二级索引列值为 <code>NULL</code> 的情况。不论是普通的二级索引，还是唯一的二级索引，它们的索引列对包含 <code>NULL</code> 值的数量并不限制，所以采用 <code>列名 IS NULL</code> 这种形式的搜索条件最多只能使用 <code>ref</code> 的访问类型，而不是 <code>const</code> 的类型。</li>
<li>对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用 <code>ref</code> 的访问类型；如果最左边的连续索引列并不全部是等值比较的话，它的访问类型就不能称为 <code>ref</code>。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 是 ref 类型</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:28:23&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:28:23&#x27;</span> <span class="keyword">AND</span> order_status <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 非 ref 类型</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:28:23&#x27;</span> <span class="keyword">AND</span> order_status <span class="operator">&gt;</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-6-fulltext-类型"><a href="#4-8-6-fulltext-类型" class="headerlink" title="4.8.6. fulltext 类型"></a>4.8.6. fulltext 类型</h4><p>全文索引，极少使用。暂不研究</p>
<h4 id="4-8-7-ref-or-null-类型"><a href="#4-8-7-ref-or-null-类型" class="headerlink" title="4.8.7. ref_or_null 类型"></a>4.8.7. ref_or_null 类型</h4><p>查询某个二级索引列的值等于某个常数的记录，和该列的值为 NULL 的记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp_cut <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">or</span> order_no <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------------+---------------+--------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>         <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------------+---------------+--------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> order_exp_cut <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> ref_or_null <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">153</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------------+---------------+--------------+---------+-------+------+----------+-----------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.08</span> sec)</span><br></pre></td></tr></table></figure>
<p>其中 <code>order_no</code> 列是允许为空。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028472.png" alt=""></p>
<p>上面的查询相当于先分别从 order_exp_cut 表的 idx_order_no 索引对应的 B+树中找出 <code>order_no IS NULL</code> 和 <code>order_no= &#39;abc&#39;</code>的两个连续的记录范围，然后根据这些二级索引记录中的 id 值再回表查找完整的用户记录。</p>
<h4 id="4-8-8-index-merge-类型"><a href="#4-8-8-index-merge-类型" class="headerlink" title="4.8.8. index_merge 类型"></a>4.8.8. index_merge 类型</h4><p>一般情况下对于某个表的查询只能使用到一个索引，在某些场景下可以使用<strong>索引合并</strong>的方式来执行查询。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:23:42&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-----------------------------------------------+------------------------------+---------+------+------+----------+--------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type        <span class="operator">|</span> possible_keys                                 <span class="operator">|</span> key                          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-----------------------------------------------+------------------------------+---------+------+------+----------+--------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index_merge <span class="operator">|</span> u_idx_day_status,idx_order_no,idx_insert_time <span class="operator">|</span> idx_order_no,idx_insert_time <span class="operator">|</span> <span class="number">152</span>,<span class="number">5</span>   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">union</span>(idx_order_no,idx_insert_time); <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------------+-----------------------------------------------+------------------------------+---------+------+------+----------+--------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="4-8-9-unique-subquery-类型"><a href="#4-8-9-unique-subquery-类型" class="headerlink" title="4.8.9. unique_subquery 类型"></a>4.8.9. unique_subquery 类型</h4><p>类似于两表连接中被驱动表的 <code>eq_ref</code> 访问类型，<code>unique_subquery</code> 是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 <code>unique_subquery</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> s1.insert_time <span class="operator">=</span> s2.insert_time) <span class="keyword">OR</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------------------------------+---------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type        <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type            <span class="operator">|</span> possible_keys                            <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------------------------------+---------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>            <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>             <span class="operator">|</span> idx_order_no                             <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DEPENDENT SUBQUERY <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> unique_subquery <span class="operator">|</span> <span class="keyword">PRIMARY</span>,u_idx_day_status,idx_insert_time <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> func <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------------+-------+------------+-----------------+------------------------------------------+---------+---------+------+-------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行计划的第二条记录的 type 值就是 <code>unique_subquery</code>，说明在执行子查询时会使用到 id 列的索引。</p>
</blockquote>
<h4 id="4-8-10-index-subquery-类型"><a href="#4-8-10-index-subquery-类型" class="headerlink" title="4.8.10. index_subquery 类型"></a>4.8.10. index_subquery 类型</h4><p>index_subquery 与 unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_no <span class="keyword">FROM</span> s2 <span class="keyword">where</span> s1.insert_time <span class="operator">=</span> s2.insert_time) <span class="keyword">OR</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028473.png" alt=""></p>
<blockquote>
<p>这个语句和 unique_subquery 章节中的唯一不同是 in 子句的字段由 id 变成了 order_no。</p>
</blockquote>
<h4 id="4-8-11-range-类型"><a href="#4-8-11-range-类型" class="headerlink" title="4.8.11. range 类型"></a>4.8.11. range 类型</h4><p>利用索引进行范围匹配获取某些范围区间的记录，这种访问方式就可能使用到 <code>range</code> 访问类型。一般在 <code>where</code> 语句中出现了<code>between</code>、<code>&lt;</code>、<code>&gt;</code>、<code>in</code>等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，结束于另一点，不用扫描全部索引。</p>
<blockquote>
<p>值得注意的是：使用索引进行范围匹配中的“索引”可以是聚簇索引，也可以是二级索引。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> order_no <span class="operator">&lt;</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="4-8-12-index-类型"><a href="#4-8-12-index-类型" class="headerlink" title="4.8.12. index 类型"></a>4.8.12. index 类型</h4><p>当可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问类型就是 index。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> insert_time <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> expire_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:28:28&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+------------------+------------------+---------+------+-------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys    <span class="operator">|</span> key              <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+------------------+------------------+---------+------+-------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> <span class="number">12</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+------------------+------------------+---------+------+-------+----------+--------------------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="4-8-13-all-类型"><a href="#4-8-13-all-类型" class="headerlink" title="4.8.13. all 类型"></a>4.8.13. all 类型</h4><p>全表扫描，将遍历全表以找到匹配的行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<h3 id="4-9-possible-keys-列"><a href="#4-9-possible-keys-列" class="headerlink" title="4.9. possible_keys 列"></a>4.9. possible_keys 列</h3><p>possible_keys 列，用于显示可能应用在这张表中的索引。如果为空，则没有可能的索引。可以为相关的域从 WHERE 语句中选择一个合适的语句。</p>
<p>另外需要注意的一点是，<font color=red><strong>possible keys 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间</strong></font>，所以如果可以的话，尽量删除那些用不到的索引。</p>
<h3 id="4-10-key-列"><a href="#4-10-key-列" class="headerlink" title="4.10. key 列"></a>4.10. key 列</h3><p>key 列是指实际使用的索引。如果为 NULL，则没有使用索引。很少的情况下，MySQL 会选择优化不足的索引。这种情况下，可以在 SELECT 语句中使用 <code>FORCE INDEX(indexname)</code> 来强制使用一个索引或者用 <code>IGNORE INDEX(indexname)</code> 来强制忽略索引。</p>
<h3 id="4-11-key-len-列"><a href="#4-11-key-len-列" class="headerlink" title="4.11. key_len 列"></a>4.11. key_len 列</h3><p>key_len 列表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好。</p>
<p>索引最大长度是 768 字节，当字符串过长时，mysql 会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<h4 id="4-11-1-key-len-计算规则"><a href="#4-11-1-key-len-计算规则" class="headerlink" title="4.11.1. key_len 计算规则"></a>4.11.1. key_len 计算规则</h4><p>key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出来的。计算方式是如下：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是 <code>VARCHAR(100)</code>，使用的字符集是 utf8，那么该列实际占用的最大存储空间就是 <code>100 x 3 = 300</code> 个字节。</li>
<li>如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值时多 1 个字节；对于变长字段来说，都会有 2 个字节的空间来存储该变长列的实际长度。</li>
</ul>
<h4 id="4-11-2-不同类型占用的字节数"><a href="#4-11-2-不同类型占用的字节数" class="headerlink" title="4.11.2. 不同类型占用的字节数"></a>4.11.2. 不同类型占用的字节数</h4><p><strong>字符串类型</strong>：5.0.3 以后版本中，定义时的 n 均代表字符数，而不是字节数。以下以 UTF-8 字符编码为例：</p>
<ul>
<li><code>char(n)</code>：如果存汉字长度就是 3n 字节</li>
<li><code>varchar(n)</code>：如果存汉字则长度是 3n + 2 字节，加的 2 字节用来存储字符串长度，因为 varchar 是变长字符串</li>
</ul>
<blockquote>
<p>Notes: <code>char</code>和<code>varchar</code> 跟字符编码也有密切的联系，比如 latin1 占用 1 个字节，gbk 占用 2 个字节，utf8 占用 3 个字节。如果是 utf-8，一个数字或字母占 1 个字节，一个汉字占 3 个字节。</p>
</blockquote>
<p><strong>数值类型</strong>：</p>
<ul>
<li>tinyint：1 字节</li>
<li>smallint：2 字节</li>
<li>int：4 字节</li>
<li>bigint：8字节</li>
</ul>
<p><strong>时间类型</strong>：</p>
<ul>
<li>date：3 字节</li>
<li>timestamp：4 字节</li>
<li>datetime：8 字节</li>
</ul>
<p><strong>如果字段允许为 NULL，需要 1 字节记录是否为 NULL</strong>。</p>
<h4 id="4-11-3-示例"><a href="#4-11-3-示例" class="headerlink" title="4.11.3. 示例"></a>4.11.3. 示例</h4><p>由于 id 列的类型是 bigint，并且不可以存储 NULL 值，所以在使用该列的索引时 key_len 大小就是 8。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<p>由于 order_no 列的类型是<code>VARCHAR(50)</code>，所以该列实际最多占用的存储空间就是 <code>50 x 3</code> 个字节，又因为该列是可变长度列，所以 key_len 需要加 2，所以最后 ken_len 的值就是 152。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<h3 id="4-12-ref-列"><a href="#4-12-ref-列" class="headerlink" title="4.12. ref 列"></a>4.12. ref 列</h3><p>ref 列表示哪些字段或常量值被用于查找索引列。可能的值为：<code>库.表.字段</code>、<code>const</code>(常量)、null、<code>func</code></p>
<p>与索引作等值匹配的对象是一个常数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<p>聚簇索引与一个列进行等值匹配的条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.id <span class="operator">=</span> s2.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+--------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>          <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+--------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> tempdb.s2.id <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+--------+---------------+---------+---------+--------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<p>与索引列进行等值匹配的对象是一个函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s2.order_no <span class="operator">=</span> <span class="built_in">UPPER</span>(s1.order_no);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> func <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
<h3 id="4-13-rows-列"><a href="#4-13-rows-列" class="headerlink" title="4.13. rows 列"></a>4.13. rows 列</h3><p>MySQL 认为必须检查的用来返回请求数据的行数。根据表统计信息及索引选用的情况，大致估算找到所需记录需要读取的行数。</p>
<p>查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的 rows 列就代表预计需要扫描的行数；如果使用索引来执行查询时，执行计划的 rows 列就代表预计扫描的索引记录行数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>    <span class="number">50.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<h3 id="4-14-filtered-列"><a href="#4-14-filtered-列" class="headerlink" title="4.14. filtered 列"></a>4.14. filtered 列</h3><p>filtered 列显示了通过条件过滤出的行数的百分比估计值。查询优化器预测有多少条记录满足其余的搜索条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">AND</span> order_no <span class="operator">=</span> <span class="string">&#x27;DD00_9S&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> const <span class="operator">|</span>   <span class="number">17</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<p>从执行计划的 key 列中可以看出来，该查询使用 PRIMARY 索引来执行查询，从 rows 列可以看出满足 <code>id &gt; 5890</code> 的记录有 5286 条。执行计划的 filtered 列就代表查询优化器预测在这 5286 条记录中，有多少条记录满足其余的搜索条件，也就是 <code>order_note = &#39;a&#39;</code> 这个条件的百分比。此处 filtered 列的值是 10.0，说明查询优化器预测在 5286 条记录中有 10.00% 的记录满足 <code>order_note = &#39;a&#39;</code>这个条件。</p>
<p>对于单表查询来说，这个 filtered 列的值没什么意义，一般更关注在连接查询中驱动表对应的执行计划记录的 filtered 值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.order_no <span class="operator">=</span> s2.order_no <span class="keyword">WHERE</span> s1.order_note <span class="operator">&gt;</span> <span class="string">&#x27;你好&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+--------------------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+--------------------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>    <span class="number">33.33</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> tempdb.s1.order_no <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+--------------------+-------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>从执行计划中可以看出来，查询优化器打算把 s1 当作驱动表，s2 当作被驱动表。其中驱动表 s1 表的执行计划的 rows 列为 10573，filtered 列为 33.33，这意味着驱动表 s1 的扇出值就是 <code>10573 x 33.33 % = 3524.3</code>，这说明还要对被驱动表执行大约 3524 次查询。</p>
<h3 id="4-15-Extra-列"><a href="#4-15-Extra-列" class="headerlink" title="4.15. Extra 列"></a>4.15. Extra 列</h3><p>Extra 列用于记录关于 MySQL 如何解析查询的额外信息，包含不适合在其他列中显示但十分重要的额外信息。通过这些额外信息来更准确的理解 MySQL 到底将如何执行给定的查询语句。</p>
<p>例如可以看到 Using temporary 和 Using filesort 这些坏的例子，意思 MySQL 根本不能使用索引，结果是检索会很慢。</p>
<h4 id="4-15-1-No-tables-used"><a href="#4-15-1-No-tables-used" class="headerlink" title="4.15.1. No tables used"></a>4.15.1. No tables used</h4><p>当查询语句的没有 FROM 子句时将会提示该额外信息。</p>
<h4 id="4-15-2-impossible-where"><a href="#4-15-2-impossible-where" class="headerlink" title="4.15.2. impossible where"></a>4.15.2. impossible where</h4><p>查询语句的 WHERE 子句永远为 FALSE 时将会提示该额外信息。这个值强调了 where 语句会导致没有符合条件的行。</p>
<h4 id="4-15-3-No-matching-min-max-row"><a href="#4-15-3-No-matching-min-max-row" class="headerlink" title="4.15.3. No matching min/max row"></a>4.15.3. No matching min/max row</h4><p>当查询列表处有 MIN 或者 MAX 聚集函数，但是并没有符合 WHERE 子句中的搜索条件的记录时，将会提示该额外信息。</p>
<h4 id="4-15-4-Using-index"><a href="#4-15-4-Using-index" class="headerlink" title="4.15.4. Using index"></a>4.15.4. Using index</h4><p>当查询列表以及搜索条件中只包含属于某个索引的列。即 select 操作使用了索引覆盖，避免回表访问表的数据行，效率不错。同时还有以下两种情况：</p>
<ul>
<li>如果同时出现 Using where，表明索引被用来执行索引键值的查找。</li>
<li>如果没有同时出现 Using where 表明索引用来读取数据而非执行查找动作。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> order_number <span class="keyword">from</span> tb_order <span class="keyword">group</span> <span class="keyword">by</span> order_number;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+-------+--------------------+--------------------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> type  <span class="operator">|</span> possible_keys      <span class="operator">|</span> key                <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+-------+--------------------+--------------------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_order <span class="operator">|</span> index <span class="operator">|</span> index_order_number <span class="operator">|</span> index_order_number <span class="operator">|</span> <span class="number">99</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">1</span>   <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+-------+--------------------+--------------------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="4-15-5-Using-index-condition"><a href="#4-15-5-Using-index-condition" class="headerlink" title="4.15.5. Using index condition"></a>4.15.5. Using index condition</h4><p>搜索条件中虽然出现了索引列，但却不能使用到索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">AND</span> order_no <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>其中的<code>order_no &gt; &#39;z&#39;</code>可以使用到索引，但是<code>order_no LIKE &#39;%a&#39;</code>却无法使用到索引。这里出现了<font color=red><strong>“索引条件下推”</strong></font>的概念。</p>
<ol>
<li>先根据<code>order_no &gt; &#39;z&#39;</code>这个条件，定位到二级索引 idx_order_no 中对应的二级索引记录。</li>
<li>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足<code>order_no LIKE &#39;%a&#39;</code>这个条件，如果这个条件不满足，则该二级索引记录就没必要回表。</li>
<li>对于满足<code>order_no LIKE &#39;%a&#39;</code>这个条件的二级索引记录执行回表操作。</li>
</ol>
<p>回表操作其实是一个随机 IO，比较耗时，所以上述修改可以省去很多回表操作的成本。这个改进称之为索引条件下推（英文名：ICP ，Index Condition Pushdown）。如果在查询语句的执行过程中将要使用索引条件下推这个特性，在 Extra 列中将会显示 Using index condition</p>
<h4 id="4-15-6-Using-where"><a href="#4-15-6-Using-where" class="headerlink" title="4.15.6. Using where"></a>4.15.6. Using where</h4><p>表示 mysql 服务器将在存储引擎检索行后再进行过滤。许多 where 条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带 where 字句的查询都会显示”Using where”。有时”Using where”的出现就是一个暗示：查询可受益与不同的索引。</p>
<p>当使用索引访问来执行对某个表的查询，并且该语句的 WHERE 子句中有除了该索引包含的列之外的其他搜索条件时，在 Extra 列中也会提示上述信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> order_note <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p><strong>出现了 Using where，只是表示在 server 层根据 where 条件进行了过滤，和是否全表扫描或读取了索引文件没有关系</strong>，有认为把 Using where 和是否读取索引进行关联，也有认为把 Using where 和回表进行了关联，都是不正确。</p>
<blockquote>
<p>MySQL 官方的说明：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_extra">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_extra</a></p>
<p>Extra 列中出现了 Using where 代表 WHERE 子句用于限制要与下一个表匹配或发送给客户端的行。很明显，Using where 只是表示 MySQL 使用 where 子句中的条件对记录进行了过滤。</p>
</blockquote>
<h4 id="4-15-7-Using-join-buffer-Block-Nested-Loop"><a href="#4-15-7-Using-join-buffer-Block-Nested-Loop" class="headerlink" title="4.15.7. Using join buffer (Block Nested Loop)"></a>4.15.7. Using join buffer (Block Nested Loop)</h4><p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL 一般会为其分配一块名叫 join buffer 的内存块来加快查询速度。</p>
<p>该值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进性能。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.order_note <span class="operator">=</span> s2.order_note;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10621</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> <span class="keyword">join</span> buffer (hash <span class="keyword">join</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+--------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>上例的 Extra 信息解析：</p>
<ul>
<li>Using where：可以看到查询语句中有一个<code>s1.order_note = s2.order_note</code>条件，因为 s2 是驱动表，s1 是被驱动表，所以在访问 s1 表时，s1.order_note 的值已经确定下来了，所以实际上查询 s1 表的条件就是<code>s1.order_note = 一个常数</code>，所以提示了 Using where 额外信息。</li>
<li>Using join buffer (Block Nested Loop)：这是因为对表 s1 的访问不能有效利用索引，只好退而求其次，使用 join buffer 来减少对 s1 表的访问次数，从而提高性能。</li>
</ul>
<blockquote>
<p>注：测试时本地是安装 MySQL 8.0 版本，此时 extra 的显示为 <code>Using join buffer (hash join)</code></p>
</blockquote>
<h4 id="4-15-8-Not-exists"><a href="#4-15-8-Not-exists" class="headerlink" title="4.15.8. Not exists"></a>4.15.8. Not exists</h4><p>当使用左（外）连接时，如果 WHERE 子句中包含要求被驱动表的某个列等于 NULL 值的搜索条件，而且那个列又是不允许存储 NULL 值的，那么在该表的执行计划的 Extra 列就会提示 Not exists 额外信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.order_no <span class="operator">=</span> s2.order_no <span class="keyword">WHERE</span> s2.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+--------------------+-------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key          <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>                <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+--------------------+-------+----------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>               <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>                    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s2    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> idx_order_no <span class="operator">|</span> <span class="number">152</span>     <span class="operator">|</span> tempdb.s1.order_no <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Not</span> <span class="keyword">exists</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+--------------+---------+--------------------+-------+----------+-------------------------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述查询中 s1 表是驱动表，s2 表是被驱动表，s2.id 列是主键而且不允许存储 NULL 值的，而 WHERE 子句中又包含<code>s2.id IS NULL</code>的搜索条件。</p>
</blockquote>
<h4 id="4-15-9-Using-intersect-…-、Using-union-…-和-Using-sort-union-…"><a href="#4-15-9-Using-intersect-…-、Using-union-…-和-Using-sort-union-…" class="headerlink" title="4.15.9. Using intersect(…)、Using union(…)和 Using sort_union(…)"></a>4.15.9. Using intersect(…)、Using union(…)和 Using sort_union(…)</h4><p>当 MySQL 决定要在一个给定的表上使用超过一个索引的时候，就会出现以下格式中的一个，详细说明使用的索引以及合并的类型</p>
<ul>
<li>如果执行计划的 Extra 列出现了<code>Using intersect(...)</code>提示，说明准备使用 Intersect 索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；</li>
<li>如果出现了<code>Using union(...)</code>提示，说明准备使用 Union 索引合并的方式执行查询；</li>
<li>如果出现了<code>Using sort_union(...)</code>提示，说明准备使用 Sort-Union 索引合并的方式执行查询。</li>
</ul>
<h4 id="4-15-10-Zero-limit"><a href="#4-15-10-Zero-limit" class="headerlink" title="4.15.10. Zero limit"></a>4.15.10. Zero limit</h4><p>当 LIMIT 子句的参数为 0 时，表示不打算从表中读出任何记录，将会提示该额外信息。</p>
<h4 id="4-15-11-Using-filesort（文件排序）"><a href="#4-15-11-Using-filesort（文件排序）" class="headerlink" title="4.15.11. Using filesort（文件排序）"></a>4.15.11. Using filesort（文件排序）</h4><p>很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，MySQL 把这种无法按照表内既定的索引顺序进行读取，并在内存中或者磁盘上进行排序的方式统称为『文件排序』。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的 Extra 列中显示 Using filesort。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">explain <span class="keyword">select</span> order_number from tb_order order by order_money;</span></span><br><span class="line">+----+-------------+----------+------+---------------+------+---------+------+------+----------------+</span><br><span class="line">| id | select_type | table    | type | possible_keys | key  | key_len | ref  | rows | Extra          |</span><br><span class="line">+----+-------------+----------+------+---------------+------+---------+------+------+----------------+</span><br><span class="line">| 1  | SIMPLE      | tb_order | ALL  | NULL          | NULL | NULL    | NULL |  1   | Using filesort |</span><br><span class="line">+----+-------------+----------+------+---------------+------+---------+------+------+----------------+</span><br></pre></td></tr></table></figure>
<p>说明：order_number 是表内的一个唯一索引列，但是 order by 没有使用该索引列排序，所以 MySQL 使用不得不另起一列进行排序。</p>
<h5 id="4-15-11-1-filesort-文件排序方式"><a href="#4-15-11-1-filesort-文件排序方式" class="headerlink" title="4.15.11.1. filesort 文件排序方式"></a>4.15.11.1. filesort 文件排序方式</h5><ul>
<li><strong>单路排序</strong>：是一次性取出满足条件行的所有字段，然后在 sort buffer 中进行排序；用 trace 工具可以看到 sort_mode 信息里显示<code>&lt;sort_key, additional_fields&gt;</code>或者<code>&lt;sort_key,packed_additional_fields&gt;</code></li>
<li><strong>双路排序</strong>（又叫<strong>回表</strong>排序模式）：是首先根据相应的条件取出相应的<strong>排序字段和可以直接定位行数据的行 ID</strong>，然后在 sort buffer 中进行排序，排序完后需要再次回表去查询其它需要的字段；用 trace 工具可以看到 sort_mode 信息里显示<code>&lt;sort_key, rowid&gt;</code></li>
</ul>
<p>其实对比两个排序模式，单路排序会把所有需要查询的字段都放到 sort buffer 中，而双路排序只会把主键和需要排序的字段放到 sort buffer 中进行排序，然后再通过主键回到原表查询需要的字段。</p>
<h5 id="4-15-11-2-文件排序模式的选择"><a href="#4-15-11-2-文件排序模式的选择" class="headerlink" title="4.15.11.2. 文件排序模式的选择"></a>4.15.11.2. 文件排序模式的选择</h5><p>MySQL 通过比较系统变量 <code>max_length_for_sort_data</code>(默认1024字节) 的大小和需要查询的字段总大小来判断使用哪种排序模式。</p>
<ul>
<li>如果字段的总长度小于 <code>max_length_for_sort_data</code>，那么使用单路排序模式</li>
<li>如果字段的总长度大于 <code>max_length_for_sort_data</code>，那么使用双路排序模式</li>
</ul>
<p>如果内存配置比较小并且没有条件继续增加，可以适当把 max_length_for_sort_data 配置小点，让优化器选择使用双路排序算法，可以在 sort_buffer 中一次排序更多的行，但需要再根据主键回到原表取数据；如果内存充足，可以适当增大 max_length_for_sort_data 的值，让优化器优先选择全字段排序(单路排序)，把需要的字段放到 sort_buffer 中，这样排序后就会直接从内存里返回查询结果了。</p>
<p>所以，MySQL 通过 max_length_for_sort_data 这个参数来控制排序，在不同场景使用不同的排序模式，从而提升排序效率。</p>
<blockquote>
<p>Tips: 如果全部使用 sort_buffer 内存排序一般情况下效率会高于磁盘文件排序，但因此而随便增大 sort_buffer(默认1M)，mysql 很多参数设置都是经过优化的，<strong>不要轻易调整</strong>。</p>
</blockquote>
<h4 id="4-15-12-Using-temporary"><a href="#4-15-12-Using-temporary" class="headerlink" title="4.15.12. Using temporary"></a>4.15.12. Using temporary</h4><p>Mysql使用了临时表保存中间结果，常见于排序<code>order by</code>和分组查询<code>group by</code>。</p>
<p>比如在执行许多包含 DISTINCT、GROUP BY、UNION 等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL 很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的 Extra 列将会显示 Using temporary 提示</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> order_number <span class="keyword">from</span> tb_order <span class="keyword">group</span> <span class="keyword">by</span> order_money;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------+---------------+------+---------+------+------+---------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------+---------------+------+---------+------+------+---------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_order <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">1</span>   <span class="operator">|</span> <span class="keyword">Using</span> temporary; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------+---------------+------+---------+------+------+---------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>上述执行计划的 Extra 列不仅仅包含 Using temporary 提示，还包含 Using filesort 提示。因为 MySQL 会在包含 GROUP BY 子句的查询中默认添加上 ORDER BY 子句，也就是说上述查询其实和下边这个查询等价：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> order_note, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> order_note <span class="keyword">order</span> <span class="keyword">by</span> order_note;</span><br></pre></td></tr></table></figure>
<p>如果并不想为包含 GROUP BY 子句的查询进行排序，需要显式的写上 <code>ORDER BY NULL</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> order_note, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> amount <span class="keyword">FROM</span> s1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> order_note <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>
<p>这样执行计划中就没有 Using filesort 的提示了，也就意味着执行查询时可以省去对记录进行文件排序的成本了。很明显，执行计划中出现 Using temporary 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以最好能使用索引来替代掉使用临时表。</p>
<h4 id="4-15-13-Start-temporary-End-temporary"><a href="#4-15-13-Start-temporary-End-temporary" class="headerlink" title="4.15.13. Start temporary, End temporary"></a>4.15.13. Start temporary, End temporary</h4><p>有子查询时，查询优化器会优先尝试将 IN 子查询转换成 semi-join(半连接优化技术，本质上是把子查询上拉到父查询中，与父查询的表做 join 操作)，而 semi-join 又有好多种执行策略，当执行策略为 DuplicateWeedout 时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的 Extra 列将显示 Start temporary 提示，被驱动表查询执行计划的 Extra 列将显示 End temporary 提示。</p>
<h4 id="4-15-14-select-tables-optimized-away"><a href="#4-15-14-select-tables-optimized-away" class="headerlink" title="4.15.14. select tables optimized away"></a>4.15.14. select tables optimized away</h4><p>这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行。</p>
<h4 id="4-15-15-LooseScan"><a href="#4-15-15-LooseScan" class="headerlink" title="4.15.15. LooseScan"></a>4.15.15. LooseScan</h4><p>在将 In 子查询转为 semi-join 时，如果采用的是 LooseScan 执行策略，则在驱动表执行计划的 Extra 列就是显示 LooseScan 提示。</p>
<h4 id="4-15-16-FirstMatch-tbl-name"><a href="#4-15-16-FirstMatch-tbl-name" class="headerlink" title="4.15.16. FirstMatch(tbl_name)"></a>4.15.16. FirstMatch(tbl_name)</h4><p>在将 In 子查询转为 semi-join 时，如果采用的是 FirstMatch 执行策略，则在被驱动表执行计划的 Extra 列就是显示 FirstMatch(tbl_name)提示。</p>
<h3 id="4-16-explain-两个变种"><a href="#4-16-explain-两个变种" class="headerlink" title="4.16. explain 两个变种"></a>4.16. explain 两个变种</h3><h4 id="4-16-1-explain-extended（已过时）"><a href="#4-16-1-explain-extended（已过时）" class="headerlink" title="4.16.1. explain extended（已过时）"></a>4.16.1. explain extended（已过时）</h4><blockquote>
<p>Notes: 在 5.7 版本以前可以使用，后续的版本已取消此关键字。</p>
</blockquote>
<p><code>explain extended</code> 会在 <code>explain</code> 的基础上额外提供一些查询优化的信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain extended <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> film <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>紧随其后通过 <code>show warnings</code> 命令可以得到优化后的查询语句，从而看出优化器做了什么优化。额外还有 filtered 列，是一个百分比的值，<code>rows * filtered/100</code> 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> warnings;</span><br></pre></td></tr></table></figure>
<h4 id="4-16-2-explain-partitions"><a href="#4-16-2-explain-partitions" class="headerlink" title="4.16.2. explain partitions"></a>4.16.2. explain partitions</h4><p>相比 <code>explain</code> 多了个 <code>partitions</code> 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<h2 id="5-分析慢-sql-的其他方法"><a href="#5-分析慢-sql-的其他方法" class="headerlink" title="5. 分析慢 sql 的其他方法"></a>5. 分析慢 sql 的其他方法</h2><p>通过应用程序访问 MySQL 服务时，有时候性能不一定全部卡在语句的执行上。常用的手段是通过慢查询日志定位那些执行效率较低的SQL语句。</p>
<ol>
<li>慢查询日志在查询结束以后才记录，在应用反映执行效率出现问题的时候查询未必执行完成</li>
<li>有时候问题的产生不一定是语句的执行，有可能是其他原因导致的。慢查询日志并不能定位问题。</li>
</ol>
<h3 id="5-1-通过-show-processlist-分析-SQL"><a href="#5-1-通过-show-processlist-分析-SQL" class="headerlink" title="5.1. 通过 show processlist 分析 SQL"></a>5.1. 通过 show processlist 分析 SQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> processlist;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+----------------+--------+---------+------+------------------------+------------------+</span></span><br><span class="line"><span class="operator">|</span> Id <span class="operator">|</span> <span class="keyword">User</span>            <span class="operator">|</span> Host           <span class="operator">|</span> db     <span class="operator">|</span> Command <span class="operator">|</span> <span class="type">Time</span> <span class="operator">|</span> State                  <span class="operator">|</span> Info             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+----------------+--------+---------+------+------------------------+------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> event_scheduler <span class="operator">|</span> localhost      <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> Daemon  <span class="operator">|</span> <span class="number">2784</span> <span class="operator">|</span> Waiting <span class="keyword">on</span> <span class="keyword">empty</span> queue <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> root            <span class="operator">|</span> localhost:<span class="number">2772</span> <span class="operator">|</span> tempdb <span class="operator">|</span> Query   <span class="operator">|</span>    <span class="number">0</span> <span class="operator">|</span> init                   <span class="operator">|</span> <span class="keyword">show</span> processlist <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">9</span> <span class="operator">|</span> root            <span class="operator">|</span> localhost:<span class="number">2779</span> <span class="operator">|</span> tempdb <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">1533</span> <span class="operator">|</span>                        <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> root            <span class="operator">|</span> localhost:<span class="number">2780</span> <span class="operator">|</span> tempdb <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">1957</span> <span class="operator">|</span>                        <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">11</span> <span class="operator">|</span> root            <span class="operator">|</span> localhost:<span class="number">2781</span> <span class="operator">|</span> tempdb <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">2128</span> <span class="operator">|</span>                        <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">12</span> <span class="operator">|</span> root            <span class="operator">|</span> localhost:<span class="number">2782</span> <span class="operator">|</span> tempdb <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">2128</span> <span class="operator">|</span>                        <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">13</span> <span class="operator">|</span> root            <span class="operator">|</span> localhost:<span class="number">2783</span> <span class="operator">|</span> tempdb <span class="operator">|</span> Sleep   <span class="operator">|</span> <span class="number">2128</span> <span class="operator">|</span>                        <span class="operator">|</span> <span class="keyword">NULL</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------------+----------------+--------+---------+------+------------------------+------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li>id 列：线程 id，用户登录 mysql 时，系统分配的”connection_id”，可以使用函数<code>connection_id()</code>查看。此 id 可用于 <code>kill id</code> 杀死某个线程</li>
<li>user 列：显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</li>
<li>host 列：数据库实例的 IP，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户</li>
<li>db 列：显示这个进程目前连接的是哪个数据库</li>
<li>command 列：显示当前连接执行的命令，一般取值为休眠（<code>sleep</code>），查询（<code>query</code>），连接（<code>connect</code>）等</li>
<li>time 列：显示这个状态持续的时间，单位是秒</li>
<li>state 列(<strong>重要</strong>)：显示使用当前连接的 sql 语句的状态，描述的是语句执行中的某一个状态。以查询语句为例，可能需要经过 copying to tmp table、sorting result、sending data 等状态才可以完成。此列主要有以下常见状态：<ul>
<li><code>Sleep</code>，线程正在等待客户端发送新的请求</li>
<li><code>Locked</code>，线程正在等待锁</li>
<li><code>Sending data</code>，正在处理 SELECT 查询的记录，同时把结果发送给客户端</li>
<li><code>Kill</code>，正在执行 kill 语句，杀死指定线程</li>
<li><code>Connect</code>，一个从节点连上了主节点</li>
<li><code>Quit</code>，线程正在退出</li>
<li><code>Sorting for group</code>，正在为 GROUP BY 做排序</li>
<li><code>Sorting for order</code>，正在为 ORDER BY 做排序</li>
</ul>
</li>
<li>info 列：显示这个 sql 语句，是判断问题语句的一个重要依据</li>
</ul>
<p>通过上面的命令可以查看线程状态。可以了解当前 MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看SQL的执行情况，同时对一些锁表操作进行优化。在一个繁忙的服务器上，可能会看到大量的不正常的状态，例如 <code>statistics</code> 正占用大量的时间。这通常表示，某个地方有异常了。如：</p>
<ul>
<li>statistics</li>
</ul>
<blockquote>
<p>The server is calculating statistics to develop a query execution plan. If a thread is in this state for a long time, the server is probably disk-bound performing other work.</p>
</blockquote>
<p>服务器正在计算统计信息以研究一个查询执行计划。如果线程长时间处于此状态，则服务器可能是磁盘绑定执行其他工作。</p>
<ul>
<li>Creating tmp table</li>
</ul>
<blockquote>
<p>The thread is creating a temporary table in memory or on disk. If the table is created in memory but later is converted to an on-disk table, the state during that operation is Copying to tmp table on disk.</p>
</blockquote>
<p>该线程正在内存或磁盘上创建临时表。如果表在内存中创建但稍后转换为磁盘表，则该操作期间的状态将为 Copying to tmp table on disk</p>
<ul>
<li>Sending data</li>
</ul>
<blockquote>
<p>The thread is reading and processing rows for a SELECT statement, and sending data to the client. Because operations occurring during this state tend to perform large amounts of disk access (reads), it is often the longest-running state over the lifetime of a given query.</p>
</blockquote>
<p>线程正在读取和处理 SELECT 语句的行 ，并将数据发送到客户端。由于在此状态期间发生的操作往往会执行大量磁盘访问（读取），因此它通常是给定查询生命周期中运行时间最长的状态。</p>
<blockquote>
<p>具体状态参数解释参考官网：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html">https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html</a></p>
</blockquote>
<h3 id="5-2-通过-show-profile-分析-SQL"><a href="#5-2-通过-show-profile-分析-SQL" class="headerlink" title="5.2. 通过 show profile 分析 SQL"></a>5.2. 通过 show profile 分析 SQL</h3><p>对于每个线程到底时间耗费在哪里，可以通过 <code>show profile</code> 来分析。</p>
<ol>
<li>首先检查当前 MySQL 是否支持 profile</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@have_profiling</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@have_profiling</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> YES              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br></pre></td></tr></table></figure>
<ol>
<li>默认 profiling 是关闭的，执行如下命令可以查看是否开启 profiling。（0-关闭；1-开启）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@profiling</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br><span class="line"><span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+</span></span><br></pre></td></tr></table></figure>
<ol>
<li>可以通过 <code>set</code> 语句在 Session 级别开启 profiling：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>执行一个 SQL 查询。（<em>如：`select count(</em>) from order_exp;`*）</li>
<li>执行以下系列的语句，可以以不同的方式来查看执行的耗时</li>
</ol>
<ul>
<li>查看当前 SQL 的 Query ID 和 SQL 语句执行的耗时：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query                          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+--------------------------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">0.01082900</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> order_exp <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">0.00130800</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> order_exp <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">3</span> <span class="operator">|</span> <span class="number">0.00159725</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> order_exp <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">0.00131825</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> order_exp <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+--------------------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>show profile for query query_id</code> 语句查看指定 query_id 的 SQL 执行过程中每个阶段的状态和消耗的时间</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status               <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting             <span class="operator">|</span> <span class="number">0.000035</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables       <span class="operator">|</span> <span class="number">0.000010</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                 <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock          <span class="operator">|</span> <span class="number">0.000005</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing           <span class="operator">|</span> <span class="number">0.000002</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics           <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing            <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing            <span class="operator">|</span> <span class="number">0.000001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sending data         <span class="operator">|</span> <span class="number">0.010714</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                  <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>            <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables       <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items        <span class="operator">|</span> <span class="number">0.000023</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up          <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br></pre></td></tr></table></figure>
<p>通过仔细检查输出，能够发现在执行<code>COUNT(*)</code>的过程中，时间主要消耗在<code>Sending data</code>这个状态上。</p>
<ul>
<li>通过 <code>show profile cpu for query query_id;</code> 请求，查看指定 query_id 的 SQL 语句 CPU 的使用情况</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu <span class="keyword">for</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span> Status               <span class="operator">|</span> Duration <span class="operator">|</span> CPU_user <span class="operator">|</span> CPU_system <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+----------+------------+</span></span><br><span class="line"><span class="operator">|</span> starting             <span class="operator">|</span> <span class="number">0.000035</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables       <span class="operator">|</span> <span class="number">0.000010</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                 <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock          <span class="operator">|</span> <span class="number">0.000005</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing           <span class="operator">|</span> <span class="number">0.000002</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics           <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing            <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing            <span class="operator">|</span> <span class="number">0.000001</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sending data         <span class="operator">|</span> <span class="number">0.010714</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                  <span class="operator">|</span> <span class="number">0.000003</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>            <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables       <span class="operator">|</span> <span class="number">0.000004</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items        <span class="operator">|</span> <span class="number">0.000023</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up          <span class="operator">|</span> <span class="number">0.000006</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span> <span class="number">0.000000</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+----------+------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在获取到最消耗时间的线程状态后，MySQL 支持进一步选择 all、cpu、block io、contextswitch、page faults 等明细类型来查看 MySQL 在使用什么资源上耗费了过高的时间:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">all</span> <span class="keyword">for</span> query <span class="number">1</span>\G;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028474.png" alt=""></p>
<p>能够发现 Sending data 状态下，时间主要消耗在 CPU 上了。所以<code>show profile</code>能够在做SQL优化时帮助了解时间都耗费到哪里去了，同时如果 MySQL 源码感兴趣，还可以通过 <code>show profile source for query</code> 查看 SQL 解析执行过程中每个步骤对应的源码的文件、函数名以及具体的源文件行数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Status</td>
<td>sql语句执行的状态</td>
</tr>
<tr>
<td style="text-align:center">Duration</td>
<td>sql执行过程中第一个步骤的耗时</td>
</tr>
<tr>
<td style="text-align:center">CPU_user</td>
<td>当前用户占有的CPU</td>
</tr>
<tr>
<td style="text-align:center">CPU_system</td>
<td>系统占有的CPU</td>
</tr>
</tbody>
</table>
</div>
<h2 id="6-SQL-优化最佳实践"><a href="#6-SQL-优化最佳实践" class="headerlink" title="6. SQL 优化最佳实践"></a>6. SQL 优化最佳实践</h2><h3 id="6-1-SQL-编写规范"><a href="#6-1-SQL-编写规范" class="headerlink" title="6.1. SQL 编写规范"></a>6.1. SQL 编写规范</h3><ol>
<li>SQL 语句中优先使用 <code>in</code> 代替 <code>or</code>。<code>in</code> 是范围查找，MySQL 内部会对 <code>in</code> 的列表值进行排序后查找，比 <code>or</code> 效率更高。</li>
<li>如果查询结果集不需要去重、排序，应使用 <code>UNION ALL</code> 代替 <code>UNION</code>。</li>
<li>将查询条件中的 <code>or</code> 关键字转换为 <code>UNION ALL</code>，从应用层面处理 <code>UNION ALL</code> 中的重复数据。</li>
<li>需要使用随机数查询时，不应使用 <code>order by rand()</code>。因为此操作会为表增加一个伪列，然后用 <code>rand()</code> 函数为每一行数据计算出随机值，然后再基于该值排序，这通常都会生成磁盘上的临时表，因此效率非常低。<strong>建议先使用 <code>rand()</code> 函数获得随机的主键值，然后通过主键获取数据</strong>。</li>
<li>使用批量插入的 SQL 语句。</li>
<li>insert 和 update 等语句中以及 select 嵌套语句的最里面层，应使用明确的字段名，避免使用 <code>*</code> 获取全部。这样可减少网络带宽消耗，有效利用覆盖索引（如有），表结构变更对程序基本无影响。</li>
<li>使用 <code>group by</code> 的时候，如果确认不需要排序，语句应加上 <code>order by null</code>，避免多余的排序。因为 <code>group by</code> 默认会进行排序。</li>
<li>进行数据比较时，如果两边的数据类型不一致，应在一方加上类型转换的函数，避免隐式类型转换。日期类型是特例，包换 DATE、TIME、DATETIME。例如：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.username <span class="keyword">from</span> employee e <span class="keyword">where</span> e.birthday <span class="operator">&gt;=</span> <span class="string">&#x27;1999-12-12 11:11:11&#x27;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>限制表连接操作所涉及的表的个数。参与表连接的表数量不宜超过3个，<strong>若有超过3个表连接的需求，建议从应用层面进行优化</strong></li>
<li>限制嵌套查询的层数。过多的嵌套层数，会使用查询语句的复杂度大幅增加而影响执行效率，查询语句的嵌套层数不应该多于3层</li>
</ol>
<h3 id="6-2-插入数据优化"><a href="#6-2-插入数据优化" class="headerlink" title="6.2. 插入数据优化"></a>6.2. 插入数据优化</h3><p>如果需要一次性往数据库表中插入多条记录，可以从以下3个方面进行优化。</p>
<h4 id="6-2-1-批量插入"><a href="#6-2-1-批量插入" class="headerlink" title="6.2.1. 批量插入"></a>6.2.1. 批量插入</h4><p>批量插入数据 SQL 语句，减少与数据库交互次数。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其他</span></span><br><span class="line"><span class="keyword">insert</span> ... <span class="keyword">on</span> duplicate key <span class="keyword">update</span></span><br><span class="line">replace <span class="keyword">into</span></span><br><span class="line"><span class="keyword">insert</span> ignore</span><br><span class="line"><span class="keyword">insert into</span> <span class="keyword">values</span>(), (), ...</span><br></pre></td></tr></table></figure>
<h4 id="6-2-2-手动控制事务"><a href="#6-2-2-手动控制事务" class="headerlink" title="6.2.2. 手动控制事务"></a>6.2.2. 手动控制事务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert into</span> tb_test <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-3-主键顺序插入"><a href="#6-2-3-主键顺序插入" class="headerlink" title="6.2.3. 主键顺序插入"></a>6.2.3. 主键顺序插入</h4><p>尽可能让主键顺序插入行。主键顺序插入，性能要高于乱序插入。</p>
<ul>
<li>主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3</li>
<li>主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</li>
</ul>
<p>最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于I/O密集型的应用。如果聚簇索引的插入变得完全随机，会存在以下的问题：</p>
<ul>
<li>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB 在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机 IO。</li>
<li>因为写入是乱序的，InnoDB 不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</li>
</ul>
<p>所以使用 InnoDB 时应该尽可能地按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行。</p>
<h3 id="6-3-MySQL-大批量数据导入性能优化"><a href="#6-3-MySQL-大批量数据导入性能优化" class="headerlink" title="6.3. MySQL 大批量数据导入性能优化"></a>6.3. MySQL 大批量数据导入性能优化</h3><h4 id="6-3-1-传统的-insert-优化"><a href="#6-3-1-传统的-insert-优化" class="headerlink" title="6.3.1. 传统的 insert 优化"></a>6.3.1. 传统的 insert 优化</h4><p>如果使用传统的 insert 插入大批量数据，提高导入性能一般有以下几点：</p>
<ol>
<li>对于有主键的表，导入前将数据按照主键的顺序排序，可以有效提高导入数据的效率</li>
<li>导入数据前通过<code>set unique_checks=0</code>，关闭唯一性校验，可以提高导入效率，导入完成后再用<code>set unique_checks=1</code>打开</li>
<li>通过<code>set autocommit=0</code>，关闭自动提交，可以提高导入效率</li>
<li>insert 语句采用<code>INSERT INTO VALUES(), (), ...</code>的方式，一条件语句插入多条数据（但需要注意 SQL 语句长度限制，<code>max_allowed_packet</code> 参数，大基线默认32M），可以幅度提高导入的效率。</li>
<li>使用工具导入（如：load data），比通过 sql 语句方式提速20倍。需要<code>show global variables like &#39;local_infile&#39;;</code>查看是否开启，通过<code>set global local_infile=1;</code>开启。</li>
<li>使用<code>insert delayed ...</code>异步插入的方式（先写入内存），mysql 可以进行合并写入，提高性能（值得注意的是，如果 mysql 数据库设备宕机，会丢失数据）。</li>
<li>对于要先查询是否有记录，有记录就 update，没有记录则 insert，最好采用下面的语法执行，减少 sql 交互</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> ... <span class="keyword">on</span> duplicate key <span class="keyword">update</span></span><br><span class="line">replace <span class="keyword">into</span></span><br><span class="line"><span class="keyword">insert</span> ignore</span><br></pre></td></tr></table></figure>
<h4 id="6-3-2-存储过程-开启事务"><a href="#6-3-2-存储过程-开启事务" class="headerlink" title="6.3.2. 存储过程+开启事务"></a>6.3.2. 存储过程+开启事务</h4><p>通过存储过程可以实现循环批量插入大量数据，但正常情况与逐条插入的效率差不多，只是存储过程允许编写循环插入。可以开启事务来提高数据导入的速度。示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$  <span class="comment">-- 定义结束符（为了不跟储存过程的“;”冲突，这里重新定义）</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> `insert_batch_index` $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">procedure</span> `insert_batch_index` (<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">declare</span> resource_id <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">declare</span> test_name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="keyword">declare</span> cate_id <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">declare</span> input_time <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	while i <span class="operator">&lt;</span> n do</span><br><span class="line">		<span class="keyword">set</span> resource_id <span class="operator">=</span> <span class="built_in">floor</span>(<span class="number">1</span> <span class="operator">+</span> rand() <span class="operator">*</span> <span class="number">3000</span>);</span><br><span class="line">		<span class="keyword">set</span> test_name <span class="operator">=</span> concat(<span class="string">&#x27;name_&#x27;</span>, resource_id);</span><br><span class="line">		<span class="keyword">set</span> cate_id <span class="operator">=</span> <span class="built_in">floor</span>(<span class="number">1</span> <span class="operator">+</span> rand() <span class="operator">*</span> <span class="number">20</span>);</span><br><span class="line">		<span class="keyword">set</span> input_time <span class="operator">=</span> <span class="built_in">floor</span>(<span class="number">1609430400</span> <span class="operator">+</span> rand() <span class="operator">*</span> <span class="number">32227200</span>);</span><br><span class="line">		<span class="keyword">insert into</span> batch_index <span class="keyword">values</span> (<span class="keyword">null</span>, resource_id, test_name, cate_id, input_time);</span><br><span class="line">		<span class="keyword">set</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span> $$</span><br><span class="line">delimiter ;  <span class="comment">--把结束符再设置回“;”</span></span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">call</span> insert_batch_index(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-使用-load-指令"><a href="#6-3-3-使用-load-指令" class="headerlink" title="6.3.3. 使用 load 指令"></a>6.3.3. 使用 load 指令</h4><p>如果一次性需要插入大批量数据(几百万的记录)，使用 insert 语句插入性能较低，此时可以使用 MySQL 数据库提供的 <code>load</code> 指令进行插入。操作如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028475.png" alt=""></p>
<ol>
<li>首先，检查一个全局系统变量 <code>&#39;local_infile&#39;</code> 的状态， 如果得到如下显示 <code>Value=OFF</code>，则说明这是不可用的</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;local_infile&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> local_infile  <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure>
<ol>
<li>修改 <code>local_infile</code> 值为 on，开启 local_infile</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 load 命令加载数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;D:\\sql_data\\sql.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令参数说明：</p>
<ul>
<li><code>&#39;D:\\sql_data\\sql.log&#39;</code>：待导入的数据文件</li>
<li><code>tb_user</code>：待导入的表名称</li>
<li><code>fields terminated by &#39;,&#39;</code>：每行数据的字段值的分隔符是“<code>,</code>”</li>
<li><code>lines terminated by &#39;\n&#39;</code>：每行数据的分隔符是换行符“<code>\n</code>”</li>
</ul>
</blockquote>
<h4 id="6-3-4-主键顺序导入"><a href="#6-3-4-主键顺序导入" class="headerlink" title="6.3.4. 主键顺序导入"></a>6.3.4. 主键顺序导入</h4><p>因为 InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果 InnoDB 表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p>
<h4 id="6-3-5-关闭唯一性校验"><a href="#6-3-5-关闭唯一性校验" class="headerlink" title="6.3.5. 关闭唯一性校验"></a>6.3.5. 关闭唯一性校验</h4><p>在导入数据前执行 <code>SET UNIQUE_CHECKS=0</code>，关闭唯一性校验，在导入结束后执行 <code>SET UNIQUE_CHECKS=1</code>，恢复唯一性校验，可以提高导入的效率。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导入前，关闭唯一性校验</span></span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 导入数据</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;D:\\sql_data\\sql.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">-- 导入后，开启唯一性校验</span></span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-优化-order-by-语句"><a href="#6-4-优化-order-by-语句" class="headerlink" title="6.4. 优化 order by 语句"></a>6.4. 优化 order by 语句</h3><p>MySQL 一般有两种排序方式：</p>
<ul>
<li><code>Using filesort</code>：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li>
<li><code>Using index</code>：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li>
</ul>
<p>对于以上的两种排序方式，<strong>Using index 的性能高，而 Using filesort 的性能低</strong>，在优化排序操作时，尽量要优化为 Using index。</p>
<h4 id="6-4-1-Filesort-的优化"><a href="#6-4-1-Filesort-的优化" class="headerlink" title="6.4.1. Filesort 的优化"></a>6.4.1. Filesort 的优化</h4><p>通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让 Filesort 消失，那就需要加快 Filesort 的排序操作。MySQL 对于 Filesort 有两种排序算法：</p>
<ul>
<li>两次扫描算法(回表扫描)：MySQL 4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果 sort buffer 不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。</li>
<li>一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。</li>
</ul>
<p>MySQL 通过比较系统变量 <code>max_length_for_sort_data</code> 的大小和 Query 语句取出的字段总大小，来判定是否那种排序算法，如果 <code>max_length_for_sort_data</code> 更大，那么使用第二种优化之后的算法；否则使用第一种。</p>
<p>可以适当提高 <code>sort_buffer_size</code> 和 <code>max_length_for_sort_data</code> 系统变量，来增大排序区的大小，提高排序的效率。</p>
<h4 id="6-4-2-通过索引优化"><a href="#6-4-2-通过索引优化" class="headerlink" title="6.4.2. 通过索引优化"></a>6.4.2. 通过索引优化</h4><p>假设 tb_user 表的 age, phone 都没有索引，那么查询排序时就会出现 Using filesort，排序性能较低。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age, phone;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+----------------+</span></span><br></pre></td></tr></table></figure>
<p>给 age, phone 创建联合索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_age_phone_aa <span class="keyword">ON</span> tb_user ( age, phone );</span><br></pre></td></tr></table></figure>
<p>创建索引后，根据 age, phone 进行升序排序。由原来的 Using filesort 变为了 Using index，性能就是比较高的了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_user_age_phone_aa <span class="operator">|</span> <span class="number">37</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age, phone;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_user_age_phone_aa <span class="operator">|</span> <span class="number">37</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>根据 age, phone 进行降序排序。此时也会出现 Using index，但是此时 Extra 中出现了 Backward index scan，这个代表反向扫描索引，因为在 MySQL 中创建的索引，默认索引的叶子节点是从小到大排序的，而查询排序时是从大到小，所以在扫描时就是反向扫描，就会出现 Backward index scan。在 MySQL 8 版本中，支持降序索引，也可以创建降序索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>, phone <span class="keyword">desc</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+----------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_user_age_phone_aa <span class="operator">|</span> <span class="number">37</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> Backward index scan; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+----------------------------------+</span></span><br></pre></td></tr></table></figure>
<p>根据 phone，age 进行升序排序，phone 在前，age 在后。排序时不满足最左前缀法则，因此出现了 filesort 排序。在创建索引的时候，age 是第一个字段，phone 是第二个字段，所以排序时也该按照这个顺序来，否则就会出现 Using filesort。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> phone, age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_user_age_phone_aa <span class="operator">|</span> <span class="number">37</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-----------------------------+</span></span><br></pre></td></tr></table></figure>
<p>根据 age, phone 进行降序一个升序，一个降序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>, phone <span class="keyword">desc</span> ;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_user_age_phone_aa <span class="operator">|</span> <span class="number">37</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index; <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-----------------------------+</span></span><br></pre></td></tr></table></figure>
<p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时就会出现 Using filesort。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028476.png" alt=""></p>
<p>创建联合索引(age 升序排序，phone 倒序排序)。<strong>注：需要 MySQL 8.0 以上版本</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> INDEX idx_user_age_phone_ad <span class="keyword">ON</span> tb_user ( age <span class="keyword">ASC</span>, phone <span class="keyword">DESC</span> );</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> tb_user;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+-----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>   <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name              <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+-----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>               <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> id          <span class="operator">|</span> A         <span class="operator">|</span>          <span class="number">24</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_age_phone_aa <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> age         <span class="operator">|</span> A         <span class="operator">|</span>          <span class="number">19</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_age_phone_aa <span class="operator">|</span>            <span class="number">2</span> <span class="operator">|</span> phone       <span class="operator">|</span> A         <span class="operator">|</span>          <span class="number">24</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_age_phone_ad <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> age         <span class="operator">|</span> A         <span class="operator">|</span>          <span class="number">19</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tb_user <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> idx_user_age_phone_ad <span class="operator">|</span>            <span class="number">2</span> <span class="operator">|</span> phone       <span class="operator">|</span> D         <span class="operator">|</span>          <span class="number">24</span> <span class="operator">|</span> <span class="keyword">NULL</span>     <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------+------------+-----------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span></span><br></pre></td></tr></table></figure>
<p>再次查询，成功优化为 Using index</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>, phone <span class="keyword">desc</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key                   <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_user_age_phone_ad <span class="operator">|</span> <span class="number">37</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Notes: 以下测试sql都使用了覆盖索引，没有进行回表查询。</p>
</blockquote>
<h4 id="6-4-3-order-by-优化原则小结"><a href="#6-4-3-order-by-优化原则小结" class="headerlink" title="6.4.3. order by 优化原则小结"></a>6.4.3. order by 优化原则小结</h4><ol>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li>
<li>尽量使用覆盖索引。</li>
<li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</li>
<li>如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</li>
</ol>
<h3 id="6-5-优化-group-by-语句"><a href="#6-5-优化-group-by-语句" class="headerlink" title="6.5. 优化 group by 语句"></a>6.5. 优化 group by 语句</h3><p><code>GROUP BY</code> 实际上也同样会进行排序操作，而且与 <code>ORDER BY</code> 相比，<code>GROUP BY</code> 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在 <code>GROUP BY</code> 的实现过程中，与 <code>ORDER BY</code> 一样也可以利用到索引。</p>
<p>如果查询包含 <code>group by</code> 但是用户想要避免排序结果的消耗，则可以执行 <code>order by null</code> 禁止排序。(<em>其实通过索引来优化后，本来就已经排序了，这么做有必须吗？</em>)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="6-5-1-通过索引优化"><a href="#6-5-1-通过索引优化" class="headerlink" title="6.5.1. 通过索引优化"></a>6.5.1. 通过索引优化</h4><p>无索引的情况进行分组查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> profession, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure>
<p>对 profession、age、status 字符创建一个联合索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_pro_age_sta <span class="keyword">ON</span> tb_user ( profession, age, `status` );</span><br></pre></td></tr></table></figure>
<p>再执行上面的分组查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> profession, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> <span class="number">42</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>如果仅仅根据 age 分组，就会出现 Using temporary ；而如果是根据 profession,age 两个字段同时分组，则不会出现 Using temporary。因此可以得到<font color=red><strong>结论：对于有联合索引的字段进行分组操作，也是符合最左前缀法则的</strong></font>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> profession, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> <span class="number">42</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index; <span class="keyword">Using</span> temporary <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+------------------------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> profession, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession,age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> <span class="number">42</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+-------+----------------------+----------------------+---------+------+------+----------+-------------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> profession, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> <span class="number">36</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="6-5-2-分组操作原则"><a href="#6-5-2-分组操作原则" class="headerlink" title="6.5.2. 分组操作原则"></a>6.5.2. 分组操作原则</h4><ol>
<li>在分组操作时，可以通过索引来提高效率</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的</li>
</ol>
<h3 id="6-6-优化-limit-分页查询（超大分页）"><a href="#6-6-优化-limit-分页查询（超大分页）" class="headerlink" title="6.6. 优化 limit 分页查询（超大分页）"></a>6.6. 优化 limit 分页查询（超大分页）</h3><p>在系统中需要进行分页操作的时候，通常会使用 LIMIT 加上偏移量的办法实现，同时加上合适的 ORDER BY 子句。</p>
<p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。但有些情况，如 <code>limit 9000000,10</code> 偏移量非常大的查询，此时需要 MySQL 排序前 9000010 记录，仅仅返回 9000000 - 9000010 的记录，前面9百万记录将被丢弃，查询排序的代价非常大。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_sku;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10000000</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku limit <span class="number">9000000</span>,<span class="number">10</span>;</span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">11.92</span> sec)</span><br></pre></td></tr></table></figure>
<h4 id="6-6-1-优化思路一：子查询（连接查询）覆盖索引"><a href="#6-6-1-优化思路一：子查询（连接查询）覆盖索引" class="headerlink" title="6.6.1. 优化思路一：子查询（连接查询）覆盖索引"></a>6.6.1. 优化思路一：子查询（连接查询）覆盖索引</h4><p>优化此类分页查询的一个最简单的办法是：在索引上完成排序分页操作，通过创建『覆盖索引』+『子查询』的方式进行优化，最后根据主键关联回表查询所需要的其他列内容。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_sku a <span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tb_sku <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">9000000</span>, <span class="number">1</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这种优化方式提升查询速度主要利用了索引覆盖的如下好处：</p>
<ul>
<li>索引文件不包含行数据的所有信息，故其大小远小于数据文件，因此可以减少大量的 IO 操作。</li>
<li>索引覆盖只需要扫描一次索引树，不需要回表扫描行数据，所以性能比回表查询要高。</li>
</ul>
<p>同理，可以通过创建『覆盖索引』+『连接查询』的方式进行优化。例如：通过子查询先在索引上进行查询翻页中需要的 N 条数据的主键值，然后根据主键值回表查询相应的 N 条数据，在此过程中查询 N 条数据的主键 id 在索引中完成，所以效率会高一些。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_sku a, ( <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> tb_sku <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">9000000</span>, <span class="number">10</span> ) b <span class="keyword">WHERE</span> a.id <span class="operator">=</span> b.id;</span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">6.74</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 LIMIT <span class="number">10000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> s1 LIMIT <span class="number">10000</span>, <span class="number">10</span>) b, s1 <span class="keyword">WHERE</span> s1.id <span class="operator">=</span> b.id;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+-----------------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>      <span class="operator">|</span> partitions <span class="operator">|</span> type   <span class="operator">|</span> possible_keys <span class="operator">|</span> key             <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+-----------------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> <span class="operator">&lt;</span>derived2<span class="operator">&gt;</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10010</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> eq_ref <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span>         <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> b.id <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> DERIVED     <span class="operator">|</span> s1         <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> idx_insert_time <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10609</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------------+------------+--------+---------------+-----------------+---------+------+-------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="6-6-2-优化思路二：主键自增"><a href="#6-6-2-优化思路二：主键自增" class="headerlink" title="6.6.2. 优化思路二：主键自增"></a>6.6.2. 优化思路二：主键自增</h4><p>最佳的方式是在业务上进行配合修改：假如是主键自增的表，可以把 <code>limit</code> 查询转换成某个位置的查询。<em>但需要保证 id 必须连续</em></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb_sku <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">9000000</span> LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.16</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">9000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">10</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> s1    <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">3398</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<p>采用这种写法，需要前端通过点击 More 来获得更多数据，而不是纯粹的翻页，因此，每次查询只需要使用上次查询出的数据中的 id 来获取接下来的数据即可，但这种写法需要业务配合。</p>
<h4 id="6-6-3-优化思路三：计算边界值，转换为已知位置的查询"><a href="#6-6-3-优化思路三：计算边界值，转换为已知位置的查询" class="headerlink" title="6.6.3. 优化思路三：计算边界值，转换为已知位置的查询"></a>6.6.3. 优化思路三：计算边界值，转换为已知位置的查询</h4><p>如果 id 连续不中断，就可以计算出每一页的边界值，让 MySQL 根据边界值进行范围扫描，查出数据。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">0</span> <span class="keyword">and</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">100000</span> <span class="keyword">and</span> <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">1000000</span> <span class="keyword">and</span> <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">10000000</span> <span class="keyword">and</span> <span class="number">10000010</span>;</span><br></pre></td></tr></table></figure>
<h4 id="6-6-4-其他优化思路"><a href="#6-6-4-其他优化思路" class="headerlink" title="6.6.4. 其他优化思路"></a>6.6.4. 其他优化思路</h4><ul>
<li>使用缓存，可预测性的提前查到内容，缓存至 redis 等 K-V 数据库中，查询时直接返回即可。</li>
<li>从需求的角度减少这种请求，不做类似的需求（直接跳转到几百万页之后的具体某一页，只允许逐页查看或者按照给定的路线走，这样可预测，可缓存）以及防止ID泄漏且连续被人恶意攻击。</li>
</ul>
<blockquote>
<p>Tips: 优化方式有多种，但其核心思想都一样，就是减少 load 的数据。</p>
</blockquote>
<h3 id="6-7-优化-count-查询"><a href="#6-7-优化-count-查询" class="headerlink" title="6.7. 优化 count 查询"></a>6.7. 优化 count 查询</h3><h4 id="6-7-1-优化思路"><a href="#6-7-1-优化思路" class="headerlink" title="6.7.1. 优化思路"></a>6.7.1. 优化思路</h4><p><code>COUNT()</code>是一个特殊的函数，有两种非常不同的作用：它可以统计某个列值的数量，也可以统计行数。</p>
<ul>
<li>统计列值，要求列值是非空的（不统计 NULL)。</li>
<li>统计结果集的行数，常用的就是 <code>COUNT(*)</code>。实际上，它会忽略所有的列而直接统计所有的行数。</li>
</ul>
<p>在大数据量的表中执行 <code>select count(*) from 表;</code> 的操作时，是非常耗时。不同的存储引擎会有不同的处理：</p>
<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 <code>count(*)</code> 的时候会直接返回这个数，效率很高；但是如果是带条件的 count 操作，MyISAM 也是非常慢。</li>
<li>InnoDB 引擎执行 <code>count(*)</code> 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数，因此效率非常底。</li>
</ul>
<p>通常来说，<code>COUNT()</code>都需要扫描大量的行（意味着要访问大量数据）才能获得精确的结果，因此是很难优化的。在 MySQL 层面能做的基本只有索引覆盖扫描了。如果说要大幅度提升 InnoDB 表的 count 效率，就需要考虑修改应用的架构，可以用估算值取代精确值，可以增加汇总表，或者增加类似 Redis 这样的外部缓存系统。</p>
<p>主要的优化思路：自己进行计数(可以借助于 redis 这样的数据库进行，但是如果是带条件的 count 操作还是比较麻烦)，新增/删除由自己来维护。或者在数据库增加一张专门维护表计数的表，每次新增/修改都在同一个事务中，可以保证数据的一致性，但同时增加维护的成本，并且也无法实现条件统计。</p>
<h4 id="6-7-2-count-的各种写法比较"><a href="#6-7-2-count-的各种写法比较" class="headerlink" title="6.7.2. count 的各种写法比较"></a>6.7.2. count 的各种写法比较</h4><p><code>count()</code> 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。主要用法有以下几种：</p>
<ul>
<li><code>count(主键)</code>：InnoDB 引擎会遍历整张表，把每一行的主键 id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null) </li>
<li><code>count(字段)</code>：分以下两种情况<ul>
<li>没有 not null 约束的字段：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为 null，不为 null 则计数累加。</li>
<li>有 not null 约束的字段：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</li>
</ul>
</li>
<li><code>count(数字)</code>：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，都赋指定的“数字”的值，直接按行进行累加。</li>
<li><code>count(*)</code>：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</li>
</ul>
<blockquote>
<p>Notes: 综上所述，按照效率的排序是，<code>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</code>，所以尽量使用 <code>count(*)</code>。</p>
</blockquote>
<h3 id="6-8-优化-update-语句"><a href="#6-8-优化-update-语句" class="headerlink" title="6.8. 优化 update 语句"></a>6.8. 优化 update 语句</h3><p>update 语句执行时的注意事项。当执行根据主键 id 更新的 SQL 语句时，会锁定 id 所在的一行的数据，然后事务提交之后，行锁释放。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;javaEE&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>
<p>但是当执行根据没有索引的字段更新的 SQL 时，行锁会升级为了表锁，导致该 update 语句的性能大大降低。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name 字段没有建索引</span></span><br><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;SpringBoot&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;PHP&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Notes: InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。因此更新数据时最好以索引列做为条件。</p>
</blockquote>
<h3 id="6-9-优化子查询"><a href="#6-9-优化子查询" class="headerlink" title="6.9. 优化子查询"></a>6.9. 优化子查询</h3><p>子查询的执行效率不高。子查询时，MySQL 需要为内层查询语句的查询结果建立一个临时表。然后外层查询语句再临时表中查询记录。查询完毕后，MySQL 需要撤销这些临时表。所以子查询的速度会受到一定的影响。如果查询的数据量比较大，影响速度就会随之增大。在 MySQL 中可以使用连接查询来代替子查询，连接查询不需要建立临时表，其速度比子查询要快。</p>
<p>有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> uid <span class="keyword">in</span> (<span class="keyword">select</span> uid <span class="keyword">from</span> user_role);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> u,user_role ur <span class="keyword">where</span> u.uid <span class="operator">=</span> ur.uid;</span><br></pre></td></tr></table></figure>
<p>连接(join)查询之所以更有效率一些 ，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p>
<h3 id="6-10-关联查询的优化"><a href="#6-10-关联查询的优化" class="headerlink" title="6.10. 关联查询的优化"></a>6.10. 关联查询的优化</h3><ul>
<li>关联字段加索引，让 mysql 做 join 操作时尽量选择 NLJ 算法（<em>详见后面的章节</em>）</li>
<li>小表驱动大表，写多表连接 sql 时如果明确知道哪张表是小表可以用 <code>straight_join</code> 写法固定连接驱动方式，省去 mysql 优化器判断的时间</li>
<li>尽量 inner join 而不用 left join 或者 right join（<em>如必须使用，一定要以小表为驱动</em>）。因为内连接会对两个表进行优化，优先把小表放到外边，把大表放到里边。而 left join 或 right join，不会重新调整顺序。</li>
</ul>
<blockquote>
<p>Tips: 使用 straight_join 一定要慎重，因为大部分情况下人为指定的执行顺序并不一定会比优化引擎选择的要更优，建议尽可能让优化器去判断。</p>
</blockquote>
<h3 id="6-11-in-和-exsits-优化"><a href="#6-11-in-和-exsits-优化" class="headerlink" title="6.11. in 和 exsits 优化"></a>6.11. in 和 exsits 优化</h3><p><code>in</code> 和 <code>exsits</code> 语句的优化原则是，<strong>小表驱动大表</strong>，即小的数据集驱动大的数据集。例如：</p>
<ul>
<li>当<code>in</code>关键字后面是子查询时，该查询是优先执行，因此下例当B表的数据集小于A表的数据集时，使用 <code>in</code> 优于 <code>exists</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> B)</span><br></pre></td></tr></table></figure>
<ul>
<li>当<code>exists</code>关键字后面是子查询时，外层的查询是优先于<code>exists</code>后面的子查询执行，因为下例中当A表的数据集小于B表的数据集时，使用 <code>exists</code> 优于 <code>in</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id <span class="operator">=</span> A.id)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: <code>EXISTS</code> 子查询也可以用 <code>JOIN</code> 来代替，但需要具体问题具体分析才能决定哪种方式最优</p>
</blockquote>
<h3 id="6-12-SQL-语法优化的总结"><a href="#6-12-SQL-语法优化的总结" class="headerlink" title="6.12. SQL 语法优化的总结"></a>6.12. SQL 语法优化的总结</h3><ol>
<li>使用<code>EXPLAIN</code>关键字去查看执行计划<ul>
<li><code>type</code>列，连接类型。一个好的 SQL 语句至少要达到 range 级别。杜绝出现 all 级别。</li>
<li><code>key</code>列，使用到的索引名。如果没有选择索引，值是 NULL。可以采取强制索引方式。</li>
<li><code>key_len</code>列，索引长度。</li>
<li><code>rows</code>列，扫描行数。该值是个预估值。</li>
<li><code>extra</code>列，详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。</li>
</ul>
</li>
<li>比较运算符能用<code>=</code>就不用<code>&lt;&gt;</code>，因为<code>=</code>增加了索引的使用几率。</li>
<li>如果确定只有一条查询结果，则使用<code>LIMIT 1</code>。可以避免全表扫描，找到对应结果后就不会再继续扫描了。使 EXPLAIN 中 type 列达到 const 类型</li>
<li>为列选择合适的数据类型。能用 TINYINT 就不用 SMALLINT，能用 SMALLINT 就不用 INT</li>
<li>将大的<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>查询变成多个小查询。一个执行几十行、几百行数据的 sql 尽量优化成多个小的 sql</li>
<li>如果结果集允许重复或者保证两个结果集不出现重复时，使用<code>UNION ALL</code>代替<code>UNION</code>，因为<code>UNION ALL</code>不去重，效率高于<code>UNION</code></li>
<li>尽量避免使用<code>SELECT *</code>，因为它会进行全表扫描，不能有效利用索引，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络 IO 开销</li>
<li><code>WHERE</code>子句、<code>JOIN</code>子句、<code>ORDER BY</code>的列里面的列尽量使用索引。根据实际情况进行调整，因为有时索引太多也会降低性能</li>
</ol>
<h2 id="7-高性能的索引策略"><a href="#7-高性能的索引策略" class="headerlink" title="7. 高性能的索引策略"></a>7. 高性能的索引策略</h2><p>索引可以快速的定位表中的某条记录。如果查询时不使用索引，查询语句将查询表中的所有字段，查询速度会很慢；如果使用索引进行查询，查询语句只查询索引字段，可以减少查询的记录数，提高查询速度。</p>
<h3 id="7-1-索引创建策略"><a href="#7-1-索引创建策略" class="headerlink" title="7.1. 索引创建策略"></a>7.1. 索引创建策略</h3><h4 id="7-1-1-索引列的类型尽量小"><a href="#7-1-1-索引列的类型尽量小" class="headerlink" title="7.1.1. 索引列的类型尽量小"></a>7.1.1. 索引列的类型尽量小</h4><p>类型大小指的就是该类型表示的数据范围的大小。原因如下：</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快（CPU 层次)</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p>此建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O。</p>
<h4 id="7-1-2-索引的选择性-离散性要高"><a href="#7-1-2-索引的选择性-离散性要高" class="headerlink" title="7.1.2. 索引的选择性/离散性要高"></a>7.1.2. 索引的选择性/离散性要高</h4><p>创建索引应该选择选择性/离散性高的列。索引的选择性/离散性是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数(N)的比值，范围从 1/N 到 1 之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p>
<p>很差的索引选择性就是列中的数据重复度很高，如：性别、是/否字典类字段等。计算索引的选择性/离散性如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> order_no)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) cnt <span class="keyword">FROM</span> order_exp;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> cnt    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.9676</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> order_status)<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) cnt <span class="keyword">FROM</span> order_exp;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> cnt    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">0.0001</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+</span></span><br></pre></td></tr></table></figure>
<p>显然，order_no 列上的索引就比 order_status 列上的索引的选择性就要好，离散性更高。</p>
<h4 id="7-1-3-前缀索引"><a href="#7-1-3-前缀索引" class="headerlink" title="7.1.3. 前缀索引"></a>7.1.3. 前缀索引</h4><p>当字段类型为字符串（varchar，text，longtext 等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO，影响查询效率。一种解决方案是<strong>模拟哈希索引</strong>。模拟哈希索引的做法：一个表中 a 字段很长，想把它作为一个索引，可以增加一个 a_hash 字段来存储 a 的哈希值，然后在 a_hash 上建立索引，相对于之前的索引速度会有明显提升，一个是对完整的 a 做索引，而后者则是用整数哈希值做索引，显然数字的比较比字符串的匹配要高效得多。</p>
<p>模拟哈希索引的缺点：</p>
<ol>
<li>需要额外维护 order_not_hash 字段；</li>
<li>哈希算法的选择决定了哈希冲突的概率，不良的哈希算法会导致重复值很多</li>
<li>不支持范围查找</li>
</ol>
<p>于是有改进的方案 - <font color=red><strong>前缀索引</strong></font>：就是以开始的一部分字符前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。一般情况下需要保证某个列前缀的选择性也是足够高的，以满足查询性能。（尤其对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，应该使用前缀索引，因为 MySQL 不允许索引这些列的完整长度）。创建语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式一：</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX 索引名称 <span class="keyword">ON</span> 表名(字段名(长度));</span><br><span class="line"><span class="comment">-- 方式二：</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD</span> KEY (字段名(长度));</span><br></pre></td></tr></table></figure>
<p>那么前缀索引的的长度选择多少最合适？诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间)。所谓的<font color=red><strong>选择性</strong></font>是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p>
<p>前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。即前缀的“基数”应该接近于完整列的“基数”。为了决定前缀的合适长度，可以找到最常见的值的列表，然后和最常见的前缀列表进行比较</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028477.png" alt=""></p>
<p>可以看见，从第 10 个开始选择性的增加值很高，随着前缀字符的越来越多，选择度也在不断上升，但是增长到第 15 时，已经和第 14 没太大差别了，选择性提升的幅度已经很小了，都非常接近整个列的选择性了。那么针对这个字段做前缀索引的话，从第 13 到第 15 都是不错的选择，甚至第 12 也不是不能考虑。然后就是创建索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> order_exp <span class="keyword">ADD</span> KEY (order_note(<span class="number">14</span>));</span><br></pre></td></tr></table></figure>
<p>前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点 MySQL 无法使用前缀索引做 <code>ORDER BY</code> 和 <code>GROUP BY</code>，也无法使用前缀索引做覆盖扫描。有时候<strong>后缀索引</strong> (suffix index)也有用途（例如，找到某个域名的所有电子邮件地址)。MySQL 原生并不支持反向索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器或者应用程序自行处理来维护索引。</p>
<p>前缀索引的查询流程图示：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028478.png" alt=""></p>
<h4 id="7-1-4-只为用于搜索、排序或分组的列创建索引"><a href="#7-1-4-只为用于搜索、排序或分组的列创建索引" class="headerlink" title="7.1.4. 只为用于搜索、排序或分组的列创建索引"></a>7.1.4. 只为用于搜索、排序或分组的列创建索引</h4><p>只为出现在<code>WHERE</code>子句中的列、连接子句中的连接列创建索引，而出现在查询列表中的列一般就没必要建立索引了，除非是需要使用覆盖索引；又或者为出现在<code>ORDER BY</code>或<code>GROUP BY</code>子句中的列创建索引</p>
<h4 id="7-1-5-多列索引列的顺序的选择"><a href="#7-1-5-多列索引列的顺序的选择" class="headerlink" title="7.1.5. 多列索引列的顺序的选择"></a>7.1.5. 多列索引列的顺序的选择</h4><p>建立索引的目的是：希望通过索引进行数据查找，减少随机IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>
<p>正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。在一个多列 B-Tree 索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的 ORDER BY、GROUP BY 和 DISTINCT 等子句的查询需求。</p>
<p>如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化 WHERE 条件的查找。在这种情况下，这样设计的索引确实能够最快地过滤出需要的行，对于在 WHERE 子句中只使用了索引部分前缀列的查询来说选择性也更高。</p>
<p>性能不只是依赖于索引列的选择性，也和查询条件的有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序，比如排序和分组，让这种情况下索引的选择性最高。同时在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。</p>
<p>索引列顺序的选择总结如下：</p>
<ul>
<li><strong>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；</strong></li>
<li><strong>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；</strong></li>
<li><strong>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。</strong></li>
</ul>
<h4 id="7-1-6-设计三星索引"><a href="#7-1-6-设计三星索引" class="headerlink" title="7.1.6. 设计三星索引"></a>7.1.6. 设计三星索引</h4><h5 id="7-1-6-1-概念"><a href="#7-1-6-1-概念" class="headerlink" title="7.1.6.1. 概念"></a>7.1.6.1. 概念</h5><p>对于一个查询而言，一个三星索引，可能是其最好的索引。如果查询使用三星索引，一次查询通常只需要进行一次磁盘随机读以及一次窄索引片的扫描，因此其相应时间通常比使用一个普通索引的响应时间少几个数量级。</p>
<blockquote>
<p>三星索引概念是在《Rrelational Database Index Design and the optimizers》 一书中提出来的。原文如下：</p>
<p>The index earns one star if it places relevant rows adjacent to each other, a second star if its rows are sorted in the order the query needs, and a final star if it contains all the columns needed for the query.</p>
<p>索引将相关的记录放到一起则获得一星；如果索引中的数据顺序和查找中的排列顺序一致则获得二星；如果索引中的列包含了查询中需要的全部列则获得三星。</p>
</blockquote>
<p><strong>一星</strong>：</p>
<p>如果一个查询相关的索引行是相邻的或者至少相距足够靠近的话，必须扫描的索引片宽度就会缩至最短，也就是说，让索引片尽量变窄，也就是我们所说的索引的扫描范围越小越好。</p>
<p><strong>二星（排序星）</strong>：</p>
<p>在满足一星的情况下，当查询需要排序，group by、 order by，如果查询所需的顺序与索引是一致的（索引本身是有序的），是不是就可以不用再另外排序了，一般来说排序可是影响性能的关键因素。</p>
<p><strong>三星（宽索引星）</strong>：</p>
<p>在满足了二星的情况下，如果索引中所包含了这个查询所需的所有列（包括 <code>where</code> 子句 和 <code>select</code> 子句中所需的列，也就是覆盖索引），这样一来，查询就不再需要回表了，减少了查询的步骤和 IO 请求次数，性能几乎可以提升一倍。</p>
<p>第三颗星是最重要。因为将一个列排除在索引之外可能会导致很多磁盘随机读（回表操作）。第一和第二颗星重要性差不多，可以理解为第三颗星比重是 50%，第一颗星为 27%，第二颗星为 23%，所以在大部分的情况下，会先考虑第一颗星，但会根据业务情况调整这两颗星的优先度。</p>
<h5 id="7-1-6-2-达成三星索引"><a href="#7-1-6-2-达成三星索引" class="headerlink" title="7.1.6.2. 达成三星索引"></a>7.1.6.2. 达成三星索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create table</span> customer(</span><br><span class="line">    cno <span class="type">int</span>,</span><br><span class="line">    lname <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    fname <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    sex <span class="type">int</span>,</span><br><span class="line">    weight <span class="type">int</span>,</span><br><span class="line">    city <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_cust <span class="keyword">on</span> customer(city, lname, fname, cno);</span><br></pre></td></tr></table></figure>
<p>符合三星索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cno,fname <span class="keyword">from</span> customer <span class="keyword">where</span> lname <span class="operator">=</span>’xx’ <span class="keyword">and</span> city <span class="operator">=</span>’yy’ <span class="keyword">order</span> <span class="keyword">by</span> fname;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一颗星：所有等值谓词的列，是组合索引的开头的列，可以把索引片缩得很窄，符合。</li>
<li>第二颗星：order by 的 fname 字段在组合索引中且是索引自动排序好的，符合。</li>
<li>第三颗星：select 中的 cno 字段、fname 字段在组合索引中存在，符合。</li>
</ul>
<h5 id="7-1-6-3-达不成三星索引"><a href="#7-1-6-3-达不成三星索引" class="headerlink" title="7.1.6.3. 达不成三星索引"></a>7.1.6.3. 达不成三星索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> `test` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `user_name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `sex` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `c_date` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">12</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<p>达不到三星索引的sql分析</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name,sex,age <span class="keyword">from</span> test <span class="keyword">where</span> user_name <span class="keyword">like</span> <span class="string">&#x27;test%&#x27;</span> <span class="keyword">and</span> sex <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br></pre></td></tr></table></figure>
<p>如果建立索引(user_name,sex,age)：</p>
<ul>
<li>第三颗星，满足</li>
<li>第一颗星，满足</li>
<li>第二颗星，不满足，user_name 采用了范围匹配，sex 是过滤列，此时 age 列无法保证有序的。</li>
</ul>
<p>如果建立索引(sex, age，user_name)：</p>
<ul>
<li>第一颗星，不满足，只可以匹配到 sex，sex 选择性很差，意味着是一个宽索引片</li>
<li>第二颗星，满足，等值 sex 的情况下，age 是有序的</li>
<li>第三颗星，满足，select 查询的列都在索引列中</li>
</ul>
<p>以上2个索引，都是无法同时满足三星索引设计中的三个需求的，只能尽力满足2个。而在多数情况下，能够满足2颗星，已经能缩小很大的查询范围了，具体最终要保留那一颗星（排序星 or 窄索引片星）</p>
<h4 id="7-1-7-主键索引设计原则"><a href="#7-1-7-主键索引设计原则" class="headerlink" title="7.1.7. 主键索引设计原则"></a>7.1.7. 主键索引设计原则</h4><ul>
<li>选择很少修改的列做为主键。因为行是按照聚集索引物理排序的，如果主键频繁改变(update)，物理顺序会改变，MySQL 要不断调整 B+树，并且中间可能会产生页面的分裂和合并等等，会导致性能会急剧降低。</li>
<li>满足业务需求的情况下，尽量降低主键的长度。</li>
<li>插入数据时，尽量选择顺序插入，选择使用 <code>AUTO_INCREMENT</code> 自增主键。</li>
<li>尽量不要使用 UUID 做主键或者是其他自然主键，如身份证号。因为其数值既是乱序，长度又过长</li>
<li>业务操作时，避免对主键的修改。</li>
</ul>
<h4 id="7-1-8-避免建立冗余索引和重复索引"><a href="#7-1-8-避免建立冗余索引和重复索引" class="headerlink" title="7.1.8. 避免建立冗余索引和重复索引"></a>7.1.8. 避免建立冗余索引和重复索引</h4><p>建立冗余索引和重复索引，这样会增加查询优化器生成执行计划的时间。需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。</p>
<ul>
<li><strong>重复索引示例：primary key(id)、index(id)、unique index(id)</strong></li>
<li><strong>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</strong></li>
</ul>
<p>冗余索引和重复索引有一些不同。如果创建了索引(A,B)，再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引。因此索引(A,B)也可以当作索引(A)来使用（这种冗余只是对 B-Tree 索引来说的)。但是如果再创建索引 (B,A)，则不是冗余索引，索引(B)也不是，因为 B 不是索引(A,B)的最左前缀列。已有的索引(A)，扩展为(A，ID)，其中 ID 是主键，对于 InnoDB 来说主键列已经包含在二级索引中了，所以这也是冗余的。</p>
<p>删除冗余索引和重复索引，但首先要做的是找出这样的索引。可以通过写一些复杂的访问<code>INFORMATION_SCHEMA</code>表的查询来找</p>
<h4 id="7-1-9-删除未使用的索引"><a href="#7-1-9-删除未使用的索引" class="headerlink" title="7.1.9. 删除未使用的索引"></a>7.1.9. 删除未使用的索引</h4><p>有一些表永远不用的索引，建议考虑删除。</p>
<h4 id="7-1-10-不建议使用索引的情况"><a href="#7-1-10-不建议使用索引的情况" class="headerlink" title="7.1.10. 不建议使用索引的情况"></a>7.1.10. 不建议使用索引的情况</h4><ul>
<li>where 条件中用不到的字段不适合建立索引</li>
<li>表记录较少</li>
<li>需要经常增删改的表或者字段</li>
<li>参与列计算的列不适合建索引</li>
</ul>
<h3 id="7-2-索引使用策略"><a href="#7-2-索引使用策略" class="headerlink" title="7.2. 索引使用策略"></a>7.2. 索引使用策略</h3><blockquote>
<p>Tips: 若不按以下策略使用索引，可能会导致索引失效。</p>
</blockquote>
<h4 id="7-2-1-不在索引列上做任何操作"><a href="#7-2-1-不在索引列上做任何操作" class="headerlink" title="7.2.1. 不在索引列上做任何操作"></a>7.2.1. 不在索引列上做任何操作</h4><p>如果查询中的列不是独立的，则 MySQL 就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。即不在索引列上做任何的逻辑处理</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_status <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> TO_DAYS(insert_time) <span class="operator">-</span> TO_DAYS(expire_time) <span class="operator">&lt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>WHERE 中的表达式其实等价于<code>order_status = 0</code>，但是 MySQL 无法自动解析这个方程式；在索引列上使用函数，也是无法利用索引的。</p>
<h4 id="7-2-2-尽量全值匹配"><a href="#7-2-2-尽量全值匹配" class="headerlink" title="7.2.2. 尽量全值匹配"></a>7.2.2. 尽量全值匹配</h4><p>建立了联合索引列后，如果搜索条件中的列和索引列一致的话，这种情况就称为全值匹配</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">and</span> order_status<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> expire_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上述语句的联合索引中的三个列都用到。<font color=red>值得注意是，WHERE 子句中的几个<code>and</code>连接的搜索条件的顺序对查询结果是否使用索引，是没有任何影响</font>。查询优化器会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。</p>
<h4 id="7-2-3-最佳左前缀法则"><a href="#7-2-3-最佳左前缀法则" class="headerlink" title="7.2.3. 最佳左前缀法则"></a>7.2.3. 最佳左前缀法则</h4><p>建立了联合索引列，尽管在查询语句中无法包含全部联合索引中的列，但也要遵守最左前缀法则。『最左前缀法则』指的是查询从索引的最左前列开始并且不跳过索引中的列，并且遇到范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>)就停止匹配</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 联合索引</span></span><br><span class="line">index(a,b,c)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 能使用索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 无法使用索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> b <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> c <span class="operator">=</span> <span class="string">&#x27;3&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>根据联合索引的数据结构可以分析，索引是先按a，再按b，最后按c来进行排序，如果跳过a直接使用b或者c去匹配，因为b与c可能是乱序，所以查询优化器可能就会直接选择全表扫描。如下图，对(a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当a相等时，会根据b进行排序）。直接执行 <code>b = 2</code> 这种查询条件无法使用索引。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028479.png" alt=""></p>
<p>如果想使用联合索引中尽可能多的列，<font color=red><strong>搜索条件中的各个列必须是联合索引中从最左边连续的列</strong></font>。</p>
<blockquote>
<p>Tips: 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与编写SQL时<font color=red><strong>条件的先后顺序无关</strong></font>。mysql的查询优化器会优化成索引可以识别的形式。</p>
</blockquote>
<h4 id="7-2-4-范围条件放最后"><a href="#7-2-4-范围条件放最后" class="headerlink" title="7.2.4. 范围条件放最后"></a>7.2.4. 范围条件放最后</h4><p>这一点，也是针对联合索引而言。所有记录都是按照索引列的值从小到大的顺序排好序的，而联合索引则是按创建索引时的顺序进行分组排序。</p>
<p>对于一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp_cut <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">and</span> order_status<span class="operator">=</span><span class="number">0</span> <span class="keyword">and</span> expire_time<span class="operator">&gt;</span><span class="string">&#x27;2021-03-22 18:23:57&#x27;</span> <span class="keyword">and</span> expire_time<span class="operator">&lt;</span><span class="string">&#x27;2021-03-22 18:35:00&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>         <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys    <span class="operator">|</span> key              <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> order_exp_cut <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> <span class="number">13</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
<p>中间有范围查询会导致后面的列全部失效，无法充分利用这个联合索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> order_exp_cut <span class="keyword">where</span> insert_time<span class="operator">=</span><span class="string">&#x27;2021-03-22 18:23:42&#x27;</span> <span class="keyword">and</span> order_status<span class="operator">&gt;</span><span class="number">-1</span> <span class="keyword">and</span> expire_time<span class="operator">&gt;</span><span class="string">&#x27;2021-03-22 18:35:14&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>         <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys    <span class="operator">|</span> key              <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> order_exp_cut <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> <span class="number">8</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>    <span class="number">50.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="keyword">condition</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+------+------+----------+-----------------------+</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Notes: 当范围查询使用 <code>&gt;=</code> 或 <code>&lt;=</code> 时，是可以使用联合索引（待验证）</p>
</blockquote>
<h4 id="7-2-5-优先使用覆盖索引"><a href="#7-2-5-优先使用覆盖索引" class="headerlink" title="7.2.5. 优先使用覆盖索引"></a>7.2.5. 优先使用覆盖索引</h4><p><strong>覆盖索引</strong>：是指查询使用了索引，并且需要返回索引所包含的列，即包含了所有查询字段(where, select, ordery by, group by 包含的字段)的索引。</p>
<p>对于频繁的查询优先考虑使用覆盖索引。覆盖索引是非常有用的工具，能够极大地提高性能，三星索引里最重要的那颗星就是宽索引星。查询只需要扫描索引而无须回表的有以下好处：</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那 MySQL 就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于 I/O 密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中。</li>
<li><strong>可以把随机IO变成顺序IO加快查询效率</strong>。由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。。</li>
<li>由于 InnoDB 的聚簇索引，覆盖索引对 InnoDB 表特别有用。InnoDB 的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li>
</ul>
<p>所以尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，不是必要的情况下减少<code>select *</code>，除非是需要将表中的全部列检索后，进行缓存。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp_cut <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2022-08-04 10:39:11&#x27;</span> <span class="keyword">AND</span> order_status <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> expire_time <span class="operator">=</span> <span class="string">&#x27;2022-08-04 10:39:16&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>         <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys    <span class="operator">|</span> key              <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> order_exp_cut <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> <span class="number">13</span>      <span class="operator">|</span> const,const,const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+-------------------+------+----------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> expire_time,id <span class="keyword">FROM</span> order_exp_cut <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2022-08-04 10:39:11&#x27;</span> <span class="keyword">AND</span> order_status <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> expire_time <span class="operator">=</span> <span class="string">&#x27;2022-08-04 10:39:16&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+-------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>         <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys    <span class="operator">|</span> key              <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+-------------------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> order_exp_cut <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> const <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> u_idx_day_status <span class="operator">|</span> <span class="number">13</span>      <span class="operator">|</span> const,const,const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------------+------------+-------+------------------+------------------+---------+-------------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="7-2-6-不等于要慎用"><a href="#7-2-6-不等于要慎用" class="headerlink" title="7.2.6. 不等于要慎用"></a>7.2.6. 不等于要慎用</h4><p>mysql 在使用不等于(<code>!=</code>或者<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">&lt;&gt;</span> <span class="string">&#x27;DD00_6S&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>     <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>  <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> order_exp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> idx_order_no  <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">10311</span> <span class="operator">|</span>    <span class="number">55.93</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+-------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="7-2-7-null-not-Null-对索引的影响"><a href="#7-2-7-null-not-Null-对索引的影响" class="headerlink" title="7.2.7. null / not Null 对索引的影响"></a>7.2.7. null / not Null 对索引的影响</h4><p>需要注意搜索条件是 null/not null 对索引的可能影响</p>
<ul>
<li><code>is not null</code> 容易导致索引失效。</li>
<li><code>is null</code> 则会区分被检索的列是否允许为 null，如果可以为 null 则会走 ref 类型的索引访问；如果不能为 null，也是全表扫描。</li>
</ul>
<p>注意：如果联合索引上使用时覆盖索引时，情况又不同，可以使用上索引。</p>
<h4 id="7-2-8-注意使用-LIKE-关键字"><a href="#7-2-8-注意使用-LIKE-关键字" class="headerlink" title="7.2.8. 注意使用 LIKE 关键字"></a>7.2.8. 注意使用 LIKE 关键字</h4><p>在查询语句中使用<code>LIKE</code>关键字进行查询时，如果匹配字符串的第一个字符为 <code>%</code> 时，索引将不会被使用。如果 <code>%</code> 不是在第一个位置，索引就会被使用。</p>
<p>如果使用覆盖索引可以改善这个索引失效的问题。即在<code>select</code>语句中只查询索引列，则即使在开始使用 <code>%</code> 进行匹配，索引也会被使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 索引列<span class="number">1</span>,索引列<span class="number">2</span>,... <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> 索引列 <span class="keyword">like</span> <span class="string">&#x27;%xxx&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h5 id="7-2-8-1-索引下推"><a href="#7-2-8-1-索引下推" class="headerlink" title="7.2.8.1. 索引下推"></a>7.2.8.1. 索引下推</h5><p>索引下推（Index Condition Pushdown，ICP），对于使用辅助的联合索引，正常情况按照最左前缀原则，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test_table <span class="keyword">WHERE</span> `name` <span class="keyword">like</span> <span class="string">&#x27;moon%&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">AND</span> position <span class="operator">=</span><span class="string">&#x27;manager&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如上情况只会走 name 字段索引，因为根据 name 字段过滤完，得到的索引行里的 age 和 position 是无序的，无法很好的利用索引。</p>
<ul>
<li>在 MySQL 5.6 之前的版本，此查询只能在联合索引里匹配到名字是<code>&#39;moon&#39;</code>开头的索引，然后拿这些索引对应的主键逐个回表，到主键索引上找出相应的记录，再比对 age 和 position 这两个字段的值是否符合。</li>
<li>MySQL 5.6 以后版本引入了索引下推优化，可以在索引遍历过程中，对索引中包含的所有字段先做判断，过滤掉不符合条件的记录之后再回表，可以有效的减少回表次数。使用了索引下推优化后，上面那个查询在联合索引里匹配到名字是<code>&#39;moon&#39;</code>开头的索引之后，同时还会在索引里过滤 age 和 position 这两个字段，将过滤完后剩下的索引对应的主键再回表查整行数据。</li>
</ul>
<p>索引下推会减少回表次数，对于 innodb 引擎的表索引下推只能用于二级索引(辅助索引)或联合索引(复合索引)，innodb 的主键索引（聚簇索引）树叶子节点上保存的是全行数据，所以这个时候索引下推并不会起到减少查询全行数据的效果。</p>
<blockquote>
<p>Tips: 在某些范围查询中，如果根据首个字段范围查找过滤的结果集过大（已接近全表扫描），然后每条记录还进行索引下推比对，此时 MySQL 会认为使用索引下推的方式反而会加大查询成本，因此就会选择不使用索引下推。</p>
</blockquote>
<h4 id="7-2-9-字符类型加引号"><a href="#7-2-9-字符类型加引号" class="headerlink" title="7.2.9. 字符类型加引号"></a>7.2.9. 字符类型加引号</h4><p>搜索条件列为字符串时，如果不加单引号，会导致索引失效。因为 MySQL 的查询优化器，会自动的进行类型转换（隐式转换），然后再进行比较，自然造成索引失效。</p>
<h4 id="7-2-10-查询语句中使用-OR-关键字"><a href="#7-2-10-查询语句中使用-OR-关键字" class="headerlink" title="7.2.10. 查询语句中使用 OR 关键字"></a>7.2.10. 查询语句中使用 OR 关键字</h4><p>查询语句只有<code>OR</code>关键字时，如果<code>OR</code>前后的两个条件的列都是索引时，查询中将使用索引；如果<code>OR</code>前后有其中一个条件的列不是索引，查询中将不使用索引。</p>
<h4 id="7-2-11-使用索引扫描来做排序和分组"><a href="#7-2-11-使用索引扫描来做排序和分组" class="headerlink" title="7.2.11. 使用索引扫描来做排序和分组"></a>7.2.11. 使用索引扫描来做排序和分组</h4><p>只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL 才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。</p>
<h4 id="7-2-12-排序要当心"><a href="#7-2-12-排序要当心" class="headerlink" title="7.2.12. 排序要当心"></a>7.2.12. 排序要当心</h4><ul>
<li>ASC、DESC 两种排序别混用。对于使用联合索引进行排序的场景，各个排序列的排序顺序是一致的，也就是要么各个列都是 ASC 规则排序，要么都是 DESC 规则排序。</li>
<li>排序列包含非同一个索引的列。这种情况也不能使用索引进行排序</li>
</ul>
<h4 id="7-2-13-索引-SET-规范"><a href="#7-2-13-索引-SET-规范" class="headerlink" title="7.2.13. 索引 SET 规范"></a>7.2.13. 索引 SET 规范</h4><p><strong>尽量避免使用外键约束</strong></p>
<ul>
<li>不建议使用外键约束（foreign key），但<font color=red><strong>一定要在表与表之间的关联键上建立索引</strong></font>。</li>
<li>外键可用于保证数据的参照完整性，但建议在业务端实现。</li>
<li>外键会影响父表和子表的写操作从而降低性能。</li>
</ul>
<h4 id="7-2-14-查询语句中使用联合（多列）索引"><a href="#7-2-14-查询语句中使用联合（多列）索引" class="headerlink" title="7.2.14. 查询语句中使用联合（多列）索引"></a>7.2.14. 查询语句中使用联合（多列）索引</h4><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。联合（多列）索引是在表的多个字段上创建一个索引。</p>
<p>如果查询使用的是联合索引，具体的结构示意图如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028480.png" alt=""></p>
<p>只有查询条件中使用了联合索引中第一个字段时，索引才会被使用；如果查询条件中只使用多列索引中非首个字段的其他字段时，索引将会失效。<em>这就是“最佳左前缀法则”原理</em>。</p>
<h4 id="7-2-15-少创建多个单列索引"><a href="#7-2-15-少创建多个单列索引" class="headerlink" title="7.2.15. 少创建多个单列索引"></a>7.2.15. 少创建多个单列索引</h4><p>如果一个表创建了多个单列索引，即使<code>where</code>查询条件中都使用这些索引列，但也只会匹配一个最优索引生效。所以一般建议使用组合索引。</p>
<h4 id="7-2-16-in-not-in-对索引的影响"><a href="#7-2-16-in-not-in-对索引的影响" class="headerlink" title="7.2.16. in / not in 对索引的影响"></a>7.2.16. in / not in 对索引的影响</h4><p>在索引列使用 <code>in</code> 查询条件，是可以使用索引；但使用 <code>not in</code> 则索引失效。</p>
<p>如果是主键索引，则 <code>in</code> 和 <code>not in</code>，均可使用索引。</p>
<h4 id="7-2-17-主键顺序插入优化"><a href="#7-2-17-主键顺序插入优化" class="headerlink" title="7.2.17. 主键顺序插入优化"></a>7.2.17. 主键顺序插入优化</h4><p>以下分析主键顺序插入的性能是要高于乱序插入的原因</p>
<h5 id="7-2-17-1-数据组织方式"><a href="#7-2-17-1-数据组织方式" class="headerlink" title="7.2.17.1. 数据组织方式"></a>7.2.17.1. 数据组织方式</h5><p>在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p>
<p>行数据，都是存储在聚集索引的叶子节点上的。InnoDB 的逻辑结构图（<em>引用于《MySQL数据库01-体系架构》笔记</em>）：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028481.png" alt=""></p>
<p>在 InnoDB 引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着，一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。</p>
<h5 id="7-2-17-2-页分裂"><a href="#7-2-17-2-页分裂" class="headerlink" title="7.2.17.2. 页分裂"></a>7.2.17.2. 页分裂</h5><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p>
<h5 id="7-2-17-3-主键顺序插入效果"><a href="#7-2-17-3-主键顺序插入效果" class="headerlink" title="7.2.17.3. 主键顺序插入效果"></a>7.2.17.3. 主键顺序插入效果</h5><ol>
<li>从磁盘中申请页，主键顺序插入</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028482.png" alt=""></p>
<ol>
<li>第一个页没有满，继续往第一页插入</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028483.png" alt=""></p>
<ol>
<li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028484.png" alt=""></p>
<ol>
<li>当第二页写满了，再往第三页写入</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028485.png" alt=""></p>
<h5 id="7-2-17-4-主键乱序插入效果"><a href="#7-2-17-4-主键乱序插入效果" class="headerlink" title="7.2.17.4. 主键乱序插入效果"></a>7.2.17.4. 主键乱序插入效果</h5><p>假设加入1#,2#页都已经写满了，存放了如图所示的数据</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028486.png" alt=""></p>
<p>此时再插入id为50的记录，是不会开启新一个页</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028487.png" alt=""></p>
<p>因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028488.png" alt=""></p>
<p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。那么此时会开辟一个新的页3#。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028489.png" alt=""></p>
<p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028490.png" alt=""></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028491.png" alt=""></p>
<p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。1#的下一个页，应该是3#，3#的下一个页是2#。所以，此时，需要重新设置链表指针。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028492.png" alt=""></p>
<p>上述的这种现象，称之为”页分裂”，是比较耗费性能的操作。</p>
<h5 id="7-2-17-5-页合并"><a href="#7-2-17-5-页合并" class="headerlink" title="7.2.17.5. 页合并"></a>7.2.17.5. 页合并</h5><p>目前表中已有数据的索引结构(叶子节点)如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028493.png" alt=""></p>
<p>当对已有数据进行删除时，具体的效果如下：</p>
<p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028494.png" alt=""></p>
<p>当继续删除2#的数据记录</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028495.png" alt=""></p>
<p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB 会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028496.png" alt=""></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028497.png" alt=""></p>
<p>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028498.png" alt=""></p>
<p>这个里面所发生的合并页的这个现象，就称之为”页合并”。</p>
<blockquote>
<p>Tips: <code>MERGE_THRESHOLD</code> 合并页的阈值，可以自行设置，在创建表或者创建索引时指定。</p>
</blockquote>
<h4 id="7-2-18-SQL-提示"><a href="#7-2-18-SQL-提示" class="headerlink" title="7.2.18. SQL 提示"></a>7.2.18. SQL 提示</h4><p>SQL 提示，是优化数据库的一个重要手段，即是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。</p>
<ul>
<li><code>use index</code>：建议 MySQL 使用哪一个索引完成此次查询（仅仅是建议，mysql 内部还会再次进行评估是否使用索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> <span class="number">36</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ignore index</code>：忽略指定的索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>    <span class="number">10.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>force index</code>：强制使用索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>   <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys        <span class="operator">|</span> key                  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> tb_user <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> idx_user_pro_age_sta <span class="operator">|</span> <span class="number">36</span>      <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">NULL</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+---------+------------+------+----------------------+----------------------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure>
<h3 id="7-3-索引策略总结"><a href="#7-3-索引策略总结" class="headerlink" title="7.3. 索引策略总结"></a>7.3. 索引策略总结</h3><ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li><strong>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列，或者包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</strong>。但并不建议将符合 <code>where</code> 和 <code>ORDER BY</code>、<code>GROUP BY</code> 中的字段的列都各自建立一个索引，通常是建立联合索引效果更好</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li>
<li>要控制索引的数量，索引并不是越多越好。索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li>
<li>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。</li>
<li><strong>多表join的关联列</strong></li>
<li>联合索引是否被使用判断总结（下图引用自网络）：</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028499.png" alt=""></p>
<blockquote>
<p>Tips: <code>like KK%</code> 相当于<code>=常量</code>，<code>%KK</code>和<code>%KK%</code>相当于范围查询</p>
</blockquote>
<h2 id="8-MySQL-的查询成本"><a href="#8-MySQL-的查询成本" class="headerlink" title="8. MySQL 的查询成本"></a>8. MySQL 的查询成本</h2><h3 id="8-1-成本的概念"><a href="#8-1-成本的概念" class="headerlink" title="8.1. 成本的概念"></a>8.1. 成本的概念</h3><p>MySQL 执行一个查询可以有不同的执行方案，它会选择其中成本最低，或者说代价最低的那种方案去真正的执行查询。在 MySQL 中一条查询语句的执行成本是由下边这两个方面组成的：</p>
<ul>
<li><strong>I/O 成本</strong>：数据库的表经常使用的 MyISAM、InnoDB 存储引擎都是将数据和索引都存储到磁盘上的，当查询表中的记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称之为 I/O 成本。</li>
<li><strong>CPU 成本</strong>：读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 CPU 成本</li>
</ul>
<p>对于 InnoDB 存储引擎来说，页是磁盘和内存之间交互的基本单位，MySQL 规定读取一个页面花费的成本默认是1.0，读取以及检测一条记录是否符合搜索条件的成本默认是0.2。1.0、0.2 这些数字称之为成本常数，这两个成本常数最常用到，当然还有其他的成本常数。</p>
<p>注意，不管读取记录时需不需要检测是否满足搜索条件，其成本都算是0.2。</p>
<h3 id="8-2-单表查询的成本-基于成本的优化步骤（TODO-mark-待补充）"><a href="#8-2-单表查询的成本-基于成本的优化步骤（TODO-mark-待补充）" class="headerlink" title="8.2. 单表查询的成本 - 基于成本的优化步骤（TODO mark: 待补充）"></a>8.2. 单表查询的成本 - 基于成本的优化步骤（TODO mark: 待补充）</h3><p>在一条单表查询语句真正执行之前，MySQL 的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查询，这个过程主要是：</p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
<p>示例成本分析sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	order_exp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	order_no <span class="keyword">IN</span> ( <span class="string">&#x27;DD00_6S&#x27;</span>, <span class="string">&#x27;DD00_9S&#x27;</span>, <span class="string">&#x27;DD00_10S&#x27;</span> )</span><br><span class="line">	<span class="keyword">AND</span> expire_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-03-22 18:28:28&#x27;</span></span><br><span class="line">	<span class="keyword">AND</span> expire_time <span class="operator">&lt;=</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span> <span class="keyword">AND</span> insert_time <span class="operator">&gt;</span> expire_time</span><br><span class="line">	<span class="keyword">AND</span> order_note <span class="keyword">LIKE</span> <span class="string">&#x27;%7 排 1%&#x27;</span></span><br><span class="line">	<span class="keyword">AND</span> order_status <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="8-2-1-根据搜索条件，找出所有可能使用的索引"><a href="#8-2-1-根据搜索条件，找出所有可能使用的索引" class="headerlink" title="8.2.1. 根据搜索条件，找出所有可能使用的索引"></a>8.2.1. 根据搜索条件，找出所有可能使用的索引</h4><p>对于 B+树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者 <code>LIKE</code> 操作符连接起来，就可以产生一个所谓的范围区间（<code>LIKE</code>匹配字符串前缀也行），MySQL 把一个查询中可能使用到的索引称之为 possible keys。</p>
<h3 id="8-3-！待整理-单表查询的成本-基于索引统计数据的成本计算"><a href="#8-3-！待整理-单表查询的成本-基于索引统计数据的成本计算" class="headerlink" title="8.3. (！待整理)单表查询的成本 - 基于索引统计数据的成本计算"></a>8.3. (！待整理)单表查询的成本 - 基于索引统计数据的成本计算</h3><blockquote>
<p>TODO: 整理中</p>
</blockquote>
<h3 id="8-4-！待整理-EXPLAIN-输出成本"><a href="#8-4-！待整理-EXPLAIN-输出成本" class="headerlink" title="8.4. (！待整理)EXPLAIN 输出成本"></a>8.4. (！待整理)EXPLAIN 输出成本</h3><blockquote>
<p>TODO: 整理中</p>
</blockquote>
<h3 id="8-5-Optimizer-Trace-分析优化器执行计划"><a href="#8-5-Optimizer-Trace-分析优化器执行计划" class="headerlink" title="8.5. Optimizer Trace 分析优化器执行计划"></a>8.5. Optimizer Trace 分析优化器执行计划</h3><p>对于 MySQL5.6 之前的版本来说，只能通过 <code>EXPLAIN</code> 语句查看到最后优化器决定使用的执行计划，却无法知道它为什么做这个决策。</p>
<p>在 MySQL 5.6 以及之后的版本中，MySQL 提出了一个 optimizer trace 的功能，这个功能可以让我们方便的查看优化器生成执行计划的整个过程，这个功能的开启与关闭由系统变量 <code>optimizer_trace</code> 决定</p>
<h4 id="8-5-1-检查是否开启-Trace-功能"><a href="#8-5-1-检查是否开启-Trace-功能" class="headerlink" title="8.5.1. 检查是否开启 Trace 功能"></a>8.5.1. 检查是否开启 Trace 功能</h4><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;optimizer_trace&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+--------------------------+</span><br><span class="line">| Variable_name   | Value                    |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">| optimizer_trace | enabled=off,one_line=off |</span><br><span class="line">+-----------------+--------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>从输出结果可知。<code>enabled</code> 值为 <code>off</code>，表明这个功能默认是关闭的。<code>one_line</code> 的值是控制输出格式是否在一行显示，如果为 <code>on</code> 那么所有输出都将在一行中展示。</p>
<h4 id="8-5-2-使用-Trace-功能"><a href="#8-5-2-使用-Trace-功能" class="headerlink" title="8.5.2. 使用 Trace 功能"></a>8.5.2. 使用 Trace 功能</h4><p>开启 Trace 功能，必须首先把 <code>enabled</code> 的值改为 <code>on</code>。同时可设置格式为JSON，并设置 trace 最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>
<p>输入想要查看优化过程的查询语句，当该查询语句执行完成后，就可以到 information_schema 数据库下的 OPTIMIZER_TRACE 表中查看完整的优化过程。 OPTIMIZER_TRACE 表有 4 个列，分别是：</p>
<ul>
<li>QUERY：表示执行的查询语句。</li>
<li>TRACE：表示优化过程的 JSON 格式文本。</li>
<li>MISSING_BYTES_BEYOND_MAX_MEM_SIZE：由于优化过程可能会输出很多，如果超过某个限制时，多余的文本将不会被显示，这个字段展示了被忽略的文本字节数。</li>
<li>INSUFFICIENT_PRIVILEGES：表示是否没有权限查看优化过程，默认值是 0，只有某些特殊情况下才会是 1，暂时不关心这个字段的值。</li>
</ul>
<p>最后，输入以下查询语句，检查 information_schema.optimizer_trace 就可以知道 MySQL 是如何执行 SQL 的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.OPTIMIZER_TRACE \G;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028500.png" alt=""></p>
<blockquote>
<p>注：展示的内容极多，日后需要时再慢慢了解</p>
</blockquote>
<p>最后当停止查看语句的优化过程时，把 optimizer trace 功能关闭</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=off&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="8-5-3-注意事项"><a href="#8-5-3-注意事项" class="headerlink" title="8.5.3. 注意事项"></a>8.5.3. 注意事项</h4><font color=red>**开启 trace 会影响 mysql 性能，所以只能临时分析 sql 使用，用完之后立即关闭**</font>

<h3 id="8-6-连接查询的成本"><a href="#8-6-连接查询的成本" class="headerlink" title="8.6. 连接查询的成本"></a>8.6. 连接查询的成本</h3><p><strong>连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数(即从驱动表查出的记录数) x 单次访问被驱动表的成本</strong></p>
<h3 id="8-7-！待整理-调节成本常数"><a href="#8-7-！待整理-调节成本常数" class="headerlink" title="8.7. (！待整理)调节成本常数"></a>8.7. (！待整理)调节成本常数</h3><blockquote>
<p>TODO: 整理中</p>
</blockquote>
<h2 id="9-全局考虑性能优化"><a href="#9-全局考虑性能优化" class="headerlink" title="9. 全局考虑性能优化"></a>9. 全局考虑性能优化</h2><h3 id="9-1-为什么查询速度会慢"><a href="#9-1-为什么查询速度会慢" class="headerlink" title="9.1. 为什么查询速度会慢"></a>9.1. 为什么查询速度会慢</h3><p>快速的查询，真正重要是响应时间。如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。</p>
<p>MySQL 查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。</p>
<p>在完成这些任务的时候，查询需要在不同的地方花费时间，包括网络，CPU计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作，CPU 操作和内存不足时导致的IO操作上消耗时间。根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。<strong>优化查询的目的就是减少和消除这些操作所花费的时间</strong>。</p>
<h3 id="9-2-查询执行的流程"><a href="#9-2-查询执行的流程" class="headerlink" title="9.2. 查询执行的流程"></a>9.2. 查询执行的流程</h3><p>MySQL 执行一个查询的过程。具体流程如下图：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028501.png" alt=""></p>
<ol>
<li>客户端发送一条查询给服务器。</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。</li>
<li>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。</li>
<li>将结果返回给客户端。</li>
</ol>
<p>很多查询优化工作实际上就是遵循一些原则让优化器能够按照预想的合理的方式运行。但除了查询优化器之外，其他部分也是对查询的性能有一定程度的影响。</p>
<h3 id="9-3-MySQL-客户端-服务器通信协议"><a href="#9-3-MySQL-客户端-服务器通信协议" class="headerlink" title="9.3. MySQL 客户端/服务器通信协议"></a>9.3. MySQL 客户端/服务器通信协议</h3><p>大致理MySQL解通信协议。MySQL 客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。所以，无法也无须将一个消息切成小块独立来发送。</p>
<p>这种协议让 MySQL 通信简单快速，但会没法进行流量控制。一旦一端开始发生消息，另一端要接收完整个消息才能响应它。</p>
<p>客户端用一个单独的数据包将查询传给服务器。当查询的语句很长的时，参数<code>max_allowed_packet</code>就相当重要。一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这种情况下，客户端若接收完整的结果，然后取前面几条需要的结果，或者接收完几条结果后就直接地断开连接，都不是好方法。这也是在必要的时候一定要在查询中加上<code>LIMIT</code>限制的原因。</p>
<p>当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是 MySQL 在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也没法让服务器停下来。</p>
<p>多数连接 MySQL 的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL 通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束、早点释放相应的资源。</p>
<p>当使用库函数从 MySQL 获取数据时，其结果看起来都像是从 MySQL 服务器获取数据，而实际上都是从这个库函数的缓存获取数据。多数情况下这没什么问题，但是如果需要返回一个很大的结果集的时候，这种做法就可能有问题，因为库函数会花很多时间和内存来存储所有的结果集。对于 Java 程序来说，很有可能发生 OOM，所以 MySQL 的 JDBC 里提供了<code>setFetchSize()</code>之类的功能，来解决这个问题：</p>
<ol>
<li>当<code>statement</code>设置以下属性时，采用的是流数据接收方式，每次只从服务器接收部份数据，直到所有数据处理完毕，不会发生JVM OOM。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setResultSetType(ResultSet.TYPE_FORWARD_ONLY);</span><br><span class="line">setFetchSize(Integer.MIN_VALUE);</span><br></pre></td></tr></table></figure>
<ol>
<li>调用<code>statement</code>的<code>enableStreamingResults</code>方法，实际上<code>enableStreamingResults</code>方法内部封装的就是第 1 种方式。</li>
<li>设置连接属性<code>useCursorFetch=true</code>(5.0 版驱动开始支持)，<code>statement</code>以<code>TYPE_FORWARD_ONLY</code>打开，再设置<code>fetch size</code>参数，表示采用服务器端游标，每次从服务器取<code>fetch_size</code>条数据。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">con = DriverManager.getConnection(url);</span><br><span class="line">ps = (PreparedStatement) con.prepareStatement(sql,ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">ps.setFetchSize(Integer.MIN_VALUE);</span><br><span class="line">ps.setFetchDirection(ResultSet.FETCH_REVERSE);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="comment">// ...实际的业务处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-4-查询状态"><a href="#9-4-查询状态" class="headerlink" title="9.4. 查询状态"></a>9.4. 查询状态</h3><p>对于一个 MySQL 连接，或者说一个线程，任何时刻都有一个状态，该状态表示了 MySQL 当前正在做什么。在一个查询的生命周期中，状态会变化很多次。</p>
<h3 id="9-5-查询优化处理"><a href="#9-5-查询优化处理" class="headerlink" title="9.5. 查询优化处理"></a>9.5. 查询优化处理</h3><p>查询的生命周期的下一步是将一个 SQL 转换成一个执行计划，MySQL 再依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析 SQL、预处理、优化 SQL 执行计划。这个过程中任何错误（例如语法错误）都可能终止查询。在实际执行中，这几部分可能一起执行也可能单独执行。</p>
<p>MySQL 的查询优化器是一个非常复杂的部件，它使用了很多优化策略来生成一个最优的执行计划。优化策略可以简单地分为两种，一种是静态优化，一种是动态优化。</p>
<p>静态优化可以直接对解析树进行分析，并完成优化。例如，优化器可以通过一些简单的代数变换将<code>WHERE</code>条件转换成另一种等价形式。静态优化不依赖于特别的数值，如<code>WHERE</code>条件中带入的一些常数等。静态优化在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会发生变化。可以认为这是一种“编译时优化”。</p>
<p>动态优化则和查询的上下文有关，也可能和很多其他因素有关，例如<code>WHERE</code>条件中的取值、索引中条目对应的数据行数等。这需要在每次查询的时候都重新评估，可以认为这是“运行时优化”。</p>
<p>优化器是相当复杂性和智能的。如果没有必要，不要去干扰优化器的工作，让优化器按照它的方式工作。尽量按照优化器的提示去优化我们的表、索引和 SQL 语句，比如写查询，或者重新设计更优的库表结构，或者添加更合适的索引。但是请尽可能的保持 SQL 语句的简洁。当然，虽然优化器已经很智能了，但是有时候也无法给出最优的结果。如果能够确认优化器给出的不是最佳选择，并且清楚优化背后的原理，那么也可以帮助优化器做进一步的优化。</p>
<p>MySQL 架构由多个层次组成。在服务器层有查询优化器，却没有保存数据和索引的统计信息。统计信息申存储引擎实现，不同的存储引擎可能会存储不同的统计信息（也可以按照不同的格式存储统计信息)。某些引擎，例如 Archive 引擎，则根本就没有存储任何统计信息!</p>
<p>因为服务器层没有任何统计信息，所以 MySQL 查询优化器在生成查询的执行计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对应的统计信息，包括:每个表或者索引有多少个页面、每个表的每个索引的基数是多少、数据行和索引长度、索引的分布信息等。优化器根据这些信息来选择一个最优的执行计划。</p>
<h3 id="9-6-查询执行引擎"><a href="#9-6-查询执行引擎" class="headerlink" title="9.6. 查询执行引擎"></a>9.6. 查询执行引擎</h3><p>在解析和优化阶段，MySQL 将生成查询对应的执行计划，MySQL 的查询执行引擎则根据这个执行计划来完成整个查询。相对于查询优化阶段，查询执行阶段不是那么复杂：MySQL 只是简单地根据执行计划给出的指令逐步执行。</p>
<h3 id="9-7-返回结果给客户端"><a href="#9-7-返回结果给客户端" class="headerlink" title="9.7. 返回结果给客户端"></a>9.7. 返回结果给客户端</h3><p>查询执行的最后一个阶段是将结果返回给客户端。即使查询不需要返回结果集给客户端，MySQL 仍然会返回这个查询的一些信息，如该查询影响到的行数。如果查询可以被缓存，那么 MySQL 在这个阶段也会将结果存放到查询缓存中。</p>
<p>MySQL 将结果集返回客户端是一个增量、逐步返回的过程。一旦服务器开始生成第一条结果时，MySQL 就可以开始向客户端逐步返回结果集了。</p>
<p>这样处理有两个好处﹔服务器端无须存储太多的结果，也就不会因为要返回太多结果而消耗太多内存。另外，这样的处理也让 MySQL 客户端第一时间获得返回的结果。结果集中的每一行都会以一个满足 MySQL 客户端/服务器通信协议的封包发送，再通过 TCP 协议进行传输，在 TCP 传输的过程中，可能对 MySQL 的封包进行缓存然后批量传输。</p>
<h2 id="10-InnoDB-引擎底层解析"><a href="#10-InnoDB-引擎底层解析" class="headerlink" title="10. InnoDB 引擎底层解析"></a>10. InnoDB 引擎底层解析</h2><h3 id="10-1-InnoDB-中的统计数据"><a href="#10-1-InnoDB-中的统计数据" class="headerlink" title="10.1. InnoDB 中的统计数据"></a>10.1. InnoDB 中的统计数据</h3><p>查询成本的时候经常用到一些统计数据，比如通过 <code>SHOW TABLE STATUS</code> 可以看到关于表的统计数据，通过 <code>SHOW INDEX</code> 可以看到关于索引的统计数据。这些统计都是相应的存储引擎来实现。</p>
<h4 id="10-1-1-统计数据存储方式"><a href="#10-1-1-统计数据存储方式" class="headerlink" title="10.1.1. 统计数据存储方式"></a>10.1.1. 统计数据存储方式</h4><p>InnoDB 提供了两种存储统计数据的方式：</p>
<ul>
<li>永久性的统计数据，这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。</li>
<li>非永久性的统计数据，这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。</li>
</ul>
<p>MySQL提供了系统变量<code>innodb_stats_persistent</code>来控制到底采用哪种方式去存储统计数据。在 MySQL 5.6.6 之前，<code>innodb_stats_persistent</code>的值默认是<code>OFF</code>，也就是说 InnoDB 的统计数据默认是存储到内存的，之后的版本中<code>innodb_stats_persistent</code>的值默认是<code>ON</code>，也就是统计数据默认被存储到磁盘中。</p>
<p>查询当前存储统计数据的方式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;innodb_stats_persistent&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_stats_persistent <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-------+</span></span><br></pre></td></tr></table></figure>
<p>InnoDB 默认是以表为单位来收集和存储统计数据的，也就是说可以把某些表的统计数据（以及该表的索引统计数据）存储在磁盘上，把另一些表的统计数据存储在内存中。</p>
<p>在创建和修改表的时候通过指定 <code>STATS_PERSISTENT</code> 属性来指明该表的统计数据存储方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名 (...) Engine<span class="operator">=</span>InnoDB, STATS_PERSISTENT <span class="operator">=</span> (<span class="number">1</span><span class="operator">|</span><span class="number">0</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 Engine<span class="operator">=</span>InnoDB, STATS_PERSISTENT <span class="operator">=</span> (<span class="number">1</span><span class="operator">|</span><span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>当<code>STATS_PERSISTENT=1</code>时，表明我们想把该表的统计数据永久的存储到磁盘上</li>
<li>当<code>STATS_PERSISTENT=0</code>时，表明我们想把该表的统计数据临时的存储到内存中</li>
<li>如果在创建表时未指定<code>STATS_PERSISTENT</code>属性，那默认采用系统变量<code>innodb_stats_persistent</code>的值作为该属性的值</li>
</ul>
</blockquote>
<h4 id="10-1-2-基于磁盘的永久性统计数据"><a href="#10-1-2-基于磁盘的永久性统计数据" class="headerlink" title="10.1.2. 基于磁盘的永久性统计数据"></a>10.1.2. 基于磁盘的永久性统计数据</h4><p>当选择把某个表以及该表索引的统计数据存放到磁盘上时，实际上是把这些统计数据存储到了两个表里：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> mysql <span class="keyword">LIKE</span> <span class="string">&#x27;innodb%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mysql (innodb<span class="operator">%</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> innodb_index_stats        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> innodb_table_stats        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>这两个表都位于 mysql 系统数据库下。</p>
<ul>
<li><code>innodb_table_stats</code> 存储了关于表的统计数据，每一条记录对应着一个表的统计数据。</li>
<li><code>innodb_index_stats</code> 存储了关于索引的统计数据，每一条记录对应着一个索引的一个统计项的统计数据。</li>
</ul>
<h5 id="10-1-2-1-innodb-table-stats"><a href="#10-1-2-1-innodb-table-stats" class="headerlink" title="10.1.2.1. innodb_table_stats"></a>10.1.2.1. innodb_table_stats</h5><p><strong>innodb_table_stats 表结构与字段的作用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> mysql.innodb_table_stats;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-----------------+------+-----+-------------------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Field                    <span class="operator">|</span> Type            <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>           <span class="operator">|</span> Extra                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-----------------+------+-----+-------------------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> database_name            <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">64</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> table_name               <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">199</span>)    <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> last_update              <span class="operator">|</span> <span class="type">timestamp</span>       <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span> DEFAULT_GENERATED <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> n_rows                   <span class="operator">|</span> <span class="type">bigint</span> unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> clustered_index_size     <span class="operator">|</span> <span class="type">bigint</span> unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sum_of_other_index_sizes <span class="operator">|</span> <span class="type">bigint</span> unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-----------------+------+-----+-------------------+-----------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li>database_name 数据库名</li>
<li>table_name 表名</li>
<li>last_update 本条记录最后更新时间</li>
<li>n_rows 表中记录的条数</li>
<li>clustered_index_size 表的聚簇索引占用的页面数量</li>
<li>sum_of_other_index_sizes 表的其他索引占用的页面数量</li>
</ul>
<p><strong>innodb_table_stats 表内容分析</strong>，几个重要统计信息项的值如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mysql.innodb_table_stats <span class="keyword">WHERE</span> database_name <span class="operator">=</span> <span class="string">&#x27;tempdb&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------------------+---------------------+---------+----------------------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> database_name <span class="operator">|</span> table_name          <span class="operator">|</span> last_update         <span class="operator">|</span> n_rows  <span class="operator">|</span> clustered_index_size <span class="operator">|</span> sum_of_other_index_sizes <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------------------+---------------------+---------+----------------------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> account             <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">30</span>:<span class="number">34</span> <span class="operator">|</span>       <span class="number">7</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> article             <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">42</span> <span class="operator">|</span>      <span class="number">17</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> article_data        <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">42</span> <span class="operator">|</span>       <span class="number">0</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> article_type        <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">42</span> <span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> comment             <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">42</span> <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> course              <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">50</span>:<span class="number">03</span> <span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> dept                <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">49</span>:<span class="number">53</span> <span class="operator">|</span>       <span class="number">6</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> emp                 <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">50</span>:<span class="number">13</span> <span class="operator">|</span>      <span class="number">17</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> employee            <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">43</span> <span class="operator">|</span>       <span class="number">6</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> order_exp           <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">43</span> <span class="operator">|</span>   <span class="number">10625</span> <span class="operator">|</span>                   <span class="number">97</span> <span class="operator">|</span>                       <span class="number">74</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> order_exp_cut       <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">43</span> <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> s1                  <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">43</span> <span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> s2                  <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">43</span> <span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">3</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> salgrade            <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">49</span>:<span class="number">53</span> <span class="operator">|</span>       <span class="number">8</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> score               <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">43</span> <span class="operator">|</span>       <span class="number">5</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> student             <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">49</span>:<span class="number">53</span> <span class="operator">|</span>       <span class="number">4</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> student_course      <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">50</span>:<span class="number">23</span> <span class="operator">|</span>       <span class="number">6</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> tb_sku              <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">08</span>:<span class="number">22</span> <span class="operator">|</span> <span class="number">9214983</span> <span class="operator">|</span>               <span class="number">234496</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> tb_user             <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-05</span> <span class="number">10</span>:<span class="number">39</span>:<span class="number">47</span> <span class="operator">|</span>      <span class="number">24</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> teacher             <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">29</span>:<span class="number">54</span> <span class="operator">|</span>       <span class="number">5</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> type                <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">30</span>:<span class="number">04</span> <span class="operator">|</span>       <span class="number">2</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> tempdb        <span class="operator">|</span> <span class="keyword">user</span>                <span class="operator">|</span> <span class="number">2022</span><span class="number">-08</span><span class="number">-04</span> <span class="number">22</span>:<span class="number">30</span>:<span class="number">14</span> <span class="operator">|</span>       <span class="number">3</span> <span class="operator">|</span>                    <span class="number">1</span> <span class="operator">|</span>                        <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+---------------------+---------------------+---------+----------------------+--------------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>n_rows</code> 的值是10625，表明order_exp表中大约有10625条记录，注意这个数据是估计值。</li>
<li><code>clustered_index_size</code> 的值是97，表明order_exp表的聚簇索引占用97个页面，这个值是也是一个估计值。</li>
<li><code>sum_of_other_index_sizes</code> 的值是74，表明order_exp表的其他索引一共占用81个页面，这个值是也是一个估计值。</li>
</ul>
<p><strong>n_rows 统计项的收集</strong>，InnoDB 统计一个表中有多少行记录的执行流程如下：</p>
<p>按照一定算法（并不是纯粹随机的）选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的 n_rows 值</p>
<p>这个 n_rows 值精确与否取决于统计时采样的页面数量，MySQL 用名为 innodb_stats_persistent_sample_pages 的系统变量来控制使用永久性的统计数据时，计算统计数据时采样的页面数量。该值设置的越大，统计出的 n_rows值越精确，但是统计耗时也就最久；该值设置的越小，统计出的 n_rows 值越不精确，但是统计耗时特别少。所以在实际使用是需要我们去权衡利弊，该系统变量的默认值是 20。</p>
<p>InnoDB 默认是以表为单位来收集和存储统计数据的，也可以单独设置某个表的采样页面的数量，设置方式就是在创建或修改表的时候通过指定<code>STATS_SAMPLE_PAGES</code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名 (...) Engine<span class="operator">=</span>InnoDB, STATS_SAMPLE_PAGES <span class="operator">=</span> 具体的采样页面数量;</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 Engine<span class="operator">=</span>InnoDB, STATS_SAMPLE_PAGES <span class="operator">=</span> 具体的采样页面数量;</span><br></pre></td></tr></table></figure>
<p>如果在创建表的语句中并没有指定<code>STATS_SAMPLE_PAGES</code>属性的话，将默认使用系统变量<code>innodb_stats_persistent_sample_pages</code>的值作为该属性的值。<code>clustered_index_size</code>和<code>sum_of_other_index_sizes</code> 统计项的收集牵涉到很具体的 InnoDB 表空间的知识和存储页面数据的细节</p>
<h5 id="10-1-2-2-innodb-index-stats"><a href="#10-1-2-2-innodb-index-stats" class="headerlink" title="10.1.2.2. innodb_index_stats"></a>10.1.2.2. innodb_index_stats</h5><p><strong>innodb_index_stats 表结构与字段的作用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">desc</span> mysql.innodb_table_stats;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-----------------+------+-----+-------------------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Field                    <span class="operator">|</span> Type            <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>           <span class="operator">|</span> Extra                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-----------------+------+-----+-------------------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> database_name            <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">64</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> table_name               <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">199</span>)    <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> last_update              <span class="operator">|</span> <span class="type">timestamp</span>       <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span> DEFAULT_GENERATED <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> n_rows                   <span class="operator">|</span> <span class="type">bigint</span> unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> clustered_index_size     <span class="operator">|</span> <span class="type">bigint</span> unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sum_of_other_index_sizes <span class="operator">|</span> <span class="type">bigint</span> unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>              <span class="operator">|</span>                                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-----------------+------+-----+-------------------+-----------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li>database_name 数据库名</li>
<li>table_name 表名</li>
<li>index_name 索引名</li>
<li>last_update 本条记录最后更新时间</li>
<li>stat_name 统计项的名称</li>
<li>stat_value 对应的统计项的值</li>
<li>sample_size 为生成统计数据而采样的页面数量</li>
<li>stat_description 对应的统计项的描述</li>
</ul>
<p><strong>innodb_index_stats 表的每条记录代表着一个索引的一个统计项</strong>，几个重要统计信息项的值如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028502.png" alt=""></p>
<ul>
<li><code>index_name</code>：说明该记录是哪个索引的统计信息<ul>
<li>从示例结果中可以看出来，PRIMARY 索引（也就是主键）占了3条记录，idx_expire_time 索引占了6条记录。</li>
</ul>
</li>
<li><code>stat_name</code>：表示针对该索引的统计项名称<ul>
<li><code>n_leaf_pages</code>：表示该索引的叶子节点占用多少页面。</li>
<li><code>size</code>：表示该索引共占用多少页面。</li>
<li><code>n_diff_pfxNN</code>：表示对应的索引列不重复的值有多少。（其中“NN”可以被替换为01、02、03…的数字）</li>
</ul>
</li>
<li><code>stat_value</code>：该索引在该统计项上的值</li>
<li><code>sample_size</code>：表明了采样的页面数量是多少<ul>
<li>对于有多个列的联合索引来说，采样的页面数量是：<code>innodb_stats_persistent_sample_pages × 索引列的个数</code>。</li>
<li>当需要采样的页面数量大于该索引的叶子节点数量的话，就直接采用全表扫描来统计索引列的不重复值数量了。所以可以在查询结果中看到不同索引对应的size列的值可能是不同的。</li>
</ul>
</li>
<li><code>stat_description</code>：指的是来描述该统计项的含义的</li>
</ul>
<p>以<code>u_idx_day_status</code>索引为例。</p>
<ul>
<li>n_diff_pfx01 表示的是统计 insert_time 这单单一个列不重复的值有多少。</li>
<li>n_diff_pfx02 表示的是统计 insert_time,order_status 这两个列组合起来不重复的值有多少。</li>
<li>n_diff_pfx03 表示的是统计 insert_time,order_status,expire_time 这三个列组合起来不重复的值有多少。</li>
<li>n_diff_pfx04 表示的是统计 key_pare1、key_pare2、expire_time、id 这四个列组合起来不重复的值有多少。</li>
</ul>
<blockquote>
<p>查询<code>innodb_stats_persistent_sample_pages</code>值</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_stats_persistent_sample_pages%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                        <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_stats_persistent_sample_pages <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+-------+</span></span><br></pre></td></tr></table></figure>
<h5 id="10-1-2-3-定期更新统计数据"><a href="#10-1-2-3-定期更新统计数据" class="headerlink" title="10.1.2.3. 定期更新统计数据"></a>10.1.2.3. 定期更新统计数据</h5><p>随着不断的对表进行增删改操作，表中的数据也一直在变化，innodb_table_stats 和 innodb_index_stats 表里的统计数据也在变化。MySQL 提供了如下两种更新统计数据的方式：</p>
<p><strong>开启 innodb_stats_auto_recalc</strong></p>
<p>系统变量 innodb_stats_auto_recalc 决定着服务器是否自动重新计算统计数据，它的默认值是 ON，也就是该功能默认是开启的。每个表都维护了一个变量，该变量记录着对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的 10%，并且自动重新计算统计数据的功能是打开的，那么服务器会重新进行一次统计数据的计算，并且更新 innodb_table_stats 和 innodb_index_stats 表。</p>
<p>自动重新计算统计数据的过程是异步发生的，也就是即使表中变动的记录数超过了 10%，自动重新计算统计数据也不会立即发生，可能会延迟几秒才会进行计算。</p>
<p>InnoDB 默认是以表为单位来收集和存储统计数据的，所以也可以单独为某个表设置是否自动重新计算统计数的属性，设置方式就是在创建或修改表的时候通过指定<code>STATS_AUTO_RECALC</code>属性来指明该表的统计数据存储方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名 (...) Engine<span class="operator">=</span>InnoDB, STATS_AUTO_RECALC <span class="operator">=</span> (<span class="number">1</span><span class="operator">|</span><span class="number">0</span>);</span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 Engine<span class="operator">=</span>InnoDB, STATS_AUTO_RECALC <span class="operator">=</span> (<span class="number">1</span><span class="operator">|</span><span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>当<code>STATS_AUTO_RECALC=1</code>时，表明想让该表自动重新计算统计数据</li>
<li>当<code>STATS_AUTO_RECALC=0</code>时，表明不想让该表自动重新计算统计数据</li>
<li>如果在创建表时未指定<code>STATS_AUTO_RECALC</code>属性，那默认采用系统变量<code>innodb_stats_auto_recalc</code>的值作为该属性的值。</li>
</ul>
<p><strong>手动调用 ANALYZE TABLE 语句来更新统计信息</strong></p>
<p>如果 innodb_stats_auto_recalc 系统变量的值为 OFF 的话。也可以手动调用 ANALYZE TABLE 语句来重新计算统计数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>
<p>ANALYZE TABLE 语句会立即重新计算统计数据，也就是这个过程是同步的，在表中索引多或者采样页面特别多时这个过程可能会特别慢最好在业务不是很繁忙的时候再运行。</p>
<h4 id="10-1-3-手动更新-innodb-table-stats-和-innodb-index-stats-表"><a href="#10-1-3-手动更新-innodb-table-stats-和-innodb-index-stats-表" class="headerlink" title="10.1.3. 手动更新 innodb_table_stats 和 innodb_index_stats 表"></a>10.1.3. 手动更新 innodb_table_stats 和 innodb_index_stats 表</h4><p>innodb_table_stats 和 innodb_index_stats 表就相当于一个普通的表一样，能对它们做增删改查操作。这也就意味着可以手动更新某个表或者索引的统计数据。</p>
<ul>
<li>步骤一：更新 innodb_table_stats 表</li>
<li>步骤二：让 MySQL 查询优化器重新加载更改过的数据</li>
</ul>
<p>更新完 innodb_table_stats 只是单纯的修改了一个表的数据，需要让 MySQL 查询优化器重新加载我们更改过的数据，运行以下的命令即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-InnoDB-记录存储结构和索引页结构-TODO-mark-整理中"><a href="#10-2-InnoDB-记录存储结构和索引页结构-TODO-mark-整理中" class="headerlink" title="10.2. InnoDB 记录存储结构和索引页结构(TODO mark: 整理中)"></a>10.2. InnoDB 记录存储结构和索引页结构(TODO mark: 整理中)</h3><p>InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启，数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。</p>
<p>当从表中获取某些记录时，InnoDB 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB 中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取 16KB 的内容到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。</p>
<p>以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为<strong>行格式</strong>或者<strong>记录格式</strong>。InnoDB 存储引擎设计了4种不同类型的行格式，分别是 Compact、Redundant、Dynamic 和 Compressed 行格式。</p>
<h4 id="10-2-1-指定行格式的语法"><a href="#10-2-1-指定行格式的语法" class="headerlink" title="10.2.1. 指定行格式的语法"></a>10.2.1. 指定行格式的语法</h4><p>创建或修改表的语句中指定行格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> 表名 (列的信息) ROW_FORMAT<span class="operator">=</span>行格式名称;</span><br></pre></td></tr></table></figure>
<h5 id="10-2-1-1-COMPACT-类型行格式"><a href="#10-2-1-1-COMPACT-类型行格式" class="headerlink" title="10.2.1.1. COMPACT 类型行格式"></a>10.2.1.1. COMPACT 类型行格式</h5><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028503.png" alt=""></p>
<p>MySQL对于变长列，如 VARCHAR(M)、VARBINARY(M)、各种 TEXT 类型，各种 BLOB 类型。存储真实数据的同时，也会保存这些数据占用的字节数。</p>
<p>Compact 行格式会把可能为 NULL 的列统一管理起来，存储到 NULL 值列表。每个允许存储 NULL 的列对应一个二进制位，二进制位的值为 1 时，代表该列的值为 NULL。二进制位的值为 0 时，代表该列的值不为 NULL。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028504.png" alt=""></p>
<p>还有用于描述记录的<strong>记录头信息</strong>，它是由固定的 5 个字节组成。5 个字节也就是 40 个二进制位，不同的位代表不同的意思。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>位数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td><code>delete_mask</code></td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td><code>min_rec_mask</code></td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td><code>n_owned</code></td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td><code>heap_no</code></td>
<td>13</td>
<td>表示当前记录在页的位置信息</td>
</tr>
<tr>
<td><code>record_type</code></td>
<td>3</td>
<td>表示当前记录的类型，0 表示普通记录，1 表示 B+树非叶子节点记录，2 表示最小记录，3 表示最大记录</td>
</tr>
<tr>
<td><code>next_record</code></td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody>
</table>
</div>
<p>记录的真实数据除了自定义的列的数据以外，MySQL 会为每个记录默认的添加一些列（也称为隐藏列），包括：</p>
<ul>
<li><code>DB_ROW_ID(row_id)</code>：非必须，6 字节，表示行 ID，唯一标识一条记录</li>
<li><code>DB_TRX_ID</code>：必须，6 字节，表示事务 ID</li>
<li><code>DB_ROLL_PTR</code>：必须，7 字节，表示回滚指针</li>
</ul>
<h5 id="10-2-1-2-Redundant-行格式（待整理）"><a href="#10-2-1-2-Redundant-行格式（待整理）" class="headerlink" title="10.2.1.2. Redundant 行格式（待整理）"></a>10.2.1.2. Redundant 行格式（待整理）</h5><p>Redundant 行格式是 MySQL5.0 之前用的一种行格式</p>
<h4 id="10-2-2-索引页格式（待整理）"><a href="#10-2-2-索引页格式（待整理）" class="headerlink" title="10.2.2. 索引页格式（待整理）"></a>10.2.2. 索引页格式（待整理）</h4><blockquote>
<p>TODO: 待整理</p>
</blockquote>
<h3 id="10-3-InnoDB-的内存结构总结"><a href="#10-3-InnoDB-的内存结构总结" class="headerlink" title="10.3. InnoDB 的内存结构总结"></a>10.3. InnoDB 的内存结构总结</h3><h4 id="10-3-1-InnoDB-的内存结构和磁盘存储结构图总结"><a href="#10-3-1-InnoDB-的内存结构和磁盘存储结构图总结" class="headerlink" title="10.3.1. InnoDB 的内存结构和磁盘存储结构图总结"></a>10.3.1. InnoDB 的内存结构和磁盘存储结构图总结</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028505.png" alt=""></p>
<p>其中的 Insert/Change Buffer 主要是用于对二级索引的写入优化，Undo 空间则是 undo 日志一般放在系统表空间，但是通过参数配置后，也可以用独立表空间存放，所以用虚线表示。</p>
<h4 id="10-3-2-扩展知识"><a href="#10-3-2-扩展知识" class="headerlink" title="10.3.2. 扩展知识"></a>10.3.2. 扩展知识</h4><p>计算机基础原理，但凡是对硬盘的读写操作，都是先从硬盘上数据读取到内存，然后cpu再从内存中读取数据。修改数据数据的操作也是一样，从先内存中的数据进行操作后，然后再将内存中的数据持久化到磁盘中。</p>
<p>所以之前在mysql的成本计算中提到的I/O成本与CPU成本。就是分别指从磁盘到内存，然后cpu读取内存的时间成本。</p>
<p>内存的扩容成本是很昂贵的，一般都是尽可能一次申请合适的内存。如JVM，一般会将堆的最小值与最大值都设置为一样，为了防止在运行过程中出现向cpu重新申请内存的操作。因为一般内存区域都是连续的。所以一般内存的扩容是先向cpu申请新的一块内存区域，然后将原本的内存中的数据再复制到新的内存区域中。这个扩容成本是巨大的。</p>
<h2 id="11-MySQL-的执行原理"><a href="#11-MySQL-的执行原理" class="headerlink" title="11. MySQL 的执行原理"></a>11. MySQL 的执行原理</h2><h3 id="11-1-单表访问之索引合并"><a href="#11-1-单表访问之索引合并" class="headerlink" title="11.1. 单表访问之索引合并"></a>11.1. 单表访问之索引合并</h3><p>MySQL 在一般情况下执行一个查询时最多只会用到单个二级索引，但存在有特殊情况，在这些特殊情况下也可能在一个查询中使用到多个二级索引，MySQL 中这种使用到多个索引来完成一次查询的执行方法称之为：索引合并（index merge），具体的索引合并算法有以下的3种：</p>
<h4 id="11-1-1-并集（Intersection）合并"><a href="#11-1-1-并集（Intersection）合并" class="headerlink" title="11.1.1. 并集（Intersection）合并"></a>11.1.1. 并集（Intersection）合并</h4><p>某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> index1 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> index2 <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>假设这个查询使用 Intersection 合并的方式执行的话，那执行过程是：</p>
<ul>
<li>从<code>index1</code>相应的二级索引对应的B+树中取出<code>index1 = &#39;a&#39;</code>的相关记录。</li>
<li>从<code>index2</code>相应的二级索引对应的B+树中取出<code>index2 = &#39;b&#39;</code>的相关记录。</li>
</ul>
<p>因为二级索引的组成结构都是由索引列+主键构成，所以可以计算出这两个结果集中主键的交集。然后再根据这个主键的交集去进行回表操作，也就是从聚簇索引中把指定的主键的完整行记录返回。</p>
<p>【问题】：不同的查询方式的执行成本比较</p>
<ul>
<li><strong>只读取一个二级索引的成本</strong>：按照某个搜索条件读取一个二级索引，根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件</li>
<li><strong>读取多个二级索引之后取交集成本</strong>：按照不同的搜索条件分别读取不同的二级索引，将从多个二级索引得到的主键值取交集，然后进行回表操作</li>
</ul>
<p>【解释】：虽然读取多个二级索引比读取一个二级索引消耗性能，但是大部分情况下读取二级索引的操作是顺序I/O，而回表操作是随机I/O，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为回表而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。</p>
<p>MySQL 在以下特定的情况下才可能会使用到 Intersection 索引合并</p>
<h5 id="11-1-1-1-情况一：等值匹配"><a href="#11-1-1-1-情况一：等值匹配" class="headerlink" title="11.1.1.1. 情况一：等值匹配"></a>11.1.1.1. 情况一：等值匹配</h5><ul>
<li>二级索引列是等值匹配的情况</li>
<li>对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</li>
</ul>
<p>满足以上的情况，才可能会使用到索引合并</p>
<h5 id="11-1-1-2-情况二：主键列可以是范围匹配"><a href="#11-1-1-2-情况二：主键列可以是范围匹配" class="headerlink" title="11.1.1.2. 情况二：主键列可以是范围匹配"></a>11.1.1.2. 情况二：主键列可以是范围匹配</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表 <span class="keyword">WHERE</span> 主键列 <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">AND</span> 索引列 <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>对于 InnoDB 的二级索引来说，记录先是按照索引列进行排序，如果该二级索引是一个联合索引，那么会按照联合索引中的各个列依次排序。而二级索引的用户记录是由索引列 + 主键构成的，二级索引列的值相同的记录可能会有好多条，这些索引列的值相同的记录又是按照主键的值进行排序的</p>
<p><font color=red><strong>之所以在二级索引列都是等值匹配的情况下才可能使用Intersection 索引合并，是因为在这种情况下根据二级索引查询出的结果集是按照主键值排序的</strong></font>。因为各个二级索引中查询的到的结果集按主键排好序，取交集的过程比较容易。按照有序的主键值去回表取记录有个专有名词，叫：Rowid Ordered Retrieval，简称 ROR。</p>
<p>如果从各个二级索引中查询出的结果集并不是按照主键排序的话，那就要先把结果集中的主键值排序完再来做上边的那个过程，就比较耗时了。</p>
<p><font color=red><em>**</em>不仅是多个二级索引之间可以采用 Intersection 索引合并，索引合并也可以有聚簇索引。在搜索条件中有主键的范围匹配的情况下也可以使用 Intersection 索引合并索引合并</font>。如上例，通过二级索引查询到相应的主键值集合，因为主键已经排序，所以很容易就匹配主键范围条件，取最终的结果集</p>
<h5 id="11-1-1-3-索引并集合并小结"><a href="#11-1-1-3-索引并集合并小结" class="headerlink" title="11.1.1.3. 索引并集合并小结"></a>11.1.1.3. 索引并集合并小结</h5><p>上边的情况一和情况二只是发生 Intersection 索引合并的必要条件，不是充分条件。也就是说即使情况一、情况二成立，也不一定发生 Intersection索引合并，这得看优化器的具体分析。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过 Intersection 索引合并后需要回表的记录数大大减少时才会使用 Intersection 索引合并。</p>
<h4 id="11-1-2-Union-合并"><a href="#11-1-2-Union-合并" class="headerlink" title="11.1.2. Union 合并"></a>11.1.2. Union 合并</h4><p>查询时经常会把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，然后这些不同的搜索条件之间是<code>OR</code>关系。有时候<code>OR</code>关系的不同搜索条件会使用到不同的索引，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表 <span class="keyword">WHERE</span> 索引列<span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> 索引列<span class="number">2</span> <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>Union 是并集的意思，适用于使用不同索引的搜索条件之间使用<code>OR</code>连接起来的情况。与 Intersection 索引合并类似，MySQL 在某些特定的情况下才可能会使用到 Union 索引合并：</p>
<h5 id="11-1-2-1-情况一：等值匹配"><a href="#11-1-2-1-情况一：等值匹配" class="headerlink" title="11.1.2.1. 情况一：等值匹配"></a>11.1.2.1. 情况一：等值匹配</h5><p>分析与Intersection 合并同理</p>
<h5 id="11-1-2-2-情况二：主键列可以是范围匹配"><a href="#11-1-2-2-情况二：主键列可以是范围匹配" class="headerlink" title="11.1.2.2. 情况二：主键列可以是范围匹配"></a>11.1.2.2. 情况二：主键列可以是范围匹配</h5><p>分析与 Intersection 合并同理</p>
<h5 id="11-1-2-3-情况三：使用-Intersection-索引合并的搜索条件"><a href="#11-1-2-3-情况三：使用-Intersection-索引合并的搜索条件" class="headerlink" title="11.1.2.3. 情况三：使用 Intersection 索引合并的搜索条件"></a>11.1.2.3. 情况三：使用 Intersection 索引合并的搜索条件</h5><p>此情况是，搜索条件的某些部分使用 Intersection 索引合并的方式得到的主键集合和其他方式得到的主键集合取交集。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> order_status <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span> <span class="keyword">AND</span> expire_time <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">OR</span> (order_no <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">AND</span> expire_time <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>优化器可能采用这样的方式来执行这个查询：</p>
<ul>
<li>先按照搜索条件 order_no = ‘a’ AND expire_time = ‘b’从索引 idx_order_no 和 idx_expire_time 中使用 Intersection 索引合并的方式得到一个主键集合。</li>
<li>再按照搜索条件 insert_time = ‘a’ AND order_status = ‘b’ AND expire_time = ‘c’ 从联合索引 u_idx_day_status 中得到另一个主键集合。</li>
<li>采用 Union 索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给客户端。</li>
</ul>
<h5 id="11-1-2-4-索引并集合并小结"><a href="#11-1-2-4-索引并集合并小结" class="headerlink" title="11.1.2.4. 索引并集合并小结"></a>11.1.2.4. 索引并集合并小结</h5><p>查询条件符合了以上情况也不一定就会采用 Union 索引合并，也得看优化器的具体分析。优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过 Union 索引合并后进行访问的代价比全表扫描更小时才会使用Union 索引合并。</p>
<h4 id="11-1-3-Sort-Union-合并"><a href="#11-1-3-Sort-Union-合并" class="headerlink" title="11.1.3. Sort-Union 合并"></a>11.1.3. Sort-Union 合并</h4><p>Union 索引合并的使用条件必须保证各个二级索引列在进行等值匹配的条件下才可能被用到。有一些情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表 <span class="keyword">WHERE</span> 索引列<span class="number">1</span> <span class="operator">&lt;</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">OR</span> 索引列<span class="number">2</span> <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>先根据索引列1从二级索引中获取到记录，并将记录上的主键进行排序</li>
<li>同样操作索引列2</li>
<li>两个二级索引主键值都是排好序后，后续的操作和 Union 索引合并方式就一样了</li>
</ul>
<p>上述这种先按照二级索引记录的主键值进行排序，之后按照 Union 索引合并方式执行的方式称之为 Sort-Union 索引合并，很显然，这种 Sort-Union 索引合并比单纯的 Union 索引合并多了一步对二级索引记录的主键值排序的过程。</p>
<h4 id="11-1-4-联合索引替代-Intersection-索引合并"><a href="#11-1-4-联合索引替代-Intersection-索引合并" class="headerlink" title="11.1.4. 联合索引替代 Intersection 索引合并"></a>11.1.4. 联合索引替代 Intersection 索引合并</h4><p>在使用 Intersection 索引合并的方式来处理的查询语句，是因为查询条件的列分别是索引，并且是各个单独的B+树。可以直接将其各个二级索引合并成一个联合索引</p>
<h3 id="11-2-连接查询的实现原理"><a href="#11-2-连接查询的实现原理" class="headerlink" title="11.2. 连接查询的实现原理"></a>11.2. 连接查询的实现原理</h3><blockquote>
<p>连接查询的基础知识详见前面《连接查询》的章节</p>
</blockquote>
<h4 id="11-2-1-嵌套循环连接-Nested-Loop-Join-NLJ-算法"><a href="#11-2-1-嵌套循环连接-Nested-Loop-Join-NLJ-算法" class="headerlink" title="11.2.1. 嵌套循环连接 Nested-Loop Join (NLJ) 算法"></a>11.2.1. 嵌套循环连接 Nested-Loop Join (NLJ) 算法</h4><ul>
<li>两表连接查询：驱动表只会被访问一次，但被驱动表具体访问次数取决于对驱动表执行单表查询后的结果集中的记录条数。</li>
<li>内连接查询：选取哪个表为驱动表都没关系</li>
<li>外连接查询：驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表。</li>
<li>3个表连接查询：那么首先两表连接得到的结果集作为新的驱动表，然后第三个表作为被驱动表</li>
</ul>
<p>从上面可以看出，连接查询这个过程就像是一个嵌套的循环，所以这种驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式称之为嵌套循环连接（Nested-Loop Join），这是最简单，也是最笨拙的一种连接查询算法，时间复杂度是<code>O(N*M*L)</code>。</p>
<h4 id="11-2-2-使用索引加快连接速度"><a href="#11-2-2-使用索引加快连接速度" class="headerlink" title="11.2.2. 使用索引加快连接速度"></a>11.2.2. 使用索引加快连接速度</h4><p>被驱动表其实就相当于一次单表查询，假设查询驱动表后的结果集中有N条记录，根据嵌套循环连接算法需要对被驱动表查询N次。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> e1, e2 <span class="keyword">WHERE</span> e1.m1 <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> e1.m1 <span class="operator">=</span> e2.m2 <span class="keyword">AND</span> e2.n2 <span class="operator">&lt;</span> <span class="string">&#x27;d&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如上示例，如果给被驱动表的连接列（即上例的m2列）建立索引，因为m2列的条件是等值查找，所以可能使用到<code>ref</code>类型的访问方法； 如果m2列是e2表的主键或者唯一二级索引列，那么使用<code>e2.m2 = 常数值</code>这样的条件从 e2 表中查找记录的过程的代价就是常数级别的。在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为<code>const</code>，而 MySQL 把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为：<code>eq_ref</code>。</p>
<p>如果连接查询条件列与其他条件列都存在索引，需要从所有索引中选一个代价更低的去执行对被驱动表的查询。当然，建立了索引不一定使用索引，只有在二级索引+回表的代价比全表扫描的代价更低时才会使用索引。</p>
<p>有时候连接查询的查询列表和过滤条件中可能只涉及被驱动表的部分列，而这些列都是某个索引的一部分，这种情况下即使不能使用<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>或者<code>range</code>这些访问方法执行对被驱动表的查询的话，也可以使用索引扫描，也就是index(索引覆盖)的访问方法来查询被驱动表。</p>
<h4 id="11-2-3-基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法"><a href="#11-2-3-基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法" class="headerlink" title="11.2.3. 基于块的嵌套循环连接 Block Nested-Loop Join (BNL)算法"></a>11.2.3. 基于块的嵌套循环连接 Block Nested-Loop Join (BNL)算法</h4><p>扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。当表数据量很大的时候，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。这个 I/O 代价就非常大了，所以需想办法：尽量减少访问被驱动表的次数。</p>
<p>MySQL 提出了一个 join buffer 的概念，join buffer 就是执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个 join buffer 中，然后<strong>开始扫描被驱动表，每一条被驱动表的记录一次性和 join buffer 中的多条驱动表记录做匹配，</strong>因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 I/O 代价。使用 join buffer 的过程如下图所示：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251028506.png" alt=""></p>
<p>其中最好的情况是 join buffer 足够大，能容纳驱动表结果集中的所有记录。这种加入了 join buffer 的嵌套循环连接算法称之为<strong>基于块的嵌套连接（Block Nested-Loop Join）算法</strong>。</p>
<p>这个 join buffer 的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为 262144 字节（也就是 256KB），最小可以设置为 128 字节。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;join_buffer_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> join_buffer_size <span class="operator">|</span> <span class="number">262144</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+--------+</span></span><br></pre></td></tr></table></figure>
<p>对于优化被驱动表的查询来说，最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大<code>join_buffer_size</code>的值来对连接查询进行优化。</p>
<p>需要注意的是，驱动表的记录并不是所有列都会被放到 join buffer 中，只有查询列表中的列和过滤条件中的列才会被放到 join buffer 中，所以最好不要把<code>*</code>作为查询列表，只将需要的列放到查询列表就好了，这样还可以在 join buffer 中放置更多的记录。</p>
<h2 id="12-MySQL-的查询重写规则（了解）"><a href="#12-MySQL-的查询重写规则（了解）" class="headerlink" title="12. MySQL 的查询重写规则（了解）"></a>12. MySQL 的查询重写规则（了解）</h2><h3 id="12-1-条件化简"><a href="#12-1-条件化简" class="headerlink" title="12.1. 条件化简"></a>12.1. 条件化简</h3><p>查询语句的搜索条件本质上是一个表达式，MySQL 的查询优化器会简化这些表达式。</p>
<h4 id="12-1-1-移除不必要的括号"><a href="#12-1-1-移除不必要的括号" class="headerlink" title="12.1.1. 移除不必要的括号"></a>12.1.1. 移除不必要的括号</h4><p>表达式里有许多无用的括号，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> b <span class="operator">=</span> c) <span class="keyword">OR</span> ((a <span class="operator">&gt;</span> c) <span class="keyword">AND</span> (c <span class="operator">&lt;</span> <span class="number">5</span>)))</span><br></pre></td></tr></table></figure>
<p>优化器会把那些用不到的括号移除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> b <span class="operator">=</span> c) <span class="keyword">OR</span> (a <span class="operator">&gt;</span> c <span class="keyword">AND</span> c <span class="operator">&lt;</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h4 id="12-1-2-常量传递（constant-propagation）"><a href="#12-1-2-常量传递（constant-propagation）" class="headerlink" title="12.1.2. 常量传递（constant_propagation）"></a>12.1.2. 常量传递（constant_propagation）</h4><p>当表达式是某个列和某个常量做等值匹配（<code>a=5</code>），当这个表达式和其他涉及列a的表达式使用<code>AND</code>连接起来时，可以将其他表达式中的a的值替换为5</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> a</span><br><span class="line"><span class="comment">-- 替换成</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">AND</span> b <span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多个列之间存在等值匹配的关系</span></span><br><span class="line">a <span class="operator">=</span> b <span class="keyword">and</span> b <span class="operator">=</span> c <span class="keyword">and</span> c <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="comment">-- 替换成</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">5</span> <span class="keyword">and</span> c <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="12-1-3-移除没用的条件（trivial-condition-removal）"><a href="#12-1-3-移除没用的条件（trivial-condition-removal）" class="headerlink" title="12.1.3. 移除没用的条件（trivial_condition_removal）"></a>12.1.3. 移除没用的条件（trivial_condition_removal）</h4><p>对于一些永远为<code>TRUE</code>或者<code>FALSE</code>的表达式，优化器会将其移除。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(a <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> b) <span class="keyword">OR</span> (a <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> <span class="number">5</span> <span class="operator">!=</span> <span class="number">5</span>)</span><br><span class="line"><span class="comment">-- 简化后</span></span><br><span class="line">(a <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">and</span> <span class="literal">TRUE</span>) <span class="keyword">OR</span> (a <span class="operator">=</span> <span class="number">6</span> <span class="keyword">OR</span> <span class="literal">FALSE</span>)</span><br><span class="line"><span class="comment">-- 最终的表达式</span></span><br><span class="line">a <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">OR</span> a <span class="operator">=</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h4 id="12-1-4-表达式计算"><a href="#12-1-4-表达式计算" class="headerlink" title="12.1.4. 表达式计算"></a>12.1.4. 表达式计算</h4><p>在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">5</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="comment">-- 简化</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中，出现在某个更复杂表达式中，优化器是不会尝试对这些表达式进行化简的。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ABS</span>(a) <span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="operator">-</span>a <span class="operator">&lt;</span> <span class="number">-8</span></span><br></pre></td></tr></table></figure>
<p>所以只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，以上会示例可能会使索引失效</p>
<h4 id="12-1-5-常量表检测"><a href="#12-1-5-常量表检测" class="headerlink" title="12.1.5. 常量表检测"></a>12.1.5. 常量表检测</h4><p>使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。MySQL把通过这两种方式查询的表称之为常量表（英文名：constant tables）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line">    <span class="keyword">ON</span> table1.column1 <span class="operator">=</span> table2.column2</span><br><span class="line">    <span class="keyword">WHERE</span> table1.primary_key <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>优化器在分析以上查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。所以这个查询可以使用主键和常量值的等值匹配来查询 table1 表，也就是在这个查询中 table1 表相当于常量表，在分析对 table2 表的查询成本之前，就会执行对 table1 表的查询，并把查询中涉及 table1 表的条件都替换掉，也就是上边的语句会被转换成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1 表记录的各个字段的常量值, table2.<span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1 表 column1 列的常量值 <span class="operator">=</span> table2.column2;</span><br></pre></td></tr></table></figure>
<h3 id="12-2-外连接消除"><a href="#12-2-外连接消除" class="headerlink" title="12.2. 外连接消除"></a>12.2. 外连接消除</h3><p>外连接和内连接的本质区别就是：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配<code>ON</code>子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用<code>NULL</code>值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配<code>ON</code>子句中的过滤条件的记录，那么该记录会被舍弃。</p>
<p>只要在搜索条件中指定关于被驱动表相关列的值不为<code>NULL</code>，那么外连接中在被驱动表中找不到符合<code>ON</code>子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：外连接和内连接也就没有什么区别了！</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> e1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> e2 <span class="keyword">ON</span> e1.m1 <span class="operator">=</span> e2.m2 <span class="keyword">WHERE</span> e2.n2 <span class="keyword">IS</span> <span class="keyword">NOT NULL</span>;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> e1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> e2 <span class="keyword">ON</span> e1.m1 <span class="operator">=</span> e2.m2 <span class="keyword">WHERE</span> e2.m2 <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>这种在外连接查询中，指定的<code>WHERE</code>子句中包含被驱动表中的列不为 NULL 值的条件称之为空值拒绝（英文名：reject-NULL）。在被驱动表的<code>WHERE</code>子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。</p>
<h3 id="12-3-子查询优化（待补充）"><a href="#12-3-子查询优化（待补充）" class="headerlink" title="12.3. 子查询优化（待补充）"></a>12.3. 子查询优化（待补充）</h3><blockquote>
<p>TODO: 待补充内容</p>
<ol>
<li>子查询的执行方式</li>
<li>标量子查询、行子查询的执行方式</li>
<li>MySQL 对 IN 子查询的优化</li>
<li>物化表转连接</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io">蓝桉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io/posts/e582bf51.html">https://ktzxy.github.io/posts/e582bf51.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ktzxy.github.io" target="_blank">蓝桉`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post-share"><div class="social-share" data-image="/bg/Image00013.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src="/img/wechat.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src="/img/alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/d97c3bd3.html" title="MySQL-索引"><img class="cover" src="/bg/Image00025.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MySQL-索引</div></div><div class="info-2"><div class="info-item-1">1. 索引概述1.1. 什么是索引MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的示意图所示：  **索引的本质是：一种数据结构** **索引的作用是：高效获取数据**     左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。 1.2. 索引的优缺点1.2.1. 索引的优势 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消...</div></div></div></a><a class="pagination-related" href="/posts/ac28f454.html" title="MySQL-开发规范"><img class="cover" src="/bg/Image00024.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MySQL-开发规范</div></div><div class="info-2"><div class="info-item-1">1. 标准 SQL 语言没有规范以下功能 ID自示增长 分页 函数 编程语言 服务端的数据软件  2. 数据库命名规范 所有数据库对象名称必须使用小写字母并用下划线分割； 所有数据库对象名称禁止使用mysql保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）； 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符； 临时库表必须以tmp为前缀并以日期为后缀，备份表必须以bak为前缀并以日期(时间戳)为后缀； 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索 引失效，导致查询效率降低）。  3. SQL 语句规范 SQL 语句可以单行或多行书写，以分号结尾 可使用空格和缩进来增强语句的可读性 同样可以使用/**/的方式完成注释 MySQL 数据库的 SQL 语句不区分大小写，建议关键字使用大写，自定义的使用小写，例如：  1SELECT * FROM user; 4. 命名规范 数据库、表、字段的命名要遵守可读性原则，尽可能少使用或者不使用缩写 表名、字段名必须使用小写字母或数字，禁止...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img class="cover" src="/bg/Image00018.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">MySQL数据库150道高频面试题</div></div><div class="info-2"><div class="info-item-1">[toc] 1. Mysql 索引1.1. Mysql如何实现的索引机制？MySQL中索引分三类：B+树索引、Hash索引、全文索引 1.1.1. InnoDB索引与MyISAM索引实现的区别是什么？ MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的。 在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。 InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址。 MyISAM的表在磁盘上存储在以下文件中：  *.sdi（描述表结构）、*.MYD（数据），*.MYI（索引） InnoDB的表在磁盘上存储在以下文件中： .ibd（表结构、索引和数据都存在一起）   InnoDB的非聚簇索引data域存储相应记录主键的值 ，而MyISAM索引记录的是地址 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。 MyISAM的回表操作是十分快速的，因为是拿着地址偏...</div></div></div></a><a class="pagination-related" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img class="cover" src="/bg/Image00014.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">技术同学必会的MySQL设计规约</div></div><div class="info-2"><div class="info-item-1">在我们对数据库技术方案设计的时候，我们是否有自己的设计理念或者原则，还是更多的依据自己的直觉去设计，是否曾经懊悔线上发生过的一次低级故障，可能稍微注意点就可以避免，是否想过怎么才能很好的避免，下面规范的价值正是我们工作的检查清单，需要我们不断从错误中积累有效经验来指导未来的工作。以下规范在大型互联网公司经过了充分的验证，尤其适用于并发量大、数据量大的业务场景。先介绍的是安全规范，因为安全无小事，很多公司都曾经因为自己的数据泄露导致用户的惨痛损失，所以将安全规范放到了第一位。﻿ 一、安全规范1.【强制】禁止在数据库中存储明文密码，需把密码加密后存储 说明：对于加密操作建议由公司的中间件团队基于如mybatis的扩展，提供统一的加密算法及密钥管理，避免每个业务线单独开发一套，同时也与具体的业务进行了解耦 2.【强制】禁止在数据库中明文存储用户敏感信息，如手机号等 说明：对于手机号建议公司搭建统一的手机号查询服务，避免在每个业务线单独存储 3.【强制】禁止开发直接给业务同学导出或者查询涉及到用户敏感信息的数据，如需要需上级领导审批 4.【强制】涉及到导出数据功能的操作，如包含敏感字段都...</div></div></div></a><a class="pagination-related" href="/posts/dfdfdf4.html" title="数据库概述"><img class="cover" src="/bg/Image00002.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">数据库概述</div></div><div class="info-2"><div class="info-item-1">1. 数据库技术1.1. 概述数据库（DB）是一个以某种组织方式存储在磁盘上的数据的集合。简单理解就是用来存储数据的仓库。  数据库 DataBase（DB）：存储数据的仓库，数据是有组织的进行存储。 数据库管理系统 DataBase Management System (DBMS)：操纵和管理数据库的大型软件。  1.2. 数据库的分类  1.3. 不同的数据存储方式数据存储在集合（内存）中  优点：读写速度快 缺点：不能永久存储  数据存储在文件中  优点：可以永久存储 缺点：频繁的IO操作效率低，查询数据很不方便。  数据存储在数据库中  优点：可以永久存储。查询速度快，查询数据很方便 缺点：要使用 SQL 语言执行增删改查操作  2. 关系型数据库 关系型数据库 - 百度百科  2.1. 概念关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数...</div></div></div></a><a class="pagination-related" href="/posts/75522c08.html" title="第4节-布隆过滤器"><img class="cover" src="/bg/Image00003.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">第4节-布隆过滤器</div></div><div class="info-2"><div class="info-item-1">第4节-布隆过滤器BloomFilter面试题： 现有50亿个电话号码，选定其中10w个电话号码，如何要快速准确的判断这些号码是否已经存在？ 思路：  1、通过数据库查询———-实现快速有点难。  2、数据预放到内存集合中：50亿*8字节大约40G，内存太大了。 1、布隆过滤器是什么？它实际上==是一个很长的二进制数组+一系列随机hash算法映射函数，主要用于判断一个元素是否在集合中==。 通常我们会遇到很多要判断一个元素是否在某个集合中的业务场景，一般想到的是将集合中所有元素保存起来，然后通过比较确定。 链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。 但是随着集合中元素的增加，我们需要的存储空间也会呈现线性增长，最终达到瓶颈。 同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为O(n),O(logn),O(1)。这个时候，布隆过滤器（Bloom Filter）就应运而生  一句话概述：由一个初值为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在。 本质就是判断具体元素存不存在一个大的集合中。 布隆过滤器是一种类似set的数据...</div></div></div></a><a class="pagination-related" href="/posts/e4cd3c5b.html" title="第5节-缓存预热+缓存雪崩+缓存击穿+缓存穿透"><img class="cover" src="/bg/Image00008.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">第5节-缓存预热+缓存雪崩+缓存击穿+缓存穿透</div></div><div class="info-2"><div class="info-item-1">第5节-缓存预热+缓存雪崩+缓存击穿+缓存穿透1、缓存雪崩发生情况： ​    redis主机挂了，redis全盘崩溃，比如缓存中有大量数据同时过期。 解决方案：  redis缓存集群实现高可用，主从+哨兵|| redis cluster ehcache本地缓存 + hystrix 或者 阿里sentinel限流&amp;降级 开启Redis持久化机制/aof+rdb，尽快恢复缓存集群 2、缓存穿透 什么是缓存穿透  请求去查询一条记录，先redis后mysql发现，都查不到该条记录，但是每次请求都会打到数据库上面去，导致后台数据库压力暴增，这种现象我们称为缓存穿透，redis成为了一个摆设。 简单说就是，本来无一物，即不再redis中，也不在mysql中。  危害  数据库可能会被打崩。导致服务不可用。 第一次来查询后，一般我们会有回写redis机制， 第二次来查询的时候redis就有了，偶尔出现穿透现象一般情况无关紧要。  解决方案   1、返回空对象缓存或者缺省值 一般OK  但是存在黑客和恶意攻击情况 黑客会对你的系统进行攻击，拿到一个不存在的id，去查询数据，会产生大量...</div></div></div></a><a class="pagination-related" href="/posts/41ae0132.html" title="MongoDB-基础"><img class="cover" src="/bg/Image00026.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">MongoDB-基础</div></div><div class="info-2"><div class="info-item-1">1. MongoDb 概述MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。 1.1. MongoDB 特点MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的，模式自由的文档型数据库，具体特点总结如下：  面向集合存储，易于存储对象类型的数据 模式自由 支持动态查询 支持完全索引，包含内部对象 支持复制和故障恢复 使用高效的二进制数据存储，包括大型对象（如视频等） 自动处理碎片，以支持云计算层次的扩展性 支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，社区中也提供了对 Erlang 及.NET 等平台的驱动程序 文件存储格式为 BSON（一种 JSON 的...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">蓝桉</div><div class="author-info-description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">生活、学习、技术</b>相关的问题和看法，还有<b style="color:#fff">文章教程</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ktzxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/ktzxy" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2251511764@qq.com" target="_blank" title="Email"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-RSS"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/496148176" target="_blank" title="BiliBili"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QX-BILIBILI"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2251511764&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">1. 性能优化总论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">2. MySQL数据库优化准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 慢查询的定义与作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 慢查询基础-优化数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E8%AF%B7%E6%B1%82%E4%BA%86%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1. 请求了不需要的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%98%AF%E5%90%A6%E5%9C%A8%E6%89%AB%E6%8F%8F%E9%A2%9D%E5%A4%96%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2. 是否在扫描额外的记录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 重构查询的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E8%BF%98%E6%98%AF%E5%A4%9A%E4%B8%AA%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 一个复杂查询还是多个简单查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%88%87%E5%88%86%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 切分查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%88%86%E8%A7%A3%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3. 分解关联查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-SQL-%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. SQL 执行效率查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BC%9A%E8%AF%9D%E7%BB%9F%E8%AE%A1%E7%BB%93%E6%9E%9C"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. 查看当前会话统计结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E6%9F%A5%E7%9C%8B%E8%87%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E6%AC%A1%E5%90%AF%E5%8A%A8%E8%87%B3%E4%BB%8A%E7%BB%9F%E8%AE%A1%E7%BB%93%E6%9E%9C"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. 查看自数据库上次启动至今统计结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E6%9F%A5%E7%9C%8B%E9%92%88%E5%AF%B9Innodb%E5%BC%95%E6%93%8E%E7%9A%84%E7%BB%9F%E8%AE%A1%E7%BB%93%E6%9E%9C"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3. 查看针对Innodb引擎的统计结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="toc-number">2.5.</span> <span class="toc-text">2.5. 慢查询日志配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E6%9F%A5%E8%AF%A2%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1. 查询慢查询日志相关参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%96%B9%E5%BC%8F1-%E4%BF%AE%E6%94%B9mysql%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.2. 开启慢查询日志方式1 - 修改mysql配置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%96%B9%E5%BC%8F2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BF%AE%E6%94%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%85%8D%E7%BD%AE"><span class="toc-number">2.5.3.</span> <span class="toc-text">2.5.3. 开启慢查询日志方式2 - 命令行修改慢查询配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.5.4.</span> <span class="toc-text">2.5.4. 慢查询日志保存位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.6.</span> <span class="toc-text">2.6. 查询缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E7%8A%B6%E6%80%81"><span class="toc-number">2.6.1.</span> <span class="toc-text">2.6.1. 查询缓存状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E5%85%B3%E9%97%AD%E7%BC%93%E5%AD%98"><span class="toc-number">2.6.2.</span> <span class="toc-text">2.6.2. 关闭缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-sql-no-cache-%E5%85%B3%E9%94%AE%E5%AD%97%E7%A6%81%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">2.6.3.</span> <span class="toc-text">2.6.3. sql_no_cache 关键字禁用缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E8%AF%84%E4%BC%B0%E8%A1%A8%E6%95%B0%E6%8D%AE%E4%BD%93%E9%87%8F"><span class="toc-number">2.7.</span> <span class="toc-text">2.7. 评估表数据体量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E8%A1%A8%E5%AE%B9%E9%87%8F"><span class="toc-number">2.7.1.</span> <span class="toc-text">2.7.1. 表容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4"><span class="toc-number">2.7.2.</span> <span class="toc-text">2.7.2. 磁盘空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-%E5%AE%9E%E4%BE%8B%E5%AE%B9%E9%87%8F"><span class="toc-number">2.7.3.</span> <span class="toc-text">2.7.3. 实例容量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SQL-%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">3. SQL 语句性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E4%BD%8D%E4%BD%8E%E6%95%88%E7%8E%87%E6%89%A7%E8%A1%8C%E7%9A%84-SQL"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 定位低效率执行的 SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%A7%A3%E8%AF%BB%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 慢查询解读分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%85%A2%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. 慢日志格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-%E4%BA%86%E8%A7%A3"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. 分析工具(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-1-Mysqldumpslow"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">3.2.2.1. Mysqldumpslow</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-2-Mysqlsla"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">3.2.2.2. Mysqlsla</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-3-pt-query-digest"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">3.2.2.3. pt-query-digest</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-EXPLAIN-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">4.</span> <span class="toc-text">4. EXPLAIN 执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-explain-%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. explain 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 执行计划的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB%E8%A1%A8"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 字段类型汇总表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-id-%E5%88%97"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. id 列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E5%8D%95-SELECT-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1. 单 SELECT 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2. 连接查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E5%8C%85%E5%90%AB%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3. 包含子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-%E5%8C%85%E5%90%AB-UNION-%E5%AD%90%E5%8F%A5"><span class="toc-number">4.4.4.</span> <span class="toc-text">4.4.4. 包含 UNION 子句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-select-type-%E5%88%97"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. select_type 列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-SIMPLE-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1. SIMPLE 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-PRIMARY-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2. PRIMARY 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-UNION-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.5.3. UNION 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-4-UNION-RESULT-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.4.</span> <span class="toc-text">4.5.4. UNION RESULT 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-5-SUBQUERY-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.5.</span> <span class="toc-text">4.5.5. SUBQUERY 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-6-DEPENDENT-UNION%E3%80%81DEPENDENT-SUBQUERY-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.6.</span> <span class="toc-text">4.5.6. DEPENDENT UNION、DEPENDENT SUBQUERY 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-7-DERIVED-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.7.</span> <span class="toc-text">4.5.7. DERIVED 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-8-MATERIALIZED-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.8.</span> <span class="toc-text">4.5.8. MATERIALIZED 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-9-UNCACHEABLE-SUBQUERY%E3%80%81UNCACHEABLE-UNION-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.9.</span> <span class="toc-text">4.5.9. UNCACHEABLE SUBQUERY、UNCACHEABLE UNION 类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-table-%E5%88%97"><span class="toc-number">4.6.</span> <span class="toc-text">4.6. table 列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-partitions-%E5%88%97"><span class="toc-number">4.7.</span> <span class="toc-text">4.7. partitions 列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-type-%E5%88%97"><span class="toc-number">4.8.</span> <span class="toc-text">4.8. type 列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-1-type-%E5%88%97%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB"><span class="toc-number">4.8.1.</span> <span class="toc-text">4.8.1. type 列常见的类型汇总</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-2-system-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.2.</span> <span class="toc-text">4.8.2. system 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-3-const-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.3.</span> <span class="toc-text">4.8.3. const 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-4-eq-ref-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.4.</span> <span class="toc-text">4.8.4. eq_ref 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-5-ref-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.5.</span> <span class="toc-text">4.8.5. ref 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-6-fulltext-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.6.</span> <span class="toc-text">4.8.6. fulltext 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-7-ref-or-null-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.7.</span> <span class="toc-text">4.8.7. ref_or_null 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-8-index-merge-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.8.</span> <span class="toc-text">4.8.8. index_merge 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-9-unique-subquery-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.9.</span> <span class="toc-text">4.8.9. unique_subquery 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-10-index-subquery-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.10.</span> <span class="toc-text">4.8.10. index_subquery 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-11-range-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.11.</span> <span class="toc-text">4.8.11. range 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-12-index-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.12.</span> <span class="toc-text">4.8.12. index 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-13-all-%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.13.</span> <span class="toc-text">4.8.13. all 类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-possible-keys-%E5%88%97"><span class="toc-number">4.9.</span> <span class="toc-text">4.9. possible_keys 列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-key-%E5%88%97"><span class="toc-number">4.10.</span> <span class="toc-text">4.10. key 列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-key-len-%E5%88%97"><span class="toc-number">4.11.</span> <span class="toc-text">4.11. key_len 列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-11-1-key-len-%E8%AE%A1%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">4.11.1.</span> <span class="toc-text">4.11.1. key_len 计算规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-11-2-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-number">4.11.2.</span> <span class="toc-text">4.11.2. 不同类型占用的字节数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-11-3-%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.11.3.</span> <span class="toc-text">4.11.3. 示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-ref-%E5%88%97"><span class="toc-number">4.12.</span> <span class="toc-text">4.12. ref 列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-13-rows-%E5%88%97"><span class="toc-number">4.13.</span> <span class="toc-text">4.13. rows 列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-14-filtered-%E5%88%97"><span class="toc-number">4.14.</span> <span class="toc-text">4.14. filtered 列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-15-Extra-%E5%88%97"><span class="toc-number">4.15.</span> <span class="toc-text">4.15. Extra 列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-1-No-tables-used"><span class="toc-number">4.15.1.</span> <span class="toc-text">4.15.1. No tables used</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-2-impossible-where"><span class="toc-number">4.15.2.</span> <span class="toc-text">4.15.2. impossible where</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-3-No-matching-min-max-row"><span class="toc-number">4.15.3.</span> <span class="toc-text">4.15.3. No matching min&#x2F;max row</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-4-Using-index"><span class="toc-number">4.15.4.</span> <span class="toc-text">4.15.4. Using index</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-5-Using-index-condition"><span class="toc-number">4.15.5.</span> <span class="toc-text">4.15.5. Using index condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-6-Using-where"><span class="toc-number">4.15.6.</span> <span class="toc-text">4.15.6. Using where</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-7-Using-join-buffer-Block-Nested-Loop"><span class="toc-number">4.15.7.</span> <span class="toc-text">4.15.7. Using join buffer (Block Nested Loop)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-8-Not-exists"><span class="toc-number">4.15.8.</span> <span class="toc-text">4.15.8. Not exists</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-9-Using-intersect-%E2%80%A6-%E3%80%81Using-union-%E2%80%A6-%E5%92%8C-Using-sort-union-%E2%80%A6"><span class="toc-number">4.15.9.</span> <span class="toc-text">4.15.9. Using intersect(…)、Using union(…)和 Using sort_union(…)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-10-Zero-limit"><span class="toc-number">4.15.10.</span> <span class="toc-text">4.15.10. Zero limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-11-Using-filesort%EF%BC%88%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">4.15.11.</span> <span class="toc-text">4.15.11. Using filesort（文件排序）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-15-11-1-filesort-%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="toc-number">4.15.11.1.</span> <span class="toc-text">4.15.11.1. filesort 文件排序方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-15-11-2-%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">4.15.11.2.</span> <span class="toc-text">4.15.11.2. 文件排序模式的选择</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-12-Using-temporary"><span class="toc-number">4.15.12.</span> <span class="toc-text">4.15.12. Using temporary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-13-Start-temporary-End-temporary"><span class="toc-number">4.15.13.</span> <span class="toc-text">4.15.13. Start temporary, End temporary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-14-select-tables-optimized-away"><span class="toc-number">4.15.14.</span> <span class="toc-text">4.15.14. select tables optimized away</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-15-LooseScan"><span class="toc-number">4.15.15.</span> <span class="toc-text">4.15.15. LooseScan</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-15-16-FirstMatch-tbl-name"><span class="toc-number">4.15.16.</span> <span class="toc-text">4.15.16. FirstMatch(tbl_name)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-16-explain-%E4%B8%A4%E4%B8%AA%E5%8F%98%E7%A7%8D"><span class="toc-number">4.16.</span> <span class="toc-text">4.16. explain 两个变种</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-16-1-explain-extended%EF%BC%88%E5%B7%B2%E8%BF%87%E6%97%B6%EF%BC%89"><span class="toc-number">4.16.1.</span> <span class="toc-text">4.16.1. explain extended（已过时）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-16-2-explain-partitions"><span class="toc-number">4.16.2.</span> <span class="toc-text">4.16.2. explain partitions</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%88%86%E6%9E%90%E6%85%A2-sql-%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">5. 分析慢 sql 的其他方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E9%80%9A%E8%BF%87-show-processlist-%E5%88%86%E6%9E%90-SQL"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 通过 show processlist 分析 SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%80%9A%E8%BF%87-show-profile-%E5%88%86%E6%9E%90-SQL"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 通过 show profile 分析 SQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-SQL-%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.</span> <span class="toc-text">6. SQL 优化最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-SQL-%E7%BC%96%E5%86%99%E8%A7%84%E8%8C%83"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. SQL 编写规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 插入数据优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1. 批量插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2. 手动控制事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3. 主键顺序插入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-MySQL-%E5%A4%A7%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. MySQL 大批量数据导入性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E4%BC%A0%E7%BB%9F%E7%9A%84-insert-%E4%BC%98%E5%8C%96"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1. 传统的 insert 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2. 存储过程+开启事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E4%BD%BF%E7%94%A8-load-%E6%8C%87%E4%BB%A4"><span class="toc-number">6.3.3.</span> <span class="toc-text">6.3.3. 使用 load 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E5%AF%BC%E5%85%A5"><span class="toc-number">6.3.4.</span> <span class="toc-text">6.3.4. 主键顺序导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-5-%E5%85%B3%E9%97%AD%E5%94%AF%E4%B8%80%E6%80%A7%E6%A0%A1%E9%AA%8C"><span class="toc-number">6.3.5.</span> <span class="toc-text">6.3.5. 关闭唯一性校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E4%BC%98%E5%8C%96-order-by-%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. 优化 order by 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-Filesort-%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1. Filesort 的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">6.4.2.</span> <span class="toc-text">6.4.2. 通过索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-order-by-%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99%E5%B0%8F%E7%BB%93"><span class="toc-number">6.4.3.</span> <span class="toc-text">6.4.3. order by 优化原则小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E4%BC%98%E5%8C%96-group-by-%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.5.</span> <span class="toc-text">6.5. 优化 group by 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1-%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">6.5.1.</span> <span class="toc-text">6.5.1. 通过索引优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C%E5%8E%9F%E5%88%99"><span class="toc-number">6.5.2.</span> <span class="toc-text">6.5.2. 分组操作原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E4%BC%98%E5%8C%96-limit-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%EF%BC%88%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">6.6. 优化 limit 分页查询（超大分页）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%88%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%EF%BC%89%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">6.6.1. 优化思路一：子查询（连接查询）覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E"><span class="toc-number">6.6.2.</span> <span class="toc-text">6.6.2. 优化思路二：主键自增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E4%B8%89%EF%BC%9A%E8%AE%A1%E7%AE%97%E8%BE%B9%E7%95%8C%E5%80%BC%EF%BC%8C%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B7%B2%E7%9F%A5%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.6.3.</span> <span class="toc-text">6.6.3. 优化思路三：计算边界值，转换为已知位置的查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-number">6.6.4.</span> <span class="toc-text">6.6.4. 其他优化思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E4%BC%98%E5%8C%96-count-%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.7.</span> <span class="toc-text">6.7. 优化 count 查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-1-%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-number">6.7.1.</span> <span class="toc-text">6.7.1. 优化思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-count-%E7%9A%84%E5%90%84%E7%A7%8D%E5%86%99%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">6.7.2.</span> <span class="toc-text">6.7.2. count 的各种写法比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E4%BC%98%E5%8C%96-update-%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.8.</span> <span class="toc-text">6.8. 优化 update 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E4%BC%98%E5%8C%96%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">6.9.</span> <span class="toc-text">6.9. 优化子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">6.10.</span> <span class="toc-text">6.10. 关联查询的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-in-%E5%92%8C-exsits-%E4%BC%98%E5%8C%96"><span class="toc-number">6.11.</span> <span class="toc-text">6.11. in 和 exsits 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-SQL-%E8%AF%AD%E6%B3%95%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">6.12.</span> <span class="toc-text">6.12. SQL 语法优化的总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5"><span class="toc-number">7.</span> <span class="toc-text">7. 高性能的索引策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. 索引创建策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%B0%BD%E9%87%8F%E5%B0%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1. 索引列的类型尽量小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9%E6%80%A7-%E7%A6%BB%E6%95%A3%E6%80%A7%E8%A6%81%E9%AB%98"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2. 索引的选择性&#x2F;离散性要高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3. 前缀索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4-%E5%8F%AA%E4%B8%BA%E7%94%A8%E4%BA%8E%E6%90%9C%E7%B4%A2%E3%80%81%E6%8E%92%E5%BA%8F%E6%88%96%E5%88%86%E7%BB%84%E7%9A%84%E5%88%97%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.4.</span> <span class="toc-text">7.1.4. 只为用于搜索、排序或分组的列创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-5-%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">7.1.5.</span> <span class="toc-text">7.1.5. 多列索引列的顺序的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-6-%E8%AE%BE%E8%AE%A1%E4%B8%89%E6%98%9F%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.6.</span> <span class="toc-text">7.1.6. 设计三星索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-6-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.6.1.</span> <span class="toc-text">7.1.6.1. 概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-6-2-%E8%BE%BE%E6%88%90%E4%B8%89%E6%98%9F%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.6.2.</span> <span class="toc-text">7.1.6.2. 达成三星索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-6-3-%E8%BE%BE%E4%B8%8D%E6%88%90%E4%B8%89%E6%98%9F%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.6.3.</span> <span class="toc-text">7.1.6.3. 达不成三星索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-7-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">7.1.7.</span> <span class="toc-text">7.1.7. 主键索引设计原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-8-%E9%81%BF%E5%85%8D%E5%BB%BA%E7%AB%8B%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.8.</span> <span class="toc-text">7.1.8. 避免建立冗余索引和重复索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-9-%E5%88%A0%E9%99%A4%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">7.1.9.</span> <span class="toc-text">7.1.9. 删除未使用的索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-10-%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">7.1.10.</span> <span class="toc-text">7.1.10. 不建议使用索引的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. 索引使用策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E4%B8%8D%E5%9C%A8%E7%B4%A2%E5%BC%95%E5%88%97%E4%B8%8A%E5%81%9A%E4%BB%BB%E4%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1. 不在索引列上做任何操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-%E5%B0%BD%E9%87%8F%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2. 尽量全值匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.2.3. 最佳左前缀法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E6%94%BE%E6%9C%80%E5%90%8E"><span class="toc-number">7.2.4.</span> <span class="toc-text">7.2.4. 范围条件放最后</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.5.</span> <span class="toc-text">7.2.5. 优先使用覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-6-%E4%B8%8D%E7%AD%89%E4%BA%8E%E8%A6%81%E6%85%8E%E7%94%A8"><span class="toc-number">7.2.6.</span> <span class="toc-text">7.2.6. 不等于要慎用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-7-null-not-Null-%E5%AF%B9%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">7.2.7.</span> <span class="toc-text">7.2.7. null &#x2F; not Null 对索引的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-8-%E6%B3%A8%E6%84%8F%E4%BD%BF%E7%94%A8-LIKE-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.2.8.</span> <span class="toc-text">7.2.8. 注意使用 LIKE 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-8-1-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">7.2.8.1.</span> <span class="toc-text">7.2.8.1. 索引下推</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-9-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E5%8A%A0%E5%BC%95%E5%8F%B7"><span class="toc-number">7.2.9.</span> <span class="toc-text">7.2.9. 字符类型加引号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-10-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8-OR-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.2.10.</span> <span class="toc-text">7.2.10. 查询语句中使用 OR 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-11-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F%E6%9D%A5%E5%81%9A%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E7%BB%84"><span class="toc-number">7.2.11.</span> <span class="toc-text">7.2.11. 使用索引扫描来做排序和分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-12-%E6%8E%92%E5%BA%8F%E8%A6%81%E5%BD%93%E5%BF%83"><span class="toc-number">7.2.12.</span> <span class="toc-text">7.2.12. 排序要当心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-13-%E7%B4%A2%E5%BC%95-SET-%E8%A7%84%E8%8C%83"><span class="toc-number">7.2.13.</span> <span class="toc-text">7.2.13. 索引 SET 规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-14-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%EF%BC%88%E5%A4%9A%E5%88%97%EF%BC%89%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.14.</span> <span class="toc-text">7.2.14. 查询语句中使用联合（多列）索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-15-%E5%B0%91%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.15.</span> <span class="toc-text">7.2.15. 少创建多个单列索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-16-in-not-in-%E5%AF%B9%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">7.2.16.</span> <span class="toc-text">7.2.16. in &#x2F; not in 对索引的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-17-%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-number">7.2.17.</span> <span class="toc-text">7.2.17. 主键顺序插入优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-17-1-%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.17.1.</span> <span class="toc-text">7.2.17.1. 数据组织方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-17-2-%E9%A1%B5%E5%88%86%E8%A3%82"><span class="toc-number">7.2.17.2.</span> <span class="toc-text">7.2.17.2. 页分裂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-17-3-%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C"><span class="toc-number">7.2.17.3.</span> <span class="toc-text">7.2.17.3. 主键顺序插入效果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-17-4-%E4%B8%BB%E9%94%AE%E4%B9%B1%E5%BA%8F%E6%8F%92%E5%85%A5%E6%95%88%E6%9E%9C"><span class="toc-number">7.2.17.4.</span> <span class="toc-text">7.2.17.4. 主键乱序插入效果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-17-5-%E9%A1%B5%E5%90%88%E5%B9%B6"><span class="toc-number">7.2.17.5.</span> <span class="toc-text">7.2.17.5. 页合并</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-18-SQL-%E6%8F%90%E7%A4%BA"><span class="toc-number">7.2.18.</span> <span class="toc-text">7.2.18. SQL 提示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93"><span class="toc-number">7.3.</span> <span class="toc-text">7.3. 索引策略总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-MySQL-%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%88%90%E6%9C%AC"><span class="toc-number">8.</span> <span class="toc-text">8. MySQL 的查询成本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%88%90%E6%9C%AC%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. 成本的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC-%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4%EF%BC%88TODO-mark-%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. 单表查询的成本 - 基于成本的优化步骤（TODO mark: 待补充）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%EF%BC%8C%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1. 根据搜索条件，找出所有可能使用的索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%EF%BC%81%E5%BE%85%E6%95%B4%E7%90%86-%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC-%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E7%9A%84%E6%88%90%E6%9C%AC%E8%AE%A1%E7%AE%97"><span class="toc-number">8.3.</span> <span class="toc-text">8.3. (！待整理)单表查询的成本 - 基于索引统计数据的成本计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%EF%BC%81%E5%BE%85%E6%95%B4%E7%90%86-EXPLAIN-%E8%BE%93%E5%87%BA%E6%88%90%E6%9C%AC"><span class="toc-number">8.4.</span> <span class="toc-text">8.4. (！待整理)EXPLAIN 输出成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-Optimizer-Trace-%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">8.5.</span> <span class="toc-text">8.5. Optimizer Trace 分析优化器执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF-Trace-%E5%8A%9F%E8%83%BD"><span class="toc-number">8.5.1.</span> <span class="toc-text">8.5.1. 检查是否开启 Trace 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-%E4%BD%BF%E7%94%A8-Trace-%E5%8A%9F%E8%83%BD"><span class="toc-number">8.5.2.</span> <span class="toc-text">8.5.2. 使用 Trace 功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.5.3.</span> <span class="toc-text">8.5.3. 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">8.6.</span> <span class="toc-text">8.6. 连接查询的成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%EF%BC%81%E5%BE%85%E6%95%B4%E7%90%86-%E8%B0%83%E8%8A%82%E6%88%90%E6%9C%AC%E5%B8%B8%E6%95%B0"><span class="toc-number">8.7.</span> <span class="toc-text">8.7. (！待整理)调节成本常数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%85%A8%E5%B1%80%E8%80%83%E8%99%91%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">9. 全局考虑性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E4%BC%9A%E6%85%A2"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. 为什么查询速度会慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. 查询执行的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-MySQL-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">9.3.</span> <span class="toc-text">9.3. MySQL 客户端&#x2F;服务器通信协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E6%9F%A5%E8%AF%A2%E7%8A%B6%E6%80%81"><span class="toc-number">9.4.</span> <span class="toc-text">9.4. 查询状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-number">9.5.</span> <span class="toc-text">9.5. 查询优化处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-number">9.6.</span> <span class="toc-text">9.6. 查询执行引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">9.7.</span> <span class="toc-text">9.7. 返回结果给客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-InnoDB-%E5%BC%95%E6%93%8E%E5%BA%95%E5%B1%82%E8%A7%A3%E6%9E%90"><span class="toc-number">10.</span> <span class="toc-text">10. InnoDB 引擎底层解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-InnoDB-%E4%B8%AD%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">10.1.</span> <span class="toc-text">10.1. InnoDB 中的统计数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">10.1.1.</span> <span class="toc-text">10.1.1. 统计数据存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-%E5%9F%BA%E4%BA%8E%E7%A3%81%E7%9B%98%E7%9A%84%E6%B0%B8%E4%B9%85%E6%80%A7%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">10.1.2.</span> <span class="toc-text">10.1.2. 基于磁盘的永久性统计数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-2-1-innodb-table-stats"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">10.1.2.1. innodb_table_stats</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-2-2-innodb-index-stats"><span class="toc-number">10.1.2.2.</span> <span class="toc-text">10.1.2.2. innodb_index_stats</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-2-3-%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">10.1.2.3.</span> <span class="toc-text">10.1.2.3. 定期更新统计数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-%E6%89%8B%E5%8A%A8%E6%9B%B4%E6%96%B0-innodb-table-stats-%E5%92%8C-innodb-index-stats-%E8%A1%A8"><span class="toc-number">10.1.3.</span> <span class="toc-text">10.1.3. 手动更新 innodb_table_stats 和 innodb_index_stats 表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-InnoDB-%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E7%B4%A2%E5%BC%95%E9%A1%B5%E7%BB%93%E6%9E%84-TODO-mark-%E6%95%B4%E7%90%86%E4%B8%AD"><span class="toc-number">10.2.</span> <span class="toc-text">10.2. InnoDB 记录存储结构和索引页结构(TODO mark: 整理中)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-%E6%8C%87%E5%AE%9A%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">10.2.1.</span> <span class="toc-text">10.2.1. 指定行格式的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-2-1-1-COMPACT-%E7%B1%BB%E5%9E%8B%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">10.2.1.1.</span> <span class="toc-text">10.2.1.1. COMPACT 类型行格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-2-1-2-Redundant-%E8%A1%8C%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%BE%85%E6%95%B4%E7%90%86%EF%BC%89"><span class="toc-number">10.2.1.2.</span> <span class="toc-text">10.2.1.2. Redundant 行格式（待整理）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-%E7%B4%A2%E5%BC%95%E9%A1%B5%E6%A0%BC%E5%BC%8F%EF%BC%88%E5%BE%85%E6%95%B4%E7%90%86%EF%BC%89"><span class="toc-number">10.2.2.</span> <span class="toc-text">10.2.2. 索引页格式（待整理）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-InnoDB-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">10.3.</span> <span class="toc-text">10.3. InnoDB 的内存结构总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-InnoDB-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%9B%BE%E6%80%BB%E7%BB%93"><span class="toc-number">10.3.1.</span> <span class="toc-text">10.3.1. InnoDB 的内存结构和磁盘存储结构图总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-%E6%89%A9%E5%B1%95%E7%9F%A5%E8%AF%86"><span class="toc-number">10.3.2.</span> <span class="toc-text">10.3.2. 扩展知识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-MySQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">11. MySQL 的执行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E4%B9%8B%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6"><span class="toc-number">11.1.</span> <span class="toc-text">11.1. 单表访问之索引合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-%E5%B9%B6%E9%9B%86%EF%BC%88Intersection%EF%BC%89%E5%90%88%E5%B9%B6"><span class="toc-number">11.1.1.</span> <span class="toc-text">11.1.1. 并集（Intersection）合并</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-1-1-%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E7%AD%89%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-number">11.1.1.1.</span> <span class="toc-text">11.1.1.1. 情况一：等值匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-1-2-%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E4%B8%BB%E9%94%AE%E5%88%97%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%8C%83%E5%9B%B4%E5%8C%B9%E9%85%8D"><span class="toc-number">11.1.1.2.</span> <span class="toc-text">11.1.1.2. 情况二：主键列可以是范围匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-1-3-%E7%B4%A2%E5%BC%95%E5%B9%B6%E9%9B%86%E5%90%88%E5%B9%B6%E5%B0%8F%E7%BB%93"><span class="toc-number">11.1.1.3.</span> <span class="toc-text">11.1.1.3. 索引并集合并小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2-Union-%E5%90%88%E5%B9%B6"><span class="toc-number">11.1.2.</span> <span class="toc-text">11.1.2. Union 合并</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-2-1-%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E7%AD%89%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-number">11.1.2.1.</span> <span class="toc-text">11.1.2.1. 情况一：等值匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-2-2-%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E4%B8%BB%E9%94%AE%E5%88%97%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%8C%83%E5%9B%B4%E5%8C%B9%E9%85%8D"><span class="toc-number">11.1.2.2.</span> <span class="toc-text">11.1.2.2. 情况二：主键列可以是范围匹配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-2-3-%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8-Intersection-%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6%E7%9A%84%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6"><span class="toc-number">11.1.2.3.</span> <span class="toc-text">11.1.2.3. 情况三：使用 Intersection 索引合并的搜索条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-1-2-4-%E7%B4%A2%E5%BC%95%E5%B9%B6%E9%9B%86%E5%90%88%E5%B9%B6%E5%B0%8F%E7%BB%93"><span class="toc-number">11.1.2.4.</span> <span class="toc-text">11.1.2.4. 索引并集合并小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-3-Sort-Union-%E5%90%88%E5%B9%B6"><span class="toc-number">11.1.3.</span> <span class="toc-text">11.1.3. Sort-Union 合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-4-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9B%BF%E4%BB%A3-Intersection-%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6"><span class="toc-number">11.1.4.</span> <span class="toc-text">11.1.4. 联合索引替代 Intersection 索引合并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">11.2.</span> <span class="toc-text">11.2. 连接查询的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5-Nested-Loop-Join-NLJ-%E7%AE%97%E6%B3%95"><span class="toc-number">11.2.1.</span> <span class="toc-text">11.2.1. 嵌套循环连接 Nested-Loop Join (NLJ) 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-2-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E5%8A%A0%E5%BF%AB%E8%BF%9E%E6%8E%A5%E9%80%9F%E5%BA%A6"><span class="toc-number">11.2.2.</span> <span class="toc-text">11.2.2. 使用索引加快连接速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-3-%E5%9F%BA%E4%BA%8E%E5%9D%97%E7%9A%84%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5-Block-Nested-Loop-Join-BNL-%E7%AE%97%E6%B3%95"><span class="toc-number">11.2.3.</span> <span class="toc-text">11.2.3. 基于块的嵌套循环连接 Block Nested-Loop Join (BNL)算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-MySQL-%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">12. MySQL 的查询重写规则（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E6%9D%A1%E4%BB%B6%E5%8C%96%E7%AE%80"><span class="toc-number">12.1.</span> <span class="toc-text">12.1. 条件化简</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-1-%E7%A7%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">12.1.1.</span> <span class="toc-text">12.1.1. 移除不必要的括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-2-%E5%B8%B8%E9%87%8F%E4%BC%A0%E9%80%92%EF%BC%88constant-propagation%EF%BC%89"><span class="toc-number">12.1.2.</span> <span class="toc-text">12.1.2. 常量传递（constant_propagation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-3-%E7%A7%BB%E9%99%A4%E6%B2%A1%E7%94%A8%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%88trivial-condition-removal%EF%BC%89"><span class="toc-number">12.1.3.</span> <span class="toc-text">12.1.3. 移除没用的条件（trivial_condition_removal）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-4-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">12.1.4.</span> <span class="toc-text">12.1.4. 表达式计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-5-%E5%B8%B8%E9%87%8F%E8%A1%A8%E6%A3%80%E6%B5%8B"><span class="toc-number">12.1.5.</span> <span class="toc-text">12.1.5. 常量表检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E5%A4%96%E8%BF%9E%E6%8E%A5%E6%B6%88%E9%99%A4"><span class="toc-number">12.2.</span> <span class="toc-text">12.2. 外连接消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%EF%BC%88%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">12.3. 子查询优化（待补充）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img src="/bg/Image00018.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库150道高频面试题"/></a><div class="content"><a class="title" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题">MySQL数据库150道高频面试题</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术同学必会的MySQL设计规约"/></a><div class="content"><a class="title" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约">技术同学必会的MySQL设计规约</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dfdfdf4.html" title="数据库概述"><img src="/bg/Image00002.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库概述"/></a><div class="content"><a class="title" href="/posts/dfdfdf4.html" title="数据库概述">数据库概述</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/490575ab.html" title="24工厂模式俗话解释"><img src="/bg/Image00024.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24工厂模式俗话解释"/></a><div class="content"><a class="title" href="/posts/490575ab.html" title="24工厂模式俗话解释">24工厂模式俗话解释</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/364ea8cc.html" title="设计模式"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/364ea8cc.html" title="设计模式">设计模式</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2020 - 2025 By 蓝桉</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8152976493" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat/cat.js"></script><script async data-pjax src="/js/meting/music_lanan.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/day/lunar.js"></script><script defer src="/js/day/day.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '10a7db1c41b6489db9c830c668a18304';
  var gaud_map_key = '82a64bc994fb6494830f157f319f9f69';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime/runtime.min.js"></script><script async src="/js/font/ali_font_all.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java扩展-设计模式 | 蓝桉`Blog</title><meta name="author" content="蓝桉,kt_zxh@163.com"><meta name="copyright" content="蓝桉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="设计模式1. 简介设计模式（Design Pattern），是经过高度抽象化的在编程中可以被反复使用的代码设计经验的总结，是解决特定问题的一系列套路，是一种编程思想。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。 正确使用设计模式能有效提高代码的可读性、可重用性和可靠性，编写符合设计模式规范的代码不但有利于自身系统的稳定、可靠，还有利于外部系统的对接。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java扩展-设计模式">
<meta property="og:url" content="https://ktzxy.github.io/posts/680ac9d7.html">
<meta property="og:site_name" content="蓝桉&#96;Blog">
<meta property="og:description" content="设计模式1. 简介设计模式（Design Pattern），是经过高度抽象化的在编程中可以被反复使用的代码设计经验的总结，是解决特定问题的一系列套路，是一种编程思想。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。 正确使用设计模式能有效提高代码的可读性、可重用性和可靠性，编写符合设计模式规范的代码不但有利于自身系统的稳定、可靠，还有利于外部系统的对接。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ktzxy.github.io/bg/Image00010.webp">
<meta property="article:published_time" content="2025-07-09T17:28:45.000Z">
<meta property="article:modified_time" content="2025-07-13T15:45:18.464Z">
<meta property="article:author" content="蓝桉">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ktzxy.github.io/bg/Image00010.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java扩展-设计模式",
  "url": "https://ktzxy.github.io/posts/680ac9d7.html",
  "image": "https://ktzxy.github.io/bg/Image00010.webp",
  "datePublished": "2025-07-09T17:28:45.000Z",
  "dateModified": "2025-07-13T15:45:18.464Z",
  "author": [
    {
      "@type": "Person",
      "name": "蓝桉",
      "url": "https://ktzxy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ktzxy.github.io/posts/680ac9d7.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java扩展-设计模式',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/windmill/windmill.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/meting/music_lanan.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="蓝桉`Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/bg.webp);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/bg/Image00010.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">蓝桉`Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java扩展-设计模式</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java扩展-设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-09T17:28:45.000Z" title="发表于 2025-07-09 17:28:45">2025-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-13T15:45:18.464Z" title="更新于 2025-07-13 15:45:18">2025-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>设计模式（Design Pattern），是经过高度抽象化的在编程中可以被反复使用的代码设计经验的总结，是解决特定问题的一系列套路，是一种编程思想。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p>
<p>正确使用设计模式能有效提高代码的可读性、可重用性和可靠性，编写符合设计模式规范的代码不但有利于自身系统的稳定、可靠，还有利于外部系统的对接。在使用了良好的设计模式的系统工程中，无论是对满足当前的需求，还是对适应未来的需求，无论是对自身系统间模块的对接，还是对外部系统的对接，都有很大的帮助。</p>
<p>随着软件工程的不断演进，针对不同的需求，新的设计模式不断被提出（比如大数据领域中这些年不断被大家认可的数据分片思想），但设计模式的原则不会变。基于设计模式的原则，可以使用已有的设计模式，也可以根据产品或项目的开发需求在现有的设计模式基础上组合、改造或重新设计自身的设计模式。</p>
<h2 id="2-设计模式的原则"><a href="#2-设计模式的原则" class="headerlink" title="2. 设计模式的原则"></a>2. 设计模式的原则</h2><p>设计模式有 7 个原则：单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成／聚合复用原则、迪米特法则。具体内容如下：</p>
<ol>
<li><strong>单一职责原则</strong>，又称单一功能原则，它规定一个类只有一个职责。如果有多个职责（功能）被设计在一个类中，这个类就违反了单一职责原则。</li>
<li><strong>开闭原则</strong>，规定软件中的对象（类、模块、函数等）对扩展开放，对修改封闭，这意味着一个实体允许在不改变其源代码的前提下改变其行为，该特性在产品化的环境下是特别有价值的，在这种环境下，改变惊代码需要经过代码审查、单元测试等过程，以确保产品的使用质量。遵循这个原则的代码在扩展时并不发生改变，因此不需要经历上述过程。</li>
<li><strong>里氏代换原则</strong>，是对开闭原则的补充，规定了在任意父类可以出现的地方，子类都一定可以出现。实现开闭原则的关键就是抽象化，父类与子类的继承关系就是抽象化的具体表现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</li>
<li><strong>依赖倒转原则</strong>，指程序要依赖于抽象（Java 中的抽象类和接口），而不依赖于具体的实现（Java 中的实现类）。简单地说，就是要求对抽象进行编程，不要求对实现进行编程，这就降低了用户与实现模块之间的耦合度。</li>
<li><strong>接口隔离原则</strong>，指通过将不同的功能定义在不同的接口中来实现接口的隔离，这样就避免了其他类在依赖该接口（接口上定义的功能）时依赖其不需要的接口，可减少接口之间依赖的冗余性和复杂性。</li>
<li><strong>合成／聚合复用原则</strong>，指通过在一个新的对象中引人（注入）已有的对象以达到类的功能复用和扩展的目的。它的设计原则是要尽量使用合成或聚合而不要使用继承来扩展类的功能。</li>
<li><strong>迪米特法则</strong>，指一个对象尽可能少地与其他对象发生相互了解或依赖。其核心思想在于降低模块之间的耦合度，提高模块的内聚性。迪米特法则规定每个模块对其他模块都要有尽可能少的了解和依赖，因此很容易使系统模块之间功能独立，这使得各个模块的独立运行变得更简单，同时使得各个模块之间的组合变得更容易。</li>
</ol>
<h2 id="3-设计模式的分类"><a href="#3-设计模式的分类" class="headerlink" title="3. 设计模式的分类"></a>3. 设计模式的分类</h2><p>设计模式按照其功能和使用场景可以分为三大类：<strong>创建型模式（Creational Pattern）</strong>、<strong>结构型模式（Structural Pattern）</strong>和<strong>行为型模式（Behavioral Pattern）</strong></p>
<ul>
<li><strong>创建型模式</strong>：提供了多种优雅创建对象的方法<ul>
<li>[x] 工厂模式（Factory Pattern）</li>
<li>[ ] 抽象工厂模式（Abstract Factory Pattern）</li>
<li>[x] 单例模式（Singleton Pattern）</li>
<li>[ ] 建造者模式（Builder Pattern）</li>
<li>[ ] 原型模式（Prototype Pattern）</li>
</ul>
</li>
<li><strong>结构型模式</strong>：通过类和接口之间的继承和引用实现创建复杂结构对象的功能<ul>
<li>[x] 适配器模式（Adapter Pattern ）</li>
<li>[ ] 桥接模式（Bridge Pattern）</li>
<li>[ ] 过滤器模式（Filter 、Criteria Pattern）</li>
<li>[ ] 组合模式（Composite Pattern）</li>
<li>[ ] 装饰器模式（Decorator Pattern）</li>
<li>[ ] 外观模式（Facade Pattern）</li>
<li>[ ] 享元模式（Flyweight Pattern）</li>
<li>[ ] 代理模式（Proxy Pattern）</li>
</ul>
</li>
<li><strong>行为型模式</strong>：通过类之间不同的通信方式实现不同的行为方式<ul>
<li>[ ] 责任链模式（Chain of Responsibility Pattern）</li>
<li>[ ] 命令模式（Command Pattern）</li>
<li>[ ] 解释器模式（Interpreter Pattern）</li>
<li>[ ] 迭代器模式（Iterator Pattern）</li>
<li>[ ] 中介者模式（Mediator Pattern）</li>
<li>[ ] 备忘录模式（Memento Pattern）</li>
<li>[ ] 观察者模式（Observer Pattern）</li>
<li>[ ] 状态模式（State Pattern）</li>
<li>[ ] 策略模式（Strategy Pattern）</li>
<li>[x] 模板模式（Template Pattern）</li>
<li>[ ] 访问者模式（Visitor Pattern）</li>
</ul>
</li>
</ul>
<h1 id="单例设计模式（Singleten-Pattern）"><a href="#单例设计模式（Singleten-Pattern）" class="headerlink" title="单例设计模式（Singleten Pattern）"></a>单例设计模式（Singleten Pattern）</h1><blockquote>
<p>框架中会经常出现单例类</p>
</blockquote>
<h2 id="1-单例的特点"><a href="#1-单例的特点" class="headerlink" title="1. 单例的特点"></a>1. 单例的特点</h2><ol>
<li>类在程序的运行过程中只有一个对象(实例)。</li>
<li>私有构造方法，不能让外界创建该类的对象。</li>
<li>类必须提供一个静态公共方法返回该类的对象。</li>
</ol>
<h2 id="2-单例实现方式（饿汉式）"><a href="#2-单例实现方式（饿汉式）" class="headerlink" title="2. 单例实现方式（饿汉式）"></a>2. 单例实现方式（饿汉式）</h2><p>当类加载时，就立即创建该单例对象。饿汉式是线程安全的。实现步骤如下：</p>
<ol>
<li>定义一个静态的对象成员变量</li>
<li>要私有构造方法，如果不处理，系统会自动提供一个无参的构造方法。外界就可以直接new对象</li>
<li>定义一个静态的成员方法，用来获取创建好的对象成员，一般命名用 <code>getInstance()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例类，饿汉式：非懒加载。</span></span><br><span class="line"><span class="comment"> * 当类加载时，就立即创建该单例对象。以空间换时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态的成员变量，在类加载完成之后都已经完成了初始化赋值的操作。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：要私有构造方法，如果不处理，系统会自动提供一个无参的构造方法。</span></span><br><span class="line">    <span class="comment">// 保证其他类对象使用时不能直接new一个新的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态的成员方法，用来获取创建好的成员对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>涉及知识点提示：所有的静态成员在类加载完成之后都已经完成了初始化赋值的操作。也就是<code>EagerSingleton</code>类的私有构造函数会被调用，实例会被创建。还有就是构造函数要使用<code>private</code>修饰，为了防止使用<code>new</code>关键字来创建一个新的实例，就会变成“多例”并存的情况。</p>
</blockquote>
<h2 id="3-单例实现方式（懒汉式）"><a href="#3-单例实现方式（懒汉式）" class="headerlink" title="3. 单例实现方式（懒汉式）"></a>3. 单例实现方式（懒汉式）</h2><h3 id="3-1-实现前置分析"><a href="#3-1-实现前置分析" class="headerlink" title="3.1. 实现前置分析"></a>3.1. 实现前置分析</h3><p>当外界第一次要使用该类的对象时，如果还没有创建出来，则创建该单例对象。懒汉式是线程不安全的，要处理线程安全问题，实际上创建对象要进过如下几个步骤：</p>
<ol>
<li>分配内存空间</li>
<li>调用构造器，初始化实例</li>
<li>返回地址给引用</li>
</ol>
<p>因为创建对象是一个非原子操作，编译器可能会重排序⌈构造函数可能在整个对象初始化完成前执行完毕，即赋值操作（只是在内存中开辟一片存储区域后直接返回内存的引用）在初始化对象前完成⌋。而线程C在线程A赋值完时判断 instance 就不为 null 了，此时线程C拿到的将是一个没有初始化完成的半成品。这样是很危险的。因为极有可能线程C会继续拿着个没有初始化的对象中的数据进行操作，此时容易触发 NPE。</p>
<p>另外还由于可见性问题，线程A在自己的工作线程内创建了实例，但此时还未同步到主存中；此时线程C在主存中判断 instance 还是 null，那么线程C又将在自己的工作线程中创建一个实例，这样就创建了多个实例。</p>
<h3 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2. 具体实现"></a>3.2. 具体实现</h3><p>综合以上分析后，推荐使用<font color=red><strong>volatile 双重检查模式</strong></font>来创建单例对象。从性能上考虑，一般选择同步代码块去处理线程安全问题。具体实现步骤如下：</p>
<ol>
<li>定义一个静态的对象成员变量</li>
<li>要私有构造方法，如果不处理，系统会自动提供一个无参的构造方法。外界就可以直接 new 对象</li>
<li>定义一个静态的成员方法，用来获取对象成员，一般命名用 <code>getInstance</code></li>
<li>需要考虑线程安全的问题。</li>
<li>第一种是使用同步方法，增加 <code>synchronized</code>，在方法内再进行判断对象是否为空，如果为空，就直接创建。</li>
<li>第二种是使用同步代码块，一开始先判断对象是否为空，为了性能的问题，为了后面的线程不再需要加锁；同步对象写，<code>LazySingleton.class</code> 保证锁对象被所有对象共享；</li>
</ol>
<p>完整的示例实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.design.singleten;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例类，懒加载</span></span><br><span class="line"><span class="comment"> * 懒汉式：当外界第一次要使用该类的对象时，如果还没有创建出来，则创建该单例对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态的对象成员变量。注意：采用 volatile 关键字修饰也是很有必要</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要私有构造方法，如果不处理，系统会自动提供一个无参的构造方法。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态的成员方法，用来获取创建好的成员对象(同步代码块)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断如果之前对象不存在就进行创建，再加个判断，为了性能的问题，为了后面的线程不再需要加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为了解决线程安全问题，需要同步代码块，LazySingleton.class保证锁对象被所有对象共享</span></span><br><span class="line">            <span class="comment">// 如果在 instance==null 前已经有多个线程进来，所以同步方法块中的if判断不能省略</span></span><br><span class="line">            <span class="comment">// 在synchronized锁定代码中，需要再次进行是否为null检查。这种方法叫做双重检查锁定（Double-Check Locking）。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个静态的成员方法，用来获取创建好的成员对象(同步方法)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断如果之前对象不存在就进行创建</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3. 小结"></a>3.3. 小结</h3><p>虽然懒汉模式在资源利用率上有一定优势，但是懒汉模式在高并发场景，也就是多线程场景下，遇到的问题也比较多。为了防止多个线程同时调用<code>getInstance</code>方法，需要在该方法前面增加关键字<code>synchronized</code>进行线程访问锁定。但是这样就引出了新的问题，在高并发场景下，每次调用都进行线程访问锁定判断，会对系统性能产生较大的负面影响。</p>
<p>上面示例中，为了解决高并发中的线程安全问题，在<code>synchronized</code>锁定代码中，需要再次进行是否为null检查，因为可能在<code>instance == null</code>前已经多个线程进来，如果不做判断，当前一个线程创建对象后，其他线程也可以抢到锁再进入创建对象。这种方法叫做双重检查锁定（Double-Check Locking）。另外，静态的对象成员变量 instance 采用 <code>volatile</code> 关键字修饰也是很有必要，使用 <code>volatile</code> 可以禁止 JVM 的指令重排，并且在第一个获取锁的线程创建实例后，保证其他线程的可见性，从而让程序在多线程环境下正常运行。</p>
<h2 id="4-单例实现方式（静态内部类实现式）"><a href="#4-单例实现方式（静态内部类实现式）" class="headerlink" title="4. 单例实现方式（静态内部类实现式）"></a>4. 单例实现方式（静态内部类实现式）</h2><blockquote>
<p>mybatis框架，在创建<code>VFS</code>类单例实例使用了此种方式。具体参考框架的<code>org.apache.ibatis.io.VFS</code>类</p>
</blockquote>
<p>静态内部类的实例方式，是利用 JVM 加载静态类的特性来实现。JVM 在类初始化阶段（即在Class被加载后，且线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM 会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。因此<strong>静态内部类实现式是线程安全的</strong>。具体的实现步骤如下：</p>
<ol>
<li>定义一个静态的内部类</li>
<li>要私有构造方法，如果不处理，系统会自动提供一个无参的构造方法。外界就可以直接 <code>new</code> 对象</li>
<li>定义一个静态的成员方法，用来获取对象成员，一般命名用 <code>getInstance</code></li>
<li>在内部类中定义静态的成员变量，类型是外部类类型，初始化时调用外部类的构造函数，创建外部类的实例，是真正的实例变量。</li>
<li>在<code>getInstance</code>的静态方法中，返回内部类的静态成员变量（<em>外部类的实例</em>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.design.singleten;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例类实现，静态内部类实现式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HolderSingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HolderSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当getInstance方法第一次被调用的时候，它第一次读取InstanceHolder.INSTANCE时，会触发InstanceHolder类的初始化。</span></span><br><span class="line"><span class="comment">     * 而InstanceHolder类在装载并被初始化的时候，会初始化它的静态成员变量、静态域，从而创建HolderSingleton的实例。</span></span><br><span class="line"><span class="comment">     * 由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。</span></span><br><span class="line"><span class="comment">     * 这个模式的优势在于，getInstance方法并没有做线程同步控制，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HolderSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 内部类前面加static关键字，表示的是类级内部类，类级内部类只有在使用时才会被加载 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 静态变量的初始化是由JVM保证线程安全的，在类的加载时就完成了静态变量的赋值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HolderSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HolderSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结</strong>：</p>
<p>上述代码中：虽然内部类中的成员变量<code>INSTANCE</code>是被<code>static</code>修改，但这个是懒加载的，原因是<font color=red><strong>内部类前面加<code>static</code>关键字，表示的是类级内部类，类级内部类只有在使用时才会被加载</strong></font>。</p>
<p>具体的执行流程是：当<code>getInstance</code>方法第一次被调用的时候，它第一次读取<code>InstanceHolder.INSTANCE</code>时，会触发<code>InstanceHolder</code>类的初始化。而<code>InstanceHolder</code>类在装载并被初始化的时候，会初始化它的静态成员变量、静态域，从而创建<code>HolderSingleton</code>的实例。由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并静态变量的初始化是由虚拟机（JVM）来保证它的线程安全性，在内存只会存在一份，<u><em>jvm的初始化时是线程互斥的（待日后理解）</em></u>。这个模式的优势在于，<code>getInstance</code>方法并没有做线程同步控制，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。</p>
<p>通过对比基于 <code>volatile</code> 的双重检查锁定方案和基于类初始化方案的对比，会发现基于类初始化的方案的实现代码更简洁。但是基于 volatile 的双重检查锁定方案有一个额外的优势：<strong>除了可以对静态字段实现延迟加载初始化外，还可以对实例字段实现延迟初始化</strong>。</p>
<h2 id="5-单例实例方式（枚举式）"><a href="#5-单例实例方式（枚举式）" class="headerlink" title="5. 单例实例方式（枚举式）"></a>5. 单例实例方式（枚举式）</h2><p>使用枚举来实现单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先创建 Enum 时，编译器会自动生成一个继承自<code>java.lang.Enum</code>的类，枚举成员声明中被<code>static</code>和<code>final</code>所修饰，虚拟机会保证这些静态成员在多线程环境中被正确的加锁和同步，所以是线程安全的。编译后生成的类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EnumSingleton</span> <span class="keyword">extends</span> <span class="title class_">Enum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EnumSingleton instance;</span><br><span class="line">    ....省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Enum</code>的构造方法本身就是<code>private</code>修饰的，所以也防止了使用<code>new</code>关键字创建新实例。从Enum类的声明中也可以看出，Enum是提供了序列化的支持的，在某些需要序列化的场景下，提供了非常大的便利。另一个重要功能就是反序列化仍然可以保证对象在虚拟机范围内是单例的。</p>
<h2 id="6-单例实例方式（单例注册表式）"><a href="#6-单例实例方式（单例注册表式）" class="headerlink" title="6. 单例实例方式（单例注册表式）"></a>6. 单例实例方式（单例注册表式）</h2><p>单例注册表来实现单例模式，Spring框架就是最有代表性的使用者。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042834.png" alt=""></p>
<p>其实实现原理很容易理解，以一个<code>HashMap</code>（Spring 是使用了线程安全的<code>ConcurrentHashMap</code>）来存储目前已生成的类的实例，如果可以根据类名找到对象，就返回这个对象，不再创建新对象。如果找不到，就利用反射机制创建一个，并加入到 Map 中。以上只是一个示意代码，作为 Spring 核心理念IoC的重要部分，单例注册表在 Spring 中的源码要复杂的多，也做了很多性能上的优化，具体可以参考 Spring 中<code>AbstractBeanFactory</code>类的源码。</p>
<h2 id="7-涉及使用单例类的场景"><a href="#7-涉及使用单例类的场景" class="headerlink" title="7. 涉及使用单例类的场景"></a>7. 涉及使用单例类的场景</h2><ul>
<li>一个类只要一个对象的时候</li>
<li>视频播放器，音频播放器</li>
<li>数据库的连接</li>
<li>设置信息</li>
</ul>
<h2 id="8-其他小问题"><a href="#8-其他小问题" class="headerlink" title="8. 其他小问题"></a>8. 其他小问题</h2><p>开发中一般使用饿汉式，面试的时候使用懒汉式</p>
<h1 id="享元模式（Flyweight-Pattern）（-整理中）"><a href="#享元模式（Flyweight-Pattern）（-整理中）" class="headerlink" title="享元模式（Flyweight Pattern）（!整理中）"></a>享元模式（Flyweight Pattern）（!整理中）</h1><h2 id="1-定义与特点"><a href="#1-定义与特点" class="headerlink" title="1. 定义与特点"></a>1. 定义与特点</h2><p>享元模式（Flyweight Pattern）：主要通过对象的复用来减少对象创建的次数和数量，以减少系统内存的使用和降低系统的负载。享元模式属于<font color=red><strong>结构型模式</strong></font>，在系统需要一个对象时，享元模式首先在系统中查找并尝试重用现有的对象，如果未找到匹配的对象，则创建新对象并将其缓存在系统中以便下次使用。</p>
<blockquote>
<p>wikipedia: A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar objects</p>
</blockquote>
<p>享元模式会把其中共同的部分抽象出来，如果有相同的业务请求，则直接返回内存中已有的对象，避免频繁重复创建和销毁大量的对象，造成系统资源的浪费。</p>
<h2 id="2-模式的结构"><a href="#2-模式的结构" class="headerlink" title="2. 模式的结构"></a>2. 模式的结构</h2><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042835.png" alt=""></p>
<h2 id="3-基础实现"><a href="#3-基础实现" class="headerlink" title="3. 基础实现"></a>3. 基础实现</h2><blockquote>
<p>TODO: 待整理！</p>
</blockquote>
<h1 id="模板方法设计模式（Template-Method）"><a href="#模板方法设计模式（Template-Method）" class="headerlink" title="模板方法设计模式（Template Method）"></a>模板方法设计模式（Template Method）</h1><h2 id="1-定义与特点-1"><a href="#1-定义与特点-1" class="headerlink" title="1. 定义与特点"></a>1. 定义与特点</h2><p>模板方法（Template Method）模式的定义：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<p>模式的主要优点如下：</p>
<ol>
<li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li>
<li>它在父类中提取了公共的部分代码，便于代码复用。</li>
<li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li>
</ol>
<p>该模式的主要缺点如下：</p>
<ol>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
<li>由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。</li>
</ol>
<h2 id="2-模式的结构-1"><a href="#2-模式的结构-1" class="headerlink" title="2. 模式的结构"></a>2. 模式的结构</h2><p>模板方法模式，需要抽象类与具体子类之间的协作，利用多态来实现。模板方法模式包含以下主要角色：</p>
<h3 id="2-1-抽象类-抽象模板（Abstract-Class）"><a href="#2-1-抽象类-抽象模板（Abstract-Class）" class="headerlink" title="2.1. 抽象类/抽象模板（Abstract Class）"></a>2.1. 抽象类/抽象模板（Abstract Class）</h3><p>抽象模板类，负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下：</p>
<ul>
<li><strong>模板方法</strong>：定义了算法的骨架，按某种顺序调用其包含的基本方法。</li>
<li><strong>基本方法</strong>：是整个算法中的一个步骤，包含以下几种类型。<ul>
<li><strong>抽象方法</strong>：在抽象类中声明，由具体子类实现。</li>
<li><strong>具体方法</strong>：在抽象类中已经实现，在具体子类中可以继承或重写它。</li>
<li><strong>钩子方法</strong>：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li>
</ul>
</li>
</ul>
<h3 id="2-2-具体子类-具体实现（Concrete-Class）"><a href="#2-2-具体子类-具体实现（Concrete-Class）" class="headerlink" title="2.2. 具体子类/具体实现（Concrete Class）"></a>2.2. 具体子类/具体实现（Concrete Class）</h3><p>具体实现类，实现抽象类中所定义的抽象方法和钩子方法，它们是一个抽象类中模板方法逻辑的其中一个组成步骤。</p>
<h3 id="2-3-模板方法模式的结构图"><a href="#2-3-模板方法模式的结构图" class="headerlink" title="2.3. 模板方法模式的结构图"></a>2.3. 模板方法模式的结构图</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042836.gif" alt=""></p>
<h2 id="3-基础实现-1"><a href="#3-基础实现-1" class="headerlink" title="3. 基础实现"></a>3. 基础实现</h2><ul>
<li>定义抽象类，类中定义主要的模板方法与抽象方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法。定义了方法逻辑的骨架，按某种顺序调用其包含的基本方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TemplateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        abstractMethod1(); <span class="comment">// 抽象方法</span></span><br><span class="line">        hookMethod1();</span><br><span class="line">        <span class="keyword">if</span> (hookMethod2()) &#123; <span class="comment">// 抽象类已实现，但子类可以进行修改</span></span><br><span class="line">            SpecificMethod(); <span class="comment">// 具体方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        abstractMethod2(); <span class="comment">// 抽象方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SpecificMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象类中的具体方法被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法1，方法无处理逻辑，由子类来重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hookMethod1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法1，由实现类来处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod1</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法2，由实现类来处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建实现类，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法1的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法2的实现被调用...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hookMethod1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;钩子方法1被重写...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 改变抽象类中原有方法逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试调用模板方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplateMethodPattern</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractClass</span> <span class="variable">tm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass</span>();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">抽象方法1的实现被调用...</span><br><span class="line">钩子方法1被重写...</span><br><span class="line">抽象方法2的实现被调用...</span><br></pre></td></tr></table></figure>
<h1 id="适配器模式（Adapter-Pattern）"><a href="#适配器模式（Adapter-Pattern）" class="headerlink" title="适配器模式（Adapter Pattern）"></a>适配器模式（Adapter Pattern）</h1><h2 id="1-定义与特点-2"><a href="#1-定义与特点-2" class="headerlink" title="1. 定义与特点"></a>1. 定义与特点</h2><p>适配器模式（Adapter）的定义：将一个类的接口转换成另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<font color=red><strong>适配器模式分为类结构型模式和对象结构型模式</strong></font>两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<ul>
<li>该模式的主要优点如下：</li>
</ul>
<ol>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
<li>在很多业务场景中符合开闭原则。</li>
</ol>
<ul>
<li>其缺点是：</li>
</ul>
<ol>
<li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li>
<li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
</ol>
<h2 id="2-模式结构"><a href="#2-模式结构" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h2><p>类适配器模式可采用多重继承方式实现。Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<h3 id="2-1-主要角色"><a href="#2-1-主要角色" class="headerlink" title="2.1. 主要角色"></a>2.1. 主要角色</h3><p>适配器模式（Adapter）包含以下主要角色</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户端按目标接口的格式访问适配者。</li>
</ol>
<h3 id="2-2-结构类图"><a href="#2-2-结构类图" class="headerlink" title="2.2. 结构类图"></a>2.2. 结构类图</h3><p><strong>类适配器模式的结构图</strong></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042837.jpg" alt=""></p>
<p><strong>对象适配器模式的结构图</strong></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042838.jpg" alt=""></p>
<h2 id="3-基础实现-2"><a href="#3-基础实现-2" class="headerlink" title="3. 基础实现"></a>3. 基础实现</h2><h3 id="3-1-准备公共接口与适配器"><a href="#3-1-准备公共接口与适配器" class="headerlink" title="3.1. 准备公共接口与适配器"></a>3.1. 准备公共接口与适配器</h3><p>创建目标接口，最终客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建需要待适配者（类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-类适配器模式"><a href="#3-2-类适配器模式" class="headerlink" title="3.2. 类适配器模式"></a>3.2. 类适配器模式</h3><p>创建类适配器。继承适配者（类），并实现目标接口。在目标接口中，调用适配者中相应的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用适配者的方法</span></span><br><span class="line">        <span class="built_in">super</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;类适配器模式测试：&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建适配器</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassAdapter</span>();</span><br><span class="line">    <span class="comment">// 调用目标接口方法，实际是调用了被适配类中相应的方法</span></span><br><span class="line">    target.request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类适配器模式测试：</span><br><span class="line">适配者中的业务代码被调用！</span><br></pre></td></tr></table></figure>
<h3 id="3-3-对象适配器模式"><a href="#3-3-对象适配器模式" class="headerlink" title="3.3. 对象适配器模式"></a>3.3. 对象适配器模式</h3><p>创建对象适配器，只需要实现目标接口。在类中定义适配者类型的属性，通过构造函数或者 setter 方法获取到适配者对象，在调用目标接口方法时，通过适配者对象调用相应的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectAdapter</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过适配者对象调用</span></span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;对象适配器模式测试：&quot;</span>);</span><br><span class="line">    <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectAdapter</span>(adaptee);</span><br><span class="line">    <span class="comment">// 调用目标接口方法，实际是调用了被适配者对象的方法</span></span><br><span class="line">    target.request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象适配器模式测试：</span><br><span class="line">适配者中的业务代码被调用！</span><br></pre></td></tr></table></figure>
<h1 id="建造者模式（Builder-Pattern）（整理中！）"><a href="#建造者模式（Builder-Pattern）（整理中！）" class="headerlink" title="建造者模式（Builder Pattern）（整理中！）"></a>建造者模式（Builder Pattern）（整理中！）</h1><h2 id="1-定义与特点-3"><a href="#1-定义与特点-3" class="headerlink" title="1. 定义与特点"></a>1. 定义与特点</h2><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<ul>
<li>该模式的主要优点如下：</li>
</ul>
<ol>
<li>封装性好，构建和表示分离。</li>
<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li>
</ol>
<ul>
<li>其缺点如下：</li>
</ul>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
</ol>
<p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p>
<h2 id="2-结构与实现"><a href="#2-结构与实现" class="headerlink" title="2. 结构与实现"></a>2. 结构与实现</h2><font color=red>**建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成**</font>

<h1 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>在 Java 中，万物皆对象，这些对象都需要创建，如果创建的时候直接 new 该对象，就会对该对象耦合严重，假如要更换对象，所有 new 对象的地方都需要修改一遍，这显然违背了软件设计的<strong>开闭原则</strong>。如果使用工厂来生产对象，只需要和工厂打交道即可，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以工厂模式最大的优点就是：<strong>解耦</strong>。</p>
<blockquote>
<p>开闭原则：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
</blockquote>
<p><strong>三种工厂模式</strong>：</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h3 id="1-1-案例需求概述"><a href="#1-1-案例需求概述" class="headerlink" title="1.1. 案例需求概述"></a>1.1. 案例需求概述</h3><p>需求：设计一个咖啡店点餐系统。设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p>
<p>具体类的设计如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042839.jpg" alt=""></p>
<blockquote>
<p>类图的元素说明：</p>
<ol>
<li>类图中的符号：<ul>
<li><code>+</code>：表示 public 权限方法</li>
<li><code>-</code>：表示 private 权限方法</li>
<li><code>#</code>：表示 protected 权限方法</li>
</ul>
</li>
<li>泛化关系(继承)用带空心三角箭头的实线来表示</li>
<li>依赖关系使用带箭头的虚线来表示</li>
</ol>
</blockquote>
<h3 id="1-2-无设计模式实现"><a href="#1-2-无设计模式实现" class="headerlink" title="1.2. 无设计模式实现"></a>1.2. 无设计模式实现</h3><ul>
<li>定义接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加牛奶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加糖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addSuqar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;latteCoffee&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加牛奶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LatteCoffee...addMilk...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加糖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSuqar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LatteCoffee...addSuqar...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">implements</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;americanCoffee&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加牛奶</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AmericanCoffee...addMilk...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加糖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSuqar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AmericanCoffee...addSuqar...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无使用设计模式实现获取不同实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> orderCoffee(<span class="string">&quot;latte&quot;</span>);</span><br><span class="line">        System.out.println(coffee.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;american&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对生产的对象做其他处理</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addSuqar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h2><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p>
<h3 id="2-1-模式结构"><a href="#2-1-模式结构" class="headerlink" title="2.1. 模式结构"></a>2.1. 模式结构</h3><p>简单工厂包含如下角色：</p>
<ul>
<li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品：实现或者继承抽象产品的子类</li>
<li>具体工厂：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<h3 id="2-2-具体实现"><a href="#2-2-具体实现" class="headerlink" title="2.2. 具体实现"></a>2.2. 具体实现</h3><p>使用简单工厂模式对上面案例进行改进，类图如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042840.png" alt=""></p>
<ul>
<li>创建静态工厂类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;american&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 在开发中，经常会将工厂类中的创建对象的功能定义为静态的，这就是静态工厂模式，它也不属于 23 种设计模式。</p>
</blockquote>
<ul>
<li>改进使用简单静态工厂模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用简单静态工厂模式</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee1</span> <span class="operator">=</span> simpleOrderCoffee(<span class="string">&quot;american&quot;</span>);</span><br><span class="line">        System.out.println(coffee1.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">simpleOrderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过工厂获得对象，不需要知道对象实现的细节</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> SimpleCoffeeFactory.createCoffee(type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(coffee)) &#123;</span><br><span class="line">            coffee.addMilk();</span><br><span class="line">            coffee.addSuqar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：工厂（factory）处理创建对象的细节，一旦有了 SimpleCoffeeFactory，CoffeeStore 类中的 simpleOrderCoffee() 就变成此对象的客户，后期如果需要 Coffee 对象直接从工厂中获取即可。这样也就解除了和 Coffee 实现类的耦合，同时又产生了新的耦合，CoffeeStore 对象和 SimpleCoffeeFactory 工厂对象的耦合，工厂对象和商品对象的耦合。</p>
<p>后期如果再加新品种的咖啡，势必要需求修改 SimpleCoffeeFactory 的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p>
<h3 id="2-3-优缺点"><a href="#2-3-优缺点" class="headerlink" title="2.3. 优缺点"></a>2.3. 优缺点</h3><ul>
<li><strong>优点</strong>：封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</li>
<li><strong>缺点</strong>：增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</li>
</ul>
<h2 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h2><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p>
<h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1. 概述"></a>3.1. 概述</h3><p>工厂方法模式，需要定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>
<h3 id="3-2-模式结构"><a href="#3-2-模式结构" class="headerlink" title="3.2. 模式结构"></a>3.2. 模式结构</h3><p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<h3 id="3-3-具体实现"><a href="#3-3-具体实现" class="headerlink" title="3.3. 具体实现"></a>3.3. 具体实现</h3><p>使用工厂方法模式对上例进行改进，类图如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042841.png" alt=""></p>
<ul>
<li>抽象工厂</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建咖啡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义具体的工厂实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建美式咖啡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建拿铁咖啡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改造通过不同的工厂生成相应的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用工厂方法模式</span></span><br><span class="line">        <span class="type">CoffeeStore</span> <span class="variable">coffeeStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeStore</span>(<span class="keyword">new</span> <span class="title class_">LatteCoffeeFactory</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee2</span> <span class="operator">=</span> coffeeStore.methodOrderCoffee();</span><br><span class="line">        System.out.println(coffee2.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory coffeeFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CoffeeFactory coffeeFactory)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.coffeeFactory = coffeeFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">methodOrderCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 可以根据不同的工厂，创建不同的产品</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> coffeeFactory.createCoffee();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(coffee)) &#123;</span><br><span class="line">            coffee.addMilk();</span><br><span class="line">            coffee.addSuqar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：从以上编写的代码可以看到，工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码。工厂方法模式保持了简单工厂模式的优点，而且解决了简单工厂模式的缺点。</p>
<h3 id="3-4-优缺点"><a href="#3-4-优缺点" class="headerlink" title="3.4. 优缺点"></a>3.4. 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li>
</ul>
<h1 id="抽象工厂模式（Abstract-Factory-Pattern）"><a href="#抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="抽象工厂模式（Abstract Factory Pattern）"></a>抽象工厂模式（Abstract Factory Pattern）</h1><p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p>
<p>抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示</p>
<ul>
<li>产品族：一个品牌下面的所有产品；例如华为下面的电脑、手机称为华为的产品族。</li>
<li>产品等级：多个品牌下面的同种产品；例如华为和小米都有手机电脑为一个产品等级。</li>
</ul>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042842.png" alt=""></p>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。该模式是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p><strong>一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。</strong></p>
<h2 id="2-模式结构-1"><a href="#2-模式结构-1" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h2><p>抽象工厂模式的主要角色如下：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>
</ul>
<h2 id="3-具体实现（暂未整理代码）"><a href="#3-具体实现（暂未整理代码）" class="headerlink" title="3. 具体实现（暂未整理代码）"></a>3. 具体实现（暂未整理代码）</h2><p>现咖啡店业务发生改变，不仅要生产<strong>咖啡</strong>还要生产<strong>甜点</strong></p>
<ul>
<li>同一个产品等级（产品分类）<ul>
<li>咖啡：拿铁咖啡、美式咖啡 </li>
<li>甜点：提拉米苏、抹茶慕斯</li>
</ul>
</li>
<li>同一个风味，就是同一个产品族（相当于同一个品牌）<ul>
<li>美式风味：美式咖啡、抹茶慕斯</li>
<li>意大利风味：拿铁咖啡、提拉米苏</li>
</ul>
</li>
</ul>
<p>如果按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。所以这个案例可以使用抽象工厂模式实现。类图如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042843.png" alt=""></p>
<blockquote>
<p>Tips: 实现关系使用带空心三角箭头的虚线来表示</p>
</blockquote>
<p>整体调用思路：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042844.png" alt=""></p>
<h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4. 优缺点"></a>4. 优缺点</h2><ul>
<li><strong>优点</strong>：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li>
<li><strong>缺点</strong>：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</li>
</ul>
<h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5. 使用场景"></a>5. 使用场景</h2><ul>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>
</ul>
<p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p>
<h1 id="策略模式（Strategy-Pattern）"><a href="#策略模式（Strategy-Pattern）" class="headerlink" title="策略模式（Strategy Pattern）"></a>策略模式（Strategy Pattern）</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<h2 id="2-模式结构-2"><a href="#2-模式结构-2" class="headerlink" title="2. 模式结构"></a>2. 模式结构</h2><p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略类（Strategy）：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略类（Concrete Strategy）：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境类（Context）：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<h2 id="3-基础实现-3"><a href="#3-基础实现-3" class="headerlink" title="3. 基础实现"></a>3. 基础实现</h2><h3 id="3-1-需求说明"><a href="#3-1-需求说明" class="headerlink" title="3.1. 需求说明"></a>3.1. 需求说明</h3><p>案例（促销活动）需求：一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042845.png" alt=""></p>
<blockquote>
<p>Tips: 聚合关系可以用带空心菱形的实线来表示</p>
</blockquote>
<h3 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2. 代码实现"></a>3.2. 代码实现</h3><ul>
<li>定义百货公司所有促销活动的共同接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">// 为春节准备的促销活动A</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">// 为中秋准备的促销活动B</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">// 为圣诞准备的促销活动C</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义环境角色（Context）：用于连接上下文。这里可以理解为销售员，即把促销活动推销给客户。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;</span><br><span class="line">    <span class="comment">// 持有抽象策略角色的引用</span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向客户展示促销活动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SalesMan</span> <span class="variable">salesMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalesMan</span>(<span class="keyword">new</span> <span class="title class_">StrategyB</span>());</span><br><span class="line">        salesMan.salesManShow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-进阶：工厂方法设计模式-策略模式"><a href="#4-进阶：工厂方法设计模式-策略模式" class="headerlink" title="4. 进阶：工厂方法设计模式+策略模式"></a>4. 进阶：工厂方法设计模式+策略模式</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1. 概述"></a>4.1. 概述</h3><p>一般网站都会提供有多种方式可以进行登录。如果使用传统方式实现该功能，一般会存在以下问题：</p>
<ul>
<li>业务层代码大量使用到了 if…else，在后期阅读代码的时候会非常不友好，大量使用 if…else 性能也不高</li>
<li>如果业务发生变更，比如现在新增了QQ登录方式，这个时候需要修改业务层代码，违反了开闭原则</li>
</ul>
<p>解决方案：使用<strong>工厂方法设计模式+策略模式</strong>。</p>
<p>一句话总结：<strong>只要代码中有冗长的 if-else 或 switch 分支判断都可以采用策略模式优化</strong>。</p>
<h3 id="4-2-工厂-策略模式实现"><a href="#4-2-工厂-策略模式实现" class="headerlink" title="4.2. 工厂+策略模式实现"></a>4.2. 工厂+策略模式实现</h3><h4 id="4-2-1-整体思路"><a href="#4-2-1-整体思路" class="headerlink" title="4.2.1. 整体思路"></a>4.2.1. 整体思路</h4><p>不在 service 中写业务分支逻辑，而去调用工厂，然后通过 service 传递不同的参数来获取不同的登录策略（登录方式）。流程图如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042846.png" alt=""></p>
<h4 id="4-2-2-具体实现"><a href="#4-2-2-具体实现" class="headerlink" title="4.2.2. 具体实现"></a>4.2.2. 具体实现</h4><ul>
<li>基础请求/响应</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求参数：LoginReq</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginReq</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String validateCode;<span class="comment">//手机验证码</span></span><br><span class="line">    <span class="keyword">private</span> String wxCode;<span class="comment">//用于微信登录</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * account : 用户名密码登录</span></span><br><span class="line"><span class="comment">     * sms : 手机验证码登录</span></span><br><span class="line"><span class="comment">     * we_chat : 微信登录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应参数：LoginResp</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginResp</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String roleCode;</span><br><span class="line">    <span class="keyword">private</span> String token; <span class="comment">//jwt令牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象策略类：UserGranter</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserGranter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loginReq 传入的参数</span></span><br><span class="line"><span class="comment">     *                 0:账号密码</span></span><br><span class="line"><span class="comment">     *                 1:短信验证</span></span><br><span class="line"><span class="comment">     *                 2:微信授权</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> map值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>提供具体的策略：AccountGranter、SmsGranter、WeChatGranter</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountGranter</span> <span class="keyword">implements</span> <span class="title class_">UserGranter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;策略:登录方式为账号登录&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行业务操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsGranter</span> <span class="keyword">implements</span> <span class="title class_">UserGranter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;策略:登录方式为短信登录&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行业务操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatGranter</span> <span class="keyword">implements</span> <span class="title class_">UserGranter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span>  &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;策略:登录方式为微信登录&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行业务操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 application.yml 文件中新增自定义配置，不同类型</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">login:</span></span><br><span class="line">  <span class="attr">types:</span></span><br><span class="line">    <span class="attr">account:</span> <span class="string">accountGranter</span></span><br><span class="line">    <span class="attr">sms:</span> <span class="string">smsGranter</span></span><br><span class="line">    <span class="attr">we_chat:</span> <span class="string">weChatGranter</span></span><br></pre></td></tr></table></figure>
<ul>
<li>新增读取数据配置类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginTypeConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; types;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>工厂类 UserLoginFactory，用于操作策略的上下文的环境类，主要初始化时将策略汇总管理，并对外提供获取具体策略的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginFactory</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, UserGranter&gt; granterPool = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginTypeConfig loginTypeConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从配置文件中读取策略信息存储到map中</span></span><br><span class="line"><span class="comment">     * &#123; account:accountGranter, sms:smsGranter, we_chat:weChatGranter &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        loginTypeConfig.getTypes().forEach((k, v) -&gt; &#123;</span><br><span class="line">            granterPool.put(k, (UserGranter) applicationContext.getBean(v));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外提供获取具体策略</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grantType 用户的登录方式，需要跟配置文件中匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 具体策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> UserGranter <span class="title function_">getGranter</span><span class="params">(String grantType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> granterPool.get(grantType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写业务类，通过工厂获取不同的策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserLoginFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(LoginReq loginReq)</span> &#123;</span><br><span class="line">        <span class="type">UserGranter</span> <span class="variable">granter</span> <span class="operator">=</span> factory.getGranter(loginReq.getType());</span><br><span class="line">        <span class="keyword">if</span> (granter == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">LoginResp</span> <span class="variable">loginResp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginResp</span>();</span><br><span class="line">            loginResp.setSuccess(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> loginResp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LoginResp</span> <span class="variable">resp</span> <span class="operator">=</span> granter.login(loginReq);</span><br><span class="line">        resp.setSuccess(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>登陆控制层</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/user&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LoginResp <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginReq loginReq)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (loginReq.getType().equals(<span class="string">&quot;abc&quot;</span>)) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;没有这种登录方式:&#123;&#125;&quot;</span>, loginReq.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loginReq.getType().equals(<span class="string">&quot;123&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;错误的登录方式&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userService.login(loginReq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-测试"><a href="#4-2-3-测试" class="headerlink" title="4.2.3. 测试"></a>4.2.3. 测试</h4><p>使用 postman 请求测试</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042847.png" alt=""></p>
<p>使用了工厂+策略设计模式之后，业务层的代码不需要使用大量的 if…else，如果后期有新的需求改动，比如加入了QQ登录，只需要添加对应的策略就可以，无需再改动业务层代码。</p>
<h1 id="装饰器模式-整理中！"><a href="#装饰器模式-整理中！" class="headerlink" title="装饰器模式(整理中！)"></a>装饰器模式(整理中！)</h1><h2 id="1-定义与特点-4"><a href="#1-定义与特点-4" class="headerlink" title="1. 定义与特点"></a>1. 定义与特点</h2><p>装饰器（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>装饰器模式的主要优点有：</p>
<ul>
<li>装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用</li>
<li>通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果</li>
<li>装饰器模式完全遵守开闭原则</li>
</ul>
<p>其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。</p>
<h1 id="责任链模式（Chain-of-Responsibility）"><a href="#责任链模式（Chain-of-Responsibility）" class="headerlink" title="责任链模式（Chain of Responsibility）"></a>责任链模式（Chain of Responsibility）</h1><h2 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>责任链（Chain of Responsibility）模式（也叫职责链模式）的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p>责任链模式的本质是解耦请求与处理，让请求在处理链中能进行传递与被处理。责任链模式的独到之处是将其节点处理者组合成了链式结构，并允许节点自身决定是否进行请求处理或转发，相当于让请求流动起来。</p>
<p>责任链模式的应用比较常见的是，springmvc 中的拦截器，web 开发中的 filter 过滤器等。</p>
<h2 id="2-优缺点"><a href="#2-优缺点" class="headerlink" title="2. 优缺点"></a>2. 优缺点</h2><p>责任链模式是一种对象行为型模式，其主要优点如下：</p>
<ol>
<li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li>
<li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li>
<li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li>
<li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li>
<li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li>
</ol>
<p>其主要缺点如下：</p>
<ol>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用（死循环）。</li>
</ol>
<h2 id="3-模式结构"><a href="#3-模式结构" class="headerlink" title="3. 模式结构"></a>3. 模式结构</h2><h3 id="3-1-主要角色"><a href="#3-1-主要角色" class="headerlink" title="3.1. 主要角色"></a>3.1. 主要角色</h3><p>职责链模式主要包含以下角色：</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<h3 id="3-2-结构图"><a href="#3-2-结构图" class="headerlink" title="3.2. 结构图"></a>3.2. 结构图</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042848.jpg" alt=""></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042849.jpg" alt=""></p>
<h2 id="4-基础实现"><a href="#4-基础实现" class="headerlink" title="4. 基础实现"></a>4. 基础实现</h2><p>抽象处理者角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用模板模式，定义具体处理请求的流程的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用子类实现的处理流程</span></span><br><span class="line">        <span class="keyword">if</span> (!doHandle(request)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">                getNext().handleRequest(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有人处理该请求！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义抽象的模板方法，由每个子类具体实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">(String request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建具体处理者角色x（其他都可以复制里面的代码用于测试）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;流转至 ConcreteHandler1&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> request.equals(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;具体处理者1负责处理该请求！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>职责链模式测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">chainOfResponsibilityPatternTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化责任链</span></span><br><span class="line">    <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler1</span>();</span><br><span class="line">    <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler2</span>();</span><br><span class="line">    <span class="type">Handler</span> <span class="variable">handler3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler3</span>();</span><br><span class="line">    handler1.setNext(handler2);</span><br><span class="line">    handler2.setNext(handler3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用键进行处理</span></span><br><span class="line">    handler1.handleRequest(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">流转至 ConcreteHandler1</span><br><span class="line">流转至 ConcreteHandler2</span><br><span class="line">流转至 ConcreteHandler3</span><br><span class="line">具体处理者3负责处理该请求！</span><br></pre></td></tr></table></figure>
<h2 id="5-进阶案例实战"><a href="#5-进阶案例实战" class="headerlink" title="5. 进阶案例实战"></a>5. 进阶案例实战</h2><h3 id="5-1-案例需求分析"><a href="#5-1-案例需求分析" class="headerlink" title="5.1. 案例需求分析"></a>5.1. 案例需求分析</h3><p>案例需求：以创建商品为例，假设商品创建逻辑分为以下三步完成：①创建商品、②校验商品参数、③保存商品。</p>
<p>第②步校验商品又分为多种情况的校验，必填字段校验、规格校验、价格校验、库存校验等等。这些检验逻辑像一个流水线，要想创建出一个商品，必须通过这些校验。</p>
<p>综上分析，可以<strong>使用责任链模式优化</strong>：创建商品的每个校验步骤都可以作为一个单独的处理器，抽离为一个单独的类，便于复用。这些处理器形成一条链式调用，请求在处理器链上传递，如果校验条件不通过，则处理器不再向下传递请求，直接返回错误信息；若所有的处理器都通过检验，则执行保存商品步骤。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042850.png" alt=""></p>
<h3 id="5-2-接口设计分析"><a href="#5-2-接口设计分析" class="headerlink" title="5.2. 接口设计分析"></a>5.2. 接口设计分析</h3><p>UML 图：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042851.png" alt=""></p>
<p><code>AbstractCheckHandler</code> 为处理器抽象类，负责抽象处理器行为。定义了处理器的抽象方法 <code>handle()</code>，其子类需要重写 <code>handle()</code> 方法以实现特殊的处理器校验逻辑。其有 3 个子类，分别是：</p>
<ul>
<li><code>NullValueCheckHandler</code>：空值校验处理器</li>
<li><code>PriceCheckHandler</code>：价格校验处理</li>
<li><code>StockCheckHandler</code>：库存校验处理器</li>
</ul>
<p><code>AbstractCheckHandler</code> 抽象类其他属性和方法说明：</p>
<ul>
<li><code>protected ProductCheckHandlerConfig config</code> 是处理器的动态配置类，使用 <code>protected</code> 声明，每个子类处理器都持有该对象。该对象用于声明当前处理器、以及当前处理器的下一个处理器 <code>nextHandler</code>，另外也可以配置一些特殊属性，比如说接口降级配置、超时时间配置等。</li>
<li><code>AbstractCheckHandler</code> 类中的 <code>nextHandler</code> 属性是当前处理器持有的下一个处理器的引用，当前处理器执行完毕时，便调用 <code>nextHandler</code> 执行下一处理器的 <code>handle()</code> 校验方法；</li>
<li><code>protected Result next()</code> 是抽象类中定义执行下一个处理器的方法，使用 <code>protected</code> 声明，每个子类处理器都持有该对象。当子类处理器执行完毕(通过)时，调用父类的方法执行下一个处理器 <code>nextHandler</code>。</li>
</ul>
<p>另外，<code>HandlerClient</code> 类是执行处理器链路的客户端，<code>HandlerClient.executeChain()</code> 方法负责发起整个链路调用，并接收处理器链路的返回值。</p>
<h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3. 代码实现"></a>5.3. 代码实现</h3><h4 id="5-3-1-产品实体类"><a href="#5-3-1-产品实体类" class="headerlink" title="5.3.1. 产品实体类"></a>5.3.1. 产品实体类</h4><p>定义 ProductVO ，保存创建商品的参数对象，包含商品的基础信息。并且其作为责任链模式中多个处理器的入参，多个处理器都以 roductVO 为入参进行特定的逻辑处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductVO</span> &#123;</span><br><span class="line">    <span class="comment">/** 商品SKU，唯一 */</span></span><br><span class="line">    <span class="keyword">private</span> Long skuId;</span><br><span class="line">    <span class="comment">/** 商品名称 */</span></span><br><span class="line">    <span class="keyword">private</span> String skuName;</span><br><span class="line">    <span class="comment">/** 商品图片路径 */</span></span><br><span class="line">    <span class="keyword">private</span> String Path;</span><br><span class="line">    <span class="comment">/** 价格 */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="comment">/** 库存 */</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-抽象类处理器：抽象行为，子类共有属性、方法"><a href="#5-3-2-抽象类处理器：抽象行为，子类共有属性、方法" class="headerlink" title="5.3.2. 抽象类处理器：抽象行为，子类共有属性、方法"></a>5.3.2. 抽象类处理器：抽象行为，子类共有属性、方法</h4><p>创建抽象类处理器 <code>AbstractCheckHandler</code>，并使用 <code>@Component</code> 注解注册为由 Spring 管理的 Bean 对象，方便使用 Spring 来管理各个处理器实现 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCheckHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前处理器持有下一个处理器的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">protected</span> AbstractCheckHandler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">protected</span> ProductCheckHandlerConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器执行方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Result <span class="title function_">handle</span><span class="params">(ProductVO param)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链路传递</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Result <span class="title function_">next</span><span class="params">(ProductVO param)</span> &#123;</span><br><span class="line">        <span class="comment">// 下一个链路没有处理器了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(nextHandler)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.success();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行下一个处理器</span></span><br><span class="line">        <span class="keyword">return</span> nextHandler.handle(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类的属性和方法说明如下：</p>
<ul>
<li><code>public abstract Result handle(ProductVO param)</code>：表示抽象的校验方法，每个处理器都应该继承 <code>AbstractCheckHandler</code> 抽象类处理器，并重写其 <code>handle</code> 方法，各个处理器从而实现特殊的校验逻辑，实际上就是多态的思想。</li>
<li><code>protected ProductCheckHandlerConfig config</code>：表示每个处理器的动态配置类，可以通过“配置中心”动态修改该配置，实现处理器的“动态编排”和“顺序控制”。配置类中可以配置处理器的名称、下一个处理器、以及处理器是否降级等属性。</li>
<li><code>protected AbstractCheckHandler nextHandler</code>：表示当前处理器持有下一个处理器的引用，如果当前处理器 <code>handle()</code> 校验方法执行完毕，则执行下一个处理器 <code>nextHandler</code> 的 <code>handle()</code> 校验方法执行校验逻辑。</li>
<li><code>protected Result next(ProductVO param)</code>：此方法用于处理器链路传递，子类处理器执行完毕后，调用父类的 <code>next()</code> 方法执行在 <code>config</code> 配置的链路上的下一个处理器，如果所有处理器都执行完毕了，就返回结果了。</li>
</ul>
<p>创建 ProductCheckHandlerConfig 配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理器配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductCheckHandlerConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器Bean名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String handler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProductCheckHandlerConfig next;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否降级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">down</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-子类处理器：处理特有的校验逻辑"><a href="#5-3-3-子类处理器：处理特有的校验逻辑" class="headerlink" title="5.3.3. 子类处理器：处理特有的校验逻辑"></a>5.3.3. 子类处理器：处理特有的校验逻辑</h4><p>创建3个子类处理器，各个处理器继承 <code>AbstractCheckHandler</code> 抽象类处理器，并重写其 <code>handle()</code> 处理方法以实现特有的校验逻辑。</p>
<ul>
<li><code>NullValueCheckHandler</code>：空值校验处理器。针对性校验创建商品中必填的参数。如果校验未通过，则返回错误码 ErrorCode，责任链在此截断(停止)，创建商品返回被校验住的错误信息。<em>注意代码中的降级配置！</em>使用 <code>@Component</code> 注册到 Spring 容器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空值校验处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullValueCheckHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractCheckHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Result <span class="title function_">handle</span><span class="params">(ProductVO param)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;空值校验 Handler 开始...&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 降级：如果配置了降级，则跳过此处理器，执行下一个处理器</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">super</span>.getConfig().getDown()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;空值校验 Handler 已降级，跳过空值校验 Handler...&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">super</span>.next(param);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 参数必填校验</span></span><br><span class="line">		<span class="keyword">if</span> (Objects.isNull(param)) &#123;</span><br><span class="line">			<span class="keyword">return</span> Result.failure(ErrorCode.PARAM_NULL_ERROR);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// SkuId 商品主键参数必填校验</span></span><br><span class="line">		<span class="keyword">if</span> (Objects.isNull(param.getSkuId())) &#123;</span><br><span class="line">			<span class="keyword">return</span> Result.failure(ErrorCode.PARAM_SKU_NULL_ERROR);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Price 价格参数必填校验</span></span><br><span class="line">		<span class="keyword">if</span> (Objects.isNull(param.getPrice())) &#123;</span><br><span class="line">			<span class="keyword">return</span> Result.failure(ErrorCode.PARAM_PRICE_NULL_ERROR);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Stock 库存参数必填校验</span></span><br><span class="line">		<span class="keyword">if</span> (Objects.isNull(param.getStock())) &#123;</span><br><span class="line">			<span class="keyword">return</span> Result.failure(ErrorCode.PARAM_STOCK_NULL_ERROR);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;空值校验 Handler 通过...&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行下一个处理器</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.next(param);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Notes: <code>super.getConfig().getDown()</code> 是获取 <code>AbstractCheckHandler</code> 处理器对象中保存的配置信息，如果处理器配置了降级，则跳过该处理器，直接调用 <code>super.next()</code> 执行下一个处理器逻辑。</p>
</blockquote>
<ul>
<li><code>PriceCheckHandler</code>：价格校验处理。针对创建商品的价格参数进行校验。这里只是做了简单的判断价格大于0的校验，实际业务中比较复杂，比如“价格门”这些防范措施等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 价格校验处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriceCheckHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractCheckHandler</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Result <span class="title function_">handle</span><span class="params">(ProductVO param)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;价格校验 Handler 开始...&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 非法价格校验</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">illegalPrice</span> <span class="operator">=</span> param.getPrice().compareTo(BigDecimal.ZERO) &lt;= <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (illegalPrice) &#123;</span><br><span class="line">			<span class="keyword">return</span> Result.failure(ErrorCode.PARAM_PRICE_ILLEGAL_ERROR);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他校验逻辑...</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;价格校验 Handler 通过...&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行下一个处理器</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.next(param);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>StockCheckHandler</code>：库存校验处理器。针对创建商品的库存参数进行校验。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StockCheckHandler</span> <span class="keyword">extends</span> <span class="title class_">AbstractCheckHandler</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Result <span class="title function_">handle</span><span class="params">(ProductVO param)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;库存校验 Handler 开始...&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 非法库存校验</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">illegalStock</span> <span class="operator">=</span> param.getStock() &lt; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (illegalStock) &#123;</span><br><span class="line">			<span class="keyword">return</span> Result.failure(ErrorCode.PARAM_STOCK_ILLEGAL_ERROR);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他校验逻辑..</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;库存校验 Handler 通过...&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行下一个处理器</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.next(param);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-4-客户端：执行处理器链路"><a href="#5-3-4-客户端：执行处理器链路" class="headerlink" title="5.3.4. 客户端：执行处理器链路"></a>5.3.4. 客户端：执行处理器链路</h4><p><code>HandlerClient</code> 客户端类负责发起整个处理器链路的执行，通过 <code>executeChain()</code> 方法。如果处理器链路返回错误信息，即校验未通过，则整个链路截断（停止），返回相应的错误信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerClient</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">executeChain</span><span class="params">(AbstractCheckHandler handler, ProductVO param)</span> &#123;</span><br><span class="line">		<span class="comment">//执行处理器</span></span><br><span class="line">		<span class="type">Result</span> <span class="variable">handlerResult</span> <span class="operator">=</span> handler.handle(param);</span><br><span class="line">		<span class="keyword">if</span> (!handlerResult.isSuccess()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;HandlerClient 责任链执行失败返回：&quot;</span> + handlerResult.toString());</span><br><span class="line">			<span class="keyword">return</span> handlerResult;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Result.success();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-5-责任链模式参数校验-paramCheck-方法步骤说明"><a href="#5-3-5-责任链模式参数校验-paramCheck-方法步骤说明" class="headerlink" title="5.3.5. 责任链模式参数校验 paramCheck 方法步骤说明"></a>5.3.5. 责任链模式参数校验 paramCheck 方法步骤说明</h4><p>创建参数校验 <code>paramCheck()</code> 方法使用责任链模式进行参数校验，方法内没有声明具体都有哪些校验，具体有哪些参数校验逻辑是通过多个处理器链传递的。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Result <span class="title function_">paramCheck</span><span class="params">(ProductVO param)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取处理器配置：通常配置使用统一配置中心存储，支持动态变更</span></span><br><span class="line">	<span class="type">ProductCheckHandlerConfig</span> <span class="variable">handlerConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandlerConfigFile();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取处理器</span></span><br><span class="line">	<span class="type">AbstractCheckHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.getHandler(handlerConfig);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过客户端，执行处理器链路</span></span><br><span class="line">	<span class="type">Result</span> <span class="variable">executeChainResult</span> <span class="operator">=</span> HandlerClient.executeChain(handler, param);</span><br><span class="line">	<span class="keyword">if</span> (!executeChainResult.isSuccess()) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;创建商品 失败...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> executeChainResult;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理器链路全部成功</span></span><br><span class="line">	<span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-3-5-1-步骤1：获取处理器配置"><a href="#5-3-5-1-步骤1：获取处理器配置" class="headerlink" title="5.3.5.1. 步骤1：获取处理器配置"></a>5.3.5.1. 步骤1：获取处理器配置</h5><p>通过 <code>getHandlerConfigFile()</code> 方法获取处理器配置类对象，配置类保存了链上各个处理器的上下级节点配置，支持流程编排、动态扩展。通常配置是通过Ducc(京东自研的配置中心)、Nacos(阿里开源的配置中心)等配置中心存储的，支持动态变更、实时生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取处理器配置：通常配置使用统一配置中心存储，支持动态变更</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ProductCheckHandlerConfig <span class="title function_">getHandlerConfigFile</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 模拟配置中心存储的配置</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">configJson</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;handler\&quot;:\&quot;nullValueCheckHandler\&quot;,\&quot;down\&quot;:true,\&quot;next\&quot;:&#123;\&quot;handler\&quot;:\&quot;priceCheckHandler\&quot;,\&quot;next\&quot;:&#123;\&quot;handler\&quot;:\&quot;stockCheckHandler\&quot;,\&quot;next\&quot;:null&#125;&#125;&#125;&quot;</span>;</span><br><span class="line">	<span class="comment">// 转成Config对象</span></span><br><span class="line">	<span class="type">ProductCheckHandlerConfig</span> <span class="variable">handlerConfig</span> <span class="operator">=</span> JSON.parseObject(configJson, ProductCheckHandlerConfig.class);</span><br><span class="line">	<span class="keyword">return</span> handlerConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例没有使用配置中心存储处理器链路的配置，而是使用 JSON 串的形式去模拟配置。</p>
</blockquote>
<p>ConfigJson 存储的处理器链路配置 JSON 串，使用 json.cn 等格式化如下，配置的整个调用链路规则特别清晰</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042853.png" alt=""></p>
<p><code>getHandlerConfigFile()</code> 获到配置类方法，只是把在配置中心储存的配置规则，转换成配置类 <code>ProductCheckHandlerConfig</code> 对象，用于程序处理。结构如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042854.png" alt=""></p>
<blockquote>
<p>Notes: 此时配置类中存储的仅仅是处理器 Spring Bean 的 name 而已，并非实际处理器对象。</p>
</blockquote>
<h6 id="5-3-5-1-1-步骤2-1：配置检查"><a href="#5-3-5-1-1-步骤2-1：配置检查" class="headerlink" title="5.3.5.1.1. 步骤2-1：配置检查"></a>5.3.5.1.1. 步骤2-1：配置检查</h6><p>首先会进行了配置的一些检查操作。如果配置错误，则获取不到对应的处理器。<code>handlerMap.get(config.getHandler())</code> 是从所有处理器映射 Map 中获取到对应的处理器 Spring Bean。</p>
<blockquote>
<p>Tips: <code>handlerMap</code> 存储了所有的处理器映射，是通过 Spring 的 <code>@Resource</code> 注解注入。注入的规则是：所有继承了 <code>AbstractCheckHandler</code> 抽象类（它是 Spring 管理的 Bean）的子类（子类也是 Spring 管理的 Bean）都会注入进来。</p>
</blockquote>
<p>注入进来的 handlerMap 中 Key 对应 Bean 的 name，Value 是对应的 Bean 实例，也就是实际的处理器，这里指空值校验处理器、价格校验处理器、库存校验处理器。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042855.png" alt=""></p>
<h6 id="5-3-5-1-2-步骤2-2：保存处理器规则"><a href="#5-3-5-1-2-步骤2-2：保存处理器规则" class="headerlink" title="5.3.5.1.2. 步骤2-2：保存处理器规则"></a>5.3.5.1.2. 步骤2-2：保存处理器规则</h6><p>将配置规则保存到对应的处理器中 <code>abstractCheckHandler.setConfig(config)</code>，子类处理器就持有了配置的规则。</p>
<h6 id="5-3-5-1-3-步骤2-3：递归设置处理器链路"><a href="#5-3-5-1-3-步骤2-3：递归设置处理器链路" class="headerlink" title="5.3.5.1.3. 步骤2-3：递归设置处理器链路"></a>5.3.5.1.3. 步骤2-3：递归设置处理器链路</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstractCheckHandler.setNextHandler(<span class="built_in">this</span>.getHandler(config.getNext()));</span><br></pre></td></tr></table></figure>
<p>以上方法是递归设置链路上的处理器，结合 ConfigJson 配置的规则来看：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042856.png" alt=""></p>
<ol>
<li>由上而下，NullValueCheckHandler 空值校验处理器通过 <code>setNextHandler()</code> 方法法设置自己持有的下一节点的处理器，也就是价格处理器 PriceCheckHandler。</li>
<li>接着，PriceCheckHandler 价格处理器，同样需要经过步骤2-1配置检查、步骤2-2保存配置规则，并且最重要的是，它也需要设置下一节点的处理器 StockCheckHandler 库存校验处理器。</li>
<li>最后 StockCheckHandler 库存校验处理器也一样，同样需要经过步骤2-1配置检查、步骤2-2保存配置规则。值得注意的是，StockCheckHandler 的 next 规则配置了 null，这表示它下面没有任何处理器要执行了，它就是整个链路上的最后一个处理节点。</li>
</ol>
<p>通过递归调用 <code>getHandler()</code> 获取处理器方法，就将整个处理器链路对象串联起来了。如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042857.png" alt=""></p>
<p>实际上，<code>getHandler()</code> 获取处理器对象的代码就是把在配置中心配置的规则 <code>ConfigJson</code>，转换成配置类 <code>ProductCheckHandlerConfig</code> 对象，再根据配置类对象，转换成实际的处理器对象，这个处理器对象持有整个链路的调用顺序。</p>
<blockquote>
<p>Tips: 使用递归一定要注意截断递归的条件处理，否则可能造成死循环！</p>
</blockquote>
<h5 id="5-3-5-2-步骤2：根据配置获取处理器"><a href="#5-3-5-2-步骤2：根据配置获取处理器" class="headerlink" title="5.3.5.2. 步骤2：根据配置获取处理器"></a>5.3.5.2. 步骤2：根据配置获取处理器</h5><p>上面步骤1通过 <code>getHandlerConfigFile()</code> 方法获取到处理器链路配置规则后，再调用 <code>getHandler()</code> 获取处理器。</p>
<p><code>getHandler()</code> 方法参数是如上 <code>ConfigJson</code> 配置的规则，即步骤1转换成的 ProductCheckHandlerConfig 对象；根据 ProductCheckHandlerConfig 配置规则转换成处理器链路对象。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 Spring 注入:所有继承了AbstractCheckHandler抽象类的Spring Bean都会注入进来。Map的Key对应Bean的name,Value是name对应相应的Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, AbstractCheckHandler&gt; handlerMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AbstractCheckHandler <span class="title function_">getHandler</span><span class="params">(ProductCheckHandlerConfig config)</span> &#123;</span><br><span class="line">	<span class="comment">// 配置检查：没有配置处理器链路，则不执行校验逻辑</span></span><br><span class="line">	<span class="keyword">if</span> (Objects.isNull(config)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 配置错误</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">handler</span> <span class="operator">=</span> config.getHandler();</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.isBlank(handler)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 配置了不存在的处理器</span></span><br><span class="line">	<span class="type">AbstractCheckHandler</span> <span class="variable">abstractCheckHandler</span> <span class="operator">=</span> handlerMap.get(config.getHandler());</span><br><span class="line">	<span class="keyword">if</span> (Objects.isNull(abstractCheckHandler)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理器设置配置 Config</span></span><br><span class="line">	abstractCheckHandler.setConfig(config);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归设置链路处理器</span></span><br><span class="line">	abstractCheckHandler.setNextHandler(<span class="built_in">this</span>.getHandler(config.getNext()));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> abstractCheckHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-3-5-3-步骤3：客户端执行调用链路"><a href="#5-3-5-3-步骤3：客户端执行调用链路" class="headerlink" title="5.3.5.3. 步骤3：客户端执行调用链路"></a>5.3.5.3. 步骤3：客户端执行调用链路</h5><p><code>getHandler()</code> 获取完处理器后，整个调用链路的执行顺序也就确定了。最后通过 <code>HandlerClient</code> 客户端类的 <code>executeChain(handler, param)</code> 方法执行处理器整个调用链路，并接收处理器链路的返回值。</p>
<p><code>executeChain()</code> 通过 <code>AbstractCheckHandler.handle()</code> 触发整个链路处理器顺序执行，如果某个处理器校验没有通过 <code>!handlerResult.isSuccess()</code>，则返回错误信息；所有处理器都校验通过，则返回正确信息 <code>Result.success()</code>。</p>
<h3 id="5-4-测试"><a href="#5-4-测试" class="headerlink" title="5.4. 测试"></a>5.4. 测试</h3><p>最后创建 <code>createProduct()</code> 测试用例方法，创建商品方法抽象为2个步骤：①参数校验、②创建商品。参数校验使用责任链模式进行校验，包含：空值校验、价格校验、库存校验等等，只有链上的所有处理器均校验通过，才调用 <code>saveProduct()</code> 创建商品方法；否则返回校验错误信息。</p>
<p>在 <code>createProduct()</code> 创建商品方法中，通过责任链模式，将校验逻辑进行解耦。<code>createProduct()</code> 创建商品方法中不需要关注都要经过哪些校验处理器，以及校验处理器的细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createProduct</span><span class="params">(ProductVO param)</span> &#123;</span><br><span class="line">	<span class="comment">// 参数校验，使用责任链模式</span></span><br><span class="line">	<span class="type">Result</span> <span class="variable">paramCheckResult</span> <span class="operator">=</span> <span class="built_in">this</span>.paramCheck(param);</span><br><span class="line">	<span class="keyword">if</span> (!paramCheckResult.isSuccess()) &#123;</span><br><span class="line">		<span class="keyword">return</span> paramCheckResult;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建商品</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.saveProduct(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景1：创建商品参数中有空值（如下skuId参数为null），链路被空值处理器截断，返回错误信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProductVO</span> <span class="variable">param</span> <span class="operator">=</span> ProductVO.builder()</span><br><span class="line">      .skuId(<span class="literal">null</span>).skuName(<span class="string">&quot;华为手机&quot;</span>).Path(<span class="string">&quot;http://...&quot;</span>)</span><br><span class="line">      .price(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">1</span>))</span><br><span class="line">      .stock(<span class="number">1</span>)</span><br><span class="line">      .build();</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042858.png" alt=""></p>
<p>场景2：创建商品价格参数异常（如下price参数），被价格处理器截断，返回错误信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProductVO</span> <span class="variable">param</span> <span class="operator">=</span> ProductVO.builder()</span><br><span class="line">      .skuId(<span class="number">1L</span>).skuName(<span class="string">&quot;华为手机&quot;</span>).Path(<span class="string">&quot;http://...&quot;</span>)</span><br><span class="line">      .price(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(-<span class="number">999</span>))</span><br><span class="line">      .stock(<span class="number">1</span>)</span><br><span class="line">      .build();</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042859.png" alt=""></p>
<p>场景 3：创建商品库存参数异常（如下stock参数），被库存处理器截断，返回错误信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProductVO</span> <span class="variable">param</span> <span class="operator">=</span> ProductVO.builder()</span><br><span class="line">      .skuId(<span class="number">1L</span>).skuName(<span class="string">&quot;华为手机&quot;</span>).Path(<span class="string">&quot;http://...&quot;</span>)</span><br><span class="line">      .price(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">1</span>))</span><br><span class="line">      .stock(-<span class="number">999</span>)</span><br><span class="line">      .build();</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042860.png" alt=""></p>
<p>场景4：创建商品所有处理器校验通过，保存商品。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProductVO</span> <span class="variable">param</span> <span class="operator">=</span> ProductVO.builder()</span><br><span class="line">      .skuId(<span class="number">1L</span>).skuName(<span class="string">&quot;华为手机&quot;</span>).Path(<span class="string">&quot;http://...&quot;</span>)</span><br><span class="line">      .price(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">999</span>))</span><br><span class="line">      .stock(<span class="number">1</span>).build();</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251042861.png" alt=""></p>
<h1 id="门面模式（整理中！）"><a href="#门面模式（整理中！）" class="headerlink" title="门面模式（整理中！）"></a>门面模式（整理中！）</h1><blockquote>
<p>在软件开发领域有这样一句话：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。而门面模式就是对于这句话的典型实践。</p>
</blockquote>
<p>门面模式（Facade Pattern），也称之为外观模式，其核心为：外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-网络参考资料"><a href="#1-网络参考资料" class="headerlink" title="1. 网络参考资料"></a>1. 网络参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247487936&amp;idx=2&amp;sn=02c48b88fa45a32e55b99fa0be610a29&amp;chksm=ebd62eecdca1a7faccf9f26d17bd2108e1b8939421640f71f1ebf5f14b621448ac05ad168a00&amp;mpshare=1&amp;scene=1&amp;srcid=#rd">设计模式内容聚合</a></li>
<li><del><a target="_blank" rel="noopener" href="http://c.biancheng.net/design_pattern/">Java设计模式：23种设计模式全面解析（超级详细）</a></del>，内容被清空了？</li>
<li><a target="_blank" rel="noopener" href="https://java-design-patterns.com/zh/">Java Design Patterns (中文)</a>，软件设计模式，编程原则还有代码片段</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io">蓝桉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io/posts/680ac9d7.html">https://ktzxy.github.io/posts/680ac9d7.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ktzxy.github.io" target="_blank">蓝桉`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/bg/Image00010.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src="/img/wechat.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src="/img/alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/51585717.html" title="Java扩展-集合类源码分析"><img class="cover" src="/bg/touxiang.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java扩展-集合类源码分析</div></div><div class="info-2"><div class="info-item-1">1. ArrayList 源码分析1.1. 属性分析12345678910111213141516171819202122232425262728293031/** * 默认初始化容量 */private static final int DEFAULT_CAPACITY = 10;/** * 如果自定义容量为0，则会默认用它来初始化ArrayList。或者用于空数组替换。 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * 如果没有自定义容量，则会使用它来初始化ArrayList。或者用于空数组比对。 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * 这就是ArrayList底层用到的数组 * 非私有，以简化嵌套类访问 * transient 在已经实现序列化的类中，不允许某变量序列化 */transient Object[] elementData;/** * 实际...</div></div></div></a><a class="pagination-related" href="/posts/3c07d37f.html" title="Java扩展-算法"><img class="cover" src="/bg/Image00005.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java扩展-算法</div></div><div class="info-2"><div class="info-item-1">在计算机世界里“数据结构+算法=程序”，因此算法在程序开发中起着至关重要的作用。  目录 [TOC]  1. 初识算法1.1. 什么是算法？算法的定义：在数学和计算机科学领域，算法是一系列有限的严谨指令，通常用于解决一类特定问题或执行计算。  In mathematics and computer science, an algorithm (/ˈælɡərɪðəm/) is a finite sequence of rigorous instructions, typically used to solve a class of specific problems or to perform a computation. — 参考文献：“Definition of ALGORITHM”. Merriam-Webster Online Dictionary. Archived from the original on February 14, 2020. Retrieved November 14, 2019.  Introduction to Algorithm（中文译作《算法...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/4e9c3100.html" title="Java基础-网络编程"><img class="cover" src="/bg/Image00026.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Java基础-网络编程</div></div><div class="info-2"><div class="info-item-1">1. 网络编程概述在计算机领域中，网络是信息传输、接收、共享的虚拟平台，将各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络编程的作用：解决计算机与计算机数据传输的问题。 网络体系大致分为三种：OSI七层模型、TCP/IP四层模型和五层模型。  Tips: 一般面试的时候考察比较多的是五层模型。  1.1. 网络通讯三要素1.1.1. IP地址IP 是每台电脑在互联网上的唯一标识符。一个 IPV4 的地址是由四段 0—255 的数字组成：192.168.0.100，每一段的取值范围由8位二进制数据组成。 IPv6 使用 16 个字节表示 IP 地址，它所拥有的地址容量约是 IPv4 的 8×1028倍，达到 2128个。  Notes:   127.0.0.1 为本地主机地址(本地回环地址)，与 localhost 类似，均代表本机地址 xxx.xxx.xxx.255 广播地址，即该网段下所有用户均可以被通知到   例如在 windows 系统中，可以通过以下命令来获取 ip 与网络相关内容： 1ipconfig  用于DOS获取计算机IP设置  1ping ip地址 ...</div></div></div></a><a class="pagination-related" href="/posts/2af7de89.html" title="Day-0-IDEA简单学习"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-0-IDEA简单学习</div></div><div class="info-2"><div class="info-item-1">﻿# Day-0-IDEA简单学习 1.设置主题 2.编辑区的字体变大或者变小：（ctrl+鼠标滚轮） 3.鼠标悬浮在代码上有提示： 4.自动导包和优化多余的包：手动导包：快捷键：alt+enter自动导包和优化多余的包：  5.显示行号 ，  方法和方法间的分隔符： 6.忽略大小写，进行提示： 7.修改代码中注释的字体颜色： 8.修改类头的文档注释信息：注意：对新建的类才有效/**  @Auther: XXX @Date: ${DATE} - ${MONTH} - ${DAY} - ${TIME}  @Description: ${PACKAGE_NAME} @version: 1.0*/   8.自动编译： 9.常用快捷键【1】创建内容：alt+insert 【2】main方法：psvm 【3】输出语句：sout 【4】复制行：ctrl+d 【5】删除行：ctrl+y 【6】代码向上/下移动：Ctrl + Shift + Up / Down 【7】搜索类：  ctrl+n 【8】生成代码  ：alt + Insert（如构造函数等，getter,setter,hashCode...</div></div></div></a><a class="pagination-related" href="/posts/72ba03f7.html" title="Day-02-java基础语法"><img class="cover" src="/bg/Image00027.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-02-java基础语法</div></div><div class="info-2"><div class="info-item-1">﻿ Day-02-java基础语法快捷键操作 psvm —&gt;快速生成public static void main(String[] args) {} sout —&gt;快速生成System.out.println();  可能会遇到的问题  每个单词的大小不能出现问题，==Java是大小写敏感的==； 尽量使用英文； 文件名和类名必须保证一致，并且首字母大写； 符号使用的了中文。   Java运行机制  编译型 解释型    注释：Java中的注释有三种： 12345678910注释：    单行注释：    //我是单行注释    多行注释      /*我是多行注释*/    文档注释    /**    *@description  HelloWrold    *@Author 作者    */ 标识符：关键字 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 标识符注意点 所有的标识符都应该以字母(A-Z或者a-z),美元符（$)、数字或者下划线(_)开始首字符之后可以是字母（A-Z或者a-z),美元符（$)、下划线(_)或数字的任何字符...</div></div></div></a><a class="pagination-related" href="/posts/369b2118.html" title="Day-03-java流程控制"><img class="cover" src="/bg/Image00020.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-03-java流程控制</div></div><div class="info-2"><div class="info-item-1">﻿ Day-03-java流程控制Scanner对象java.util.Scanner是Java5的新特性，我们可以通过Scanner类来获取用户的输入。 基本语法 1Scanner s = new Scanner(System.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext() 与hasNextLine()判断是否还有输入的数据。 12345678910111213public static void main(String[] args) &#123;    //创建一个扫描对象，用于接受键盘数据    Scanner scanner = new Scanner(System.in);    System.out.println(&quot;使用next方式接受：&quot;);    //判断用户有没有输入字符串    if (scanner.hasNext())&#123;        //使用next方式接受        String str = scanner.next();     ...</div></div></div></a><a class="pagination-related" href="/posts/bbaa91bf.html" title="Day-04-java方法详解"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-04-java方法详解</div></div><div class="info-2"><div class="info-item-1">﻿ Day-04-java方法详解何谓方法？​    System.out.println(),那么它是什么呢? ​    调用系统类里的标准输出对象out中的方法println ​    Java方法是语句的集合，它们在一起执行一个功能。 ​    方法是解决一类问题的步骤的有序组合 ​    方法包含于类或对象中，方法和方法是并列的关系，所以我们定义的方法不能写到main方法中 ​    方法在程序中被创建，在其他地方被引用 ​    设计方法的原则:方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。 方法的定义Java的方法类似争其它语言的函数,是一段用来完成特定功能的代码片段，一股情况卜，定义一个方法包含以下语法: 方法包含一个方法头和一个方法体。 下面是一个方法的所有部分: 修饰符:修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型∶方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。...</div></div></div></a><a class="pagination-related" href="/posts/cccc6599.html" title="Day-06-java面向对象"><img class="cover" src="/bg/Image00022.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-06-java面向对象</div></div><div class="info-2"><div class="info-item-1">﻿ Day-06-java面向对象什么是面向对象面向对象编程(Object-Oriented Programming, OOP) 面向对象编程的本质就是:==以类的方式组织代码，以对象的组织(封装)数据。== 抽象 三大特性: ​        封装 ​        继承 ​        多态从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象 从代码运行角度考虑是先有类后有对象。类是对象的模板。 回顾方法及加深方法的定义 修饰符 返回类型 ==break: 跳出switch，结束循环和return的区别方法名== 参数列表 异常抛出 方法的调用        静态方法 ​        非静态方法 ​        形参和实参 ​        值传递和引用传递 ​        this关键字 12345678910111213141516171819202122232425//demo1  类public class demo1 &#123;    //main方法    public static void main(String[] a...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">蓝桉</div><div class="author-info-description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">生活、学习、技术</b>相关的问题和看法，还有<b style="color:#fff">文章教程</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ktzxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/ktzxy" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2251511764@qq.com" target="_blank" title="Email"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-RSS"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/496148176" target="_blank" title="BiliBili"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QX-BILIBILI"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2251511764&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">2. 设计模式的原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">3. 设计模式的分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Singleten-Pattern%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">单例设计模式（Singleten Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%95%E4%BE%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">1. 单例的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">2. 单例实现方式（饿汉式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">3. 单例实现方式（懒汉式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%BD%AE%E5%88%86%E6%9E%90"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1. 实现前置分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2. 具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3. 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%BC%8F%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">4. 单例实现方式（静态内部类实现式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8D%95%E4%BE%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E5%BC%8F%EF%BC%88%E6%9E%9A%E4%B8%BE%E5%BC%8F%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">5. 单例实例方式（枚举式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8D%95%E4%BE%8B%E5%AE%9E%E4%BE%8B%E6%96%B9%E5%BC%8F%EF%BC%88%E5%8D%95%E4%BE%8B%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%BC%8F%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">6. 单例实例方式（单例注册表式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B6%89%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%E7%B1%BB%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">2.7.</span> <span class="toc-text">7. 涉及使用单例类的场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%85%B6%E4%BB%96%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="toc-number">2.8.</span> <span class="toc-text">8. 其他小问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88Flyweight-Pattern%EF%BC%89%EF%BC%88-%E6%95%B4%E7%90%86%E4%B8%AD%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">享元模式（Flyweight Pattern）（!整理中）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">1. 定义与特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">2. 模式的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3. 基础实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Method%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">模板方法设计模式（Template Method）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9-1"><span class="toc-number">4.1.</span> <span class="toc-text">1. 定义与特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84-1"><span class="toc-number">4.2.</span> <span class="toc-text">2. 模式的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8A%BD%E8%B1%A1%E6%A8%A1%E6%9D%BF%EF%BC%88Abstract-Class%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1. 抽象类&#x2F;抽象模板（Abstract Class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%85%B7%E4%BD%93%E5%AD%90%E7%B1%BB-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%88Concrete-Class%EF%BC%89"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2. 具体子类&#x2F;具体实现（Concrete Class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3. 模板方法模式的结构图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">4.3.</span> <span class="toc-text">3. 基础实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter-Pattern%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">适配器模式（Adapter Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9-2"><span class="toc-number">5.1.</span> <span class="toc-text">1. 定义与特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">2. 模式结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%BB%E8%A6%81%E8%A7%92%E8%89%B2"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1. 主要角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9B%BE"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2. 结构类图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">5.3.</span> <span class="toc-text">3. 基础实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%87%86%E5%A4%87%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1. 准备公共接口与适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2. 类适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.3. 对象适配器模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Builder-Pattern%EF%BC%89%EF%BC%88%E6%95%B4%E7%90%86%E4%B8%AD%EF%BC%81%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">建造者模式（Builder Pattern）（整理中！）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9-3"><span class="toc-number">6.1.</span> <span class="toc-text">1. 定义与特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.</span> <span class="toc-text">2. 结构与实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Pattern%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">工厂模式（Factory Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">1. 定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A1%88%E4%BE%8B%E9%9C%80%E6%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.1. 案例需求概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%97%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.1.2.</span> <span class="toc-text">1.2. 无设计模式实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">2. 简单工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.1.</span> <span class="toc-text">2.1. 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.2. 具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">7.2.3.</span> <span class="toc-text">2.3. 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">3. 工厂方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">7.3.1.</span> <span class="toc-text">3.1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">7.3.2.</span> <span class="toc-text">3.2. 模式结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.3.</span> <span class="toc-text">3.3. 具体实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">7.3.4.</span> <span class="toc-text">3.4. 优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Abstract-Factory-Pattern%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">抽象工厂模式（Abstract Factory Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-1"><span class="toc-number">8.2.</span> <span class="toc-text">2. 模式结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%9A%82%E6%9C%AA%E6%95%B4%E7%90%86%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">3. 具体实现（暂未整理代码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.4.</span> <span class="toc-text">4. 优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.5.</span> <span class="toc-text">5. 使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy-Pattern%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">策略模式（Strategy Pattern）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="toc-number">9.1.</span> <span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84-2"><span class="toc-number">9.2.</span> <span class="toc-text">2. 模式结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">9.3.</span> <span class="toc-text">3. 基础实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%9C%80%E6%B1%82%E8%AF%B4%E6%98%8E"><span class="toc-number">9.3.1.</span> <span class="toc-text">3.1. 需求说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.2.</span> <span class="toc-text">3.2. 代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">4. 进阶：工厂方法设计模式+策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">9.4.1.</span> <span class="toc-text">4.1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%B7%A5%E5%8E%82-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.4.2.</span> <span class="toc-text">4.2. 工厂+策略模式实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%95%B4%E4%BD%93%E6%80%9D%E8%B7%AF"><span class="toc-number">9.4.2.1.</span> <span class="toc-text">4.2.1. 整体思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.4.2.2.</span> <span class="toc-text">4.2.2. 具体实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E6%B5%8B%E8%AF%95"><span class="toc-number">9.4.2.3.</span> <span class="toc-text">4.2.3. 测试</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-%E6%95%B4%E7%90%86%E4%B8%AD%EF%BC%81"><span class="toc-number">10.</span> <span class="toc-text">装饰器模式(整理中！)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9-4"><span class="toc-number">10.1.</span> <span class="toc-text">1. 定义与特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88Chain-of-Responsibility%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">责任链模式（Chain of Responsibility）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-2"><span class="toc-number">11.1.</span> <span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">11.2.</span> <span class="toc-text">2. 优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">11.3.</span> <span class="toc-text">3. 模式结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%B8%BB%E8%A6%81%E8%A7%92%E8%89%B2"><span class="toc-number">11.3.1.</span> <span class="toc-text">3.1. 主要角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">11.3.2.</span> <span class="toc-text">3.2. 结构图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.4.</span> <span class="toc-text">4. 基础实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%9B%E9%98%B6%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98"><span class="toc-number">11.5.</span> <span class="toc-text">5. 进阶案例实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A1%88%E4%BE%8B%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">11.5.1.</span> <span class="toc-text">5.1. 案例需求分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90"><span class="toc-number">11.5.2.</span> <span class="toc-text">5.2. 接口设计分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.5.3.</span> <span class="toc-text">5.3. 代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E4%BA%A7%E5%93%81%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">11.5.3.1.</span> <span class="toc-text">5.3.1. 产品实体类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9A%E6%8A%BD%E8%B1%A1%E8%A1%8C%E4%B8%BA%EF%BC%8C%E5%AD%90%E7%B1%BB%E5%85%B1%E6%9C%89%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">11.5.3.2.</span> <span class="toc-text">5.3.2. 抽象类处理器：抽象行为，子类共有属性、方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E5%AD%90%E7%B1%BB%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9A%E5%A4%84%E7%90%86%E7%89%B9%E6%9C%89%E7%9A%84%E6%A0%A1%E9%AA%8C%E9%80%BB%E8%BE%91"><span class="toc-number">11.5.3.3.</span> <span class="toc-text">5.3.3. 子类处理器：处理特有的校验逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A%E6%89%A7%E8%A1%8C%E5%A4%84%E7%90%86%E5%99%A8%E9%93%BE%E8%B7%AF"><span class="toc-number">11.5.3.4.</span> <span class="toc-text">5.3.4. 客户端：执行处理器链路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-5-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C-paramCheck-%E6%96%B9%E6%B3%95%E6%AD%A5%E9%AA%A4%E8%AF%B4%E6%98%8E"><span class="toc-number">11.5.3.5.</span> <span class="toc-text">5.3.5. 责任链模式参数校验 paramCheck 方法步骤说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-5-1-%E6%AD%A5%E9%AA%A41%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%A4%84%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">11.5.3.5.1.</span> <span class="toc-text">5.3.5.1. 步骤1：获取处理器配置</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#5-3-5-1-1-%E6%AD%A5%E9%AA%A42-1%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%A3%80%E6%9F%A5"><span class="toc-number">11.5.3.5.1.1.</span> <span class="toc-text">5.3.5.1.1. 步骤2-1：配置检查</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-3-5-1-2-%E6%AD%A5%E9%AA%A42-2%EF%BC%9A%E4%BF%9D%E5%AD%98%E5%A4%84%E7%90%86%E5%99%A8%E8%A7%84%E5%88%99"><span class="toc-number">11.5.3.5.1.2.</span> <span class="toc-text">5.3.5.1.2. 步骤2-2：保存处理器规则</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-3-5-1-3-%E6%AD%A5%E9%AA%A42-3%EF%BC%9A%E9%80%92%E5%BD%92%E8%AE%BE%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%E9%93%BE%E8%B7%AF"><span class="toc-number">11.5.3.5.1.3.</span> <span class="toc-text">5.3.5.1.3. 步骤2-3：递归设置处理器链路</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-5-2-%E6%AD%A5%E9%AA%A42%EF%BC%9A%E6%A0%B9%E6%8D%AE%E9%85%8D%E7%BD%AE%E8%8E%B7%E5%8F%96%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">11.5.3.5.2.</span> <span class="toc-text">5.3.5.2. 步骤2：根据配置获取处理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-5-3-%E6%AD%A5%E9%AA%A43%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%89%A7%E8%A1%8C%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF"><span class="toc-number">11.5.3.5.3.</span> <span class="toc-text">5.3.5.3. 步骤3：客户端执行调用链路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%B5%8B%E8%AF%95"><span class="toc-number">11.5.4.</span> <span class="toc-text">5.4. 测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%95%B4%E7%90%86%E4%B8%AD%EF%BC%81%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">门面模式（整理中！）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">13.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">13.1.</span> <span class="toc-text">1. 网络参考资料</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img src="/bg/Image00018.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库150道高频面试题"/></a><div class="content"><a class="title" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题">MySQL数据库150道高频面试题</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术同学必会的MySQL设计规约"/></a><div class="content"><a class="title" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约">技术同学必会的MySQL设计规约</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dfdfdf4.html" title="数据库概述"><img src="/bg/Image00002.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库概述"/></a><div class="content"><a class="title" href="/posts/dfdfdf4.html" title="数据库概述">数据库概述</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/490575ab.html" title="24工厂模式俗话解释"><img src="/bg/Image00024.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24工厂模式俗话解释"/></a><div class="content"><a class="title" href="/posts/490575ab.html" title="24工厂模式俗话解释">24工厂模式俗话解释</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/364ea8cc.html" title="设计模式"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/364ea8cc.html" title="设计模式">设计模式</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2020 - 2025 By 蓝桉</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8152976493" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat/cat.js"></script><script async data-pjax src="/js/meting/music_lanan.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/day/lunar.js"></script><script defer src="/js/day/day.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '10a7db1c41b6489db9c830c668a18304';
  var gaud_map_key = '82a64bc994fb6494830f157f319f9f69';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime/runtime.min.js"></script><script async src="/js/font/ali_font_all.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>
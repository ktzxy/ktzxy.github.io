<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础-Java8新特性 | 蓝桉`Blog</title><meta name="author" content="蓝桉,kt_zxh@163.com"><meta name="copyright" content="蓝桉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Java 8 新特性概述Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。Java8 新增了非常多的特性，常用有以下几个：  Lambda 表达式 − Lambda 允许把函数作为一个方法的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础-Java8新特性">
<meta property="og:url" content="https://ktzxy.github.io/posts/8bebd4ec.html">
<meta property="og:site_name" content="蓝桉&#96;Blog">
<meta property="og:description" content="1. Java 8 新特性概述Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。Java8 新增了非常多的特性，常用有以下几个：  Lambda 表达式 − Lambda 允许把函数作为一个方法的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ktzxy.github.io/bg/Image00018.webp">
<meta property="article:published_time" content="2025-07-09T17:28:45.000Z">
<meta property="article:modified_time" content="2025-07-13T15:45:18.461Z">
<meta property="article:author" content="蓝桉">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ktzxy.github.io/bg/Image00018.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础-Java8新特性",
  "url": "https://ktzxy.github.io/posts/8bebd4ec.html",
  "image": "https://ktzxy.github.io/bg/Image00018.webp",
  "datePublished": "2025-07-09T17:28:45.000Z",
  "dateModified": "2025-07-13T15:45:18.461Z",
  "author": [
    {
      "@type": "Person",
      "name": "蓝桉",
      "url": "https://ktzxy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ktzxy.github.io/posts/8bebd4ec.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础-Java8新特性',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/windmill/windmill.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/meting/music_lanan.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="蓝桉`Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/bg.webp);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/bg/Image00018.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">蓝桉`Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础-Java8新特性</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java基础-Java8新特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-09T17:28:45.000Z" title="发表于 2025-07-09 17:28:45">2025-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-13T15:45:18.461Z" title="更新于 2025-07-13 15:45:18">2025-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-Java-8-新特性概述"><a href="#1-Java-8-新特性概述" class="headerlink" title="1. Java 8 新特性概述"></a>1. Java 8 新特性概述</h2><p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。Java8 新增了非常多的特性，常用有以下几个：</p>
<ul>
<li><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</li>
<li><strong>方法引用</strong> − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li>
<li><strong>默认方法</strong> − 默认方法就是一个在接口里面有了一个实现的方法。</li>
<li><strong>新的编译工具</strong> - 如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li>
<li><strong>Stream API</strong> − 新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>
<li><strong>Date Time API</strong> − 加强对日期与时间的处理。</li>
<li><strong>Optional 类</strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li><strong>Nashorn, JavaScript 引擎</strong> − Java 8 提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
<h2 id="2-Lambda-表达式"><a href="#2-Lambda-表达式" class="headerlink" title="2. Lambda 表达式"></a>2. Lambda 表达式</h2><h3 id="2-1-Lambda-表达式定义"><a href="#2-1-Lambda-表达式定义" class="headerlink" title="2.1. Lambda 表达式定义"></a>2.1. Lambda 表达式定义</h3><ul>
<li>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性</li>
<li>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）</li>
<li>使用 Lambda 表达式可以使代码变的更加简洁紧凑</li>
<li>在调用方法时，如果参数是函数式接口，就可以考虑使用Lambda表达式，Lambda表达式相当于是对接口中抽象方法的重写</li>
</ul>
<p>示例：当需要启动一个线程去完成任务时，通常会通过 <code>Runnable</code> 接口来定义任务内容，并使用 <code>Thread</code> 类来启动该线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 示例：当需要启动一个线程去完成任务时，通常会通过 `Runnable` 接口来定义任务内容，并使用 `Thread` 类来启动该线程。 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickstartTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 传统写法，使用匿名内部类实现</span></span><br><span class="line"><span class="comment">     * 对于 Runnable 的匿名内部类用法，可以分析出几点内容：</span></span><br><span class="line"><span class="comment">     *      1.Thread 类需要 Runnable 接口作为参数，其中的抽象 run 方法是用来指定线程任务内容的核心</span></span><br><span class="line"><span class="comment">     *      2.为了指定 run 的方法体，不得不需要 Runnable 接口的实现类</span></span><br><span class="line"><span class="comment">     *      3.为了省去定义一个 Runnable 实现类的麻烦，不得不使用匿名内部类</span></span><br><span class="line"><span class="comment">     *      4.必须覆盖重写抽象 run 方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错</span></span><br><span class="line"><span class="comment">     *      5.实际上，似乎只有方法体才是关键所在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;新线程任务执行！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用Lambda表达式实现，Lambda是一个匿名函数</span></span><br><span class="line"><span class="comment">     *       简化匿名内部类的使用，语法更加简单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Lambda表达式创建的线程任务执行了！&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Lambda-表达式语法"><a href="#2-2-Lambda-表达式语法" class="headerlink" title="2.2. Lambda 表达式语法"></a>2.2. Lambda 表达式语法</h3><h4 id="2-2-1-Lambda的标准语法格式"><a href="#2-2-1-Lambda的标准语法格式" class="headerlink" title="2.2.1. Lambda的标准语法格式"></a>2.2.1. Lambda的标准语法格式</h4><ul>
<li>标准语法格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123;</span><br><span class="line">    代码体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其他简化格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">(parameters) -&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-lambda表达式的重要特征（可省略规则）"><a href="#2-2-2-lambda表达式的重要特征（可省略规则）" class="headerlink" title="2.2.2. lambda表达式的重要特征（可省略规则）"></a>2.2.2. lambda表达式的重要特征（可省略规则）</h4><ul>
<li><strong>可选类型声明</strong>：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号</strong>：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号</strong>：如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字</strong>：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<h4 id="2-2-3-使用-Lambda-表达式前提条件"><a href="#2-2-3-使用-Lambda-表达式前提条件" class="headerlink" title="2.2.3. 使用 Lambda 表达式前提条件"></a>2.2.3. 使用 Lambda 表达式前提条件</h4><ol>
<li>Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li>
<li>使用Lambda表达式的接口只能有一个方法，此种接口可以称为函数式接口</li>
<li>如果一个接口使用注解<code>@FunctonalInterface</code>修饰，则该接口称为函数式接口。如果该接口中有多个方法，但除了一个方法外的其它方法都有默认实现（使用<code>default</code>关键字修改的方法），则也是可以做为函数式接口</li>
<li>如果接口里面有Object类下的非默认方法，也是一个函数式接口，可以使用lambda表达式</li>
</ol>
<h3 id="2-3-Lambda-表达式示例"><a href="#2-3-Lambda-表达式示例" class="headerlink" title="2.3. Lambda 表达式示例"></a>2.3. Lambda 表达式示例</h3><blockquote>
<p>TODO: 后面需要深入使用时，参考阿里的《Java工程师必读手册.pdf》电子书的[最完美的 Lambda 表达式只有一行]章节</p>
</blockquote>
<h4 id="2-3-1-基础综合示例1"><a href="#2-3-1-基础综合示例1" class="headerlink" title="2.3.1. 基础综合示例1"></a>2.3.1. 基础综合示例1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5</span></span><br><span class="line">() -&gt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值</span></span><br><span class="line">x -&gt; <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值</span></span><br><span class="line">(x, y) -&gt; x – y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和</span></span><br><span class="line">(<span class="type">int</span> x, <span class="type">int</span> y) -&gt; x + y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)</span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-综合示例2"><a href="#2-3-2-综合示例2" class="headerlink" title="2.3.2. 综合示例2"></a>2.3.2. 综合示例2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Java8Tester</span> <span class="variable">tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类型声明</span></span><br><span class="line">        <span class="type">MathOperation</span> <span class="variable">addition</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a + b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不用类型声明</span></span><br><span class="line">        <span class="type">MathOperation</span> <span class="variable">subtraction</span> <span class="operator">=</span> (a, b) -&gt; a - b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大括号中的返回语句</span></span><br><span class="line">        <span class="type">MathOperation</span> <span class="variable">multiplication</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有大括号及返回语句</span></span><br><span class="line">        <span class="type">MathOperation</span> <span class="variable">division</span> <span class="operator">=</span> (<span class="type">int</span> a, <span class="type">int</span> b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;10 + 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">        System.out.println(<span class="string">&quot;10 - 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">        System.out.println(<span class="string">&quot;10 x 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">        System.out.println(<span class="string">&quot;10 / 5 = &quot;</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不用括号</span></span><br><span class="line">        <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用括号</span></span><br><span class="line">        <span class="type">GreetingService</span> <span class="variable">greetService2</span> <span class="operator">=</span> (message) -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br><span class="line"></span><br><span class="line">        greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        greetService2.sayMessage(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">MathOperation</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">operation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">operate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, MathOperation mathOperation)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac Java8Tester.java</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java Java8Tester</span></span><br><span class="line">10 + 5 = 15</span><br><span class="line">10 - 5 = 5</span><br><span class="line">10 x 5 = 50</span><br><span class="line">10 / 5 = 2</span><br><span class="line">Hello Runoob</span><br><span class="line">Hello Google</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-无参数无返回值的Lambda"><a href="#2-3-3-无参数无返回值的Lambda" class="headerlink" title="2.3.3. 无参数无返回值的Lambda"></a>2.3.3. 无参数无返回值的Lambda</h4><ul>
<li>定义只有一个抽象方法的接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Sportable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSport</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用Lambda表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无参数无返回值的Lambda */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambdaNoParamsTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 传统写法：匿名内部类方式实现</span></span><br><span class="line">    playBasketball(<span class="keyword">new</span> <span class="title class_">Sportable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSport</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用匿名内部类方式调用playBasketball(Sportable sportable)方法...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Lambda表达式方式实现</span></span><br><span class="line"><span class="comment">     *  相当于是对接口抽象方法的重写</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    playBasketball(() -&gt; System.out.println(<span class="string">&quot;使用Lambda表达式方式调用playBasketball(Sportable sportable)方法...&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义方法，入参为Sportable接口，方法体中调用Sportable接口的doSport()方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">playBasketball</span><span class="params">(Sportable sportable)</span> &#123;</span><br><span class="line">    sportable.doSport();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-有参数有返回值的Lambda"><a href="#2-3-4-有参数有返回值的Lambda" class="headerlink" title="2.3.4. 有参数有返回值的Lambda"></a>2.3.4. 有参数有返回值的Lambda</h4><p>示例：调用 <code>java.util.Comparator&lt;T&gt;</code> 接口的使用场景代码，其中的抽象方法定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br></pre></td></tr></table></figure>
<p>当需要对一个对象集合进行排序时，<code>Collections.sort</code> 方法需要一个 <code>Comparator</code> 接口实例来指定排序的规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 02 有参数有返回值的Lambda */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambdaHasParamsTest</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;Person&gt; persons = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">30</span>, <span class="number">156</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">28</span>, <span class="number">168</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;天锁斩月&quot;</span>, <span class="number">183</span>, <span class="number">180</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;樱木花道&quot;</span>, <span class="number">18</span>, <span class="number">189</span>));</span><br><span class="line">    <span class="comment">// 传统写法：匿名内部类方式实现</span></span><br><span class="line">    <span class="comment">/*Collections.sort(persons, new Comparator&lt;Person&gt;() &#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public int compare(Person o1, Person o2) &#123;</span></span><br><span class="line"><span class="comment">            // 返回对象年龄属性的差值，可以实现按年龄排序</span></span><br><span class="line"><span class="comment">            return o1.getAge() - o2.getAge();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">    <span class="comment">// Lambda表达式方式实现，标准格式</span></span><br><span class="line">    Collections.sort(persons, (Person o1, Person o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 输入结果</span></span><br><span class="line">    <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-5-省略格式的Lambda"><a href="#2-3-5-省略格式的Lambda" class="headerlink" title="2.3.5. 省略格式的Lambda"></a>2.3.5. 省略格式的Lambda</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lambda表达式省略格式写法示例 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Person&gt; persons = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">30</span>, <span class="number">156</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">28</span>, <span class="number">168</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;天锁斩月&quot;</span>, <span class="number">183</span>, <span class="number">180</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;樱木花道&quot;</span>, <span class="number">18</span>, <span class="number">189</span>));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Lambda表达式省略格式写法：多个参数，有返回值</span></span><br><span class="line"><span class="comment">     *  1. 小括号内参数的类型可以省略</span></span><br><span class="line"><span class="comment">     *  2. 小括号内参数是多个，则小括号不可以省略</span></span><br><span class="line"><span class="comment">     *  3. 如果大括号内有且仅有一个语句，可以同时省略大括号、return关键字及语句分号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Collections.sort(persons, (o1, o2) -&gt; o1.getAge() - o2.getAge());</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Lambda表达式省略格式写法：单个参数，无返回值</span></span><br><span class="line"><span class="comment">     *  1. 小括号内参数的类型可以省略</span></span><br><span class="line"><span class="comment">     *  2. 小括号内参数只有一个，则小括号可以省略</span></span><br><span class="line"><span class="comment">     *  3. 如果大括号内有且仅有一个语句，可以同时省略大括号、return关键字及语句分号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    persons.forEach(person -&gt; System.out.println(person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Lambda的实现原理（！待整理）"><a href="#2-4-Lambda的实现原理（！待整理）" class="headerlink" title="2.4. Lambda的实现原理（！待整理）"></a>2.4. Lambda的实现原理（！待整理）</h3><blockquote>
<p>参考《2019.10.25-JavaJDK新特性详解-JDK8》笔记</p>
</blockquote>
<h4 id="2-4-1-类型推断与检查"><a href="#2-4-1-类型推断与检查" class="headerlink" title="2.4.1. 类型推断与检查"></a>2.4.1. 类型推断与检查</h4><p>Java 编译器会从上下文中推断出用什么函数式接口来配合 Lambda 表达式。Java 编译器<strong>类型推断</strong>步骤如下：</p>
<ol>
<li>首先，根据 Lambda 表达式对应的方法、参数和返回值，确定使用了哪个函数式接口；</li>
<li>然后，Java 编译器根据这个函数式接口，获取到唯一抽象方法的函数描述符（参数和返回值类型）；</li>
<li>最后，Java 编译器通过函数描述符推断出 Lambda 表达式的参数类型。</li>
</ol>
<p><strong>类型检查</strong>：利用 Java 编译器推断出来的函数描述符（参数和返回值类型），验证 Lambda 表达式参数是否合法。</p>
<h4 id="2-4-2-this-指向对象"><a href="#2-4-2-this-指向对象" class="headerlink" title="2.4.2. this 指向对象"></a>2.4.2. this 指向对象</h4><p>Lambda 表达式可以用来取代唯一抽象方法的内部匿名类的。但是 this 指针指向对象，却是完全不一样的：</p>
<ul>
<li>对于 Java 中的匿名内部类，编译器会自动生成它的类名（<code>外部类类名$数字</code>）。而<font color=red><strong>匿名内部类中的 this，将指向的是这个内部类对象本身</strong></font>。</li>
<li>对于 Java 中的<font color=red><strong>Lambda 表达式中的 this，指向的是 Lambda 表达式所在类的对象</strong></font>。即 Lambda 表达式中的 this 与普通表达式中的 this 没有任何区别。</li>
</ul>
<h3 id="2-5-变量作用域"><a href="#2-5-变量作用域" class="headerlink" title="2.5. 变量作用域"></a>2.5. 变量作用域</h3><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1. 概述"></a>2.5.1. 概述</h4><p>Java 局部类和匿名类都存在变量捕获（Captured Variable）和变量隐藏（Shadow Variable），但 Lambda 表达式只存在变量捕获，不存在变量隐藏。即 Lambda 表达式的作用域：</p>
<ul>
<li>Lambda 表达式不会从超类继承或引入新级别的作用域</li>
<li>Lambda 表达式中的声明变量和普通封闭程序块中的一样</li>
</ul>
<p>Lambda 表达式可以无限制地捕获变量或常量，但是局部变量必须定义为 <code>final</code> 或准 <code>final</code> 型（不允许修改）。因为 Lambda 表达式只通过 <code>this</code> 指针捕获一次局部变量值，后续局部变量发生更改将无法得知。所以干脆禁止这些局部变量的更改，期望这些局部变量被定义为 <code>final</code> 或准 <code>final</code> 型，否则会出现编译错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>; <span class="comment">// 定义为准备 final 型</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    <span class="comment">// str = &quot;inner&quot;; // 报错，不允许修改</span></span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">// str = &quot;outer&quot;; // 报错，不允许修改</span></span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-使用示例"><a href="#2-5-2-使用示例" class="headerlink" title="2.5.2. 使用示例"></a>2.5.2. 使用示例</h4><p>lambda 表达式只能引用标记了 <code>final</code> 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">salutation</span> <span class="operator">=</span> <span class="string">&quot;Hello! &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt; System.out.println(salutation + message);</span><br><span class="line">        greetService1.sayMessage(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac Java8Tester.java</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">java Java8Tester</span></span><br><span class="line">Hello! Runoob</span><br></pre></td></tr></table></figure>
<p>也可以直接在 lambda 表达式中访问外层的局部变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));</span><br><span class="line">        s.convert(<span class="number">2</span>);  <span class="comment">// 输出结果为 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; s = (param) -&gt; System.out.println(String.valueOf(param + num));</span><br><span class="line">s.convert(<span class="number">2</span>);</span><br><span class="line">num = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 报错信息：Local variable num defined in an enclosing scope must be final or effectively final</span></span><br><span class="line"><span class="comment">// 把num=5；注释掉就不报错了</span></span><br></pre></td></tr></table></figure>
<p>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  <span class="comment">// 把String first = &quot;&quot;;注掉就不报错了</span></span><br><span class="line">        Comparator&lt;String&gt; comparator = (first, second) -&gt; System.out.println(Integer.compare(first.length(), second.length())); <span class="comment">// 编译会出错</span></span><br><span class="line">        comparator.com(<span class="string">&quot;aaaaa&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">com</span><span class="params">(String a, String b)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-Lambda-和匿名内部类对比总结"><a href="#2-6-Lambda-和匿名内部类对比总结" class="headerlink" title="2.6. Lambda 和匿名内部类对比总结"></a>2.6. Lambda 和匿名内部类对比总结</h3><p>实际上 Lambda 表达式<strong>并非匿名内部类的语法糖</strong>。Lambda 表达式在大多数虚拟机中采用 <code>invokeDynamic</code> 指令实现，相对于匿名内部类在<strong>效率上会更高</strong>一些。</p>
<ol>
<li>所需的类型不一样<ul>
<li>匿名内部类需要的类型可以是类，抽象类，接口</li>
<li>Lambda 表达式需要的类型必须是接口</li>
</ul>
</li>
<li>抽象方法的数量不一样<ul>
<li>匿名内部类所需的接口中抽象方法的数量随意</li>
<li>Lambda 表达式所需的接口只能有一个抽象方法</li>
</ul>
</li>
<li>实现原理不同<ul>
<li>匿名内部类是在编译后会生成一个名称为 <code>外部类类名$数字</code> 的 class 文件</li>
<li>Lambda 表达式是在程序运行的时候动态生成一个类（class 文件），在类中新增一个方法，这个方法的方法体就是 Lambda 表达式中的代码；还会生成一个匿名内部类，实现接口，重写抽象方法；在接口的重写方法中会调用前面新生成的方法（即 Lambda 表达式的代码）</li>
</ul>
</li>
</ol>
<h2 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3. 方法引用"></a>3. 方法引用</h2><p>方法引用是Lambda表达式的一个简化写法。所引用的方法其实是Lambda表达式的方法体的实现。如果正好有某个方法满足一个lambda表达式的形式，那就可以将这个lambda表达式用方法引用的方式表示，但是如果这个lambda表达式的比较复杂就不能用方法引用进行替换。实际上方法引用是lambda表达式的一种语法糖</p>
<ul>
<li>方法引用通过方法的名字来指向一个方法</li>
<li>方法引用可以使语言的构造更紧凑简洁，减少冗余代码</li>
<li>方法引用语法是使用一对冒号 <code>::</code></li>
</ul>
<p><strong>应用场景</strong>：如果 Lambda 所要实现的方案，已经有其他方法存在相同方案，那么则可以使用方法引用</p>
<p><strong>方法引用的注意事项</strong></p>
<ol>
<li><font color=red>**方法引用只能"引用"已经存在的方法**</font></li>
<li><font color=red>**Lambda 体中调用的方法的参数列表与返回值类型，要与函数式中接口的抽象方法的参数列表和返回值类型一样**</font>

</li>
</ol>
<h3 id="3-1-方法引用语法格式"><a href="#3-1-方法引用语法格式" class="headerlink" title="3.1. 方法引用语法格式"></a>3.1. 方法引用语法格式</h3><ul>
<li><strong>方法引用语法符号</strong>：<code>::</code></li>
<li><strong>方法引用符号说明</strong>：双冒号为方法引用运算符，而它所在的表达式被称为方法引用。</li>
</ul>
<h3 id="3-2-常见引用方式"><a href="#3-2-常见引用方式" class="headerlink" title="3.2. 常见引用方式"></a>3.2. 常见引用方式</h3><p>主要有5种语法格式</p>
<h4 id="3-2-1-实例对象普通方法的引用"><a href="#3-2-1-实例对象普通方法的引用" class="headerlink" title="3.2.1. 实例对象普通方法的引用"></a>3.2.1. 实例对象普通方法的引用</h4><p>最常见的一种用法，如果一个类中已经存在了一个成员方法，并且当 Lambda 表达式参数与调用的对象实例方法参数一致时，可以采用实例方法引用语法。表达式语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象名::引用成员方法</span></span><br><span class="line">instanceName::methodName</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对象::实例方法 - 方法引用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodReftest01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">// Lambda表达式实现函数式接口</span></span><br><span class="line">    <span class="comment">// Supplier&lt;Long&gt; supplier = () -&gt; now.getTime();</span></span><br><span class="line">    <span class="comment">// 使用方法引用对象实例方法，实现函数式接口</span></span><br><span class="line">    Supplier&lt;Long&gt; supplier = now::getTime;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">time</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;time: &quot;</span> + time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-类静态方法的引用"><a href="#3-2-2-类静态方法的引用" class="headerlink" title="3.2.2. 类静态方法的引用"></a>3.2.2. 类静态方法的引用</h4><p>当 Lambda 表达式参数与调用的静态方法参数一致时，可以采用静态方法引用语法。表达式语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名::引用静态方法名</span></span><br><span class="line">ClassName::staticMethodName</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Lambda表达式实现函数式接口</span></span><br><span class="line">    <span class="comment">// Supplier&lt;Long&gt; supplier = () -&gt; System.currentTimeMillis();</span></span><br><span class="line">    <span class="comment">// 使用方法引用类静态方法，实现函数式接口</span></span><br><span class="line">    Supplier&lt;Long&gt; supplier = System::currentTimeMillis;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">time</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-参数类方法的引用"><a href="#3-2-3-参数类方法的引用" class="headerlink" title="3.2.3. 参数类方法的引用"></a>3.2.3. 参数类方法的引用</h4><p>Java面向对象中，类名只能调用静态方法。而在方法引用中，也可以使用类名引用普通方法。</p>
<p>但类名引用实例方法是有前提的，<font color=red><strong>当 Lambda 表达式只有一个参数且调用该参数的无参类方法时，可以使用类名实例方法引用，实际上是拿第一个参数作为方法的调用者</strong></font>。表达式语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名::实例方法名</span></span><br><span class="line">ClassName::methodName</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Lambda表达式实现函数式接口(一个参数)</span></span><br><span class="line">    <span class="comment">// Function&lt;String, Integer&gt; f1 = str -&gt; str.length();</span></span><br><span class="line">    <span class="comment">// 使用方法引用类实例方法，实现函数式接口(注意:类名::实例方法实际上会将第一个参数作为方法的调用者)</span></span><br><span class="line">    Function&lt;String, Integer&gt; f1 = String::length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> f1.apply(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;length = &quot;</span> + length);</span><br><span class="line">    <span class="comment">// Lambda表达式实现函数式接口(两个参数)</span></span><br><span class="line">    <span class="comment">// BiFunction&lt;String, Integer, String&gt; f2 = (String str, Integer index) -&gt; str.substring(index);</span></span><br><span class="line">    <span class="comment">// 使用方法引用类实例方法，实现函数式接口</span></span><br><span class="line">    BiFunction&lt;String, Integer, String&gt; f2 = String::substring;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> f2.apply(<span class="string">&quot;helloworld&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;str2 = &quot;</span> + str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-4-构造方法的引用"><a href="#3-2-4-构造方法的引用" class="headerlink" title="3.2.4. 构造方法的引用"></a>3.2.4. 构造方法的引用</h4><p>当 Lambda 表达式参数与调用的构造方法参数一致时，可以采用构造方法引用语法。由于构造器的名称与类名完全一样，所以可以使用类名引用。表达式语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名::new</span></span><br><span class="line">ClassName::<span class="keyword">new</span></span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行Person类无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;执行Person类有参构造&quot;</span> + <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">                .add(<span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&quot;</span>)</span><br><span class="line">                .add(<span class="string">&quot;age=&quot;</span> + age)</span><br><span class="line">                .toString();</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Lambda表达式实现函数式接口</span></span><br><span class="line">    <span class="comment">// Supplier&lt;Person&gt; supplier1 = () -&gt; new Person();</span></span><br><span class="line">    <span class="comment">// 使用方法引用类构造器方法，实现函数式接口</span></span><br><span class="line">    Supplier&lt;Person&gt; supplier1 = Person::<span class="keyword">new</span>;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> supplier1.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;person = &quot;</span> + person);</span><br><span class="line">    <span class="comment">// Lambda表达式实现函数式接口</span></span><br><span class="line">    <span class="comment">// BiFunction&lt;String, Integer, Person&gt; bif = (String name, Integer age) -&gt; new Person(name, age);</span></span><br><span class="line">    <span class="comment">// 使用方法引用类构造器方法（有参构造），实现函数式接口。方法引用时，会根据参数列表的个数，引用相应的构造方法</span></span><br><span class="line">    BiFunction&lt;String, Integer, Person&gt; bif = Person::<span class="keyword">new</span>;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> bif.apply(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;person2 = &quot;</span> + person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-5-数组构造器的引用"><a href="#3-2-5-数组构造器的引用" class="headerlink" title="3.2.5. 数组构造器的引用"></a>3.2.5. 数组构造器的引用</h4><p>数组也是 <code>Object</code> 的子类对象，所以同样具有构造器引用。表达式语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型[]::new</span></span><br><span class="line">TypeName[]::<span class="keyword">new</span></span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Lambda表达式实现函数式接口</span></span><br><span class="line">    <span class="comment">// Function&lt;Integer, int[]&gt; f = (Integer length) -&gt; new int[length];</span></span><br><span class="line">    <span class="comment">// 使用方法引用数组构造器方法</span></span><br><span class="line">    Function&lt;Integer, <span class="type">int</span>[]&gt; f = <span class="type">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line">    <span class="type">int</span>[] arr = f.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-方法引用用法综合示例"><a href="#3-3-方法引用用法综合示例" class="headerlink" title="3.3. 方法引用用法综合示例"></a>3.3. 方法引用用法综合示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02MethodRefComprehensive</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器引用：它的语法是Class::new，或者更一般的Class&lt;T&gt;::new实例如下：</span></span><br><span class="line">        <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> Car.create(Car::<span class="keyword">new</span>);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> Car.create(Car::<span class="keyword">new</span>);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> Car.create(Car::<span class="keyword">new</span>);</span><br><span class="line">        <span class="type">Car</span> <span class="variable">car3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        List&lt;Car&gt; cars = Arrays.asList(car, car1, car2, car3);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================构造器引用========================&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态方法引用：它的语法是Class::static_method，实例如下：</span></span><br><span class="line">        cars.forEach(Car::collide);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================静态方法引用========================&quot;</span>);</span><br><span class="line">        <span class="comment">// 特定类的任意对象的方法引用：它的语法是Class::method实例如下：</span></span><br><span class="line">        cars.forEach(Car::repair);</span><br><span class="line">        System.out.println(<span class="string">&quot;==============特定类的任意对象的方法引用================&quot;</span>);</span><br><span class="line">        <span class="comment">// 特定对象的方法引用：它的语法是instance::method实例如下：</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Car</span> <span class="variable">police</span> <span class="operator">=</span> Car.create(Car::<span class="keyword">new</span>);</span><br><span class="line">        cars.forEach(police::follow);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================特定对象的方法引用===================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="comment">// Supplier是jdk1.8的接口，这里和lamda一起使用了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">create</span><span class="params">(<span class="keyword">final</span> Supplier&lt;Car&gt; supplier)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">collide</span><span class="params">(<span class="keyword">final</span> Car car)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Collided &quot;</span> + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">follow</span><span class="params">(<span class="keyword">final</span> Car another)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Following the &quot;</span> + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repair</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Repaired &quot;</span> + <span class="built_in">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出程序</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">===================构造器引用========================</span><br><span class="line">Collided com.moon.java.jdk8methodref.Car@3b9a45b3</span><br><span class="line">Collided com.moon.java.jdk8methodref.Car@7699a589</span><br><span class="line">Collided com.moon.java.jdk8methodref.Car@58372a00</span><br><span class="line">Collided com.moon.java.jdk8methodref.Car@4dd8dc3</span><br><span class="line">===================静态方法引用========================</span><br><span class="line">Repaired com.moon.java.jdk8methodref.Car@3b9a45b3</span><br><span class="line">Repaired com.moon.java.jdk8methodref.Car@7699a589</span><br><span class="line">Repaired com.moon.java.jdk8methodref.Car@58372a00</span><br><span class="line">Repaired com.moon.java.jdk8methodref.Car@4dd8dc3</span><br><span class="line">==============特定类的任意对象的方法引用================</span><br><span class="line">Following the com.moon.java.jdk8methodref.Car@3b9a45b3</span><br><span class="line">Following the com.moon.java.jdk8methodref.Car@7699a589</span><br><span class="line">Following the com.moon.java.jdk8methodref.Car@58372a00</span><br><span class="line">Following the com.moon.java.jdk8methodref.Car@4dd8dc3</span><br><span class="line">===================特定对象的方法引用===================</span><br></pre></td></tr></table></figure>
<h2 id="4-JDK8-接口的默认方法与静态方法"><a href="#4-JDK8-接口的默认方法与静态方法" class="headerlink" title="4. JDK8 接口的默认方法与静态方法"></a>4. JDK8 接口的默认方法与静态方法</h2><h3 id="4-1-JDK-8接口增强介绍"><a href="#4-1-JDK-8接口增强介绍" class="headerlink" title="4.1. JDK 8接口增强介绍"></a>4.1. JDK 8接口增强介绍</h3><p>JDK 8以前的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名 &#123;</span><br><span class="line">    静态常量;</span><br><span class="line">    抽象方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 8对接口的增强，接口还可以有<strong>默认方法</strong>和<strong>静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名 &#123;</span><br><span class="line">    静态常量;</span><br><span class="line">    抽象方法;</span><br><span class="line">    默认方法;</span><br><span class="line">    静态方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-默认方法"><a href="#4-2-默认方法" class="headerlink" title="4.2. 默认方法"></a>4.2. 默认方法</h3><h4 id="4-2-1-接口引入默认方法的背景介绍"><a href="#4-2-1-接口引入默认方法的背景介绍" class="headerlink" title="4.2.1. 接口引入默认方法的背景介绍"></a>4.2.1. 接口引入默认方法的背景介绍</h4><ul>
<li>Java 8 新增了接口的默认方法。简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。</li>
<li>只需在方法名前面加个default关键字即可实现默认方法。</li>
</ul>
<p>为什么要有这个特性？</p>
<p>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法的目的是为了解决接口的修改与现有的实现类不兼容的问题。</p>
<h4 id="4-2-2-接口默认方法语法格式"><a href="#4-2-2-接口默认方法语法格式" class="headerlink" title="4.2.2. 接口默认方法语法格式"></a>4.2.2. 接口默认方法语法格式</h4><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名 &#123;</span><br><span class="line">    修饰符 <span class="keyword">default</span> 返回值类型 方法名() &#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：接口中的默认方法修饰符可省略，默认是public</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Java8DefaultMethod</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-接口默认方法的使用"><a href="#4-2-3-接口默认方法的使用" class="headerlink" title="4.2.3. 接口默认方法的使用"></a>4.2.3. 接口默认方法的使用</h4><ul>
<li>方式一：实现类直接调用接口默认方法</li>
<li>方式二：实现类重写接口默认方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义动物接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义默认方法（方法修饰符可省略，默认是public）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Animal接口的默认方法eat()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认方法使用方式一: 实现类可以直接使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认方法使用方式二: 实现类重写接口默认方法，对象进行调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是Person实现类重写后的默认方法eat()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultFunctionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方式一：创建实现类，直接调用默认方法</span></span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    cat.eat();</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">// 方式二：创建实现类，实现类重写默认方法，再调用</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-4-多个默认方法"><a href="#4-2-4-多个默认方法" class="headerlink" title="4.2.4. 多个默认方法"></a>4.2.4. 多个默认方法</h4><p>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，有以下两种解决的方案</p>
<ol>
<li>第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法</li>
<li>第二种解决方案可以使用 <code>super</code> 关键字来调用指定接口的默认方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义接口1与同名参数列表相同的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Java8Interface1</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java8Interface1.defaultMethod()方法执行了....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义接口2与同名参数列表相同的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Java8Interface2</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java8Interface2.defaultMethod()方法执行了....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiDefaultMethodImpl1</span> <span class="keyword">implements</span> <span class="title class_">Java8Interface1</span>, Java8Interface2 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现两个接口的MultiDefaultMethodImpl1.defaultMethod()方法执行了....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第二种解决方案可以使用 super 关键字来调用指定接口的默认方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiDefaultMethodImpl2</span> <span class="keyword">implements</span> <span class="title class_">Java8Interface1</span>, Java8Interface2 &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用接口1的方法</span></span><br><span class="line">        Java8Interface1.<span class="built_in">super</span>.defaultMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;实现两个接口的MultiDefaultMethodImpl2.defaultMethod()方法执行了....&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用接口2的方法</span></span><br><span class="line">        Java8Interface2.<span class="built_in">super</span>.defaultMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiDefaultFunctionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方式一：实现类，重写两个接口的同名方法</span></span><br><span class="line">    <span class="type">MultiDefaultMethodImpl1</span> <span class="variable">impl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiDefaultMethodImpl1</span>();</span><br><span class="line">    impl1.defaultMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">// 方式二：实现类，重写两个接口的同名方法，方法内部使用super关键字调用指定的接口的默认方法</span></span><br><span class="line">    <span class="type">MultiDefaultMethodImpl2</span> <span class="variable">impl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiDefaultMethodImpl2</span>();</span><br><span class="line">    impl2.defaultMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-静态默认方法"><a href="#4-3-静态默认方法" class="headerlink" title="4.3. 静态默认方法"></a>4.3. 静态默认方法</h3><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。</p>
<h4 id="4-3-1-接口默认方法语法格式"><a href="#4-3-1-接口默认方法语法格式" class="headerlink" title="4.3.1. 接口默认方法语法格式"></a>4.3.1. 接口默认方法语法格式</h4><p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名 &#123;</span><br><span class="line">    修饰符 <span class="keyword">static</span> 返回值类型 方法名() &#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：接口中的默认方法修饰符可省略，默认是public</p>
</blockquote>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Java8DefaultMethod1</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-接口静态方法的使用"><a href="#4-3-2-接口静态方法的使用" class="headerlink" title="4.3.2. 接口静态方法的使用"></a>4.3.2. 接口静态方法的使用</h4><p>直接使用接口名调用即可，<code>接口名.静态方法名();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义有静态方法的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">StaticMethodInterface</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义静态方法（方法修饰符可省略，默认是public）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是StaticMethodInterface接口的静态方法staticMethod()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口实现类，静态方法不能被继承与重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticMethodInterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">StaticMethodInterface</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法不被重写，也不被继承</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void staticMethod() &#123;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultFunctionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建接口实现类</span></span><br><span class="line">    <span class="type">StaticMethodInterfaceImpl</span> <span class="variable">impl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticMethodInterfaceImpl</span>();</span><br><span class="line">    <span class="comment">// 报错，说明实现类无法继承接口的静态方法，对象也不能调用</span></span><br><span class="line">    <span class="comment">// impl.staticMethod();</span></span><br><span class="line">    <span class="comment">// 接口静态方法的调用：接口名.静态方法名();</span></span><br><span class="line">    StaticMethodInterface.staticMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-接口默认方法和静态方法的区别"><a href="#4-4-接口默认方法和静态方法的区别" class="headerlink" title="4.4. 接口默认方法和静态方法的区别"></a>4.4. 接口默认方法和静态方法的区别</h3><ol>
<li>默认方法通过实例调用，静态方法通过接口名调用。</li>
<li>默认方法可以被继承，实现类可以直接使用接口默认方法，也可以重写接口默认方法。</li>
<li>静态方法不能被继承，实现类不能重写接口静态方法，只能使用接口名调用。</li>
</ol>
<p>小结：如果接口某个方法需要被实现类继承或重写，则使用默认方法，如果接口中的方法不需要被继承就使用静态方法</p>
<h3 id="4-5-默认方法与默认方法综合示例"><a href="#4-5-默认方法与默认方法综合示例" class="headerlink" title="4.5. 默认方法与默认方法综合示例"></a>4.5. 默认方法与默认方法综合示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Jdk8DefaultAndStaticMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Vehicle</span> <span class="variable">vehicle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        vehicle.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一辆车!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">blowHorn</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;按喇叭!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">FourWheeler</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一辆四轮车!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span>, FourWheeler &#123;</span><br><span class="line">    <span class="comment">// 重写两个接口同名默认方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        Vehicle.<span class="built_in">super</span>.print();</span><br><span class="line">        FourWheeler.<span class="built_in">super</span>.print(); <span class="comment">// 调用接口的默认方法</span></span><br><span class="line">        Vehicle.blowHorn(); <span class="comment">// 调用接口静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是一辆汽车!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是一辆车!</span><br><span class="line">我是一辆四轮车!</span><br><span class="line">按喇叭!!!</span><br><span class="line">我是一辆汽车!</span><br></pre></td></tr></table></figure>
<h2 id="5-Java-8-函数式接口"><a href="#5-Java-8-函数式接口" class="headerlink" title="5. Java 8 函数式接口"></a>5. Java 8 函数式接口</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1. 定义"></a>5.1. 定义</h3><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong></p>
<ul>
<li>函数式接口(FunctionalInterface)就是一个有且仅有一个抽象方法的接口，但可以有多个默认方法，静态方法</li>
<li>接口默认继承 <code>java.lang.Object</code>，所以如果接口显示声明覆盖了 <code>Object</code> 中方法，那么也不算抽象方法。</li>
<li>函数式接口可以被隐式转换为 lambda 表达式</li>
<li>函数式接口可以现有的函数友好地支持 lambda 表达式</li>
</ul>
<h3 id="5-2-FunctionalInterface-注解"><a href="#5-2-FunctionalInterface-注解" class="headerlink" title="5.2. @FunctionalInterface 注解"></a>5.2. @FunctionalInterface 注解</h3><p>与 <code>@Override</code> 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code>。该注解可用于一个接口的定义上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> interface 接口名 &#123;</span><br><span class="line">    返回值类型 方法名();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。不过，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来效果一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01FunctionalInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">functionalInterfaceTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建待求和数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">// 使用lambda表达式方式，调用方法</span></span><br><span class="line">        sum(arr, a -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n : a) &#123;</span><br><span class="line">                total += n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义方法，方法形参为自定义的函数式接口作为方法参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>[] arr, Operator operator)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 调用函数式接口的求和抽象方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> operator.getSum(arr);</span><br><span class="line">        <span class="comment">// 2. 输入结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组的计算结果是：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义函数式接口（只有一个抽象方法，可以有多个默认方法与静态方法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] arr)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-相关Java内置函数式接口接口"><a href="#5-3-相关Java内置函数式接口接口" class="headerlink" title="5.3. 相关Java内置函数式接口接口"></a>5.3. 相关Java内置函数式接口接口</h3><ul>
<li>JDK 1.8之前已有的函数式接口:<ul>
<li>java.lang.Runnable</li>
<li>java.util.concurrent.Callable</li>
<li>java.security.PrivilegedAction</li>
<li>java.util.Comparator</li>
<li>java.io.FileFilter</li>
<li>java.nio.file.PathMatcher</li>
<li>java.lang.reflect.InvocationHandler</li>
<li>java.beans.PropertyChangeListener</li>
<li>java.awt.event.ActionListener</li>
<li>javax.swing.event.ChangeListener</li>
</ul>
</li>
<li>JDK 1.8 新增加的函数接口：<ul>
<li>java.util.function 包下</li>
</ul>
</li>
</ul>
<p><code>java.util.function</code> 它包含了很多类，用来支持 Java的函数式编程，</p>
<h3 id="5-4-常用内置函数式接口"><a href="#5-4-常用内置函数式接口" class="headerlink" title="5.4. 常用内置函数式接口"></a>5.4. 常用内置函数式接口</h3><h4 id="5-4-1-Supplier-接口"><a href="#5-4-1-Supplier-接口" class="headerlink" title="5.4.1. Supplier 接口"></a>5.4.1. Supplier 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.util.function.Supplier&lt;T&gt;</code> 接口，它意味着”供给”，对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象数据。供给型接口，通过<code>Supplier</code>接口中的<code>get()</code>方法可以得到一个值，无参有返回的接口。</p>
<p>示例：使用 <code>Supplier</code> 接口作为方法参数类型，通过Lambda表达式求出int数组中的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Supplier</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">supplierTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用Lambda表达式返回数组元素最大值</span></span><br><span class="line">        printMax(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Supplier接口实现get()方法执行开始...&quot;</span>);</span><br><span class="line">            <span class="type">int</span>[] arr = &#123;<span class="number">11</span>, <span class="number">99</span>, <span class="number">88</span>, <span class="number">77</span>, <span class="number">22</span>&#125;;</span><br><span class="line">            <span class="comment">// Arrays工具类的sort方法默认是升序排序</span></span><br><span class="line">            Arrays.sort(arr);</span><br><span class="line">            <span class="keyword">return</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(Supplier&lt;Integer&gt; supplier)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;printMax()方法执行开始...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用“供给”接口Supplier，获取数组最大值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;max = &quot;</span> + max);</span><br><span class="line">        System.out.println(<span class="string">&quot;printMax()方法执行结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printMax()方法执行开始...</span><br><span class="line">Supplier接口实现get()方法执行开始...</span><br><span class="line">max = 99</span><br><span class="line">printMax()方法执行结束...</span><br></pre></td></tr></table></figure>
<h4 id="5-4-2-Consumer-接口"><a href="#5-4-2-Consumer-接口" class="headerlink" title="5.4.2. Consumer 接口"></a>5.4.2. Consumer 接口</h4><h5 id="5-4-2-1-基础使用"><a href="#5-4-2-1-基础使用" class="headerlink" title="5.4.2.1. 基础使用"></a>5.4.2.1. 基础使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.util.function.Consumer&lt;T&gt;</code> 接口则正好与<code>Supplier</code>相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型参数决定。<code>Consumer</code>消费型接口，可以拿到<code>accept(T t)</code>方法参数传递过来的数据进行处理, 有参无返回的接口。</p>
<p>示例：将一个字符串转成全大写的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumerTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始!&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用Lambda表达式将一个字符串转成大写的字符串</span></span><br><span class="line">        printString(str -&gt; System.out.println(str.toUpperCase()));</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Consumer&lt;String&gt; consumer)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;printString()方法执行开始...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用“消费型”接口Consumer，处理传入的字符串</span></span><br><span class="line">        consumer.accept(<span class="string">&quot;Hello Consumer&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;printString()方法执行结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">程序开始!</span><br><span class="line">printString()方法执行开始...</span><br><span class="line">HELLO CONSUMER</span><br><span class="line"><span class="title function_">printString</span><span class="params">()</span>方法执行结束...</span><br><span class="line">程序结束!!</span><br></pre></td></tr></table></figure>
<h5 id="5-4-2-2-默认方法：andThen"><a href="#5-4-2-2-默认方法：andThen" class="headerlink" title="5.4.2.2. 默认方法：andThen()"></a>5.4.2.2. 默认方法：andThen()</h5><p>如果一个方法的参数和返回值全都是 <code>Consumer</code> 类型，那么就可以实现效果：消费一个数据的时候，首先做一个操作，然后再做一个操作，实现组合。而这个方法就是 <code>Consumer</code> 接口中的default方法 <code>andThen()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注： <code>java.util.Objects</code> 的 <code>requireNonNull</code> 静态方法将会在参数为null时主动抛出 <code>NullPointerException</code> 异常。这省去了重复编写if语句和抛出空指针异常的麻烦</p>
</blockquote>
<p>示例：将一个字符串先转成全小写的字符串，再转成全大写的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04ConsumerAndThen</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumerTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始!&quot;</span>);</span><br><span class="line">        <span class="comment">/* 使用Lambda表达式先将一个字符串转成小写的字符串,再转成大写 */</span></span><br><span class="line">        printString(str -&gt; System.out.println(str.toLowerCase()),</span><br><span class="line">                str -&gt; System.out.println(str.toUpperCase()));</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printString</span><span class="params">(Consumer&lt;String&gt; c1, Consumer&lt;String&gt; c2)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;printString()方法执行开始...&quot;</span>);</span><br><span class="line">        <span class="comment">// 待处理字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello Consumer&quot;</span>;</span><br><span class="line">        <span class="comment">// 实现方式一：先后调用两个“消费型”接口Consumer，处理不同的逻辑</span></span><br><span class="line">        <span class="comment">// c1.accept(str);</span></span><br><span class="line">        <span class="comment">// c2.accept(str);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现方式二：使用Consumer接口的andThen方法，实现先后执行不同的Consumer接口实现</span></span><br><span class="line">        c1.andThen(c2).accept(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;printString()方法执行结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">程序开始!</span><br><span class="line">printString()方法执行开始...</span><br><span class="line">hello consumer</span><br><span class="line">HELLO CONSUMER</span><br><span class="line"><span class="title function_">printString</span><span class="params">()</span>方法执行结束...</span><br><span class="line">程序结束!!</span><br></pre></td></tr></table></figure>
<h4 id="5-4-3-Function-接口"><a href="#5-4-3-Function-接口" class="headerlink" title="5.4.3. Function 接口"></a>5.4.3. Function 接口</h4><h5 id="5-4-3-1-基础使用"><a href="#5-4-3-1-基础使用" class="headerlink" title="5.4.3.1. 基础使用"></a>5.4.3.1. 基础使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.util.function.Function&lt;T,R&gt;</code> 接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。<code>Function</code>转换型接口，对<code>apply</code>方法传入的<code>T</code>类型数据进行处理，返回<code>R</code>类型的结果，有参有返回的接口。</p>
<blockquote>
<font color=red>**请注意，Function的前置条件泛型和后置条件泛型可以相同。**</font>

</blockquote>
<p>示例：将 String 类型转换为 Integer 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05Function</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">functionTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始!&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用Lambda表达式将字符串转成数字</span></span><br><span class="line">        stringToInteger(str -&gt; Integer.parseInt(str));</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stringToInteger</span><span class="params">(Function&lt;String, Integer&gt; function)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;stringToInteger()方法执行开始...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用“转换型”接口Function，处理传入的字符串转成数字类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> function.apply(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串转数字类型结果：&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;stringToInteger()方法执行结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">程序开始!</span><br><span class="line">stringToInteger()方法执行开始...</span><br><span class="line">字符串转数字类型结果：<span class="number">8</span></span><br><span class="line">stringToInteger()方法执行结束...</span><br><span class="line">程序结束!!</span><br></pre></td></tr></table></figure>
<h5 id="5-4-3-2-默认方法：andThen"><a href="#5-4-3-2-默认方法：andThen" class="headerlink" title="5.4.3.2. 默认方法：andThen()"></a>5.4.3.2. 默认方法：andThen()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Function</code> 接口中有一个默认的 <code>andThen</code> 方法，用来进行组合操作。</p>
<p>示例：先将字符串解析成为int数字，再操作数字乘以10</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06FunctionAndThen</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">functionTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始!&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用Lambda表达式先将字符串解析成为int数字，再操作数字乘以10</span></span><br><span class="line">        stringToInteger(str -&gt; Integer.parseInt(str), i -&gt; i * <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stringToInteger</span><span class="params">(Function&lt;String, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;stringToInteger()方法执行开始...&quot;</span>);</span><br><span class="line">        <span class="comment">// 实现方式一：选择调用“转换型”接口Function，先后处理不同的转换逻辑</span></span><br><span class="line">        <span class="comment">// Integer num = f1.apply(&quot;8&quot;);</span></span><br><span class="line">        <span class="comment">// Integer result = f2.apply(num);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现方式二：使用Function接口的andThen方法，实现先后执行不同的Function接口实现</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> f1.andThen(f2).apply(<span class="string">&quot;8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;字符串转数字类型再乘10后结果：&quot;</span> + result);</span><br><span class="line">        System.out.println(<span class="string">&quot;stringToInteger()方法执行结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入结果</span></span><br><span class="line">程序开始!</span><br><span class="line">stringToInteger()方法执行开始...</span><br><span class="line">字符串转数字类型再乘<span class="number">10</span>后结果：<span class="number">80</span></span><br><span class="line">stringToInteger()方法执行结束...</span><br><span class="line">程序结束!!</span><br></pre></td></tr></table></figure>
<h4 id="5-4-4-Predicate-接口"><a href="#5-4-4-Predicate-接口" class="headerlink" title="5.4.4. Predicate 接口"></a>5.4.4. Predicate 接口</h4><h5 id="5-4-4-1-基础使用"><a href="#5-4-4-1-基础使用" class="headerlink" title="5.4.4.1. 基础使用"></a>5.4.4.1. 基础使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="title function_">isEqual</span><span class="params">(Object targetRef)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>java.util.function.Predicate&lt;T&gt;</code> 接口是一个函数式接口，它接受一个输入参数<code>T</code>，返回一个布尔值结果</li>
<li>该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）</li>
<li>该接口用于测试对象是 true 或 false</li>
</ul>
<p>示例1：判断一个人名如果超过3个字就认为是很长的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07Predicate</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">predicateTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始!&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用Lambda判断一个人名如果超过3个字就认为是很长的名字</span></span><br><span class="line">        isLongName(<span class="string">&quot;石原里美&quot;</span>, str -&gt; str.length() &gt; <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">isLongName</span><span class="params">(String name, Predicate&lt;String&gt; predicate)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;isLongName()方法执行开始...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用“判断型”接口Predicate，进行相应的逻辑处理</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLong</span> <span class="operator">=</span> predicate.test(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;名字是否过长：&quot;</span> + isLong);</span><br><span class="line">        System.out.println(<span class="string">&quot;isLongName()方法执行结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">程序开始!</span><br><span class="line">isLongName()方法执行开始...</span><br><span class="line">名字是否过长：<span class="literal">true</span></span><br><span class="line"><span class="title function_">isLongName</span><span class="params">()</span>方法执行结束...</span><br><span class="line">程序结束!!</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.jav.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predicate&lt;Integer&gt; predicate = n -&gt; true</span></span><br><span class="line"><span class="comment">         *      n 是一个参数传递到 Predicate 接口的 test 方法</span></span><br><span class="line"><span class="comment">         *      n 如果存在则 test 方法返回 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输出所有数据:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传递参数 n</span></span><br><span class="line">        eval(list, n -&gt; <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span></span><br><span class="line"><span class="comment">         *      n 是一个参数传递到 Predicate 接口的 test 方法</span></span><br><span class="line"><span class="comment">         *      如果 n%2 为 0 test 方法返回 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n输出所有偶数:&quot;</span>);</span><br><span class="line">        eval(list, n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span></span><br><span class="line"><span class="comment">         *      n 是一个参数传递到 Predicate 接口的 test 方法</span></span><br><span class="line"><span class="comment">         *      如果 n 大于 3 test 方法返回 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n输出大于 3 的所有数字:&quot;</span>);</span><br><span class="line">        eval(list, n -&gt; n &gt; <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eval</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer n : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(n)) &#123;</span><br><span class="line">                System.out.print(n + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">输出所有数据:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">输出所有偶数:</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line">输出大于<span class="number">3</span>的所有数字:</span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<h5 id="5-4-4-2-默认方法：and、or、negate"><a href="#5-4-4-2-默认方法：and、or、negate" class="headerlink" title="5.4.4.2. 默认方法：and、or、negate"></a>5.4.4.2. 默认方法：and、or、negate</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认方法<code>and()</code>：将两个 <code>Predicate</code> 条件使用“<code>&amp;&amp;</code>”逻辑连接起来实现“并且”的效果</li>
<li>默认方法<code>or()</code>：将两个 <code>Predicate</code> 条件使用“<code>||</code>”逻辑连接起来实现“或者”的效果</li>
<li>默认方法<code>negate()</code>：将 <code>Predicate</code> 条件使用“<code>!</code>”逻辑实现“非”（“取反”）的效果</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08PredicateAndOrNegate</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">predicateTest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序开始!&quot;</span>);</span><br><span class="line">        test(<span class="string">&quot;Hello World&quot;</span>, str -&gt; str.contains(<span class="string">&quot;W&quot;</span>), str -&gt; str.contains(<span class="string">&quot;H&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str, Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test()方法执行开始...&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用Lambda表达式判断一个字符串中既包含W,也包含H</span></span><br><span class="line">        <span class="comment">// and方法，相当于 p1.test(str) &amp;&amp; p2.test(str)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> p1.and(p2).test(str);</span><br><span class="line">        <span class="keyword">if</span> (b1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;既包含W,也包含H&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式判断一个字符串中包含W或者包含H</span></span><br><span class="line">        <span class="comment">// or方法，相当于 p1.test(str) || p2.test(str)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> p1.or(p2).test(str);</span><br><span class="line">        <span class="keyword">if</span> (b2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;包含W或者包含H&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式判断一个字符串中不包含W</span></span><br><span class="line">        <span class="comment">// negate相当于取反 相当于 !p1.test(str)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> p1.negate().test(str);</span><br><span class="line">        <span class="keyword">if</span> (b3) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不包含W&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;test()方法执行结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-函数式接口应用示例"><a href="#5-5-函数式接口应用示例" class="headerlink" title="5.5. 函数式接口应用示例"></a>5.5. 函数式接口应用示例</h3><h4 id="5-5-1-实现对象通用-Builder-链式设置属性值"><a href="#5-5-1-实现对象通用-Builder-链式设置属性值" class="headerlink" title="5.5.1. 实现对象通用 Builder 链式设置属性值"></a>5.5.1. 实现对象通用 Builder 链式设置属性值</h4><ol>
<li>创建测试实体类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// ...更多其他的属性</span></span><br><span class="line">    <span class="comment">// ...省略 setter/getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>利用 <code>Supplier</code> 与 <code>Consumer</code> 函数式接口特性，实现通用对象 Builder</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonBuilder</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;T&gt; instantiator;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Consumer&lt;T&gt;&gt; modifiers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CommonBuilder</span><span class="params">(Supplier&lt;T&gt; instantiator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instantiator = instantiator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; CommonBuilder&lt;T&gt; <span class="title function_">of</span><span class="params">(Supplier&lt;T&gt; instantiator)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonBuilder</span>&lt;&gt;(instantiator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; CommonBuilder&lt;T&gt; <span class="title function_">with</span><span class="params">(ValueConsumer&lt;T, V&gt; consumer, V v)</span> &#123;</span><br><span class="line">        Consumer&lt;T&gt; c = instance -&gt; consumer.accept(instance, v);</span><br><span class="line">        modifiers.add(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取创建的对象</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> instantiator.get();</span><br><span class="line">        <span class="comment">// 循环所有消费方法，设置对象属性值</span></span><br><span class="line">        modifiers.forEach(modifier -&gt; modifier.accept(value));</span><br><span class="line">        modifiers.clear();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义消费函数式接口</span></span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValueConsumer</span>&lt;T, V&gt; &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t, V v)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 可以参考示例自定义的函数式接口，按需求支持多个参数的设置属性方法。</p>
</blockquote>
<ol>
<li>测试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    CommonBuilder&lt;User&gt; builder = CommonBuilder.of(User::<span class="keyword">new</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> builder</span><br><span class="line">            .with(User::setUserName, <span class="string">&quot;MooN&quot;</span>)</span><br><span class="line">            .with(User::setAge, <span class="number">28</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-Stream-流"><a href="#6-Stream-流" class="headerlink" title="6. Stream 流"></a>6. Stream 流</h2><ul>
<li>Java 8 API 添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</li>
<li>Stream 使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。</li>
<li>Stream API 可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li>
<li>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。</li>
<li>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</li>
</ul>
<p>Stream流式思想类似于工厂车间的“生产流水线”，Stream流不是一种数据结构，不保存数据，而是对数据进行加工处理处理</p>
<h3 id="6-1-什么是-Stream？"><a href="#6-1-什么是-Stream？" class="headerlink" title="6.1. 什么是 Stream？"></a>6.1. 什么是 Stream？</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035325.jpg" alt="Stream 流程图"></p>
<ul>
<li>Stream（流）是一个来自数据源的元素队列并支持聚合操作<ul>
<li><strong>元素</strong>：是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong>：流的来源。可以是集合，数组，I/O channel，产生器generator等。</li>
<li><strong>聚合操作</strong>：类似SQL语句一样的操作，比如filter, map, reduce, find, match, sorted等。</li>
</ul>
</li>
<li>和以前的Collection操作不同，Stream操作还有两个基础的特征：<ul>
<li>Pipelining:：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。这样做可以对操作进行优化，比如延迟执行(laziness)和短路(short-circuiting)。</li>
<li>内部迭代：以前对集合遍历都是通过Iterator或者For-Each的方式,显式的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，通过访问者模式(Visitor)实现。</li>
</ul>
</li>
</ul>
<h3 id="6-2-流的操作特性（重要）"><a href="#6-2-流的操作特性（重要）" class="headerlink" title="6.2. 流的操作特性（重要）"></a>6.2. 流的操作特性（重要）</h3><ol>
<li>stream 不是数据结构，不存储数据</li>
<li>stream 不改变原来的数据源，它会将操作后的数据保存到另外一个对象中。</li>
<li>stream 不可重复使用。每次进行操作后都会产生新的流，原来的流就会关闭，所以可以进行链式编程，就不会出现“流已关闭”的错误</li>
<li>惰性求值，流在中间处理过程中，只是对操作进行了记录，并不会立即执行（<em>即相当于预告声明，不会马上操作</em>），需要等到执行终止操作的时候才会进行实际的计算。（即Stream不调用终结方法时，中间的操作不会执行）</li>
</ol>
<h3 id="6-3-流的分类"><a href="#6-3-流的分类" class="headerlink" title="6.3. 流的分类"></a>6.3. 流的分类</h3><h4 id="6-3-1-流的操作类型"><a href="#6-3-1-流的操作类型" class="headerlink" title="6.3.1. 流的操作类型"></a>6.3.1. 流的操作类型</h4><p>stream 所有操作组合在一起即变成了管道，管道中有以下两个操作：</p>
<ul>
<li><strong>中间操作</strong>（intermediate）：调用中间操作方法会返回一个新的流。通过连续执行多个操作倒便就组成了 Stream 中的执行管道（pipeline）。需要注意的是这些管道被添加后并不会真正执行，只有等到调用终值操作之后才会执行。</li>
<li><strong>终值操作</strong>（terminal）：在调用该方法之后，将执行之前所有的中间操作，获得返回结果结束对流的使用</li>
</ul>
<p>流的执行顺序说明：其每个元素挨着作为参数去调用中间操作及终值操作，而不是遍历一个方法，再遍历下一个方法</p>
<h4 id="6-3-2-流的API方法对应分类"><a href="#6-3-2-流的API方法对应分类" class="headerlink" title="6.3.2. 流的API方法对应分类"></a>6.3.2. 流的API方法对应分类</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035326.png" alt="流方法分类"></p>
<ul>
<li>无状态：指元素的处理不受之前元素的影响；</li>
<li>有状态：指该操作只有拿到所有元素之后才能继续下去。</li>
<li>非短路操作：指必须处理所有元素才能得到最终结果；</li>
<li><p>短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 <code>A || B</code>，只要A为true，则无需判断B的结果。</p>
</li>
<li><p>Intermediate：</p>
<ul>
<li>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</li>
</ul>
</li>
<li>Terminal：<ul>
<li>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</li>
</ul>
</li>
<li>Short-circuiting：<ul>
<li>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</li>
</ul>
</li>
</ul>
<h3 id="6-4-流的常用创建方法"><a href="#6-4-流的常用创建方法" class="headerlink" title="6.4. 流的常用创建方法"></a>6.4. 流的常用创建方法</h3><h4 id="6-4-1-Collection-下的-stream-方法"><a href="#6-4-1-Collection-下的-stream-方法" class="headerlink" title="6.4.1. Collection 下的 stream() 方法"></a>6.4.1. Collection 下的 stream() 方法</h4><p>在 Java 8 中，所有的 <code>Collection</code> 集合接口都有<code>stream()</code>为集合创建串行流。<font color=red><strong>串行的流，就是在一个线程上执行</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());    <span class="comment">// 获取一个串行流</span></span><br><span class="line">    Stream&lt;String&gt; parallelStream = strings.parallelStream();    <span class="comment">// 获取一个并行流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-2-Stream-中的静态方法：of-、iterate-、generate"><a href="#6-4-2-Stream-中的静态方法：of-、iterate-、generate" class="headerlink" title="6.4.2. Stream 中的静态方法：of()、iterate()、generate()"></a>6.4.2. Stream 中的静态方法：of()、iterate()、generate()</h4><p>由于数组对象不可能添加默认方法，所以 <code>Stream</code> 接口中提供了静态方法 <code>of</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">stream2.forEach(System.out::println); <span class="comment">// 0 2 4 6 8 10</span></span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">2</span>);</span><br><span class="line">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注： <code>Stream.of()</code> 方法的参数其实是一个可变参数，所以支持数组。</p>
</blockquote>
<h4 id="6-4-3-Arrays-stream"><a href="#6-4-3-Arrays-stream" class="headerlink" title="6.4.3. Arrays.stream()"></a>6.4.3. Arrays.stream()</h4><p><code>Arrays</code> 中的 <code>stream()</code> 静态方法，将数组转成流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">10</span>];</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(nums);</span><br></pre></td></tr></table></figure>
<h4 id="6-4-4-BufferedReader-lines"><a href="#6-4-4-BufferedReader-lines" class="headerlink" title="6.4.4. BufferedReader.lines()"></a>6.4.4. BufferedReader.lines()</h4><p><code>BufferedReader.lines()</code> 方法，将每行内容转成流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;F:\\test_stream.txt&quot;</span>));</span><br><span class="line">Stream&lt;String&gt; lineStream = reader.lines();</span><br><span class="line">lineStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="6-4-5-Pattern-splitAsStream"><a href="#6-4-5-Pattern-splitAsStream" class="headerlink" title="6.4.5. Pattern.splitAsStream()"></a>6.4.5. Pattern.splitAsStream()</h4><p><code>Pattern.splitAsStream()</code> 方法，将字符串分隔成流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="string">&quot;a,b,c,d&quot;</span>);</span><br><span class="line">stringStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="6-5-流的中间操作"><a href="#6-5-流的中间操作" class="headerlink" title="6.5. 流的中间操作"></a>6.5. 流的中间操作</h3><h4 id="6-5-1-map-方法"><a href="#6-5-1-map-方法" class="headerlink" title="6.5.1. map 方法"></a>6.5.1. map 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的<code>map</code>方法流中的元素映射到另一个流中，该接口需要一个 <code>Function</code> 函数式接口参数，该函数会被应用到每个元素上，可以将当前流中的<code>T</code>类型数据转换为另一种<code>R</code>类型新元素的流。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mapTest</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;33&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取流，调用Stream流的map将一种类型的流转换成另一种类型的流</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 示例1：将Stream流中的字符串转成Integer</span></span><br><span class="line"><span class="comment">     *  map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*Stream&lt;Integer&gt; stream = original.map((String s) -&gt; &#123;</span></span><br><span class="line"><span class="comment">        return Integer.parseInt(s);</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">    <span class="comment">// 简化lambda表达式</span></span><br><span class="line">    <span class="comment">// original.map(s -&gt; Integer.parseInt(s)).forEach(System.out::println)</span></span><br><span class="line">    <span class="comment">// 使用方法引用</span></span><br><span class="line">    original.map(Integer::parseInt).forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 示例2：获取数组元素的平方数</span></span><br><span class="line">    List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    List&lt;Integer&gt; squaresList = numbers.stream()</span><br><span class="line">            .map(i -&gt; i * i)</span><br><span class="line">            .distinct()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    System.out.println(squaresList);    <span class="comment">// 输出：[9, 4, 49, 25]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-5-2-flatMap-方法"><a href="#6-5-2-flatMap-方法" class="headerlink" title="6.5.2. flatMap 方法"></a>6.5.2. flatMap 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的<code>flatMap</code>方法流中的元素映射到另一个流中，接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;1,2,3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将每个元素转成一个新的且不带逗号的元素</span></span><br><span class="line">Stream&lt;String&gt; s1 = list.stream().map(s -&gt; s.replaceAll(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">s1.forEach(System.out::println); <span class="comment">// abc  123</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; s3 = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">    <span class="comment">// 将每个元素转换成一个stream</span></span><br><span class="line">    String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;);</span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// a b c 1 2 3</span></span><br></pre></td></tr></table></figure>
<p><strong>理解flapMap的行为</strong>：flapMap是用来将多个Stream对象合并成一个新的流Stream对象，而在方法体中的操作，就是解除不需要的嵌套关系，将包含嵌套关系的Stream流转换成持有目标类型的Stream流对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of(</span><br><span class="line">	Arrays.asList(<span class="number">1</span>),</span><br><span class="line">	Arrays.asList(<span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">	Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">);</span><br><span class="line">Stream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream());</span><br></pre></td></tr></table></figure>
<p>原本的inputStream持有的元素中类型为<code>List&lt;Integer&gt;</code>，而在扁平化后的outputStream只想要持有Integer类型的元素，即去除List这层嵌套关系。因此在flapMap中，对每个<code>List&lt;Integer&gt;</code>类型的元素执行<code>childList.stream()</code>方法，转换成<code>Stream&lt;Integer&gt;</code>类型，然后由flatMap进行合并。</p>
<h4 id="6-5-3-filter-方法"><a href="#6-5-3-filter-方法" class="headerlink" title="6.5.3. filter 方法"></a>6.5.3. filter 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的 <code>filter</code> 方法用于过滤数据，返回符合过滤条件的数据，保留返回true的元素，抛弃返回false的元素。可以通过 <code>filter</code> 方法将一个流转换成另一个子集流。</p>
<p>该接口接收一个 <code>Predicate</code> 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filterTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(nameList, <span class="string">&quot;天锁斩月&quot;</span>, <span class="string">&quot;剑圣&quot;</span>, <span class="string">&quot;石原里美&quot;</span>, <span class="string">&quot;樱木花道&quot;</span>, <span class="string">&quot;敌法师&quot;</span>, <span class="string">&quot;新垣结衣&quot;</span>);</span><br><span class="line">    <span class="comment">// 示例1：获取流，调用Stream流的filter过滤名字长度为4个字的人</span></span><br><span class="line">    <span class="comment">/*nameList.stream().filter((String s) -&gt; &#123;</span></span><br><span class="line"><span class="comment">        return s.length() == 4;</span></span><br><span class="line"><span class="comment">    &#125;).forEach((String n) -&gt; &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(n);</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">    <span class="comment">// 简化lambda表达式与使用方法引用</span></span><br><span class="line">    nameList.stream().filter(s -&gt; s.length() == <span class="number">4</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 示例2：获取空字符串的数量</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (<span class="type">int</span>) strings.stream().filter(String::isEmpty).count();</span><br><span class="line">    System.out.println(<span class="string">&quot;空字符串的数量: &quot;</span> + count); <span class="comment">// 空字符串的数量: 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-5-4-limit-方法"><a href="#6-5-4-limit-方法" class="headerlink" title="6.5.4. limit 方法"></a>6.5.4. limit 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的 <code>limit</code> 方法可以对流进行截取，只取用前的<code>maxSize</code>个数据。参数是一个long型，<font color=red><strong>如果集合当前长度大于参数则进行截取。否则不进行操作</strong></font>。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">limitTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(nameList, <span class="string">&quot;天锁斩月&quot;</span>, <span class="string">&quot;剑圣&quot;</span>, <span class="string">&quot;石原里美&quot;</span>, <span class="string">&quot;樱木花道&quot;</span>, <span class="string">&quot;敌法师&quot;</span>, <span class="string">&quot;新垣结衣&quot;</span>);</span><br><span class="line">    <span class="comment">// 示例1：获取流，调用Stream流的limit获取前3个名字</span></span><br><span class="line">    nameList.stream()</span><br><span class="line">            .limit(<span class="number">3</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 示例2：获取10个随机数</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Random</span>().ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-5-5-skip-方法"><a href="#6-5-5-skip-方法" class="headerlink" title="6.5.5. skip 方法"></a>6.5.5. skip 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的 <code>skip</code> 方法可以跳过前几个元素，并获取一个截取之后的新流。<font color=red><strong>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流</strong></font>。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">skipTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(nameList, <span class="string">&quot;天锁斩月&quot;</span>, <span class="string">&quot;剑圣&quot;</span>, <span class="string">&quot;石原里美&quot;</span>, <span class="string">&quot;樱木花道&quot;</span>, <span class="string">&quot;敌法师&quot;</span>, <span class="string">&quot;新垣结衣&quot;</span>);</span><br><span class="line">    <span class="comment">// 示例1：获取流，调用Stream流的skip跳过前面2个数据</span></span><br><span class="line">    nameList.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：Stream流的<code>skip(n)</code>方法配合<code>limit(n)</code>方法，可以实现分页的效果</p>
</blockquote>
<h4 id="6-5-6-distinct-方法"><a href="#6-5-6-distinct-方法" class="headerlink" title="6.5.6. distinct 方法"></a>6.5.6. distinct 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的 <code>distinct</code> 方法用于去除重复数据。通过流中元素的 <code>hashCode()</code> 和 <code>equals()</code> 去除重复元素，如果对引用对象运行去重，引用对象要实现hashCode和equal方法，否则去重无效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">distinctTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 示例1：基本类型集合去重</span></span><br><span class="line">    List&lt;Integer&gt; integerList = Stream.of(<span class="number">22</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">33</span>).distinct().collect(Collectors.toList());</span><br><span class="line">    System.out.println(integerList);</span><br><span class="line">    List&lt;String&gt; stringList = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>).distinct().collect(Collectors.toList());</span><br><span class="line">    System.out.println(stringList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例2：对象集合去重。引用对象必须要重写hashCode和equal方法，否则去重无效。</span></span><br><span class="line">    List&lt;Person&gt; persons = Stream.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">18</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">30</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;夜神月&quot;</span>, <span class="number">16</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">18</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">30</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;L&quot;</span>, <span class="number">17</span>)</span><br><span class="line">    ).distinct().collect(Collectors.toList());</span><br><span class="line">    System.out.println(persons);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-5-7-sorted-方法"><a href="#6-5-7-sorted-方法" class="headerlink" title="6.5.7. sorted 方法"></a>6.5.7. sorted 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">()</span>;</span><br><span class="line">Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的<code>sorted</code>方法是用于排序，可以根据元素的自然顺序排序，也可以指定比较器排序。</p>
<ul>
<li><code>sorted()</code>：自然排序，流中元素需实现Comparable接口</li>
<li><code>sorted(Comparator comparator)</code>：定制排序，自定义<code>Comparator</code>排序器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortedTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 示例1：</span></span><br><span class="line"><span class="comment">     *   sorted(): 根据元素的自然顺序排序</span></span><br><span class="line"><span class="comment">     *   sorted(Comparator&lt;? super T&gt; comparator): 根据比较器指定的规则排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">55</span>);</span><br><span class="line">    <span class="comment">// 对元素自然顺序排序</span></span><br><span class="line">    <span class="comment">// stream.sorted().forEach(System.out::println);</span></span><br><span class="line">    <span class="comment">// 使用比较器排序</span></span><br><span class="line">    <span class="comment">/*stream.sorted((Integer i1, Integer i2) -&gt; &#123;</span></span><br><span class="line"><span class="comment">        return i2 - i1;</span></span><br><span class="line"><span class="comment">    &#125;).forEach(System.out::println);*/</span></span><br><span class="line">    <span class="comment">// 使用lambda表达与方法引用</span></span><br><span class="line">    stream.sorted((i1, i2) -&gt; i2 - i1).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例2：使用 sorted 方法对输出的 10 个随机数进行排序</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Random</span>().ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例3：字符串排序。String 类自身已实现Compareable接口</span></span><br><span class="line">    List&lt;String&gt; strList = Arrays.asList(<span class="string">&quot;dd&quot;</span>, <span class="string">&quot;ff&quot;</span>, <span class="string">&quot;aa&quot;</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    System.out.println(strList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例4：对象自定义排序：先按姓名升序，姓名相同则按年龄升序</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">28</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;敌法师&quot;</span>, <span class="number">180</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;新月&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    List&lt;Person&gt; persons = Arrays.asList(p1, p2, p3, p4).stream().sorted((o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1.getName().startsWith(o2.getName().substring(<span class="number">0</span>, <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    System.out.println(persons);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-5-8-peek-方法"><a href="#6-5-8-peek-方法" class="headerlink" title="6.5.8. peek 方法"></a>6.5.8. peek 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的<code>peek</code>方法如同于map，能得到流中的每一个元素。但map接收的是一个<code>Function</code>表达式，有返回值；而peek接收的是<code>Consumer</code>表达式，没有返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2);</span><br><span class="line"></span><br><span class="line">studentList.stream()</span><br><span class="line">        .peek(o -&gt; o.setAge(<span class="number">100</span>))</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;aa&#x27;</span>, age=<span class="number">100</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;bb&#x27;</span>, age=<span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-6-流的终止操作"><a href="#6-6-流的终止操作" class="headerlink" title="6.6. 流的终止操作"></a>6.6. 流的终止操作</h3><h4 id="6-6-1-forEach-方法"><a href="#6-6-1-forEach-方法" class="headerlink" title="6.6.1. forEach 方法"></a>6.6.1. forEach 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream 提供的方法 <code>forEach</code> 来迭代流中的每个数据。该方法接收一个 <code>Consumer</code> 接口函数，会将每一个流元素交给该函数进行处理。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(nameList, <span class="string">&quot;天锁斩月&quot;</span>, <span class="string">&quot;剑圣&quot;</span>, <span class="string">&quot;石原里美&quot;</span>, <span class="string">&quot;樱木花道&quot;</span>, <span class="string">&quot;敌法师&quot;</span>, <span class="string">&quot;新垣结衣&quot;</span>);</span><br><span class="line">    <span class="comment">// 示例1：遍历名称字符串集合</span></span><br><span class="line">    <span class="comment">// 获取流，调用Stream流的forEach方法遍历集合</span></span><br><span class="line">    nameList.stream().forEach((String str) -&gt; &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 简化Lambda表达式</span></span><br><span class="line">    nameList.stream().forEach(str -&gt; System.out.println(str));</span><br><span class="line">    <span class="comment">// 使用方法引用替换Lambda表达式</span></span><br><span class="line">    nameList.stream().forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 示例2：输出了10个随机数</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="comment">// Random类的ints()方法获取IntStream流对象，可以使用</span></span><br><span class="line">    random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-6-2-count-方法"><a href="#6-6-2-count-方法" class="headerlink" title="6.6.2. count 方法"></a>6.6.2. count 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流提供 <code>count</code> 方法来统计其中的元素个数。该方法返回一个<code>long</code>值代表元素个数。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(nameList, <span class="string">&quot;天锁斩月&quot;</span>, <span class="string">&quot;剑圣&quot;</span>, <span class="string">&quot;石原里美&quot;</span>, <span class="string">&quot;樱木花道&quot;</span>, <span class="string">&quot;敌法师&quot;</span>, <span class="string">&quot;新垣结衣&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取流，调用Stream流的count获取集合的个数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> nameList.stream().count();</span><br><span class="line">    System.out.println(<span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-6-3-match-相关方法"><a href="#6-6-3-match-相关方法" class="headerlink" title="6.6.3. match 相关方法"></a>6.6.3. match 相关方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">noneMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的 <code>anyMatch</code>、<code>allMatch</code>、<code>noneMatch</code> 方法用于判断数据是否匹配指定的条件</p>
<ul>
<li><code>anyMatch</code>：接收一个 <code>Predicate</code> 函数，只要流中有一个元素满足该断言则返回true，否则返回false</li>
<li><code>allMatch</code>：接收一个 <code>Predicate</code> 函数，当流中每个元素都符合该断言时才返回true，否则返回false</li>
<li><code>noneMatch</code>：接收一个 <code>Predicate</code> 函数，当流中每个元素都不符合该断言时才返回true，否则返回false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">matchTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义集合</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allMatch: 匹配所有元素，所有元素都需要满足条件</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> list.stream().allMatch(i -&gt; i &gt; <span class="number">2</span>);</span><br><span class="line">    System.out.println(allMatch);</span><br><span class="line">    <span class="comment">// anyMatch: 匹配某个元素，只要有其中一个元素满足条件即可</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> list.stream().anyMatch(i -&gt; i &gt; <span class="number">5</span>);</span><br><span class="line">    System.out.println(anyMatch);</span><br><span class="line">    <span class="comment">// noneMatch: 匹配所有元素，所有元素都不满足条件</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> list.stream().noneMatch(i -&gt; i &lt; <span class="number">0</span>);</span><br><span class="line">    System.out.println(noneMatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-6-4-find-相关方法"><a href="#6-6-4-find-相关方法" class="headerlink" title="6.6.4. find 相关方法"></a>6.6.4. find 相关方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">findFirst</span><span class="params">()</span>;</span><br><span class="line">Optional&lt;T&gt; <span class="title function_">findAny</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的 <code>findFirst</code>、<code>findAny</code> 方法用于查找数据，都是返回流中的第一元素</p>
<h4 id="6-6-5-max-和-min-方法"><a href="#6-6-5-max-和-min-方法" class="headerlink" title="6.6.5. max 和 min 方法"></a>6.6.5. max 和 min 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">min</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line">Optional&lt;T&gt; <span class="title function_">max</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流的 <code>max</code> 和 <code>min</code> 方法是用于获取最大值和最小值</p>
<ul>
<li><code>max</code>：返回流中元素最大值</li>
<li><code>min</code>：返回流中元素最小值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">maxAndMinTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义集合</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 获取最大值</span></span><br><span class="line">    Optional&lt;Integer&gt; max = list.stream().max((o1, o2) -&gt; o1 - o2);</span><br><span class="line">    System.out.println(<span class="string">&quot;最大值: &quot;</span> + max.get());</span><br><span class="line">    <span class="comment">// 获取最小值</span></span><br><span class="line">    Optional&lt;Integer&gt; min = list.stream().min(Integer::compareTo);</span><br><span class="line">    System.out.println(<span class="string">&quot;最小值: &quot;</span> + min.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-6-6-reduce-方法"><a href="#6-6-6-reduce-方法" class="headerlink" title="6.6.6. reduce 方法"></a>6.6.6. reduce 方法</h4><h5 id="6-6-6-1-功能介绍"><a href="#6-6-6-1-功能介绍" class="headerlink" title="6.6.6.1. 功能介绍"></a>6.6.6.1. 功能介绍</h5><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 <code>reduce</code></p>
<p>例如：Stream 的 sum 就相当于 <code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code> 或 <code>Integer sum = integers.reduce(0, Integer::sum);</code>；也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p>
<h5 id="6-6-6-2-源码相关API"><a href="#6-6-6-2-源码相关API" class="headerlink" title="6.6.6.2. 源码相关API"></a>6.6.6.2. 源码相关API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次执行时，accumulator函数的第一个参数为流中的第一个元素，第二个参数为流中元素的第二个元素；第二次执行时，第一个参数为第一次函数执行的结果，第二个参数为流中的第三个元素；依次类推。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>流程跟上面一样，只是第一次执行时，<code>accumulator</code>函数的第一个参数为identity，而第二个参数为流中的第一个元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在串行流(stream)中，该方法跟第二个方法一样，即第三个参数combiner不会起作用。在并行流(parallelStream)中，我们知道流被fork join出多个线程进行执行，此时每个线程的执行流程就跟第二个方法reduce(identity,accumulator)一样，而第三个参数combiner函数，则是将每个线程的执行结果当成一个新的流，然后使用第一个方法reduce(accumulator)流程进行规约</li>
</ul>
<h5 id="6-6-6-3-基础使用示例"><a href="#6-6-6-3-基础使用示例" class="headerlink" title="6.6.6.3. 基础使用示例"></a>6.6.6.3. 基础使用示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduceTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义集合</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</span></span><br><span class="line"><span class="comment">     *  第1个参数identity：方法执行时初始值，首次执行的时候，会赋值给accumulator参数函数的第一个入参</span></span><br><span class="line"><span class="comment">     *  第2个参数accumulator：流每次处理数据的逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 示例中reduce方法的执行流程：</span></span><br><span class="line"><span class="comment">     *  第一次, 将默认值赋值给x, 取出集合第一元素赋值给y</span></span><br><span class="line"><span class="comment">     *  第二次, 将上一次返回的结果赋值x, 取出集合第二元素赋值给y</span></span><br><span class="line"><span class="comment">     *  第三次, 将上一次返回的结果赋值x, 取出集合第三元素赋值给y</span></span><br><span class="line"><span class="comment">     *  第四次, 将上一次返回的结果赋值x, 取出集合第四元素赋值给y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 使用reduce方法求和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, (x, y) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;, y = &quot;</span> + y);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;result = &quot;</span> + result); <span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用reduce方法获取最大值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, (x, y) -&gt; x &gt; y ? x : y);</span><br><span class="line">    System.out.println(<span class="string">&quot;max = &quot;</span> + max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串连接，concat = &quot;ABCD&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">concatString</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, String::concat);</span><br><span class="line">    System.out.println(<span class="string">&quot;concatString = &quot;</span> + concatString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">minValue</span> <span class="operator">=</span> Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min);</span><br><span class="line">    System.out.println(<span class="string">&quot;minValue = &quot;</span> + minValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求和，sumValue = 11, 有起始值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sumValue</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">1</span>, Integer::sum);</span><br><span class="line">    System.out.println(<span class="string">&quot;sumValue = &quot;</span> + sumValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">    sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line">    System.out.println(<span class="string">&quot;sumValue = &quot;</span> + sumValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤，字符串连接，concatString = &quot;ace&quot;</span></span><br><span class="line">    concatString = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;F&quot;</span>)</span><br><span class="line">            .filter(x -&gt; x.compareTo(<span class="string">&quot;Z&quot;</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            .reduce(<span class="string">&quot;&quot;</span>, String::concat);</span><br><span class="line">    System.out.println(<span class="string">&quot;concatString = &quot;</span> + concatString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//经过测试，当元素个数小于24时，并行时线程数等于元素个数，当大于等于24时，并行时线程数为16</span></span><br><span class="line">    List&lt;Integer&gt; testList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> testList.stream().reduce((x1, x2) -&gt; x1 + x2).get();</span><br><span class="line">    System.out.println(v);   <span class="comment">// 300</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用方法引用简化lambda表达式。Integer类的static int sum(int a, int b)静态方法等价于(x1, x2) -&gt; x1 + x2</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">v1</span> <span class="operator">=</span> testList.stream().reduce(<span class="number">10</span>, Integer::sum);</span><br><span class="line">    System.out.println(v1);  <span class="comment">// 310</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">v2</span> <span class="operator">=</span> testList.stream().reduce(<span class="number">0</span>,</span><br><span class="line">            (x1, x2) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;stream accumulator: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">                <span class="keyword">return</span> x1 - x2;</span><br><span class="line">            &#125;,</span><br><span class="line">            (x1, x2) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;stream combiner: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">                <span class="keyword">return</span> x1 * x2;</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(v2); <span class="comment">// -300</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">v3</span> <span class="operator">=</span> testList.parallelStream().reduce(<span class="number">0</span>,</span><br><span class="line">            (x1, x2) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;parallelStream accumulator: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">                <span class="keyword">return</span> x1 - x2;</span><br><span class="line">            &#125;,</span><br><span class="line">            (x1, x2) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;parallelStream combiner: x1:&quot;</span> + x1 + <span class="string">&quot;  x2:&quot;</span> + x2);</span><br><span class="line">                <span class="keyword">return</span> x1 * x2;</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(v3); <span class="comment">// -775946240</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-6-6-4-配合map方法使用示例"><a href="#6-6-6-4-配合map方法使用示例" class="headerlink" title="6.6.6.4. 配合map方法使用示例"></a>6.6.6.4. 配合map方法使用示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mapAndReduceTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 准备测试的集合数据</span></span><br><span class="line">    List&lt;Person&gt; persons = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">18</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;夜神月&quot;</span>, <span class="number">16</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">30</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;L&quot;</span>, <span class="number">17</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 示例1：求出所有年龄的总和</span></span><br><span class="line"><span class="comment">     *   1.得到所有的年龄</span></span><br><span class="line"><span class="comment">     *   2.让年龄相加</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">totalAge</span> <span class="operator">=</span> persons.stream()</span><br><span class="line">            .map(p -&gt; p.getAge())</span><br><span class="line">            .reduce(<span class="number">0</span>, Integer::sum); <span class="comment">// Integer类有sum方法，相当于(x, y) -&gt; x + y</span></span><br><span class="line">    System.out.println(<span class="string">&quot;totalAge = &quot;</span> + totalAge);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 示例2：求出最大年龄</span></span><br><span class="line"><span class="comment">     *  1.得到所有的年龄</span></span><br><span class="line"><span class="comment">     *  2.获取最大的年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxAge</span> <span class="operator">=</span> persons.stream()</span><br><span class="line">            .map(Person::getAge) <span class="comment">// 使用方法引用简化lambda表达式，类名::引用成员方法 相当于 p -&gt; p.getAge()</span></span><br><span class="line">            .reduce(<span class="number">0</span>, Math::max); <span class="comment">// Math类有max方法，相当于(a, b) -&gt; (a &gt;= b) ? a : b</span></span><br><span class="line">    System.out.println(<span class="string">&quot;maxAge = &quot;</span> + maxAge);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例3：统计a出现的次数。实现思路：将要统计的元素转成数值1，其他元素转成0，然后将所有1相加即为元素出现的次数</span></span><br><span class="line">    <span class="comment">//                         1    0    0    1    0    1</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .map(s -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;a&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-6-7-mapToInt、mapToLong、mapToDouble-方法"><a href="#6-6-7-mapToInt、mapToLong、mapToDouble-方法" class="headerlink" title="6.6.7. mapToInt、mapToLong、mapToDouble 方法"></a>6.6.7. mapToInt、mapToLong、mapToDouble 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream <span class="title function_">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span>;</span><br><span class="line">LongStream <span class="title function_">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span>;</span><br><span class="line">DoubleStream <span class="title function_">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>
<p>Stream流转换后的数据都默认生成对象类型或者基本包装类型，如果结果只需要一些基本类型，此时就就会出现问题。因为包装类型占用的内存比基本类型多，在Stream流操作中还会自动装箱和拆箱，这样的操作会影响程序的执行效率。</p>
<p>如果需要将Stream中的Integer类型数据转成int类型，可以使用 <code>mapToInt</code> 方法。同理于<code>mapToLong</code>、<code>mapToDouble</code>方法</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035327.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mapToIntTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例：把大于3的打印出来</span></span><br><span class="line">    <span class="comment">// Integer占用的内存比int多,在Stream流操作中会自动装箱和拆箱</span></span><br><span class="line">    list.stream().filter(n -&gt; n &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);</span></span><br><span class="line"><span class="comment">     *  IntStream：内部操作的是int类型的数据，可以节省内存，减少自动装箱和拆箱的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// IntStream intStream = list.stream().mapToInt((Integer n) -&gt; n.intValue());</span></span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">intStream</span> <span class="operator">=</span> list.stream().mapToInt(Integer::intValue); <span class="comment">// 使用方法引用简化代码</span></span><br><span class="line">    intStream.filter(n -&gt; n &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-6-8-concat-方法"><a href="#6-6-8-concat-方法" class="headerlink" title="6.6.8. concat 方法"></a>6.6.8. concat 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span><br></pre></td></tr></table></figure>
<p>Stream流的 <code>concat</code> 方法用于将两个流合并成一个流</p>
<blockquote>
<p>特别注意：</p>
<ol>
<li>这是一个静态方法，与 <code>java.lang.String</code> 当中的 <code>concat</code> 方法是不同的</li>
<li>如果使用<code>concat</code>方法将两个流合并后，此前的两个流都已关闭，如果再次操作会出现异常</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concatTest</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;夜神月&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;斩月&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;石原里美&quot;</span>, <span class="string">&quot;新垣结衣&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并成一个流</span></span><br><span class="line">    Stream&lt;String&gt; newStream = Stream.concat(streamA, streamB);</span><br><span class="line">    <span class="comment">// 注意：合并流之后，之前的流都已关闭，如果再次操作会出现异常</span></span><br><span class="line">    <span class="comment">// streamA.forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    newStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-7-Stream-流数据的收集操作"><a href="#6-7-Stream-流数据的收集操作" class="headerlink" title="6.7. Stream 流数据的收集操作"></a>6.7. Stream 流数据的收集操作</h3><h4 id="6-7-1-collect-方法"><a href="#6-7-1-collect-方法" class="headerlink" title="6.7.1. collect 方法"></a>6.7.1. collect 方法</h4><p>Stream流提供 <code>collect</code> 方法，用于将流中元素收集成另外一个数据结构，其参数需要一个 <code>java.util.stream.Collector&lt;T,A, R&gt;</code> 接口对象来指定收集到哪种集合中。<code>java.util.stream.Collectors</code> 类提供一些方法，可以作为<code>Collector</code>接口的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line"></span><br><span class="line">&lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">              BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">              BiConsumer&lt;R, R&gt; combiner)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="6-7-2-Collector-接口"><a href="#6-7-2-Collector-接口" class="headerlink" title="6.7.2. Collector 接口"></a>6.7.2. Collector 接口</h4><p><code>Collector&lt;T, A, R&gt;</code> 是一个接口，有以下5个抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;A&gt; <span class="title function_">supplier</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个结果容器A</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BiConsumer&lt;A, T&gt; <span class="title function_">accumulator</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>消费型接口，第一个参数为容器A，第二个参数为流中元素T。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;A&gt; <span class="title function_">combiner</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数接口，该参数的作用跟上一个方法(reduce)中的combiner参数一样，将并行流中各个子进程的运行结果(accumulator函数操作后的容器A)进行合并。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;A, R&gt; <span class="title function_">finisher</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数式接口，参数为：容器A，返回类型为：collect方法最终想要的结果R。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Characteristics&gt; <span class="title function_">characteristics</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回一个不可变的Set集合，用来表明该Collector的特征。有以下三个特征：<ul>
<li>CONCURRENT：表示此收集器支持并发。（官方文档还有其他描述，暂时没去探索，故不作过多翻译）</li>
<li>UNORDERED：表示该收集操作不会保留流中元素原有的顺序。</li>
<li>IDENTITY_FINISH：表示finisher参数只是标识而已，可忽略。</li>
</ul>
</li>
</ul>
<h4 id="6-7-3-Collector-工具库：Collectors"><a href="#6-7-3-Collector-工具库：Collectors" class="headerlink" title="6.7.3. Collector 工具库：Collectors"></a>6.7.3. Collector 工具库：Collectors</h4><p><code>Collectors</code> 工具类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串。</p>
<blockquote>
<p><em>具体常用的API参考以下各个操作的说明与示例</em></p>
</blockquote>
<h4 id="6-7-4-收集-Stream-流中的结果到集合中"><a href="#6-7-4-收集-Stream-流中的结果到集合中" class="headerlink" title="6.7.4. 收集 Stream 流中的结果到集合中"></a>6.7.4. 收集 Stream 流中的结果到集合中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>Collectors</code>工具类中的转成<code>Collection</code>相关类型的方法。使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">streamToCollectionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; LIST = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(LIST, <span class="string">&quot;天锁斩月&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;夜神月&quot;</span>, <span class="string">&quot;樱木花道&quot;</span>, <span class="string">&quot;宇智波鼬&quot;</span>, <span class="string">&quot;金田一一&quot;</span>, <span class="string">&quot;乌尔奇奥拉·西法&quot;</span>, <span class="string">&quot;L&quot;</span>);</span><br><span class="line">    <span class="comment">// 将流中的数据收集到List集合</span></span><br><span class="line">    List&lt;String&gt; list = LIST.stream().collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;list: &quot;</span> + list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将流中的数据收集到Set集合</span></span><br><span class="line">    Set&lt;String&gt; set = LIST.stream().collect(Collectors.toSet());</span><br><span class="line">    System.out.println(<span class="string">&quot;set: &quot;</span> + set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将流中的数据收集到指定的ArrayList类型中</span></span><br><span class="line">    ArrayList&lt;String&gt; arrayList = LIST.stream()</span><br><span class="line">            .collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;arrayList: &quot;</span> + arrayList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将流中的数据收集到指定的ArrayList类型中</span></span><br><span class="line">    HashSet&lt;String&gt; hashSet = LIST.stream().collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;hashSet: &quot;</span> + hashSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-7-5-收集-Stream-流中的结果到数组中"><a href="#6-7-5-收集-Stream-流中的结果到数组中" class="headerlink" title="6.7.5. 收集 Stream 流中的结果到数组中"></a>6.7.5. 收集 Stream 流中的结果到数组中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray()</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Stream</code>接口提供 <code>toArray</code> 方法来将结果放到一个数组中，返回值类型是<code>Object[]</code>的数组。还能指定返回数组的类型<code>T[]</code>，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">streamToArrayTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; LIST = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(LIST, <span class="string">&quot;天锁斩月&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;夜神月&quot;</span>, <span class="string">&quot;樱木花道&quot;</span>, <span class="string">&quot;宇智波鼬&quot;</span>, <span class="string">&quot;金田一一&quot;</span>, <span class="string">&quot;乌尔奇奥拉·西法&quot;</span>, <span class="string">&quot;L&quot;</span>);</span><br><span class="line">    <span class="comment">// 将流中的数据收集到数组中，默认收到到Object类型的数组中</span></span><br><span class="line">    Object[] objects = LIST.stream().toArray();</span><br><span class="line">    <span class="keyword">for</span> (Object object : objects) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;objectArray element: &quot;</span> + object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将流中的数据收集到指定类型的数组中</span></span><br><span class="line">    String[] strArray = LIST.stream().toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : strArray) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;strArray element: &quot;</span> + str + <span class="string">&quot;, string length: &quot;</span> + str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-7-6-对流中数据进行聚合、统计计算"><a href="#6-7-6-对流中数据进行聚合、统计计算" class="headerlink" title="6.7.6. 对流中数据进行聚合、统计计算"></a>6.7.6. 对流中数据进行聚合、统计计算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line">    <span class="comment">// 获取最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span><br><span class="line">    <span class="comment">// 获取最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span><br><span class="line">    <span class="comment">// 求和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span><br><span class="line">    <span class="comment">// 获取平均值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span><br><span class="line">    <span class="comment">// 统计数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; counting()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合统计操作，可以实现以上所有操作。它们主要用于int、double、long等基本类型上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, LongSummaryStatistics&gt; summarizingLong(ToLongFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Collectors</code>工具类提供相关用于<code>Stream.collect()</code>时的聚合处理的方法，当使用Stream流处理数据后，可以像数据库的聚合函数一样对某个字段进行操作。比如获取最大值，获取最小值，求总和，平均值，统计数量。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">streamToPolymerizationTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Student&gt; STUDENTS = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(STUDENTS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">23</span>, <span class="number">95</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;樱庭奈奈美&quot;</span>, <span class="number">18</span>, <span class="number">34</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;长泽雅美&quot;</span>, <span class="number">23</span>, <span class="number">45</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">18</span>, <span class="number">88</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Collectors.maxBy()方法在收集流数据时获取最大值，获取学生分数的最大值</span></span><br><span class="line">    Optional&lt;Student&gt; max = STUDENTS.stream()</span><br><span class="line">            .collect(Collectors.maxBy((o1, o2) -&gt; o1.getSocre() - o2.getSocre()));</span><br><span class="line">    System.out.println(<span class="string">&quot;分数Socre最大值: &quot;</span> + max.orElseThrow(NullPointerException::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Collectors.minBy()方法在收集流数据时获取最小值，获取学生分数最小值</span></span><br><span class="line">    Optional&lt;Student&gt; min = STUDENTS.stream()</span><br><span class="line">            .collect(Collectors.minBy((o1, o2) -&gt; o1.getSocre() - o2.getSocre()));</span><br><span class="line">    System.out.println(<span class="string">&quot;分数Socre最小值: &quot;</span> + min.orElseThrow(NullPointerException::<span class="keyword">new</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Collectors.summingInt()方法在收集流数据时获取总和，获取学生年龄的总和</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> STUDENTS.stream()</span><br><span class="line">            <span class="comment">// .collect(Collectors.summingInt(o -&gt; o.getAge()));</span></span><br><span class="line">            .collect(Collectors.summingInt(Student::getAge)); <span class="comment">// 使用方法引用优化</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年龄总和: &quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Collectors.averagingInt()方法在收集流数据时获取平均值，获取学生分数的平均值</span></span><br><span class="line">    <span class="type">Double</span> <span class="variable">avg</span> <span class="operator">=</span> STUDENTS.stream()</span><br><span class="line">            .collect(Collectors.averagingInt(Student::getSocre));</span><br><span class="line">    System.out.println(<span class="string">&quot;分数平均值: &quot;</span> + avg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Collectors.counting()方法在收集流数据时获取数量，获取学生人数统计数量</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> STUDENTS.stream().collect(Collectors.counting());</span><br><span class="line">    System.out.println(<span class="string">&quot;统计学生数量: &quot;</span> + count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collectors.summarizingInt()聚合操作汇总的方法，可以实现以上所有操作</span></span><br><span class="line">    <span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> STUDENTS.stream()</span><br><span class="line">            .collect(Collectors.summarizingInt(Student::getSocre));</span><br><span class="line">    System.out.println(</span><br><span class="line">            String.format(<span class="string">&quot;max: %d, min: %d, sum: %d, avg: %s, count: %d&quot;</span>,</span><br><span class="line">                    statistics.getMax(),</span><br><span class="line">                    statistics.getMin(),</span><br><span class="line">                    statistics.getSum(),</span><br><span class="line">                    statistics.getAverage(),</span><br><span class="line">                    statistics.getCount()</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-7-7-对流中数据进行分组"><a href="#6-7-7-对流中数据进行分组" class="headerlink" title="6.7.7. 对流中数据进行分组"></a>6.7.7. 对流中数据进行分组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier, Collector&lt;? <span class="built_in">super</span> T, A, D&gt; downstream)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, D&gt;&gt;</span><br><span class="line">        Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier,</span><br><span class="line">                                      Supplier&lt;M&gt; mapFactory,</span><br><span class="line">                                      Collector&lt;? <span class="built_in">super</span> T, A, D&gt; downstream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-7-7-1-单个分组"><a href="#6-7-7-1-单个分组" class="headerlink" title="6.7.7.1. 单个分组"></a>6.7.7.1. 单个分组</h5><p><code>Collectors</code>工具类提供<code>groupingBy()</code>方法，用于在数据收集操作时根据某个属性将数据分组的方法，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">streamToGroupingByTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Student&gt; STUDENTS = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(STUDENTS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">23</span>, <span class="number">95</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;樱庭奈奈美&quot;</span>, <span class="number">18</span>, <span class="number">34</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;长泽雅美&quot;</span>, <span class="number">23</span>, <span class="number">45</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">18</span>, <span class="number">88</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例1：根据学生的年龄分组</span></span><br><span class="line">    Map&lt;Integer, List&lt;Student&gt;&gt; ageGroupMap = STUDENTS.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Student::getAge));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在JDK8，Map提供一个新的API，用于Map数据的遍历</span></span><br><span class="line"><span class="comment">     *   default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ageGroupMap.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;::&quot;</span> + v));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例2：根据分数分组。将分数大于60的分为一组。小于60分成另一组</span></span><br><span class="line">    Map&lt;String, List&lt;Student&gt;&gt; socreGroupMap = STUDENTS.stream().collect(Collectors.groupingBy(s -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.getSocre() &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">    socreGroupMap.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;::&quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-7-7-2-多级分组"><a href="#6-7-7-2-多级分组" class="headerlink" title="6.7.7.2. 多级分组"></a>6.7.7.2. 多级分组</h5><p><code>Collectors</code>工具类提供<code>groupingBy()</code>方法，还可以在收集数据时进行多级的分组，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">streamToMultiGroupingByTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Student&gt; STUDENTS = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(STUDENTS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">23</span>, <span class="number">95</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;樱庭奈奈美&quot;</span>, <span class="number">18</span>, <span class="number">34</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;长泽雅美&quot;</span>, <span class="number">23</span>, <span class="number">45</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">18</span>, <span class="number">88</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 示例1：根据学生的年龄分组后，再根据分数分组</span></span><br><span class="line"><span class="comment">     *  使用到Collectors工具类的groupingBy重载方法</span></span><br><span class="line"><span class="comment">     *  public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,</span></span><br><span class="line"><span class="comment">     *                                 Collector&lt;? super T, A, D&gt; downstream)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; map = STUDENTS.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Student::getAge, Collectors.groupingBy(s -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.getSocre() &gt; <span class="number">60</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历多级map</span></span><br><span class="line">    map.forEach((k, v) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 输出第一次分组的key</span></span><br><span class="line">        System.out.println(k);</span><br><span class="line">        <span class="comment">// 遍历第二层map</span></span><br><span class="line">        v.forEach((k2, v2) -&gt; System.out.println(<span class="string">&quot;\t&quot;</span> + k2 + <span class="string">&quot; == &quot;</span> + v2));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035328.png" alt=""></p>
<h4 id="6-7-8-对流中数据进行分区"><a href="#6-7-8-对流中数据进行分区" class="headerlink" title="6.7.8. 对流中数据进行分区"></a>6.7.8. 对流中数据进行分区</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate,</span><br><span class="line">                                                                            Collector&lt;? <span class="built_in">super</span> T, A, D&gt; downstream)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Collectors</code>工具类提供<code>partitioningBy()</code>方法，用于在数据收集操作时根据指定的处理逻辑，返回值是否为true，把集合分割为两个列表，一个true列表，一个false列表。示例如下：</p>
<blockquote>
<p>注：分区与分组实质差不多，区别在于分组可以根据某个属性进去分组，结果可以将数据分成多个不同的组别；但分区只能分成两个区域，并且区域的key为<code>true</code>与<code>false</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">partitioningByTest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Student&gt; STUDENTS = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(STUDENTS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;石原里美&quot;</span>, <span class="number">23</span>, <span class="number">95</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;樱庭奈奈美&quot;</span>, <span class="number">18</span>, <span class="number">34</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;长泽雅美&quot;</span>, <span class="number">23</span>, <span class="number">45</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;新垣结衣&quot;</span>, <span class="number">18</span>, <span class="number">88</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例1：根据学生的分数进行分区</span></span><br><span class="line">    <span class="comment">// partitioningBy会根据值是否为true，把集合分割为两个列表，一个true列表，一个false列表。</span></span><br><span class="line">    Map&lt;Boolean, List&lt;Student&gt;&gt; map = STUDENTS.stream()</span><br><span class="line">            .collect(Collectors.partitioningBy(s -&gt; s.getSocre() &gt; <span class="number">60</span>));</span><br><span class="line">    <span class="comment">// 遍历map</span></span><br><span class="line">    map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot; :: &quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-7-9-对流中数据进行拼接"><a href="#6-7-9-对流中数据进行拼接" class="headerlink" title="6.7.9. 对流中数据进行拼接"></a>6.7.9. 对流中数据进行拼接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Collectors</span> &#123;</span><br><span class="line">    <span class="comment">// 直接将字符串元素拼接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining()</span><br><span class="line">    <span class="comment">// 指定连接符delimiter，将每个字符串元素与连接符拼接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)</span><br><span class="line">    <span class="comment">// 指定连接符delimiter、前缀prefix、后缀suffix，将每个字符串元素与连接符拼接并加上前后缀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                             CharSequence prefix,</span><br><span class="line">                                                             CharSequence suffix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Collectors</code>工具类提供<code>joining()</code>方法，用于将所有元素拼接成一个字符串。可以指定拼接时的连接符与前、后缀。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">joiningTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 示例1：将学生的姓名进去拼接</span></span><br><span class="line">    <span class="comment">// 1. 直接将所有元素进行拼接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">names1</span> <span class="operator">=</span> STUDENTS.stream().map(Student::getName)</span><br><span class="line">            .collect(Collectors.joining());</span><br><span class="line">    System.out.println(<span class="string">&quot;字符直接拼接：&quot;</span> + names1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 指定连接符，将每个元素之间连接符拼接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">names2</span> <span class="operator">=</span> STUDENTS.stream().map(Student::getName)</span><br><span class="line">            .collect(Collectors.joining(<span class="string">&quot;_&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;字符与连接符拼接：&quot;</span> + names2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 指定连接符、前缀、后缀，将每个元素之间连接符拼接再加上前后缀</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">names3</span> <span class="operator">=</span> STUDENTS.stream().map(Student::getName)</span><br><span class="line">            .collect(Collectors.joining(<span class="string">&quot;_&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;字符与连接符、前后缀拼接：&quot;</span> + names3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-7-10-Collectors-toList-源码解析（了解）"><a href="#6-7-10-Collectors-toList-源码解析（了解）" class="headerlink" title="6.7.10. Collectors.toList() 源码解析（了解）"></a>6.7.10. Collectors.toList() 源码解析（了解）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collectors.toList() 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化一下源码中的lambda表达式，方便理解</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    Supplier&lt;List&lt;T&gt;&gt; supplier = () -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator = (list, t) -&gt; list.add(t);</span><br><span class="line">    BinaryOperator&lt;List&lt;T&gt;&gt; combiner = (list1, list2) -&gt; &#123;</span><br><span class="line">        list1.addAll(list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;;</span><br><span class="line">    Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher = (list) -&gt; list;</span><br><span class="line">    Set&lt;Collector.Characteristics&gt; characteristics = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Collector</span>&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Supplier <span class="title function_">supplier</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> supplier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> BiConsumer <span class="title function_">accumulator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> accumulator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> BinaryOperator <span class="title function_">combiner</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> combiner;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Function <span class="title function_">finisher</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> finisher;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title function_">characteristics</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> characteristics;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-8-并行的-Stream-流"><a href="#6-8-并行的-Stream-流" class="headerlink" title="6.8. 并行的 Stream 流"></a>6.8. 并行的 Stream 流</h3><h4 id="6-8-1-创建方式"><a href="#6-8-1-创建方式" class="headerlink" title="6.8.1. 创建方式"></a>6.8.1. 创建方式</h4><ol>
<li>直接获取并行的流。在 Java 8 中，所有的 <code>Collection</code> 集合，都可以使用接口的<code>parallelStream()</code>方法为集合创建并行流</li>
<li>将串行流转成并行流。创建串行的Stream流后，调用<code>Stream</code>接口的<code>parallel()</code>方法，将流转成并行流</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parallelStreamCreateTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义集合</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：直接使用Collection接口的 parallelStream() 方法创建并行流</span></span><br><span class="line">    Stream&lt;Integer&gt; parallelStream1 = list.parallelStream();</span><br><span class="line">    <span class="comment">// 调用Stream接口的isParallel()来判断当前是否为并行流</span></span><br><span class="line">    System.out.println(<span class="string">&quot;parallelStream1是否为并行流: &quot;</span> + parallelStream1.isParallel());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：将串行流转成并行流，调用Stream接口的 parallel() 方法，转成并行流</span></span><br><span class="line">    Stream&lt;Integer&gt; parallelStream2 = list.stream().parallel();</span><br><span class="line">    System.out.println(<span class="string">&quot;parallelStream2是否为并行流: &quot;</span> + parallelStream2.isParallel());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-8-2-并行-Stream-流定义"><a href="#6-8-2-并行-Stream-流定义" class="headerlink" title="6.8.2. 并行 Stream 流定义"></a>6.8.2. 并行 Stream 流定义</h4><p>以上学习使用的 Stream 流是串行的，就是在一个线程上执行。</p>
<p>而<code>parallelStream</code>其实就是一个并行执行的流。它通过默认的<code>ForkJoinPool</code>，可能提高多线程任务的速度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialAndParallelStreamTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建串行流，输出执行时线程的名称</span></span><br><span class="line">    LIST.stream().filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;::&quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;).count();</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建串行流，输出执行时线程的名称</span></span><br><span class="line">    LIST.parallelStream().filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;::&quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;).count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035329.png" alt=""></p>
<h4 id="6-8-3-串行与并行流的效率对比"><a href="#6-8-3-串行与并行流的效率对比" class="headerlink" title="6.8.3. 串行与并行流的效率对比"></a>6.8.3. 串行与并行流的效率对比</h4><p>需求：使用for循环，串行Stream流，并行Stream流来对5亿个数字求和。看消耗的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义循环的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">500000000</span>;</span><br><span class="line"><span class="comment">// 定义开始时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;消耗时间: &quot;</span> + (endTime - startTime));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* for循环对5亿个数字求和的执行效率测试  消耗时间：166 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachEfficiencyTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 串行Stream流对5亿个数字求和的执行效率测试  消耗时间：390 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialStreamTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// LongStream类的rangeClosed静态方法用于创建一个指定执行次数的流</span></span><br><span class="line">    LongStream.rangeClosed(<span class="number">0</span>, times).reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 并行Stream流对5亿个数字求和的执行效率测试  消耗时间：186 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parallelStreamTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// LongStream类的rangeClosed静态方法用于创建一个指定执行次数的流</span></span><br><span class="line">    LongStream.rangeClosed(<span class="number">0</span>, times)</span><br><span class="line">            .parallel() <span class="comment">// 转成并行流</span></span><br><span class="line">            .reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例正常来说，应该是<code>parallelStream</code>的执行效率是最高的（<em>不知道为什么，本机测试居然比for循环还要慢</em>）</p>
<p>Stream并行处理的过程会分而治之，也就是将一个大任务切分成多个小任务，这表示每个任务都是一个操作。</p>
<h4 id="6-8-4-parallelStream-线程安全问题"><a href="#6-8-4-parallelStream-线程安全问题" class="headerlink" title="6.8.4. parallelStream 线程安全问题"></a>6.8.4. parallelStream 线程安全问题</h4><p>并行流<code>parallelStream</code>是多线程操作，所以就会出现线程安全的问题。线程安全问题示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadSafetyTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义待测试的集合</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 创建并行流，往集合插入数据，会出现线程安全问题</span></span><br><span class="line"><span class="comment">     *  实现插入数据数量比指定的数次少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">            .parallel()</span><br><span class="line">            <span class="comment">// .forEach(i -&gt; list.add(i));</span></span><br><span class="line">            .forEach(list::add); <span class="comment">// 使用方法引用简化lambda表达式</span></span><br><span class="line">    System.out.println(<span class="string">&quot;list = &quot;</span> + list.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解决parallelStream线程安全问题方案一: 使用同步代码块 */</span></span><br><span class="line">    list.clear(); <span class="comment">// 演示线程安全，重复使用集合，需要先清空</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 定义锁对象</span></span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">            .parallel()</span><br><span class="line">            .forEach(i -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;list = &quot;</span> + list.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解决parallelStream线程安全问题方案二: 使用线程安全的集合 */</span></span><br><span class="line">    <span class="comment">// 线程安全的集合1：Vector</span></span><br><span class="line">    Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">            .parallel()</span><br><span class="line">            .forEach(vector::add);</span><br><span class="line">    System.out.println(<span class="string">&quot;vector = &quot;</span> + vector.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的集合2：Collections工具类提供的synchronizedList方法，将非线程安全的list转成线程安全</span></span><br><span class="line">    list.clear(); <span class="comment">// 演示线程安全，重复使用集合，需要先清空</span></span><br><span class="line">    List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">            .parallel()</span><br><span class="line">            .forEach(synchronizedList::add);</span><br><span class="line">    System.out.println(<span class="string">&quot;synchronizedList = &quot;</span> + synchronizedList.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解决parallelStream线程安全问题方案三: 调用Stream流的collect/toArray */</span></span><br><span class="line">    List&lt;Integer&gt; collectList = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line">            .parallel()</span><br><span class="line">            .boxed() <span class="comment">// 转成stream流</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;collectList = &quot;</span> + collectList.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">list = <span class="number">985</span></span><br><span class="line">list = <span class="number">1000</span></span><br><span class="line">vector = <span class="number">1000</span></span><br><span class="line">synchronizedList = <span class="number">1000</span></span><br><span class="line">collectList = <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>总结parallelStream线程安全的解决方案有：</p>
<ol>
<li>在操作出现线程安全部分的代码时，使用同步代码块</li>
<li>使用线程安全的集合，如：<code>Vector</code>、<code>Collections</code>工具类提供的<code>synchronizedList</code>方法将集合转换成线程安全的</li>
<li>调用Stream流的<code>collect</code>、<code>toArray</code>去操作集合</li>
</ol>
<h4 id="6-8-5-parallelStream-底层实现原理"><a href="#6-8-5-parallelStream-底层实现原理" class="headerlink" title="6.8.5. parallelStream 底层实现原理"></a>6.8.5. parallelStream 底层实现原理</h4><blockquote>
<p>注：parallelStream底层实现是使用Fork/Join框架，此框架的详细学习笔记详见《并发编程》中的相关笔记</p>
</blockquote>
<h5 id="6-8-5-1-Fork-Join-框架介绍"><a href="#6-8-5-1-Fork-Join-框架介绍" class="headerlink" title="6.8.5.1. Fork/Join 框架介绍"></a>6.8.5.1. Fork/Join 框架介绍</h5><p>parallelStream使用的是Fork/Join框架。Fork/Join框架自JDK 7引入。Fork/Join框架可以将一个大任务拆分为很多小任务来异步执行。 Fork/Join框架主要包含三个模块：</p>
<ol>
<li>线程池：<code>ForkJoinPool</code></li>
<li>任务对象：<code>ForkJoinTask</code></li>
<li>执行任务的线程：<code>ForkJoinWorkerThread</code></li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035330.png" alt=""></p>
<h5 id="6-8-5-2-Fork-Join-原理-分治法"><a href="#6-8-5-2-Fork-Join-原理-分治法" class="headerlink" title="6.8.5.2. Fork/Join 原理-分治法"></a>6.8.5.2. Fork/Join 原理-分治法</h5><p>ForkJoinPool主要用来使用分治法(Divide-and-Conquer Algorithm)来解决问题。ForkJoinPool需要使用相对少的线程来处理大量的任务。比如要对1000万个数据进行排序，那么会将这个任务分割成两个500万的排序任务和一个针对这两组500万数据的合并任务。以此类推，对于500万的数据也会做出同样的分割处理，到最后会设置一个阈值来规定当数据规模到多少时，停止这样的分割处理。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035331.png" alt=""></p>
<h5 id="6-8-5-3-Fork-Join-原理-工作窃取算法"><a href="#6-8-5-3-Fork-Join-原理-工作窃取算法" class="headerlink" title="6.8.5.3. Fork/Join 原理-工作窃取算法"></a>6.8.5.3. Fork/Join 原理-工作窃取算法</h5><p>Fork/Join最核心的地方就是如何利用多核的处理器。工作窃取（work-stealing）算法就是整个Fork/Join框架的核心理念。Fork/Join工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035332.png" alt=""></p>
<p>假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p>工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争。</p>
<p>Java 8 引入了自动并行化的概念。它能够让一部分Java代码自动地以并行的方式执行，也就是使用了 <code>ForkJoinPool的ParallelStream</code>。</p>
<p>对于 <code>ForkJoinPool</code> 通用线程池的线程数量，通常使用默认值就可以了，即运行时计算机的处理器数量。可以通过设置系统属性：<code>java.util.concurrent.ForkJoinPool.common.parallelism=N</code> （N为线程数量），来调整 <code>ForkJoinPool</code> 的线程数量，可以尝试调整成不同的参数来观察每次的输出结果。</p>
<h5 id="6-8-5-4-Fork-Join-案例"><a href="#6-8-5-4-Fork-Join-案例" class="headerlink" title="6.8.5.4. Fork/Join 案例"></a>6.8.5.4. Fork/Join 案例</h5><p>需求：使用Fork/Join计算1-10000的和，当一个任务的计算数量大于3000时拆分任务，数量小于3000时计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07ForkJoin</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forkJoinTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">SumRecursiveTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumRecursiveTask</span>(<span class="number">1</span>, <span class="number">99999999999L</span>);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;消耗时间: &quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 创建一个求和的任务 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumRecursiveTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="comment">// 定义是否要拆分的临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">3000L</span>;</span><br><span class="line">    <span class="comment">// 起始值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> start;</span><br><span class="line">    <span class="comment">// 结束值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义构造器，指定起始与结束值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SumRecursiveTask</span><span class="params">(<span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理计算逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">length</span> <span class="operator">=</span> end - start;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 大于临界值，进行拆分</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumRecursiveTask</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumRecursiveTask</span>(start, middle);</span><br><span class="line">            left.fork();</span><br><span class="line">            <span class="type">SumRecursiveTask</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumRecursiveTask</span>(middle + <span class="number">1</span>, end);</span><br><span class="line">            right.fork();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 小于临界值，执行计算</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-8-6-总结"><a href="#6-8-6-总结" class="headerlink" title="6.8.6. 总结"></a>6.8.6. 总结</h4><ol>
<li>parallelStream 是线程不安全的</li>
<li>parallelStream 适用的场景 是CPU 密集型的，只是做到别浪费 CPU，假如本身电脑 CPU 的负载很大，那还到处用并行流，那并不能起到作用</li>
<li>磁盘 I/O、网络 I/O 都属于密集型 I/O 操作，这部分操作是较少消耗 CPU 资源，一般并行流中不适用于 I/O 密集型的操作，就比如使用并流行进行大批量的消息推送，涉及到了大量 I/O，使用并行流反而慢了很多</li>
<li>在使用并行流的时候是无法保证元素的顺序的，也就是即使你用了同步集合也只能保证元素都正确但无法保证其中的顺序</li>
</ol>
<h3 id="6-9-Stream-完整实例"><a href="#6-9-Stream-完整实例" class="headerlink" title="6.9. Stream 完整实例"></a>6.9. Stream 完整实例</h3><h4 id="6-9-1-综合示例1"><a href="#6-9-1-综合示例1" class="headerlink" title="6.9.1. 综合示例1"></a>6.9.1. 综合示例1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.IntSummaryStatistics;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用 Java 7: &quot;</span>);</span><br><span class="line">        <span class="comment">// 计算空字符串</span></span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;列表: &quot;</span> + strings);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> getCountEmptyStringUsingJava7(strings);</span><br><span class="line">        System.out.println(<span class="string">&quot;空字符数量为: &quot;</span> + count);</span><br><span class="line">        count = getCountLength3UsingJava7(strings);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为 3 的数量为: &quot;</span> + count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除空字符串</span></span><br><span class="line">        List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">        System.out.println(<span class="string">&quot;筛选后的列表: &quot;</span> + filtered);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除空字符串，并使用逗号把它们合并起来</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> getMergedStringUsingJava7(strings, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 获取列表元素平方数</span></span><br><span class="line">        List&lt;Integer&gt; squaresList = getSquares(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;平方数列表: &quot;</span> + squaresList);</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">17</span>, <span class="number">8</span>, <span class="number">19</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;列表: &quot;</span> + integers);</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + getMax(integers));</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + getMin(integers));</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + getSum(integers));</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数 : &quot;</span> + getAverage(integers));</span><br><span class="line">        System.out.println(<span class="string">&quot;随机数: &quot;</span>);</span><br><span class="line">        <span class="comment">// 输出10个随机数</span></span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(random.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用 Java 8: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;列表: &quot;</span> + strings);</span><br><span class="line">        count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">        System.out.println(<span class="string">&quot;空字符串数量为: &quot;</span> + count);</span><br><span class="line">        count = strings.stream().filter(string -&gt; string.length() == <span class="number">3</span>).count();</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为 3 的数量为: &quot;</span> + count);</span><br><span class="line">        filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;筛选后的列表: &quot;</span> + filtered);</span><br><span class="line">        mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br><span class="line">        squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Squares List: &quot;</span> + squaresList);</span><br><span class="line">        System.out.println(<span class="string">&quot;列表: &quot;</span> + integers);</span><br><span class="line">        <span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">        System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">        System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br><span class="line">        System.out.println(<span class="string">&quot;随机数: &quot;</span>);</span><br><span class="line">        random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 并行处理</span></span><br><span class="line">        count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">        System.out.println(<span class="string">&quot;空字符串的数量为: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCountEmptyStringUsingJava7</span><span class="params">(List&lt;String&gt; strings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">            <span class="keyword">if</span> (string.isEmpty()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCountLength3UsingJava7</span><span class="params">(List&lt;String&gt; strings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">            <span class="keyword">if</span> (string.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">deleteEmptyStringsUsingJava7</span><span class="params">(List&lt;String&gt; strings)</span> &#123;</span><br><span class="line">        List&lt;String&gt; filteredList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!string.isEmpty()) &#123;</span><br><span class="line">                filteredList.add(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filteredList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getMergedStringUsingJava7</span><span class="params">(List&lt;String&gt; strings, String separator)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!string.isEmpty()) &#123;</span><br><span class="line">                stringBuilder.append(string);</span><br><span class="line">                stringBuilder.append(separator);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">        <span class="keyword">return</span> mergedString.substring(<span class="number">0</span>, mergedString.length() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getSquares</span><span class="params">(List&lt;Integer&gt; numbers)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; squaresList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer number : numbers) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(number.intValue() * number.intValue());</span><br><span class="line">            <span class="keyword">if</span> (!squaresList.contains(square)) &#123;</span><br><span class="line">                squaresList.add(square);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> squaresList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(List&lt;Integer&gt; numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> numbers.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> numbers.get(i);</span><br><span class="line">            <span class="keyword">if</span> (number.intValue() &gt; max) &#123;</span><br><span class="line">                max = number.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(List&lt;Integer&gt; numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> numbers.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> numbers.get(i);</span><br><span class="line">            <span class="keyword">if</span> (number.intValue() &lt; min) &#123;</span><br><span class="line">                min = number.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(List numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">int</span>) (numbers.get(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            sum += (<span class="type">int</span>) numbers.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getAverage</span><span class="params">(List&lt;Integer&gt; numbers)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(numbers) / numbers.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">使用 Java 7:</span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">平方数列表: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9</span><br><span class="line">随机数: </span><br><span class="line">1940609383</span><br><span class="line">1273448576</span><br><span class="line">-1208033961</span><br><span class="line">-880625237</span><br><span class="line">-655596583</span><br><span class="line">-65568491</span><br><span class="line">-510907885</span><br><span class="line">384715598</span><br><span class="line">1145477696</span><br><span class="line">447794939</span><br><span class="line"></span><br><span class="line">使用 Java 8:</span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符串数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">Squares List: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9.444444444444445</span><br><span class="line">随机数:</span><br><span class="line">-1861468930</span><br><span class="line">-1661597688</span><br><span class="line">-154610776</span><br><span class="line">133616016</span><br><span class="line">776120450</span><br><span class="line">896964313</span><br><span class="line">916562908</span><br><span class="line">1237476550</span><br><span class="line">2074868773</span><br><span class="line">2091065305</span><br><span class="line">空字符串的数量为: 2</span><br></pre></td></tr></table></figure>
<h4 id="6-9-2-综合示例2"><a href="#6-9-2-综合示例2" class="headerlink" title="6.9.2. 综合示例2"></a>6.9.2. 综合示例2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">comprehensiveStreamTest02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 第一个队伍</span></span><br><span class="line">    List&lt;String&gt; teamA = Arrays.asList(<span class="string">&quot;天锁斩月&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;夜神月&quot;</span>, <span class="string">&quot;樱木花道&quot;</span>, <span class="string">&quot;宇智波鼬&quot;</span>, <span class="string">&quot;金田一一&quot;</span>, <span class="string">&quot;乌尔奇奥拉·西法&quot;</span>);</span><br><span class="line">    <span class="comment">// 第二个队伍</span></span><br><span class="line">    List&lt;String&gt; teamB = Arrays.asList(<span class="string">&quot;樱庭奈奈美&quot;</span>, <span class="string">&quot;长泽雅美&quot;</span>, <span class="string">&quot;新垣结衣&quot;</span>, <span class="string">&quot;石原里美&quot;</span>, <span class="string">&quot;郭靖&quot;</span>, <span class="string">&quot;杨过&quot;</span>, <span class="string">&quot;张无忌&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.第一个队伍只要名字为4个字的成员姓名;</span></span><br><span class="line">    <span class="comment">// 2.第一个队伍筛选之后只要前3个人;</span></span><br><span class="line">    Stream&lt;String&gt; streamA = teamA.stream().filter(s -&gt; s.length() == <span class="number">4</span>).limit(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.第二个队伍只要包含“美”字的成员姓名;</span></span><br><span class="line">    <span class="comment">// 4.第二个队伍筛选之后不要前2个人;</span></span><br><span class="line">    Stream&lt;String&gt; streamB = teamB.stream().filter(s -&gt; s.contains(<span class="string">&quot;美&quot;</span>)).skip(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.将两个队伍合并为一个队伍;</span></span><br><span class="line">    Stream&lt;String&gt; concatStream = Stream.concat(streamA, streamB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.根据姓名创建Person象;</span></span><br><span class="line">    Stream&lt;Person&gt; personStream = concatStream.map(Person::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.打印整个队伍的Person对象信息。</span></span><br><span class="line">    personStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-10-Stream-流最佳使用技巧"><a href="#6-10-Stream-流最佳使用技巧" class="headerlink" title="6.10. Stream 流最佳使用技巧"></a>6.10. Stream 流最佳使用技巧</h3><ul>
<li><strong>使用专属类型流以获得更好的性能</strong>。例如在使用 int、long 和 double 等基本类型数据时，使用 IntStream、LongStream 和 DoubleStream 等基本流，而不是 Integer、Long 和 Double 等装箱类型流。原始流可以通过避免装箱和拆箱的成本来提供更好的性能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// not good</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(array).sum();</span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="type">IntStream</span> <span class="variable">intStream</span> <span class="operator">=</span> IntStream.of(array);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> intStream.sum();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>避免嵌套流</strong>。因为它可能导致代码难以阅读和理解。相反可以尝试将问题分解为更小的部分，并使用中间集合或局部变量来存储中间结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list1 = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = Arrays.asList(<span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pineapple&quot;</span>, <span class="string">&quot;mango&quot;</span>);</span><br><span class="line">List&lt;String&gt; collect = Stream.concat(list1.stream(), list2.stream())</span><br><span class="line">		.filter(s -&gt; s.length() &gt; <span class="number">5</span>)</span><br><span class="line">		.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<ul>
<li>虽然并行流可以在处理大量数据时提供更好的性能，但它们也会引入开销和竞争条件。<strong>谨慎使用并行流</strong>，并考虑数据大小、操作复杂性和可用处理器数量等因素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> list.parallelStream().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<ul>
<li>Stream API 支持延迟计算，这意味着在调用终端操作之前不会执行中间操作。因此可以尝试<strong>使用惰性计算来通过减少不必要的计算来提高性能</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; result = list.stream().filter(n -&gt; n &gt; <span class="number">3</span>).findFirst();</span><br></pre></td></tr></table></figure>
<ul>
<li>Stream API 旨在对数据执行功能操作，需要<strong>避免引入副作用</strong>。例如修改流外部的变量或执行 I/O 操作，因为这可能会导致不可预测的行为并降低代码可读性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>)).forEach(s -&gt; count++);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>将流与不可变对象一起使用</strong>。Stream API 最适合使用不可变对象，可确保流的状态在处理过程中不会被修改，这可以带来更可预测的行为和更好的代码可读性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>);</span><br><span class="line">List&lt;String&gt; result  = list.stream()</span><br><span class="line">		.map(String::toUpperCase)</span><br><span class="line">		.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<ul>
<li>如果流可能包含大量不符合条件的元素，<strong>在 <code>map()</code> 之前使用 <code>filter()</code> 以避免不必要的处理</strong>，可以提高代码的性能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; filteredList = list.stream()</span><br><span class="line">		.filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		.map(i -&gt; i * <span class="number">2</span>)</span><br><span class="line">		.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<ul>
<li>与使用 lambda 表达式相比，方法引用可以使代码更加简洁和可读。在合适的情况下，<strong>优先使用方法引用代替 lambda 表达式</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果流可能包含重复元素，优先使用 <code>distinct()</code> 操作来删除它们</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; distinctList = list.stream().distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<ul>
<li>流的 <code>sorted()</code> 操作成本可能会很昂贵，尤其是对于大型流。仅在必要时<strong>谨慎使用 <code>sorted()</code></strong>。如果已确定输入的数据已经排序，则可以跳过此操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">List&lt;Integer&gt; SortedList = list.stream().sorted().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h2 id="7-StringJoiner-类（字符拼接）"><a href="#7-StringJoiner-类（字符拼接）" class="headerlink" title="7. StringJoiner 类（字符拼接）"></a>7. StringJoiner 类（字符拼接）</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1. 简介"></a>7.1. 简介</h3><p><code>StringJoiner</code> 是 <code>java.util</code> 包中的一个类，用于构造一个由分隔符分隔的字符序列（可选），并且可以从提供的前缀开始并以提供的后缀结尾</p>
<p><strong><code>StringJoiner</code> 类共有2个构造函数，5个公有方法。其中最常用的方法就是 <code>add</code> 方法和 <code>toString</code> 方法，类似于 <code>StringBuilder</code> 中的 <code>append</code> 方法和 <code>toString</code> 方法</strong></p>
<h3 id="7-2-构造方法"><a href="#7-2-构造方法" class="headerlink" title="7.2. 构造方法"></a>7.2. 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringJoiner</span><span class="params">(CharSequence delimiter)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造一个由分隔符分隔的字符序列，注意：<strong>delimiter其实是分隔符，并不是可变字符串的初始值</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringJoiner</span><span class="params">(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造一个由分隔符分隔的字符序列，prefix参数设置字符拼接的前缀，参数suffix设置后缀</li>
</ul>
<h3 id="7-3-基础用法"><a href="#7-3-基础用法" class="headerlink" title="7.3. 基础用法"></a>7.3. 基础用法</h3><h4 id="7-3-1-StringJoiner-对象"><a href="#7-3-1-StringJoiner-对象" class="headerlink" title="7.3.1. StringJoiner 对象"></a>7.3.1. StringJoiner 对象</h4><p>手动创建 <code>StringJoiner</code> 对象，实现字符串拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringJoinerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;Moon&quot;</span>);</span><br><span class="line">        sj.add(<span class="string">&quot;Zero&quot;</span>);</span><br><span class="line">        sj.add(<span class="string">&quot;kirA&quot;</span>);</span><br><span class="line">        <span class="comment">/* 输出结果 */</span></span><br><span class="line">        System.out.println(sj.toString()); <span class="comment">// ZeroMoonkirA</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringJoiner</span> <span class="variable">sj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        sj1.add(<span class="string">&quot;Moon&quot;</span>).add(<span class="string">&quot;Zero&quot;</span>).add(<span class="string">&quot;kirA&quot;</span>);</span><br><span class="line">        <span class="comment">/* 输出结果 */</span></span><br><span class="line">        System.out.println(sj1.toString()); <span class="comment">// [Moon,Zero,kirA]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-2-Stream-流的-joining-方法"><a href="#7-3-2-Stream-流的-joining-方法" class="headerlink" title="7.3.2. Stream 流的 joining 方法"></a>7.3.2. Stream 流的 joining 方法</h4><p>在 Java8 的流操作中的 <code>Collector.joining</code>，底层也使用了 <code>StringJoiner</code> 进行字符串拼接了，基础用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().collect(Collectors.joining(<span class="string">&quot;:&quot;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="7-3-3-String-类的-join-静态方法"><a href="#7-3-3-String-类的-join-静态方法" class="headerlink" title="7.3.3. String 类的 join 静态方法"></a>7.3.3. String 类的 join 静态方法</h4><p>JDK 1.8 后，String 类新增两个 <code>join</code> 静态方法，底层也使用了 <code>StringJoiner</code> 进行字符串拼接了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">join</span><span class="params">(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)</span></span><br></pre></td></tr></table></figure>
<p>基础用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">System.out.println(String.join(<span class="string">&quot;,&quot;</span>, list)); <span class="comment">// a,b,c,d</span></span><br></pre></td></tr></table></figure>
<h3 id="7-4-实现原理"><a href="#7-4-实现原理" class="headerlink" title="7.4. 实现原理"></a>7.4. 实现原理</h3><h4 id="7-4-1-StringJoiner"><a href="#7-4-1-StringJoiner" class="headerlink" title="7.4.1. StringJoiner"></a>7.4.1. StringJoiner</h4><p>通过查询源码，<code>StringJoiner</code> 其实是通过 <code>StringBuilder</code> 实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StringJoiner <span class="title function_">add</span><span class="params">(CharSequence newElement)</span> &#123;</span><br><span class="line">    prepareBuilder().append(newElement);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> StringBuilder <span class="title function_">prepareBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        value.append(delimiter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-4-2-Collector-joining"><a href="#7-4-2-Collector-joining" class="headerlink" title="7.4.2. Collector.joining"></a>7.4.2. Collector.joining</h4><p>还有 Java8 的流操作中的 <code>Collector.joining</code> 的实现原理也是使用了 <code>StringJoiner</code>，<code>Collector.joining</code> 的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-4-3-String-join"><a href="#7-4-3-String-join" class="headerlink" title="7.4.3. String.join"></a>7.4.3. String.join</h4><p><code>String.join</code> 静态方法，底层也是手动创建 <code>StringJoiner</code>，通过 <code>add</code> 添加拼接的元素，最终调用 <code>toString</code> 方法完成字符串拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(delimiter);</span><br><span class="line">    Objects.requireNonNull(elements);</span><br><span class="line">    <span class="comment">// Number of elements not likely worth Arrays.stream overhead.</span></span><br><span class="line">    <span class="type">StringJoiner</span> <span class="variable">joiner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(delimiter);</span><br><span class="line">    <span class="keyword">for</span> (CharSequence cs: elements) &#123;</span><br><span class="line">        joiner.add(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> joiner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-5-使用场景总结"><a href="#7-5-使用场景总结" class="headerlink" title="7.5. 使用场景总结"></a>7.5. 使用场景总结</h3><p><code>StringJoiner</code> 其实是通过 <code>StringBuilder</code> 实现的，所以两者性能差不多，都是非线程安全的</p>
<ol>
<li>如果只是简单的字符串拼接，考虑直接使用<code>&quot;+&quot;</code>即可。</li>
<li>如果是在 for 循环中进行字符串拼接，考虑使用 <code>StringBuilder</code> 和 <code>StringBuffer</code>。</li>
<li>如果是通过一个集合（如List）进行字符串拼接，则考虑使用 <code>StringJoiner</code>。</li>
<li>如果是对一组数据进行拼接，则可以考虑将其转换成 Stream，并使用<code>StringJoiner</code> 处理。</li>
</ol>
<h2 id="8-Optional-类"><a href="#8-Optional-类" class="headerlink" title="8. Optional 类"></a>8. Optional 类</h2><ul>
<li>Optional 类是一个可以为null的容器对象。如果值存在则<code>isPresent()</code>方法会返回true，调用<code>get()</code>方法会返回该对象。</li>
<li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</li>
<li>Optional 类的引入很好的解决空指针异常。</li>
</ul>
<blockquote>
<p>拓展：google的Guava Optional与Optional有同样的功能。不过需要注意的是，Guava Optional API 与 JDK 存在差异</p>
</blockquote>
<h3 id="8-1-类声明"><a href="#8-1-类声明" class="headerlink" title="8.1. 类声明"></a>8.1. 类声明</h3><p><code>java.util.Optional&lt;T&gt;</code>类的声明：<code>public final class Optional&lt;T&gt; extends Object</code></p>
<h3 id="8-2-Optional-类型说明"><a href="#8-2-Optional-类型说明" class="headerlink" title="8.2. Optional 类型说明"></a>8.2. Optional 类型说明</h3><ul>
<li>这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException</li>
<li>Optional里面只持有一个元素，而Stream可持有多个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strA</span> <span class="operator">=</span> <span class="string">&quot; abcd &quot;</span>, strB = <span class="literal">null</span>;</span><br><span class="line">print(strA);</span><br><span class="line">print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">print(strB);</span><br><span class="line">getLength(strA);</span><br><span class="line">getLength(<span class="string">&quot;&quot;</span>);</span><br><span class="line">getLength(strB);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String text)</span> &#123;</span><br><span class="line">	<span class="comment">// Java 8</span></span><br><span class="line">	Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pre-Java 8</span></span><br><span class="line">	<span class="keyword">if</span> (text != <span class="literal">null</span>) &#123;</span><br><span class="line">	System.out.println(text);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(String text)</span> &#123;</span><br><span class="line">	<span class="comment">// Java 8</span></span><br><span class="line">	<span class="keyword">return</span> Optional.ofNullable(text).map(String::length).orElse(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pre-Java 8</span></span><br><span class="line">	<span class="comment">// return if (text != null) ? text.length() : -1;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有ifPresentOrElse()方法等</span></span><br></pre></td></tr></table></figure>
<p>在更复杂的 <code>if (xx != null)</code> 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p>
<p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 <code>IntStream.average()</code> 返回 OptionalDouble 等等</p>
<h3 id="8-3-Optional-创建方式"><a href="#8-3-Optional-创建方式" class="headerlink" title="8.3. Optional 创建方式"></a>8.3. Optional 创建方式</h3><p><code>Optional</code>是一个没有子类的工具类。<code>Optional</code>本质是一个容器，需要将对象实例传入该容器中。<code>Optional</code> 的构造方法为 <code>private</code>，无法直接使用 <code>new</code> 构建对象，只能使用 <code>Optional</code> 提供的静态方法创建。<code>Optiona</code>l 三个创建方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">of</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Optional.of(obj)</code>方法，创建一个有值的<code>Optional</code>实例。如果方法传入的对象为null，将会抛出 NPE 异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title function_">ofNullable</span><span class="params">(T value)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Optional.ofNullable(obj)</code>方法，创建一个可以为空的<code>Optional</code>实例。如果对象为null，将会创建不包含值的 <code>empty Optional</code> 对象实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Optional.empty()</code>方法，创建一个空的<code>Optional</code>实例。等同于 <code>Optional.ofNullable(null)</code></li>
</ul>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035333.jpg" alt=""></p>
<blockquote>
<p>注：只有在确定对象不会为 null 的情况使用 <code>Optional.of()</code>，否则建议使用 <code>Optional.ofNullable()</code> 方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">optionalCreateTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* 由于Optional的构造方法为private修饰，无法直接使用new构建对象，只能使用Optional提供的静态方法创建 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方式一：public static &lt;T&gt; Optional&lt;T&gt; of(T value)</span></span><br><span class="line"><span class="comment">     *   该方法创建一个有值的Optional实例。如果方法传入的对象为null，将会抛出 NPE 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Optional&lt;String&gt; op1 = Optional.of(<span class="string">&quot;天锁斩月&quot;</span>);</span><br><span class="line">    <span class="comment">// Optional&lt;String&gt; op1 = Optional.of(null); // 异常</span></span><br><span class="line">    System.out.println(<span class="string">&quot;op1: &quot;</span> + op1.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方式二：public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</span></span><br><span class="line"><span class="comment">     *   该方法创建一个可以为空的Optional实例。如果对象为null，将会创建不包含值的empty Optional对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Optional&lt;String&gt; op2 = Optional.ofNullable(<span class="string">&quot;石原里美&quot;</span>);</span><br><span class="line">    <span class="comment">// Optional&lt;String&gt; op2 = Optional.ofNullable(null); // 创建Optional实例时不会报错</span></span><br><span class="line">    <span class="comment">// 如果是空的Optional对象实例，直接调用get()方法会抛出 NoSuchElementException 异常</span></span><br><span class="line">    System.out.println(<span class="string">&quot;op2: &quot;</span> + op2.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方式三：public static&lt;T&gt; Optional&lt;T&gt; empty()</span></span><br><span class="line"><span class="comment">     *   该方法创创建一个空的Optional实例。等同于 Optional.ofNullable(null)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Optional&lt;String&gt; op3 = Optional.empty();</span><br><span class="line">    <span class="comment">// 如果是空的Optional对象实例，直接调用get()方法会抛出 NoSuchElementException 异常</span></span><br><span class="line">    <span class="comment">// System.out.println(&quot;op3: &quot; + op3.get());</span></span><br><span class="line">    System.out.println(<span class="string">&quot;op3是否有值: &quot;</span> + op3.isPresent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-类的常用方法"><a href="#8-4-类的常用方法" class="headerlink" title="8.4. 类的常用方法"></a>8.4. 类的常用方法</h3><h4 id="8-4-1-get-与-isPresent"><a href="#8-4-1-get-与-isPresent" class="headerlink" title="8.4.1. get() 与 isPresent()"></a>8.4.1. get() 与 isPresent()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;No value present&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取<code>Optional</code>容器的值。如果在这个<code>Optional</code>中包含这个值，返回值，否则抛出异常：<code>NoSuchElementException</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPresent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断是否包含值。如果值存在则方法会返回true，否则返回false。</li>
</ul>
<p>通常使用方式：对象实例存入 <code>Optional</code> 容器中之后，最后需要从中取出。<code>Optional.get()</code> 方法用于取出内部对象实例，不过需要注意的是，如果是 empty Optional 实例，由于容器内没有任何对象实例，使用 <code>get()</code> 方法将会抛出 NoSuchElementException 异常。</p>
<p>为了防止异常抛出，可以使用 <code>Optional.isPresent()</code>。这个方法将会判断内部是否存在对象实例，若存在则返回 true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIsPresentTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建测试的Optional容器</span></span><br><span class="line">    Optional&lt;String&gt; op = Optional.ofNullable(<span class="string">&quot;石原里美&quot;</span>);</span><br><span class="line">    <span class="comment">// Optional&lt;String&gt; op = Optional.empty();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// isPresent()方法：用于判断Optional容器中是否有值，有值返回true，没有值返回false</span></span><br><span class="line">    <span class="keyword">if</span> (op.isPresent()) &#123;</span><br><span class="line">        <span class="comment">// get()方法：用于获取Optional容器中的值，如果有值则返回具体值，没有值就报错</span></span><br><span class="line">        System.out.println(<span class="string">&quot;op的值: &quot;</span> + op.get());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;op没有值&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-2-orElse-、orElseGet-与-orElseThrow"><a href="#8-4-2-orElse-、orElseGet-与-orElseThrow" class="headerlink" title="8.4.2. orElse()、orElseGet() 与 orElseThrow()"></a>8.4.2. orElse()、orElseGet() 与 orElseThrow()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">orElse</span><span class="params">(T other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>orElse</code>方法：如果容器存在该值，返回值，否则返回形参传入的other值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>orElseGet</code>方法：如果容器存在该值，返回值，否则返回形参的函数式接口<code>Supplier</code>返回的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;X <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; T <span class="title function_">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>orElseThrow</code>方法：如果容器存在该值，返回包含的值，否则抛出由 <code>Supplier</code> 继承的异常</li>
</ul>
<p>示例：当一个对象为 null 时，业务上通常可以设置一个默认值，从而使流程继续下去。或者抛出一个内部异常，记录失败原因，快速失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; op = Optional.ofNullable(<span class="string">&quot;石原里美&quot;</span>);</span><br><span class="line"><span class="comment">// private final Optional&lt;String&gt; op = Optional.empty();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Optional类的orElse()方法 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orElseTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// orElse()方法：如果Optional容器中有值，就返回该值；如果没有值就返回参数指定的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> op.orElse(<span class="string">&quot;新垣结衣?&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Optional类的orElseGet()方法 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orElseGetTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// orElseGet()方法：如果Optional容器中有值，就返回该值；如果没有值就返回参数的Supplier接口提供的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> op.orElseGet(() -&gt; <span class="string">&quot;长泽雅美&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Optional类的orElseThrow()方法 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orElseThrowTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// orElseThrow()方法：如果Optional容器中有值，就返回该值；如果没有值就抛出由Supplier继承的异常</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> op.orElseThrow(NullPointerException::<span class="keyword">new</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-3-ifPresent"><a href="#8-4-3-ifPresent" class="headerlink" title="8.4.3. ifPresent()"></a>8.4.3. ifPresent()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresent</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; consumer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>)</span><br><span class="line">        consumer.accept(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ifPresent</code>方法：如果值存在则使用该值调用 <code>Consumer</code> 接口进行消费处理，否则不做任何事情。即使用 <code>ifPresent</code> 方法，不用再进行非空检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// private final Optional&lt;String&gt; op = Optional.ofNullable(&quot;石原里美&quot;);</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;String&gt; op = Optional.empty();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ifPresentTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ifPresent()方法：如果Optional容器中有值，使用该值调用Consumer接口进行消费处理，否则不做任何事情</span></span><br><span class="line">    op.ifPresent(s -&gt; System.out.println(<span class="string">&quot;name = &quot;</span> + s));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 番外：JDK9 对Optional类做了增强，增加了ifPresentOrElse方法</span></span><br><span class="line"><span class="comment">     *  该方法可以定义容器分别是否为空时的相应处理逻辑</span></span><br><span class="line"><span class="comment">     *  参数1：当前容器有值时，执行此消费方法逻辑</span></span><br><span class="line"><span class="comment">     *  参数2：当前容器为空时，执行此方法逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*op.ifPresentOrElse(s -&gt; &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;有值: &quot; + s);</span></span><br><span class="line"><span class="comment">    &#125;, () -&gt; &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;没有值&quot;);</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-4-map-与-flatMap"><a href="#8-4-4-map-与-flatMap" class="headerlink" title="8.4.4. map() 与 flatMap()"></a>8.4.4. map() 与 flatMap()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>map</code>方法：如果存在该值，执行参数提供的映射方法<code>Function</code>，如果映射方法返回非null值，则<code>map</code>最终会返回一个包装了返回值的<code>Optional</code>实例。如果映射方法处理返回null时，则返回空的<code>Optional</code>实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> empty();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>flatMap</code>方法：如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</li>
</ul>
<blockquote>
<p>以上两个方法与 Java8 Stream 的相似，<code>Stream.map()</code>方法可以将当前对象转化为另外一个对象， <code>Optional.map()</code> 方法也与之类似</p>
<p>示例：map 方法可以将原先 <code>Optional&lt;User&gt;</code> 转变成 <code>Optional&lt;String&gt;</code> ，此时 <code>Optional</code> 内部对象变成 <code>String</code> 类型。如果转化之前 <code>Optional</code> 对象为空，则什么也不会发生</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mapTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 示例：将用户对象的用户名转成大写并返回</span></span><br><span class="line">    <span class="comment">// User user = null;</span></span><br><span class="line">    <span class="comment">// User user = new User(null, 18);</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;mooN&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map()方法：如果Optional容器中有值，则执行参数的Function接口实现逻辑；如没有值则返回空的Optional对象实例</span></span><br><span class="line">    <span class="comment">/*String userName = Optional.ofNullable(user)</span></span><br><span class="line"><span class="comment">            .map(u -&gt; u.getUserName())</span></span><br><span class="line"><span class="comment">            .map(s -&gt; s.toUpperCase())</span></span><br><span class="line"><span class="comment">            .orElse(&quot;null&quot;);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用方法引用简化上面的代码 */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> Optional.ofNullable(user) <span class="comment">// 创建User对象的Optional容器</span></span><br><span class="line">            .map(User::getUserName) <span class="comment">// 如果User实例不为空，则调用gteUserName方法获取用户名称，否则返回空Optional实例</span></span><br><span class="line">            .map(String::toUpperCase) <span class="comment">// 如果userName不为空，则调用toUpperCase方法转成大写，否则返回空Optional实例</span></span><br><span class="line">            .orElse(<span class="string">&quot;null&quot;</span>); <span class="comment">// 如果上述其中一步返回空的Optional实例，则会执行 orElse 返回默认的值</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;用户名转成大写后值为：&quot;</span> + userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-5-filter"><a href="#8-4-5-filter" class="headerlink" title="8.4.5. filter()"></a>8.4.5. filter()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> predicate.test(value) ? <span class="built_in">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>filter</code>方法：如果值存在，并且这个值匹配给定的 predicate，返回一个包含此值的<code>Optional</code>实例，否则返回一个空的<code>Optional</code>实例</li>
</ul>
<p>示例：当某些属性满足一定条件，才进行下一步动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filterTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 示例：如果用户对象的用户名称不为空且长度大于3，则输出结果</span></span><br><span class="line">    <span class="comment">// User user = null;</span></span><br><span class="line">    <span class="comment">// User user = new User(null, 18);</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;mooN&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter()方法：如果Optional容器中有值，并且这个值匹配参数的Predicate接口实现逻辑；返回一个包含此值的Optional实例，否则返回一个空的Optional实例</span></span><br><span class="line">    Optional.ofNullable(user) <span class="comment">// 创建User对象的Optional容器</span></span><br><span class="line">            .filter(u -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> u.getUserName();</span><br><span class="line">                <span class="keyword">return</span> userName != <span class="literal">null</span> &amp;&amp; userName.length() &gt; <span class="number">3</span>;</span><br><span class="line">            &#125;) <span class="comment">// 如果user对象不为空，则将user对象去匹配参数的Predicate接口实现逻辑，如果条件成功则返回user对象的Optional实例，否则返回空Optional实例</span></span><br><span class="line">            .ifPresent(u -&gt; System.out.println(<span class="string">&quot;用户名: &quot;</span> + u.getUserName())); <span class="comment">// 如果上述其中一步返回空的Optional实例，则会执行则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>filter</code> 方法将会判断对象是否符合条件。如果不符合条件，将会返回一个空的 <code>Optional</code></p>
</blockquote>
<h4 id="8-4-6-其他常用方法"><a href="#8-4-6-其他常用方法" class="headerlink" title="8.4.6. 其他常用方法"></a>8.4.6. 其他常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断其他对象是否等于 Optional。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回存在值的哈希码，如果值不存在返回 0。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回一个Optional的非空字符串，用来调试</li>
</ul>
<h3 id="8-5-Optional-使用实例"><a href="#8-5-Optional-使用实例" class="headerlink" title="8.5. Optional 使用实例"></a>8.5. Optional 使用实例</h3><h4 id="8-5-1-示例1"><a href="#8-5-1-示例1" class="headerlink" title="8.5.1. 示例1"></a>8.5.1. 示例1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.jav.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Java8Tester</span> <span class="variable">java8Tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// Optional.ofNullable - 允许传递为 null 参数</span></span><br><span class="line">        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line">        <span class="comment">// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span></span><br><span class="line">        Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">        System.out.println(java8Tester.sum(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">sum</span><span class="params">(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)</span> &#123;</span><br><span class="line">        <span class="comment">// Optional.isPresent - 判断值是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个参数值存在: &quot;</span> + a.isPresent());</span><br><span class="line">        System.out.println(<span class="string">&quot;第二个参数值存在: &quot;</span> + b.isPresent());</span><br><span class="line">        <span class="comment">// Optional.orElse - 如果值存在，返回它，否则返回默认值</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value1</span> <span class="operator">=</span> a.orElse(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//Optional.get - 获取值，值需要存在</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value2</span> <span class="operator">=</span> b.get();</span><br><span class="line">        <span class="keyword">return</span> value1 + value2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个参数值存在: false</span><br><span class="line">第二个参数值存在: true</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h4 id="8-5-2-示例2"><a href="#8-5-2-示例2" class="headerlink" title="8.5.2. 示例2"></a>8.5.2. 示例2</h4><ul>
<li>未使用Optional之前代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (staff != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">Department</span> <span class="variable">department</span> <span class="operator">=</span> staff.getDepartment();</span><br><span class="line">    <span class="keyword">if</span> (department != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> department.getCompany();</span><br><span class="line">        <span class="keyword">if</span> (company != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> company.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Unknown&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用Optional重构，将 Staff，Department 修改 getter 方法返回结果类型改成 Optional对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Staff</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Department&gt; <span class="title function_">getDepartment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(department);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line">    <span class="keyword">public</span> Optional&lt;Company&gt; <span class="title function_">getCompany</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(company);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>利用 Optional 的 Fluent Interface，以及 lambda 表达式重构代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Staff&gt; staffOpt = ...;</span><br><span class="line">staffOpt.flatMap(Staff::getDepartment)</span><br><span class="line">        .flatMap(Department::getCompany)</span><br><span class="line">        .map(Company::getName)</span><br><span class="line">        .orElse(<span class="string">&quot;Unknown&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="9-JDK8-新的日期和时间-API"><a href="#9-JDK8-新的日期和时间-API" class="headerlink" title="9. JDK8 新的日期和时间 API"></a>9. JDK8 新的日期和时间 API</h2><h3 id="9-1-旧版日期时间-API-存在的问题"><a href="#9-1-旧版日期时间-API-存在的问题" class="headerlink" title="9.1. 旧版日期时间 API 存在的问题"></a>9.1. 旧版日期时间 API 存在的问题</h3><ol>
<li>设计很差： 在<code>java.util</code>和<code>java.sql</code>的包中都有日期类，<code>java.util.Date</code>同时包含日期和时间，而<code>java.sql.Date</code>仅包含日期。此外用于格式化和解析的类在<code>java.text</code>包中定义</li>
<li>非线程安全：<code>java.util.Date</code> 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一</li>
<li>时区处理麻烦：日期类并不提供国际化，没有时区支持，因此Java引入了<code>java.util.Calendar</code>和<code>java.util.TimeZone</code>类，但他们同样存在上述所有的问题</li>
</ol>
<h3 id="9-2-新的日期时间-API"><a href="#9-2-新的日期时间-API" class="headerlink" title="9.2. 新的日期时间 API"></a>9.2. 新的日期时间 API</h3><p>JDK 8中增加了一套全新的日期时间API，这套API设计合理，是线程安全的。新的<code>java.time</code>包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。常用有以下的关键类：</p>
<ul>
<li><code>LocalDate</code>：表示日期，包含年月日，格式为 2019-10-16</li>
<li><code>LocalTime</code>：表示时间，包含时分秒，格式为 16:38:54.158549300</li>
<li><code>LocalDateTime</code>：表示日期时间，包含年月日，时分秒，格式为 2018-09-06T15:33:56.750</li>
<li><code>DateTimeFormatter</code>：日期时间格式化类</li>
<li><code>Instant</code>：时间戳，表示一个特定的时间瞬间</li>
<li><code>Duration</code>：用于计算2个时间(<code>LocalTime</code>，时分秒)的距离</li>
<li><code>Period</code>：用于计算2个日期(<code>LocalDate</code>，年月日)的距离</li>
<li><code>ZonedDateTime</code>：包含时区的时间</li>
</ul>
<p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是通常所说的公历。平年有365天，闰年是366天。此外Java 8还提供了4套其他历法，分别是：</p>
<ul>
<li><code>ThaiBuddhistDate</code>：泰国佛教历</li>
<li><code>MinguoDate</code>：中华民国历</li>
<li><code>JapaneseDate</code>：日本历</li>
<li><code>HijrahDate</code>：伊斯兰历</li>
</ul>
<h4 id="9-2-1-JDK-8的日期和时间类"><a href="#9-2-1-JDK-8的日期和时间类" class="headerlink" title="9.2.1. JDK 8的日期和时间类"></a>9.2.1. JDK 8的日期和时间类</h4><p><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>类的实例是不可变的对象，分别表示使用 ISO-8601 日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LocalDate类: 表示日期，有年月日信息 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localDateTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 工厂方法LocalDate.of()可以创建任意日期，该方法需要传入年、月、日做参数，返回对应的LocalDate实例。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;指定日期: &quot;</span> + date);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态工厂方法LocalDate.now()获取当天日期</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;今天的日期：&quot;</span> + now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取年信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;year: &quot;</span> + now.getYear());</span><br><span class="line">    <span class="comment">// 获取月信息信息（值为Month的枚举类）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Month枚举: &quot;</span> + now.getMonth());</span><br><span class="line">    <span class="comment">// 获取月信息（值为1~12），注：与Date类不一样，Date获取的月份是从0开始</span></span><br><span class="line">    System.out.println(<span class="string">&quot;month: &quot;</span> + now.getMonthValue());</span><br><span class="line">    <span class="comment">// 获取日信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;day: &quot;</span> + now.getDayOfMonth());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LocalTime: 表示时间，有时分秒的信息 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localTimeTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 通过静态工厂方法LocalTime.of()获取指定时间对象</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">13</span>, <span class="number">26</span>, <span class="number">39</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;指定时间time: &quot;</span> + time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态工厂方法LocalTime.now()获取当前时间</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前的时间,不含有日期: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;hour: &quot;</span> + now.getHour()); <span class="comment">// 获取时</span></span><br><span class="line">    System.out.println(<span class="string">&quot;minute: &quot;</span> + now.getMinute()); <span class="comment">// 获取分</span></span><br><span class="line">    System.out.println(<span class="string">&quot;second: &quot;</span> + now.getSecond()); <span class="comment">// 获取秒</span></span><br><span class="line">    System.out.println(<span class="string">&quot;nano: &quot;</span> + now.getNano()); <span class="comment">// 获取毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LocalDateTime: 相当于 LocalDate + LocalTime 具有年月日 时分秒的信息 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localDateTimeTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 通过静态工厂方法LocalDateTime.of()获取指定日期时间对象</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">28</span>, <span class="number">59</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;指定的日期时间: &quot;</span> + dateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态工厂方法LocalDateTime.now()获取当前日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前的日期时间: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;year: &quot;</span> + now.getYear()); <span class="comment">// 获取年</span></span><br><span class="line">    System.out.println(<span class="string">&quot;month: &quot;</span> + now.getMonthValue()); <span class="comment">// 获取月</span></span><br><span class="line">    System.out.println(<span class="string">&quot;day: &quot;</span> + now.getDayOfMonth()); <span class="comment">// 获取日</span></span><br><span class="line">    System.out.println(<span class="string">&quot;hour: &quot;</span> + now.getHour()); <span class="comment">// 获取时</span></span><br><span class="line">    System.out.println(<span class="string">&quot;minute: &quot;</span> + now.getMinute()); <span class="comment">// 获取分</span></span><br><span class="line">    System.out.println(<span class="string">&quot;second: &quot;</span> + now.getSecond()); <span class="comment">// 获取秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对日期时间的修改，对已存在的<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>对象，使用<code>withAttribute</code>方法会创建对象的一个副本，并按照需要修改它的属性。以下所有的方法都返回了一个修改属性的对象，不会影响原来的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LocalDate、LocalTime、LocalDateTime 日期时间修改、计算测试 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">computeLocalDateTimeTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// LocalDate、LocalTime、LocalDateTime都同样的修改方式，调用withXxxx方法修改相应的属性</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 修改当前时间的年属性，修改返回新的日期时间对象，不会影响原日期时间对象</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> now.withYear(<span class="number">2222</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;dateTime = &quot;</span> + dateTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;now == dateTime: &quot;</span> + (now == dateTime)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 增加或减去日期、时间</span></span><br><span class="line"><span class="comment">     *   plusXxxx: 增加指定的时间</span></span><br><span class="line"><span class="comment">     *   minusXxxx: 减去指定的时间</span></span><br><span class="line"><span class="comment">     *   Temporal plus(long amountToAdd, TemporalUnit unit)：通过指定时间单位，增加时间</span></span><br><span class="line"><span class="comment">     *   default Temporal minus(long amountToSubtract, TemporalUnit unit)：通过指定时间单位，减少时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注1：Java 8除了不变类型和线程安全的好处之外，还提供如更好的plusHours()方法替换add()，并且是兼容的。</span></span><br><span class="line"><span class="comment">     * 注2：这些方法返回一个全新的LocalTime实例，由于其不可变性，返回后一定要用变量赋值。</span></span><br><span class="line"><span class="comment">     * 注3：LocalDate、LocalTime、LocalDateTime 均相同的api来操作日期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 经过测试，增加指定时间后，如果日期出现跨天的话，日期也会增加</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，加上2年：&quot;</span> + now.plusYears(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，加上5月：&quot;</span> + now.plusMonths(<span class="number">5</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，加上20天：&quot;</span> + now.plusDays(<span class="number">20</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，加上10小时：&quot;</span> + now.plusHours(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，加上20分钟：&quot;</span> + now.plusMinutes(<span class="number">20</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，加上30秒：&quot;</span> + now.plusSeconds(<span class="number">30</span>));</span><br><span class="line">    <span class="comment">// 经过测试，减去指定时间后，如果日期出现跨天的话，日期也会减少</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，减去2年：&quot;</span> + now.minusYears(<span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，减去5月：&quot;</span> + now.minusMonths(<span class="number">5</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，减去29天：&quot;</span> + now.minusDays(<span class="number">29</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，减去17小时：&quot;</span> + now.minusHours(<span class="number">17</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，减去20分钟：&quot;</span> + now.minusMinutes(<span class="number">20</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;当前时间：&quot;</span> + now + <span class="string">&quot; ，减去30秒：&quot;</span> + now.minusSeconds(<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建LocalTime对象，只包含时间信息，没有日期。操作增加/减少小时、分、秒来计算的时间</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;获取当前的时间:&quot;</span> + time); <span class="comment">// 23:30:22.677</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">plusTime</span> <span class="operator">=</span> time.plusHours(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;3个小时后的时间为:&quot;</span> + plusTime); <span class="comment">// 02:30:22.677</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">minusTime</span> <span class="operator">=</span> time.minusHours(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;2个小时前的时间为:&quot;</span> + minusTime); <span class="comment">// 21:30:22.677</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建LocalDate对象，只包含日期不包含时间信息。操作增加/减少小时、分、秒来计算的时间</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;今天的日期为:&quot;</span> + today); <span class="comment">// 2020-07-12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过使用LocalDate的plus()方法来增加天、周、月，ChronoUnit类声明了这些时间单位。</span></span><br><span class="line">    <span class="comment">// 由于LocalDate也是不变类型，返回后一定要用变量赋值。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">plusDate</span> <span class="operator">=</span> today.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line">    System.out.println(<span class="string">&quot;一周后的日期为:&quot;</span> + plusDate); <span class="comment">//  2020-07-19</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">minusDate</span> <span class="operator">=</span> today.minus(<span class="number">3</span>, ChronoUnit.DAYS);</span><br><span class="line">    System.out.println(<span class="string">&quot;3天前的日期为:&quot;</span> + minusDate); <span class="comment">// 2020-07-09</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">previousYear</span> <span class="operator">=</span> today.minus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">    System.out.println(<span class="string">&quot;一年前的日期 : &quot;</span> + previousYear); <span class="comment">// 2019-07-12</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nextYear</span> <span class="operator">=</span> today.plus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">    System.out.println(<span class="string">&quot;一年后的日期:&quot;</span> + nextYear); <span class="comment">// 2021-07-12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注：可以用同样的方法增加（或减少）1个月、1年、1小时、1分钟甚至一个世纪 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>类可以通过<code>isBefore()</code>、<code>isAfter()</code>、<code>equals()</code>方法来进行日期时间的比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LocalDate、LocalTime、LocalDateTime 日期时间比较测试 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compareLocalDateTimeTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2018</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">28</span>, <span class="number">59</span>);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前日期时间:&quot;</span> + now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日期对象a,b 调用 a.isAfter(b)，用于判断a日期是否在b日期之后</span></span><br><span class="line">    System.out.println(dateTime + <span class="string">&quot;是否在当前日期之后: &quot;</span> + now.isAfter(dateTime)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 日期对象a,b 调用 a.isBefore(b)，用于判断a日期是否在b日期之前</span></span><br><span class="line">    System.out.println(dateTime + <span class="string">&quot;是否在当前日期之前: &quot;</span> + now.isBefore(dateTime)); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// 日期对象a,b 调用 a.isEqual(b)，用于判断a日期是否在b日期相等</span></span><br><span class="line">    System.out.println(dateTime + <span class="string">&quot;是否与当前日期相等: &quot;</span> + now.isEqual(dateTime)); <span class="comment">//  false</span></span><br><span class="line">    <span class="comment">// 直接调用LocalDateTime对象的equals()方法也可以判断两个日期是否相等（LocalDate也有此API）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;equals()方法，&quot;</span> + dateTime + <span class="string">&quot;是否与当前日期相等: &quot;</span> + now.equals(dateTime)); <span class="comment">//  false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">yesterday</span> <span class="operator">=</span> today.minus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前日期:&quot;</span> + today);</span><br><span class="line">    System.out.println(yesterday + <span class="string">&quot;是否在当前日期之后: &quot;</span> + yesterday.isBefore(today)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(yesterday + <span class="string">&quot;是否在当前日期之前: &quot;</span> + yesterday.isAfter(today)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(yesterday + <span class="string">&quot;是否与当前日期相等: &quot;</span> + yesterday.isEqual(today)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-2-JDK-8的时间格式化与解析"><a href="#9-2-2-JDK-8的时间格式化与解析" class="headerlink" title="9.2.2. JDK 8的时间格式化与解析"></a>9.2.2. JDK 8的时间格式化与解析</h4><p>通过 <code>java.time.format.DateTimeFormatter</code> 类可以进行日期时间解析与格式化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parseAndFormatLocalDateTimeTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 日期字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dayString</span> <span class="operator">=</span> <span class="string">&quot;20200714&quot;</span>;</span><br><span class="line">    <span class="comment">// 日期时间字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dateTimeString</span> <span class="operator">=</span> <span class="string">&quot;2020年09月20日 15时16分16秒&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建一个日期时间对象</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ==================== 日期对象转字符串测试 ==================== */</span></span><br><span class="line">    <span class="comment">// 创建日期格式化对象，使用JDK自带的时间格式 （JDK8 日期的格式化对象是DateTimeFormatter）</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">isoFormatter</span> <span class="operator">=</span> DateTimeFormatter.BASIC_ISO_DATE;</span><br><span class="line">    <span class="comment">// 使用DateTimeFormatter类的静态ofPattern()方法，创建日期格式化对象，指定自定义格式</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">customFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 调用日期时间对象的format方法，按指定的格式将日期时间对象转成字符串</span></span><br><span class="line"><span class="comment">     *  public String format(DateTimeFormatter formatter)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;LocalDateTime对象 &#x27;%s&#x27; 转成JDK自带BASIC_ISO_DATE格式字符串：&#x27;%s&#x27;%n&quot;</span>, now, now.format(isoFormatter));</span><br><span class="line">    System.out.printf(<span class="string">&quot;LocalDateTime对象 &#x27;%s&#x27; 转成自定义格式字符串：&#x27;%s&#x27;%n&quot;</span>, now, now.format(customFormatter));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ==================== 字符串解析成日期对象测试 ==================== */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 日期时间解析：LocalDateTime类的parse静态方法，将日期时间字符串转成对象</span></span><br><span class="line"><span class="comment">     *  parse(CharSequence text, DateTimeFormatter formatter)</span></span><br><span class="line"><span class="comment">     *      作用：将字符串转成LocalDate日期对象</span></span><br><span class="line"><span class="comment">     *      text参数：待转换的日期时间字符串</span></span><br><span class="line"><span class="comment">     *      formatter参数：日期格式化对象DateTimeFormatter，该格式器有一些静态属性为指定解析时日期的格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">dateFormatted</span> <span class="operator">=</span> LocalDate.parse(dayString, isoFormatter);</span><br><span class="line">    System.out.printf(<span class="string">&quot;字符串 &#x27;%s&#x27; 格式化后的日期LocalDate类型为：%s%n&quot;</span>, dayString, dateFormatted);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">parseDateTime</span> <span class="operator">=</span> LocalDateTime.parse(dateTimeString, customFormatter);</span><br><span class="line">    System.out.printf(<span class="string">&quot;字符串 &#x27;%s&#x27; 格式化后的日期LocalDateTime类型为：%s%n&quot;</span>, dateTimeString, parseDateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 测试多线程下，解析日期是否正常 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;</span><br><span class="line">                System.out.println(<span class="string">&quot;多线程解析日期 = &quot;</span> + LocalDateTime.parse(dateTimeString, customFormatter))</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-3-JDK-8的-Instant-类"><a href="#9-2-3-JDK-8的-Instant-类" class="headerlink" title="9.2.3. JDK 8的 Instant 类"></a>9.2.3. JDK 8的 Instant 类</h4><p><code>Instant</code> 类是jdk8新提供的时间戳（时间线），内部保存了从1970年1月1日 00:00:00以来的秒和纳秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instantTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Instant内部保存了秒和纳秒(一般不是给用户使用的，而是方便程序做一些统计的)</span></span><br><span class="line">    <span class="comment">// Instant类有一个静态工厂方法now()会返回当前的时间戳</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">timestamp</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;What is value of this instant : &quot;</span> + timestamp); <span class="comment">// 2020-09-28T09:22:33.732Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加秒</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">plus</span> <span class="operator">=</span> timestamp.plusSeconds(<span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;plus = &quot;</span> + plus); <span class="comment">// 2020-09-28T09:22:53.732Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减去秒</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">minus</span> <span class="operator">=</span> timestamp.minusSeconds(<span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;minus = &quot;</span> + minus); <span class="comment">// 2020-09-28T09:22:13.732Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Instant对象的getEpochSecond()方法，获取秒值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;What is value of this instant.getEpochSecond() : &quot;</span> + timestamp.getEpochSecond());</span><br><span class="line">    <span class="comment">// 调用Instant对象的getNano()方法，获取纳秒值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;What is value of this instant.getNano() : &quot;</span> + timestamp.getNano());</span><br><span class="line">    <span class="comment">// 调用Instant对象的toEpochMilli()方法，获取毫秒值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;What is value of this instant.toEpochMilli() : &quot;</span> + timestamp.toEpochMilli()); <span class="comment">// 1594646847755</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Instant类时间戳信息里同时包含了日期和时间，这和java.util.Date很像。</span></span><br><span class="line"><span class="comment">     *      实际上Instant类确实等同于 Java 8之前的Date类，可以使用Date类和Instant类各自的转换方法互相转换</span></span><br><span class="line"><span class="comment">     *      例如：Date.from(Instant) 将Instant转换成java.util.Date，Date.toInstant()则是将Date类转换成Instant类。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">dateFromInstant</span> <span class="operator">=</span> Date.from(timestamp);</span><br><span class="line">    System.out.println(<span class="string">&quot;Instant转成Date：&quot;</span> + dateFromInstant); <span class="comment">// Mon Sep 28 17:22:33 CST 2020</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">dateToInstant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().toInstant();</span><br><span class="line">    System.out.println(<span class="string">&quot;Date转成Instant：&quot;</span> + dateToInstant); <span class="comment">// 2020-09-28T09:22:33.811Z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-4-JDK-8的计算日期时间差类"><a href="#9-2-4-JDK-8的计算日期时间差类" class="headerlink" title="9.2.4. JDK 8的计算日期时间差类"></a>9.2.4. JDK 8的计算日期时间差类</h4><p>JDK8 提供了 <code>Duration</code>与<code>Period</code>类，用于计算日期时间差</p>
<ul>
<li><code>Duration</code>：用于计算2个时间(<code>LocalTime</code>，时分秒)的距离</li>
<li><code>Period</code>：用于计算2个日期(<code>LocalDate</code>，年月日)的距离</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算两个日期之间的天数、周数或月数</span></span><br><span class="line"><span class="comment"> *      在Java 8中可以用java.time.Period类来做计算。</span></span><br><span class="line"><span class="comment"> * 计算两个时间之间的天数、小时、分钟、秒、毫秒</span></span><br><span class="line"><span class="comment"> *      在Java 8中可以用java.time.Duration类来做计算。</span></span><br><span class="line"><span class="comment"> *  注：都调用以上两个的between()方法实现，都是后面参数减前端的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">computeTimeDifferenceTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;Today is : &quot;</span> + today); <span class="comment">// 2020-07-13</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">dateToCompute</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>, <span class="number">12</span>, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个日期的差值</span></span><br><span class="line">    <span class="type">Period</span> <span class="variable">periodBetweenTwoDate</span> <span class="operator">=</span> Period.between(today, dateToCompute);</span><br><span class="line">    <span class="comment">// getYears()计算的差值直接为年份数相减</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Years left between today and dateToCompute : &quot;</span> + periodBetweenTwoDate.getYears());</span><br><span class="line">    <span class="comment">// getMonths()计算的差值直接为月份数相减，年不在计算范围内</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Months left between today and dateToCompute : &quot;</span> + periodBetweenTwoDate.getMonths());</span><br><span class="line">    <span class="comment">// getDays()计算的差值直接为天数相减，月与年不在计算范围内</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Days left between today and dateToCompute : &quot;</span> + periodBetweenTwoDate.getDays());</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;Now is : &quot;</span> + nowTime); <span class="comment">// 2020-07-13</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">timeToCompute</span> <span class="operator">=</span> LocalTime.of(<span class="number">20</span>, <span class="number">12</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">// 计算两个时间的差值</span></span><br><span class="line">    <span class="type">Duration</span> <span class="variable">durationBetweenTwoTime</span> <span class="operator">=</span> Duration.between(nowTime, timeToCompute);</span><br><span class="line">    <span class="comment">// toDays()计算两个时间相差的天数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Days left between nowTime and timeToCompute : &quot;</span> + durationBetweenTwoTime.toDays());</span><br><span class="line">    <span class="comment">// toHours()计算两个时间相差的小时数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hours left between nowTime and timeToCompute : &quot;</span> + durationBetweenTwoTime.toHours());</span><br><span class="line">    <span class="comment">// toMinutes()计算两个时间相差的分钟数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Minutes left between nowTime and timeToCompute : &quot;</span> + durationBetweenTwoTime.toMinutes());</span><br><span class="line">    <span class="comment">// toMillis()计算两个时间相差的秒数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Seconds left between nowTime and timeToCompute : &quot;</span> + durationBetweenTwoTime.toMillis());</span><br><span class="line">    <span class="comment">// toNanos()计算两个时间相差的毫秒数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Milliseconds left between nowTime and timeToCompute : &quot;</span> + durationBetweenTwoTime.toNanos());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-5-JDK-8的时间校正器"><a href="#9-2-5-JDK-8的时间校正器" class="headerlink" title="9.2.5. JDK 8的时间校正器"></a>9.2.5. JDK 8的时间校正器</h4><p>时间校正器：用于自定义调整时间操作，将日期调整到指定某个时间点</p>
<ul>
<li><code>TemporalAdjuster</code>：时间校正器</li>
<li><code>TemporalAdjusters</code>：该类通过静态方法提供了大量的常用TemporalAdjuster的实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">temporalAdjusterTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TemporalAdjuster是函数式接口，使用lambda表达式创建TemporalAdjuster的实现</span></span><br><span class="line">    <span class="type">TemporalAdjuster</span> <span class="variable">firstDayOfNextMonth</span> <span class="operator">=</span> temporal -&gt; &#123;</span><br><span class="line">        <span class="comment">// LocalDateTime实现了 TemporalAdjuster 接口</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime</span> <span class="operator">=</span> (LocalDateTime) temporal;</span><br><span class="line">        <span class="comment">// 返回时间校正的规则。示例：下一个月的第一天</span></span><br><span class="line">        <span class="keyword">return</span> dateTime.plusMonths(<span class="number">1</span>).withDayOfMonth(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 调用LocalDateTime对象的with方法，传入自定义时间校正器TemporalAdjuster的lambda实现</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">newDateTime1</span> <span class="operator">=</span> now.with(firstDayOfNextMonth);</span><br><span class="line">    System.out.println(<span class="string">&quot;将当前日期时间调整到下一个月的第一天: &quot;</span> + newDateTime1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了自定义时间校正器，JDK中TemporalAdjusters类提供了很多时间调整器</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">newDateTime2</span> <span class="operator">=</span> now.with(TemporalAdjusters.firstDayOfNextYear());</span><br><span class="line">    System.out.println(<span class="string">&quot;将当前日期时间调整到下一个年的第一天: &quot;</span> + newDateTime2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-6-JDK-8设置日期时间的时区"><a href="#9-2-6-JDK-8设置日期时间的时区" class="headerlink" title="9.2.6. JDK 8设置日期时间的时区"></a>9.2.6. JDK 8设置日期时间的时区</h4><p>Java8 中加入了对时区的支持，<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code>是不带时区的，带时区的日期时间类分别为：<code>ZonedDate</code>、<code>ZonedTime</code>、<code>ZonedDateTime</code></p>
<p>其中每个时区都对应着ID，ID的格式为“区域/城市”。例如：<code>Asia/Shanghai</code>等。而所有的时区信息都定义在<code>ZoneId</code>类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Java 8中处理时区</span></span><br><span class="line"><span class="comment"> *   Java 8不仅分离了日期和时间，也把时区分离出来了。</span></span><br><span class="line"><span class="comment"> *   现在有一系列单独的类如ZoneId来处理特定时区，ZoneDateTime类来表示某时区下的时间。</span></span><br><span class="line"><span class="comment"> *   这在Java 8以前都是 GregorianCalendar类来做的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">zoneDateTimeTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 通过ZoneId类的getAvailableZoneIds静态方法，获取所有的时区ID</span></span><br><span class="line">    <span class="comment">// ZoneId.getAvailableZoneIds().forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取计算机的当前时间。LocalDate、LocalTime、LocalDateTime是不带时区的</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">// 中国使用的东八区的时区.比标准时间早8个小时</span></span><br><span class="line">    System.out.println(<span class="string">&quot;不带时区的LocalDateTime: &quot;</span> + now); <span class="comment">// 2020-09-28T23:37:11.298</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 操作带时区的类：ZonedDateTime</span></span><br><span class="line"><span class="comment">     *  now(Clock.systemUTC()): 创建世界标准时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime1</span> <span class="operator">=</span> ZonedDateTime.now(Clock.systemUTC());</span><br><span class="line">    System.out.println(<span class="string">&quot;世界标准时间ZonedDateTime: &quot;</span> + zonedDateTime1); <span class="comment">// 2020-09-28T15:37:11.299Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZonedDateTime.now(): 使用计算机的默认的时区,创建日期时间</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime2</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;带时区的当前时间zonedDateTime2: &quot;</span> + zonedDateTime2); <span class="comment">// 2020-09-28T23:37:11.299+08:00[Asia/Shanghai]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZonedDateTime.now(ZoneId zone) 使用指定的时区创建日期时间</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime3</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;America/Vancouver&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;使用指定的时区创建日期时间: &quot;</span> + zonedDateTime3); <span class="comment">// 2020-09-28T08:37:11.300-07:00[America/Vancouver]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 通过ZonedDateTime对象的withZoneSameInstant方法，修改时区</span></span><br><span class="line"><span class="comment">     *  注：withZoneSameInstant: 即更改时区，也更改时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">withZoneSameInstant</span> <span class="operator">=</span> zonedDateTime3.withZoneSameInstant(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;withZoneSameInstant = &quot;</span> + withZoneSameInstant); <span class="comment">// 2020-09-28T23:37:11.300+08:00[Asia/Shanghai]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 通过ZonedDateTime对象的withZoneSameLocal方法，修改时区</span></span><br><span class="line"><span class="comment">     *  注：withZoneSameLocal: 只更改时区,不更改时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">withZoneSameLocal</span> <span class="operator">=</span> zonedDateTime3.withZoneSameLocal(ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;withZoneSameLocal = &quot;</span> + withZoneSameLocal); <span class="comment">// 2020-09-28T08:37:11.300+08:00[Asia/Shanghai]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Date and time with timezone in Java 8（Java 8中带时区的日期和时间）</span></span><br><span class="line">    <span class="type">ZoneId</span> <span class="variable">america</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);  <span class="comment">// 指定美国时区</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localtDateAndTime</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">// 创建时间对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取带有指定时区的时间对象（ZonedDateTime）</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">dateTimeInNewYork</span> <span class="operator">=</span> ZonedDateTime.of(localtDateAndTime, america);</span><br><span class="line">    System.out.println(<span class="string">&quot;Current date and time in a particular timezone : &quot;</span> + dateTimeInNewYork); <span class="comment">// 2020-09-28T23:37:11.313-04:00[America/New_York]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-2-7-JDK8-其他的API使用示例"><a href="#9-2-7-JDK8-其他的API使用示例" class="headerlink" title="9.2.7. JDK8 其他的API使用示例"></a>9.2.7. JDK8 其他的API使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Java 8中检查是否周期性日期事件</span></span><br><span class="line"><span class="comment"> *  MonthDay对象：用于每年重复周期性事件，即月+日，如生日、节日等</span></span><br><span class="line"><span class="comment"> *  YearMonth对象：用于，还可以用这个类得到当月共有多少天。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">monthDayAndYearMonthTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* MonthDay对象测试部分 */</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2020</span>, <span class="number">7</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态工厂方法MonthDay.of(Month month, int dayOfMonth)，获取指定月与日的MonthDay对象</span></span><br><span class="line">    <span class="type">MonthDay</span> <span class="variable">birthday</span> <span class="operator">=</span> MonthDay.of(date.getMonth(), date.getDayOfMonth());</span><br><span class="line">    <span class="comment">// 通过静态方法MonthDay.from(TemporalAccessor temporal)，获取指定某年的的MonthDay对象</span></span><br><span class="line">    <span class="type">MonthDay</span> <span class="variable">currentMonthDay</span> <span class="operator">=</span> MonthDay.from(now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个MonthDay对象</span></span><br><span class="line">    <span class="keyword">if</span> (currentMonthDay.equals(birthday)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;是你的生日&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的生日还没有到&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* YearMonth对象测试部分 */</span></span><br><span class="line">    <span class="type">YearMonth</span> <span class="variable">currentYearMonth</span> <span class="operator">=</span> YearMonth.now();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Days in month year %s: %d%n&quot;</span>, currentYearMonth, currentYearMonth.lengthOfMonth()); <span class="comment">// Days in month year 2020-07: 31</span></span><br><span class="line">    <span class="type">YearMonth</span> <span class="variable">creditCardExpiry</span> <span class="operator">=</span> YearMonth.of(<span class="number">2020</span>, Month.JULY);</span><br><span class="line">    System.out.printf(<span class="string">&quot;Your credit card expires on %s %n&quot;</span>, creditCardExpiry); <span class="comment">// Your credit card expires on 2020-07</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// YearMonth实例的lengthOfMonth()方法可以返回当月的天数，在判断2月有28天还是29天时非常有用</span></span><br><span class="line">    <span class="type">YearMonth</span> <span class="variable">yearMonth</span> <span class="operator">=</span> YearMonth.of(<span class="number">2020</span>, Month.FEBRUARY);</span><br><span class="line">    <span class="keyword">if</span> (yearMonth.lengthOfMonth() == <span class="number">29</span>) &#123;</span><br><span class="line">        System.out.println(yearMonth.getYear() + <span class="string">&quot;是闰年&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(yearMonth.getYear() + <span class="string">&quot;非闰年&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Java 8中检查是否闰年 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isLeapYearTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 除了通过YearMonth实例的lengthOfMonth()返回的天数判断是否闰年，还可以使用LocalDate的isLeapYear()方法直接判断是否为闰年</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="keyword">if</span> (today.isLeapYear()) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d is Leap year&quot;</span>, today.getYear());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d is not a Leap year&quot;</span>, today.getYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Java 8的Clock时钟类</span></span><br><span class="line"><span class="comment"> *      Java 8增加了一个 Clock 时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。</span></span><br><span class="line"><span class="comment"> *      JDK8以后，可以用 Clock 对象相应的方法替换 System.currentTimeInMillis() 和 TimeZone.getDefault() 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clockTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Returns the current time based on your system clock and set to UTC.（根据您的系统时钟返回当前时间，并将其设置为UTC。）</span></span><br><span class="line">    <span class="type">Clock</span> <span class="variable">clock</span> <span class="operator">=</span> Clock.systemUTC();</span><br><span class="line">    <span class="comment">// 获取当前时间的毫秒值, 相关于JDK8以前的System.currentTimeInMillis()方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Clock的millis()方法获取的毫秒值: &quot;</span> + clock.millis()); <span class="comment">// 1594568628639</span></span><br><span class="line">    System.out.println(<span class="string">&quot;System.currentTimeInMillis()的毫秒值: &quot;</span> + clock.millis()); <span class="comment">// 1594568628639</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns time based on system clock zone（根据系统时钟区域返回时间）</span></span><br><span class="line">    <span class="type">Clock</span> <span class="variable">defaultZoneClock</span> <span class="operator">=</span> Clock.systemDefaultZone();</span><br><span class="line">    System.out.println(<span class="string">&quot;系统所在时钟区域的Clock的毫秒值: &quot;</span> + defaultZoneClock.millis()); <span class="comment">// 1594568628711</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-使用示例"><a href="#9-3-使用示例" class="headerlink" title="9.3. 使用示例"></a>9.3. 使用示例</h3><h4 id="9-3-1-本地化日期时间-API"><a href="#9-3-1-本地化日期时间-API" class="headerlink" title="9.3.1. 本地化日期时间 API"></a>9.3.1. 本地化日期时间 API</h4><p>LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.Month;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Java8Tester</span> <span class="variable">java8tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">        java8tester.testLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLocalDateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前的日期时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">currentTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间: &quot;</span> + currentTime);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> currentTime.toLocalDate();</span><br><span class="line">        System.out.println(<span class="string">&quot;date1: &quot;</span> + date1);</span><br><span class="line">        <span class="type">Month</span> <span class="variable">month</span> <span class="operator">=</span> currentTime.getMonth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> currentTime.getDayOfMonth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">seconds</span> <span class="operator">=</span> currentTime.getSecond();</span><br><span class="line">        System.out.println(<span class="string">&quot;月: &quot;</span> + month + <span class="string">&quot;, 日: &quot;</span> + day + <span class="string">&quot;, 秒: &quot;</span> + seconds);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">date2</span> <span class="operator">=</span> currentTime.withDayOfMonth(<span class="number">10</span>).withYear(<span class="number">2012</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;date2: &quot;</span> + date2);</span><br><span class="line">        <span class="comment">// 12 december 2014</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date3</span> <span class="operator">=</span> LocalDate.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">12</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;date3: &quot;</span> + date3);</span><br><span class="line">        <span class="comment">// 22 小时 15 分钟</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">date4</span> <span class="operator">=</span> LocalTime.of(<span class="number">22</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;date4: &quot;</span> + date4);</span><br><span class="line">        <span class="comment">// 解析字符串</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">date5</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;20:15:30&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;date5: &quot;</span> + date5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前时间: 2019-07-22T10:57:38.601</span><br><span class="line">date1: 2019-07-22</span><br><span class="line">月: JULY, 日: 22, 秒: 38</span><br><span class="line">date2: 2012-07-10T10:57:38.601</span><br><span class="line">date3: 2014-12-12</span><br><span class="line">date4: 22:15</span><br><span class="line">date5: 20:15:30</span><br></pre></td></tr></table></figure>
<h4 id="9-3-2-使用时区的日期时间API"><a href="#9-3-2-使用时区的日期时间API" class="headerlink" title="9.3.2. 使用时区的日期时间API"></a>9.3.2. 使用时区的日期时间API</h4><p>需要考虑到时区，就可以使用时区的日期时间API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Java8Tester</span> <span class="variable">java8tester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Java8Tester</span>();</span><br><span class="line">        java8tester.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZonedDateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间日期</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">date1</span> <span class="operator">=</span> ZonedDateTime.parse(<span class="string">&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;date1: &quot;</span> + date1);</span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">id</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Europe/Paris&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ZoneId: &quot;</span> + id);</span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">currentZone</span> <span class="operator">=</span> ZoneId.systemDefault();</span><br><span class="line">        System.out.println(<span class="string">&quot;当期时区: &quot;</span> + currentZone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]</span><br><span class="line">ZoneId: Europe/Paris</span><br><span class="line">当期时区: Asia/Shanghai</span><br></pre></td></tr></table></figure>
<h2 id="10-Base64"><a href="#10-Base64" class="headerlink" title="10. Base64"></a>10. Base64</h2><ul>
<li>在 Java 8 中，Base64 编码已经成为Java类库的标准。内置了 Base64 编码的编码器和解码器。</li>
<li>Base64 工具类提供了一套静态方法获取下面三种BASE64编解码器：<ul>
<li><strong>基本</strong>：输出被映射到一组字符<code>A-Za-z0-9+/</code>，编码不添加任何行标，输出的解码仅支持<code>A-Za-z0-9+/</code></li>
<li><strong>URL</strong>：输出映射到一组字符<code>A-Za-z0-9+_</code>，输出是URL和文件</li>
<li><strong>MIME</strong>：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用<code>\r</code>并跟随<code>\n</code>作为分割。编码输出最后没有行分割</li>
</ul>
</li>
</ul>
<h3 id="10-1-内部类"><a href="#10-1-内部类" class="headerlink" title="10.1. 内部类"></a>10.1. 内部类</h3><ul>
<li><code>static class Base64.Decoder</code><ul>
<li>该类实现一个解码器用于，使用 Base64 编码来解码字节数据</li>
</ul>
</li>
<li><code>static class Base64.Encoder</code><ul>
<li>该类实现一个编码器，使用 Base64 编码来编码字节数据</li>
</ul>
</li>
</ul>
<h3 id="10-2-相关方法"><a href="#10-2-相关方法" class="headerlink" title="10.2. 相关方法"></a>10.2. 相关方法</h3><ul>
<li><code>static Base64.Decoder getDecoder()</code><ul>
<li>返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案</li>
</ul>
</li>
<li><code>static Base64.Encoder getEncoder()</code><ul>
<li>返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案</li>
</ul>
</li>
<li><code>static Base64.Decoder getMimeDecoder()</code><ul>
<li>返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案</li>
</ul>
</li>
<li><code>static Base64.Encoder getMimeEncoder()</code><ul>
<li>返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案</li>
</ul>
</li>
<li><code>static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)</code><ul>
<li>返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符</li>
</ul>
</li>
<li><code>static Base64.Decoder getUrlDecoder()</code><ul>
<li>返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案</li>
</ul>
</li>
<li><code>static Base64.Encoder getUrlEncoder()</code><ul>
<li>返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</li>
</ul>
</li>
</ul>
<p><em>注意：Base64 类的很多方法从 <code>java.lang.Object</code> 类继承</em></p>
<h3 id="10-3-Base64-实例"><a href="#10-3-Base64-实例" class="headerlink" title="10.3. Base64 实例"></a>10.3. Base64 实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Java8Tester</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用基本编码</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">base64encodedString</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(<span class="string">&quot;runoob?java8&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Base64 编码字符串 (基本) :&quot;</span> + base64encodedString);</span><br><span class="line">            <span class="comment">// 解码</span></span><br><span class="line">            <span class="type">byte</span>[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">            System.out.println(<span class="string">&quot;原始字符串: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(base64decodedBytes, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            base64encodedString = Base64.getUrlEncoder().encodeToString(<span class="string">&quot;TutorialsPoint?java8&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Base64 编码字符串 (URL) :&quot;</span> + base64encodedString);</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">byte</span>[] mimeBytes = stringBuilder.toString().getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">mimeEncodedString</span> <span class="operator">=</span> Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">            System.out.println(<span class="string">&quot;Base64 编码字符串 (MIME) :&quot;</span> + mimeEncodedString);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Error :&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出结果：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Base64 编码字符串 (基本) :cnVub29iP2phdmE4</span><br><span class="line">原始字符串: runoob?java8</span><br><span class="line">Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg=</span><br><span class="line">Base64 编码字符串 (MIME) :MmIxYmQ2NTQtZWU4OS00ZWQyLWFkYzctOWJlNDRlZDg2MDc5ZWQxM2FmNmYtYTExNi00OGEyLTlh</span><br><span class="line">NmYtZWE3NzQyZjc0MzA4ODIyN2Q1ODYtODIyYy00MGRkLTgyNWItYTNkN2NmYmZiMTdmYzcxN2U5</span><br><span class="line">ODgtYWMwNi00MDZjLWIyOWUtOTBmZjcyNTVkNDllNzYzYmMzODItYjkwNi00MTVhLTgwYWItYmEz</span><br><span class="line">NDI5YTVjMTFhZjE1MmE2M2UtZjdmNS00MWJlLTkxYTMtMjlhMmFkZGZhYjUwY2E0MTI1MzktMzlk</span><br><span class="line">Zi00NTYyLTllYzMtMWExMzlkODE1Njc3YTk0YzFiNWUtOGVhOC00Yjg1LTg4NTYtYjE0YzA3Mzc5</span><br><span class="line">ZDc3Mjc2MDdjZjUtYjA1ZC00N2U5LTlkODItZDk5YTliMDA1MmRkN2FkZTdjM2EtZTFhOS00Zjgz</span><br><span class="line">LTlkZjgtNWZjYWIyNzhjYjlk</span><br></pre></td></tr></table></figure>
<h2 id="11-JDK-8-重复注解与类型注解"><a href="#11-JDK-8-重复注解与类型注解" class="headerlink" title="11. JDK 8 重复注解与类型注解"></a>11. JDK 8 重复注解与类型注解</h2><h3 id="11-1-重复注解"><a href="#11-1-重复注解" class="headerlink" title="11.1. 重复注解"></a>11.1. 重复注解</h3><h4 id="11-1-1-重复注解的介绍"><a href="#11-1-1-重复注解的介绍" class="headerlink" title="11.1.1. 重复注解的介绍"></a>11.1.1. 重复注解的介绍</h4><p>自从 Java 5 中引入注解以来，在各个框架和项目中被广泛使用。不过注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。JDK 8 引入了重复注解的概念，允许在同一个地方多次使用同一个注解</p>
<p>在 JDK 8 中使用<code>@Repeatable</code>注解定义重复注解。</p>
<h4 id="11-1-2-重复注解的使用步骤"><a href="#11-1-2-重复注解的使用步骤" class="headerlink" title="11.1.2. 重复注解的使用步骤"></a>11.1.2. 重复注解的使用步骤</h4><ol>
<li>定义一个可以重复的注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyRepeatableContainer.class)</span></span><br><span class="line"><span class="meta">@interface</span> MyRepeatableAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义重复的注解容器注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyRepeatableContainer &#123;</span><br><span class="line">    <span class="comment">// 定义重复注解容器的属性</span></span><br><span class="line">    MyRepeatableAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在测试类中配置多个重复的注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 3. 在类中标识重复注解 */</span></span><br><span class="line"><span class="meta">@MyRepeatableAnnotation(&quot;AA&quot;)</span></span><br><span class="line"><span class="meta">@MyRepeatableAnnotation(&quot;BB&quot;)</span></span><br><span class="line"><span class="meta">@MyRepeatableAnnotation(&quot;CC&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01RepeatableAnnotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 在方法中标识重复注解 */</span></span><br><span class="line">    <span class="meta">@MyRepeatableAnnotation(&quot;XX&quot;)</span></span><br><span class="line">    <span class="meta">@MyRepeatableAnnotation(&quot;YY&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>解析得到指定注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Class与Method对象的 getAnnotationsByType 方法是新增的API，用于获取重复的注解 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repeatableAnnotationTest</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    <span class="comment">// 获取类上的重复注解</span></span><br><span class="line">    MyRepeatableAnnotation[] repeatableAnnos = RepeatableAnnotationDemo.class</span><br><span class="line">            .getAnnotationsByType(MyRepeatableAnnotation.class);</span><br><span class="line">    <span class="comment">// 循环输出重复注解值</span></span><br><span class="line">    <span class="keyword">for</span> (MyRepeatableAnnotation repeatableAnno : repeatableAnnos) &#123;</span><br><span class="line">        System.out.println(repeatableAnno + <span class="string">&quot; 重复注解（标识在类上）的value值为: &quot;</span> + repeatableAnno.value());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取方法上的重复注解</span></span><br><span class="line">    MyRepeatableAnnotation[] methodRepeatableAnnos = RepeatableAnnotationDemo.class</span><br><span class="line">            .getMethod(<span class="string">&quot;foo&quot;</span>).getAnnotationsByType(MyRepeatableAnnotation.class);</span><br><span class="line">    <span class="keyword">for</span> (MyRepeatableAnnotation repeatableAnno : methodRepeatableAnnos) &#123;</span><br><span class="line">        System.out.println(repeatableAnno + <span class="string">&quot; 重复注解（标识在方法上）的value值为: &quot;</span> + repeatableAnno.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-类型注解"><a href="#11-2-类型注解" class="headerlink" title="11.2. 类型注解"></a>11.2. 类型注解</h3><p>JDK 8为<code>@Target</code>元注解新增了两种类型：<code>TYPE_PARAMETER</code>，<code>TYPE_USE</code></p>
<ul>
<li><code>TYPE_PARAMETER</code>：表示该注解能写在类型参数的声明语句中。类型参数声明如：<code>&lt;T&gt;</code></li>
<li><code>TYPE_USE</code>：表示注解可以再任何用到类型的地方使用</li>
</ul>
<h4 id="11-2-1-TYPE-PARAMETER-类型的使用"><a href="#11-2-1-TYPE-PARAMETER-类型的使用" class="headerlink" title="11.2.1. TYPE_PARAMETER 类型的使用"></a>11.2.1. TYPE_PARAMETER 类型的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标识在类上的泛型前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeParameterDemo</span>&lt;<span class="meta">@MyTypeParameter</span> T&gt; &#123;</span><br><span class="line">    <span class="comment">// 标识在方法上的泛型前</span></span><br><span class="line">    <span class="keyword">public</span> &lt;<span class="meta">@MyTypeParameter</span> E <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义TYPE_PARAMETER类型的注解</span></span><br><span class="line"><span class="comment"> * 表示该注解能写在类型参数的声明语句中。类型参数声明如：&lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_PARAMETER)</span></span><br><span class="line"><span class="meta">@interface</span> MyTypeParameter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-2-2-TYPE-USE-类型的使用"><a href="#11-2-2-TYPE-USE-类型的使用" class="headerlink" title="11.2.2. TYPE_USE 类型的使用"></a>11.2.2. TYPE_USE 类型的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TypeUseDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 在类属性类型前使用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@MyTypeUse</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在方法形参的类型前使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="meta">@MyTypeUse</span> String str, <span class="meta">@MyTypeUse</span> <span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="comment">// 在方法内的变量类型前使用</span></span><br><span class="line">        <span class="meta">@MyTypeUse</span> <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">10.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义TYPE_USE类型的注解</span></span><br><span class="line"><span class="comment"> * 表示注解可以再任何用到类型的地方使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="meta">@interface</span> MyTypeUse &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io">蓝桉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io/posts/8bebd4ec.html">https://ktzxy.github.io/posts/8bebd4ec.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ktzxy.github.io" target="_blank">蓝桉`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/bg/Image00018.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src="/img/wechat.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src="/img/alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/e7476577.html" title="Java基础-XML"><img class="cover" src="/bg/Image00014.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java基础-XML</div></div><div class="info-2"><div class="info-item-1">Java 基础 - XML1. XML 概述XML 的全称 Extensible Markup Language，中文：可扩展标记语言。XML 是一门语言，由 w3c 组织制定。 XML 是使用标记来描述数据格式，标记又叫标签，元素。标签又分为开始标签和结束标签，比如&lt;name&gt;是开始标签，&lt;/name&gt;是结束标签。 1.1. 作用 用于描述数据(关系型数据)，存储数据，可以当成一个小型数据库使用。 作为框架的配置文件(structs.xml, hibernate.cfg.xml…)。好处是可以提升软件的灵活性。如：数据库的配置、JavaBean 的配置。使用时的数据可以查看不同的 xml 配置文件。 可以用于不同的平台之间进行数据交换# Java基础 - XML   XML 被设计用来描述数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。  1.2. XML 的约束XML 约束是用来规定 XML 文件中应该出现哪些标签，哪些属性，每个属性的取值有哪些。其作用是：  约束XML文件结构 让XML文档的书写更加规范  1.2.1. ...</div></div></div></a><a class="pagination-related" href="/posts/1c4cf2d9.html" title="Java基础-JDK常用API"><img class="cover" src="/bg/Image00019.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java基础-JDK常用API</div></div><div class="info-2"><div class="info-item-1">1. Date 类 (在util包中)通过该类可以获得当前的日期和时间。 1.1. Date 构造方法1public Date()  获得当前的系统时间，直接输出对象的结果是系统默认的显示格式。  1public Date(long date)  根据指定的毫秒值创建日期对象，返回指定毫秒值的日期对象，(从时间零点到指定时间为止)  1.2. Date常用成员方法1public long getTime();  获得当前时间的毫秒值 (从时间零点到当前时间之间共多少毫秒) 毫秒的概念： 1秒 = 1000毫秒 时间零点：1970年1月1日  00:00:00    1public void setTime(long time);  将时间设置到指定的毫秒值上  2. DateFormat 类 / SimpleDateFormat 子类2.1. DateFormat概念 DateFormat:日期格式化类； 是一个抽象类，不能直接创建对象。 可以使用其子类SimpleDateFormat来创建对象。重写了DateFormat所有抽象方法。   SimpleDateFormat:实际...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/4e9c3100.html" title="Java基础-网络编程"><img class="cover" src="/bg/Image00026.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Java基础-网络编程</div></div><div class="info-2"><div class="info-item-1">1. 网络编程概述在计算机领域中，网络是信息传输、接收、共享的虚拟平台，将各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络编程的作用：解决计算机与计算机数据传输的问题。 网络体系大致分为三种：OSI七层模型、TCP/IP四层模型和五层模型。  Tips: 一般面试的时候考察比较多的是五层模型。  1.1. 网络通讯三要素1.1.1. IP地址IP 是每台电脑在互联网上的唯一标识符。一个 IPV4 的地址是由四段 0—255 的数字组成：192.168.0.100，每一段的取值范围由8位二进制数据组成。 IPv6 使用 16 个字节表示 IP 地址，它所拥有的地址容量约是 IPv4 的 8×1028倍，达到 2128个。  Notes:   127.0.0.1 为本地主机地址(本地回环地址)，与 localhost 类似，均代表本机地址 xxx.xxx.xxx.255 广播地址，即该网段下所有用户均可以被通知到   例如在 windows 系统中，可以通过以下命令来获取 ip 与网络相关内容： 1ipconfig  用于DOS获取计算机IP设置  1ping ip地址 ...</div></div></div></a><a class="pagination-related" href="/posts/2af7de89.html" title="Day-0-IDEA简单学习"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-0-IDEA简单学习</div></div><div class="info-2"><div class="info-item-1">﻿# Day-0-IDEA简单学习 1.设置主题 2.编辑区的字体变大或者变小：（ctrl+鼠标滚轮） 3.鼠标悬浮在代码上有提示： 4.自动导包和优化多余的包：手动导包：快捷键：alt+enter自动导包和优化多余的包：  5.显示行号 ，  方法和方法间的分隔符： 6.忽略大小写，进行提示： 7.修改代码中注释的字体颜色： 8.修改类头的文档注释信息：注意：对新建的类才有效/**  @Auther: XXX @Date: ${DATE} - ${MONTH} - ${DAY} - ${TIME}  @Description: ${PACKAGE_NAME} @version: 1.0*/   8.自动编译： 9.常用快捷键【1】创建内容：alt+insert 【2】main方法：psvm 【3】输出语句：sout 【4】复制行：ctrl+d 【5】删除行：ctrl+y 【6】代码向上/下移动：Ctrl + Shift + Up / Down 【7】搜索类：  ctrl+n 【8】生成代码  ：alt + Insert（如构造函数等，getter,setter,hashCode...</div></div></div></a><a class="pagination-related" href="/posts/72ba03f7.html" title="Day-02-java基础语法"><img class="cover" src="/bg/Image00027.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-02-java基础语法</div></div><div class="info-2"><div class="info-item-1">﻿ Day-02-java基础语法快捷键操作 psvm —&gt;快速生成public static void main(String[] args) {} sout —&gt;快速生成System.out.println();  可能会遇到的问题  每个单词的大小不能出现问题，==Java是大小写敏感的==； 尽量使用英文； 文件名和类名必须保证一致，并且首字母大写； 符号使用的了中文。   Java运行机制  编译型 解释型    注释：Java中的注释有三种： 12345678910注释：    单行注释：    //我是单行注释    多行注释      /*我是多行注释*/    文档注释    /**    *@description  HelloWrold    *@Author 作者    */ 标识符：关键字 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 标识符注意点 所有的标识符都应该以字母(A-Z或者a-z),美元符（$)、数字或者下划线(_)开始首字符之后可以是字母（A-Z或者a-z),美元符（$)、下划线(_)或数字的任何字符...</div></div></div></a><a class="pagination-related" href="/posts/369b2118.html" title="Day-03-java流程控制"><img class="cover" src="/bg/Image00020.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-03-java流程控制</div></div><div class="info-2"><div class="info-item-1">﻿ Day-03-java流程控制Scanner对象java.util.Scanner是Java5的新特性，我们可以通过Scanner类来获取用户的输入。 基本语法 1Scanner s = new Scanner(System.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext() 与hasNextLine()判断是否还有输入的数据。 12345678910111213public static void main(String[] args) &#123;    //创建一个扫描对象，用于接受键盘数据    Scanner scanner = new Scanner(System.in);    System.out.println(&quot;使用next方式接受：&quot;);    //判断用户有没有输入字符串    if (scanner.hasNext())&#123;        //使用next方式接受        String str = scanner.next();     ...</div></div></div></a><a class="pagination-related" href="/posts/bbaa91bf.html" title="Day-04-java方法详解"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-04-java方法详解</div></div><div class="info-2"><div class="info-item-1">﻿ Day-04-java方法详解何谓方法？​    System.out.println(),那么它是什么呢? ​    调用系统类里的标准输出对象out中的方法println ​    Java方法是语句的集合，它们在一起执行一个功能。 ​    方法是解决一类问题的步骤的有序组合 ​    方法包含于类或对象中，方法和方法是并列的关系，所以我们定义的方法不能写到main方法中 ​    方法在程序中被创建，在其他地方被引用 ​    设计方法的原则:方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。 方法的定义Java的方法类似争其它语言的函数,是一段用来完成特定功能的代码片段，一股情况卜，定义一个方法包含以下语法: 方法包含一个方法头和一个方法体。 下面是一个方法的所有部分: 修饰符:修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型∶方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。...</div></div></div></a><a class="pagination-related" href="/posts/cccc6599.html" title="Day-06-java面向对象"><img class="cover" src="/bg/Image00022.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-06-java面向对象</div></div><div class="info-2"><div class="info-item-1">﻿ Day-06-java面向对象什么是面向对象面向对象编程(Object-Oriented Programming, OOP) 面向对象编程的本质就是:==以类的方式组织代码，以对象的组织(封装)数据。== 抽象 三大特性: ​        封装 ​        继承 ​        多态从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象 从代码运行角度考虑是先有类后有对象。类是对象的模板。 回顾方法及加深方法的定义 修饰符 返回类型 ==break: 跳出switch，结束循环和return的区别方法名== 参数列表 异常抛出 方法的调用        静态方法 ​        非静态方法 ​        形参和实参 ​        值传递和引用传递 ​        this关键字 12345678910111213141516171819202122232425//demo1  类public class demo1 &#123;    //main方法    public static void main(String[] a...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">蓝桉</div><div class="author-info-description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">生活、学习、技术</b>相关的问题和看法，还有<b style="color:#fff">文章教程</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ktzxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/ktzxy" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2251511764@qq.com" target="_blank" title="Email"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-RSS"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/496148176" target="_blank" title="BiliBili"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QX-BILIBILI"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2251511764&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java-8-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. Java 8 新特性概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">2. Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. Lambda 表达式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. Lambda 表达式语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Lambda%E7%9A%84%E6%A0%87%E5%87%86%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1. Lambda的标准语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E9%87%8D%E8%A6%81%E7%89%B9%E5%BE%81%EF%BC%88%E5%8F%AF%E7%9C%81%E7%95%A5%E8%A7%84%E5%88%99%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2. lambda表达式的重要特征（可省略规则）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E4%BD%BF%E7%94%A8-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3. 使用 Lambda 表达式前提条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. Lambda 表达式示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B1"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 基础综合示例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B2"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 综合示例2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E6%97%A0%E5%8F%82%E6%95%B0%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84Lambda"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3. 无参数无返回值的Lambda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E6%9C%89%E5%8F%82%E6%95%B0%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84Lambda"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4. 有参数有返回值的Lambda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E7%9C%81%E7%95%A5%E6%A0%BC%E5%BC%8F%E7%9A%84Lambda"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.3.5. 省略格式的Lambda</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Lambda%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%EF%BC%81%E5%BE%85%E6%95%B4%E7%90%86%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. Lambda的实现原理（！待整理）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E4%B8%8E%E6%A3%80%E6%9F%A5"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. 类型推断与检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-this-%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. this 指向对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.5.</span> <span class="toc-text">2.5. 变量作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.2. 使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Lambda-%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text">2.6. Lambda 和匿名内部类对比总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">3. 方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 方法引用语法格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%B8%B8%E8%A7%81%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 常见引用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. 实例对象普通方法的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E7%B1%BB%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. 类静态方法的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E5%8F%82%E6%95%B0%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3. 参数类方法的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4. 构造方法的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5. 数组构造器的引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%94%A8%E6%B3%95%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 方法引用用法综合示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JDK8-%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4. JDK8 接口的默认方法与静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-JDK-8%E6%8E%A5%E5%8F%A3%E5%A2%9E%E5%BC%BA%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. JDK 8接口增强介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%8E%A5%E5%8F%A3%E5%BC%95%E5%85%A5%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E7%9A%84%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1. 接口引入默认方法的背景介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2. 接口默认方法语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3. 接口默认方法的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E5%A4%9A%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4. 多个默认方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%9D%99%E6%80%81%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 静态默认方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1. 接口默认方法语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E6%8E%A5%E5%8F%A3%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2. 接口静态方法的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. 接口默认方法和静态方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%B8%8E%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. 默认方法与默认方法综合示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Java-8-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">5. Java 8 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-FunctionalInterface-%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. @FunctionalInterface 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%9B%B8%E5%85%B3Java%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 相关Java内置函数式接口接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. 常用内置函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-Supplier-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1. Supplier 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-Consumer-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2. Consumer 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">5.4.2.1. 基础使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-2-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%EF%BC%9AandThen"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">5.4.2.2. 默认方法：andThen()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-Function-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3. Function 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">5.4.3.1. 基础使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-2-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%EF%BC%9AandThen"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">5.4.3.2. 默认方法：andThen()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-Predicate-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.4.</span> <span class="toc-text">5.4.4. Predicate 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-4-1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">5.4.4.1.</span> <span class="toc-text">5.4.4.1. 基础使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-4-2-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%EF%BC%9Aand%E3%80%81or%E3%80%81negate"><span class="toc-number">5.4.4.2.</span> <span class="toc-text">5.4.4.2. 默认方法：and、or、negate</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 函数式接口应用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E9%80%9A%E7%94%A8-Builder-%E9%93%BE%E5%BC%8F%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1. 实现对象通用 Builder 链式设置属性值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Stream-%E6%B5%81"><span class="toc-number">6.</span> <span class="toc-text">6. Stream 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF-Stream%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 什么是 Stream？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%89%B9%E6%80%A7%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 流的操作特性（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. 流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1. 流的操作类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E6%B5%81%E7%9A%84API%E6%96%B9%E6%B3%95%E5%AF%B9%E5%BA%94%E5%88%86%E7%B1%BB"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2. 流的API方法对应分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%B5%81%E7%9A%84%E5%B8%B8%E7%94%A8%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. 流的常用创建方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-Collection-%E4%B8%8B%E7%9A%84-stream-%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1. Collection 下的 stream() 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-Stream-%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9Aof-%E3%80%81iterate-%E3%80%81generate"><span class="toc-number">6.4.2.</span> <span class="toc-text">6.4.2. Stream 中的静态方法：of()、iterate()、generate()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-Arrays-stream"><span class="toc-number">6.4.3.</span> <span class="toc-text">6.4.3. Arrays.stream()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-4-BufferedReader-lines"><span class="toc-number">6.4.4.</span> <span class="toc-text">6.4.4. BufferedReader.lines()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-5-Pattern-splitAsStream"><span class="toc-number">6.4.5.</span> <span class="toc-text">6.4.5. Pattern.splitAsStream()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E6%B5%81%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-number">6.5.</span> <span class="toc-text">6.5. 流的中间操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1-map-%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.1.</span> <span class="toc-text">6.5.1. map 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-flatMap-%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.2.</span> <span class="toc-text">6.5.2. flatMap 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-3-filter-%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.3.</span> <span class="toc-text">6.5.3. filter 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-4-limit-%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.4.</span> <span class="toc-text">6.5.4. limit 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-5-skip-%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.5.</span> <span class="toc-text">6.5.5. skip 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-6-distinct-%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.6.</span> <span class="toc-text">6.5.6. distinct 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-7-sorted-%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.7.</span> <span class="toc-text">6.5.7. sorted 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-8-peek-%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.8.</span> <span class="toc-text">6.5.8. peek 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E6%B5%81%E7%9A%84%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">6.6.</span> <span class="toc-text">6.6. 流的终止操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-forEach-%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">6.6.1. forEach 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-count-%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.2.</span> <span class="toc-text">6.6.2. count 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-match-%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.3.</span> <span class="toc-text">6.6.3. match 相关方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-4-find-%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.4.</span> <span class="toc-text">6.6.4. find 相关方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-5-max-%E5%92%8C-min-%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.5.</span> <span class="toc-text">6.6.5. max 和 min 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-6-reduce-%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.6.</span> <span class="toc-text">6.6.6. reduce 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-6-1-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.6.6.1.</span> <span class="toc-text">6.6.6.1. 功能介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-6-2-%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3API"><span class="toc-number">6.6.6.2.</span> <span class="toc-text">6.6.6.2. 源码相关API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-6-3-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.6.6.3.</span> <span class="toc-text">6.6.6.3. 基础使用示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-6-6-4-%E9%85%8D%E5%90%88map%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.6.6.4.</span> <span class="toc-text">6.6.6.4. 配合map方法使用示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-7-mapToInt%E3%80%81mapToLong%E3%80%81mapToDouble-%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.7.</span> <span class="toc-text">6.6.7. mapToInt、mapToLong、mapToDouble 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-8-concat-%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.8.</span> <span class="toc-text">6.6.8. concat 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-Stream-%E6%B5%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="toc-number">6.7.</span> <span class="toc-text">6.7. Stream 流数据的收集操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-1-collect-%E6%96%B9%E6%B3%95"><span class="toc-number">6.7.1.</span> <span class="toc-text">6.7.1. collect 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-2-Collector-%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.7.2.</span> <span class="toc-text">6.7.2. Collector 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-3-Collector-%E5%B7%A5%E5%85%B7%E5%BA%93%EF%BC%9ACollectors"><span class="toc-number">6.7.3.</span> <span class="toc-text">6.7.3. Collector 工具库：Collectors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-4-%E6%94%B6%E9%9B%86-Stream-%E6%B5%81%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%9C%E5%88%B0%E9%9B%86%E5%90%88%E4%B8%AD"><span class="toc-number">6.7.4.</span> <span class="toc-text">6.7.4. 收集 Stream 流中的结果到集合中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-5-%E6%94%B6%E9%9B%86-Stream-%E6%B5%81%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%9C%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD"><span class="toc-number">6.7.5.</span> <span class="toc-text">6.7.5. 收集 Stream 流中的结果到数组中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-6-%E5%AF%B9%E6%B5%81%E4%B8%AD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%81%9A%E5%90%88%E3%80%81%E7%BB%9F%E8%AE%A1%E8%AE%A1%E7%AE%97"><span class="toc-number">6.7.6.</span> <span class="toc-text">6.7.6. 对流中数据进行聚合、统计计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-7-%E5%AF%B9%E6%B5%81%E4%B8%AD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84"><span class="toc-number">6.7.7.</span> <span class="toc-text">6.7.7. 对流中数据进行分组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-7-1-%E5%8D%95%E4%B8%AA%E5%88%86%E7%BB%84"><span class="toc-number">6.7.7.1.</span> <span class="toc-text">6.7.7.1. 单个分组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-7-7-2-%E5%A4%9A%E7%BA%A7%E5%88%86%E7%BB%84"><span class="toc-number">6.7.7.2.</span> <span class="toc-text">6.7.7.2. 多级分组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-8-%E5%AF%B9%E6%B5%81%E4%B8%AD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%BA"><span class="toc-number">6.7.8.</span> <span class="toc-text">6.7.8. 对流中数据进行分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-9-%E5%AF%B9%E6%B5%81%E4%B8%AD%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8B%BC%E6%8E%A5"><span class="toc-number">6.7.9.</span> <span class="toc-text">6.7.9. 对流中数据进行拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-10-Collectors-toList-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">6.7.10.</span> <span class="toc-text">6.7.10. Collectors.toList() 源码解析（了解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E5%B9%B6%E8%A1%8C%E7%9A%84-Stream-%E6%B5%81"><span class="toc-number">6.8.</span> <span class="toc-text">6.8. 并行的 Stream 流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-1-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">6.8.1.</span> <span class="toc-text">6.8.1. 创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-2-%E5%B9%B6%E8%A1%8C-Stream-%E6%B5%81%E5%AE%9A%E4%B9%89"><span class="toc-number">6.8.2.</span> <span class="toc-text">6.8.2. 并行 Stream 流定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-3-%E4%B8%B2%E8%A1%8C%E4%B8%8E%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-number">6.8.3.</span> <span class="toc-text">6.8.3. 串行与并行流的效率对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-4-parallelStream-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">6.8.4.</span> <span class="toc-text">6.8.4. parallelStream 线程安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-5-parallelStream-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.8.5.</span> <span class="toc-text">6.8.5. parallelStream 底层实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-8-5-1-Fork-Join-%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.8.5.1.</span> <span class="toc-text">6.8.5.1. Fork&#x2F;Join 框架介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-8-5-2-Fork-Join-%E5%8E%9F%E7%90%86-%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">6.8.5.2.</span> <span class="toc-text">6.8.5.2. Fork&#x2F;Join 原理-分治法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-8-5-3-Fork-Join-%E5%8E%9F%E7%90%86-%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95"><span class="toc-number">6.8.5.3.</span> <span class="toc-text">6.8.5.3. Fork&#x2F;Join 原理-工作窃取算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-8-5-4-Fork-Join-%E6%A1%88%E4%BE%8B"><span class="toc-number">6.8.5.4.</span> <span class="toc-text">6.8.5.4. Fork&#x2F;Join 案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-6-%E6%80%BB%E7%BB%93"><span class="toc-number">6.8.6.</span> <span class="toc-text">6.8.6. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-Stream-%E5%AE%8C%E6%95%B4%E5%AE%9E%E4%BE%8B"><span class="toc-number">6.9.</span> <span class="toc-text">6.9. Stream 完整实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-1-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B1"><span class="toc-number">6.9.1.</span> <span class="toc-text">6.9.1. 综合示例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-2-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B2"><span class="toc-number">6.9.2.</span> <span class="toc-text">6.9.2. 综合示例2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-Stream-%E6%B5%81%E6%9C%80%E4%BD%B3%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-number">6.10.</span> <span class="toc-text">6.10. Stream 流最佳使用技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-StringJoiner-%E7%B1%BB%EF%BC%88%E5%AD%97%E7%AC%A6%E6%8B%BC%E6%8E%A5%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">7. StringJoiner 类（字符拼接）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. 构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">7.3. 基础用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-StringJoiner-%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.3.1.</span> <span class="toc-text">7.3.1. StringJoiner 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-Stream-%E6%B5%81%E7%9A%84-joining-%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.2.</span> <span class="toc-text">7.3.2. Stream 流的 joining 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-3-String-%E7%B1%BB%E7%9A%84-join-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.3.</span> <span class="toc-text">7.3.3. String 类的 join 静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">7.4. 实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-StringJoiner"><span class="toc-number">7.4.1.</span> <span class="toc-text">7.4.1. StringJoiner</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-Collector-joining"><span class="toc-number">7.4.2.</span> <span class="toc-text">7.4.2. Collector.joining</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-3-String-join"><span class="toc-number">7.4.3.</span> <span class="toc-text">7.4.3. String.join</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93"><span class="toc-number">7.5.</span> <span class="toc-text">7.5. 使用场景总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Optional-%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">8. Optional 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E7%B1%BB%E5%A3%B0%E6%98%8E"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. 类声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Optional-%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. Optional 类型说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Optional-%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">8.3.</span> <span class="toc-text">8.3. Optional 创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">8.4. 类的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-get-%E4%B8%8E-isPresent"><span class="toc-number">8.4.1.</span> <span class="toc-text">8.4.1. get() 与 isPresent()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-orElse-%E3%80%81orElseGet-%E4%B8%8E-orElseThrow"><span class="toc-number">8.4.2.</span> <span class="toc-text">8.4.2. orElse()、orElseGet() 与 orElseThrow()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-ifPresent"><span class="toc-number">8.4.3.</span> <span class="toc-text">8.4.3. ifPresent()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-4-map-%E4%B8%8E-flatMap"><span class="toc-number">8.4.4.</span> <span class="toc-text">8.4.4. map() 与 flatMap()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-5-filter"><span class="toc-number">8.4.5.</span> <span class="toc-text">8.4.5. filter()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-6-%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.6.</span> <span class="toc-text">8.4.6. 其他常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-Optional-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.5.</span> <span class="toc-text">8.5. Optional 使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-%E7%A4%BA%E4%BE%8B1"><span class="toc-number">8.5.1.</span> <span class="toc-text">8.5.1. 示例1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-%E7%A4%BA%E4%BE%8B2"><span class="toc-number">8.5.2.</span> <span class="toc-text">8.5.2. 示例2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-JDK8-%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4-API"><span class="toc-number">9.</span> <span class="toc-text">9. JDK8 新的日期和时间 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%97%A7%E7%89%88%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. 旧版日期时间 API 存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. 新的日期时间 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-JDK-8%E7%9A%84%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="toc-number">9.2.1.</span> <span class="toc-text">9.2.1. JDK 8的日期和时间类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-JDK-8%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-number">9.2.2.</span> <span class="toc-text">9.2.2. JDK 8的时间格式化与解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3-JDK-8%E7%9A%84-Instant-%E7%B1%BB"><span class="toc-number">9.2.3.</span> <span class="toc-text">9.2.3. JDK 8的 Instant 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-4-JDK-8%E7%9A%84%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%B7%AE%E7%B1%BB"><span class="toc-number">9.2.4.</span> <span class="toc-text">9.2.4. JDK 8的计算日期时间差类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-5-JDK-8%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%A1%E6%AD%A3%E5%99%A8"><span class="toc-number">9.2.5.</span> <span class="toc-text">9.2.5. JDK 8的时间校正器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-6-JDK-8%E8%AE%BE%E7%BD%AE%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%97%B6%E5%8C%BA"><span class="toc-number">9.2.6.</span> <span class="toc-text">9.2.6. JDK 8设置日期时间的时区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-7-JDK8-%E5%85%B6%E4%BB%96%E7%9A%84API%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.2.7.</span> <span class="toc-text">9.2.7. JDK8 其他的API使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.3.</span> <span class="toc-text">9.3. 使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E6%9C%AC%E5%9C%B0%E5%8C%96%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API"><span class="toc-number">9.3.1.</span> <span class="toc-text">9.3.1. 本地化日期时间 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-%E4%BD%BF%E7%94%A8%E6%97%B6%E5%8C%BA%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-number">9.3.2.</span> <span class="toc-text">9.3.2. 使用时区的日期时间API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Base64"><span class="toc-number">10.</span> <span class="toc-text">10. Base64</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.1.</span> <span class="toc-text">10.1. 内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.</span> <span class="toc-text">10.2. 相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-Base64-%E5%AE%9E%E4%BE%8B"><span class="toc-number">10.3.</span> <span class="toc-text">10.3. Base64 实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-JDK-8-%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">11.</span> <span class="toc-text">11. JDK 8 重复注解与类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="toc-number">11.1.</span> <span class="toc-text">11.1. 重复注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.1.</span> <span class="toc-text">11.1.1. 重复注解的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2-%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">11.1.2.</span> <span class="toc-text">11.1.2. 重复注解的使用步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">11.2.</span> <span class="toc-text">11.2. 类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-TYPE-PARAMETER-%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.1.</span> <span class="toc-text">11.2.1. TYPE_PARAMETER 类型的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-2-TYPE-USE-%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.2.</span> <span class="toc-text">11.2.2. TYPE_USE 类型的使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img src="/bg/Image00018.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库150道高频面试题"/></a><div class="content"><a class="title" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题">MySQL数据库150道高频面试题</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术同学必会的MySQL设计规约"/></a><div class="content"><a class="title" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约">技术同学必会的MySQL设计规约</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dfdfdf4.html" title="数据库概述"><img src="/bg/Image00002.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库概述"/></a><div class="content"><a class="title" href="/posts/dfdfdf4.html" title="数据库概述">数据库概述</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/490575ab.html" title="24工厂模式俗话解释"><img src="/bg/Image00024.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24工厂模式俗话解释"/></a><div class="content"><a class="title" href="/posts/490575ab.html" title="24工厂模式俗话解释">24工厂模式俗话解释</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/364ea8cc.html" title="设计模式"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/364ea8cc.html" title="设计模式">设计模式</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2020 - 2025 By 蓝桉</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8152976493" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat/cat.js"></script><script async data-pjax src="/js/meting/music_lanan.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/day/lunar.js"></script><script defer src="/js/day/day.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '10a7db1c41b6489db9c830c668a18304';
  var gaud_map_key = '82a64bc994fb6494830f157f319f9f69';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime/runtime.min.js"></script><script async src="/js/font/ali_font_all.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>
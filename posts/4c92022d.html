<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础-IO编程 | 蓝桉`Blog</title><meta name="author" content="蓝桉,kt_zxh@163.com"><meta name="copyright" content="蓝桉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. IO 流1.1. 数据在计算机的表现形式所有数据(视频、音频、图片、文本文件)在计算机中都是由0和1组成。计算机只能识别0和1； 数据在计算机的表现形式就是：二进制数据。在数据传输过程中，一切数据(文本、图像、声音等)最终存储的均为一个个字节，即二进制数字。所以数据传输过程中使用二进制数据可以完成任意数据的传递，任何数据在传输过程中都是以0和1格式传输。 向一个文件中存储一定的数据(一些数字">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础-IO编程">
<meta property="og:url" content="https://ktzxy.github.io/posts/4c92022d.html">
<meta property="og:site_name" content="蓝桉&#96;Blog">
<meta property="og:description" content="1. IO 流1.1. 数据在计算机的表现形式所有数据(视频、音频、图片、文本文件)在计算机中都是由0和1组成。计算机只能识别0和1； 数据在计算机的表现形式就是：二进制数据。在数据传输过程中，一切数据(文本、图像、声音等)最终存储的均为一个个字节，即二进制数字。所以数据传输过程中使用二进制数据可以完成任意数据的传递，任何数据在传输过程中都是以0和1格式传输。 向一个文件中存储一定的数据(一些数字">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ktzxy.github.io/bg/Image00008.webp">
<meta property="article:published_time" content="2025-07-09T17:28:45.000Z">
<meta property="article:modified_time" content="2025-07-13T15:45:18.460Z">
<meta property="article:author" content="蓝桉">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ktzxy.github.io/bg/Image00008.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础-IO编程",
  "url": "https://ktzxy.github.io/posts/4c92022d.html",
  "image": "https://ktzxy.github.io/bg/Image00008.webp",
  "datePublished": "2025-07-09T17:28:45.000Z",
  "dateModified": "2025-07-13T15:45:18.460Z",
  "author": [
    {
      "@type": "Person",
      "name": "蓝桉",
      "url": "https://ktzxy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ktzxy.github.io/posts/4c92022d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础-IO编程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/windmill/windmill.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/meting/music_lanan.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="蓝桉`Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/bg.webp);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/bg/Image00008.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">蓝桉`Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础-IO编程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java基础-IO编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-09T17:28:45.000Z" title="发表于 2025-07-09 17:28:45">2025-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-13T15:45:18.460Z" title="更新于 2025-07-13 15:45:18">2025-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-IO-流"><a href="#1-IO-流" class="headerlink" title="1. IO 流"></a>1. IO 流</h2><h3 id="1-1-数据在计算机的表现形式"><a href="#1-1-数据在计算机的表现形式" class="headerlink" title="1.1. 数据在计算机的表现形式"></a>1.1. 数据在计算机的表现形式</h3><p>所有数据(视频、音频、图片、文本文件)在计算机中都是由0和1组成。计算机只能识别0和1；</p>
<p>数据在计算机的表现形式就是：<strong>二进制数据</strong>。在数据传输过程中，一切数据(文本、图像、声音等)最终存储的均为一个个字节，即二进制数字。所以数据传输过程中使用二进制数据可以完成任意数据的传递，<font color=red><strong>任何数据在传输过程中都是以0和1格式传输</strong></font>。</p>
<p>向一个文件中存储一定的数据(一些数字)，如果使用文本方式打开，则会以文本的方式解释数据。如果以视频的方式打开，则会以视频的方式解释数据。音频、可行执行文件等亦是如此。所以，在文件传输过程中，要时刻明确，传输的始终为二进制数据。</p>
<h3 id="1-2-IO-的概念"><a href="#1-2-IO-的概念" class="headerlink" title="1.2. IO 的概念"></a>1.2. IO 的概念</h3><h4 id="1-2-1-IO-操作"><a href="#1-2-1-IO-操作" class="headerlink" title="1.2.1. IO 操作"></a>1.2.1. IO 操作</h4><p>IO 操作，是指输入和输出操作。</p>
<ul>
<li>Input(输入操作)：数据从文件到程序的过程。</li>
<li>Output(输出操作)：数据从程序到文件的过程。</li>
</ul>
<p>例如：当使用集合保存数据时，这些数据都存在于内存中，一旦程序运行结束，这些数据将会从内存中清除，下次再想使用这些数据，已经没有了。如果希望将运算结果永久地保存下来，可以使用 IO，将这些数据持久化存储起来。要把数据持久化存储就需要把内存中的数据存储到内存以外的其他持久化设备(硬盘、光盘、U 盘等)上。此时需要数据的输入(in)输出(out)。数据输入输出相关的类均在 io 包下。</p>
<h4 id="1-2-2-IO-流"><a href="#1-2-2-IO-流" class="headerlink" title="1.2.2. IO 流"></a>1.2.2. IO 流</h4><p>按流向可分为两种：输入流（I），输出流（O）。</p>
<ul>
<li>I 表示 Intput，是数据从硬盘进内存的过程，称之为读。</li>
<li>O 表示 Output，是数据从内存到硬盘的过程。称之为写。</li>
</ul>
<p>例如：将数据写到文件中，实现数据永久化存储；读取文件中已经存在的数据。</p>
<h3 id="1-3-IO-模型分类"><a href="#1-3-IO-模型分类" class="headerlink" title="1.3. IO 模型分类"></a>1.3. IO 模型分类</h3><h4 id="1-3-1-阻塞-IO-模型（Blocking-IO）"><a href="#1-3-1-阻塞-IO-模型（Blocking-IO）" class="headerlink" title="1.3.1. 阻塞 IO 模型（Blocking IO）"></a>1.3.1. 阻塞 IO 模型（Blocking IO）</h4><p>最传统的一种 IO 模型，即在读写数据过程中用户线程会发生阻塞现象。</p>
<p>当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：<code>data = socket.read();</code>，如果数据没有就绪，就会一直阻塞在 <code>read</code> 方法的位置。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035046.png" alt=""></p>
<blockquote>
<p>在客户端连接数量不高的情况下，性能上是没问题的。但是当面对十万甚至百万级连接的时候，传统的 BIO 模型就会突显性能上的缺陷。</p>
</blockquote>
<h4 id="1-3-2-非阻塞-IO-模型（Nonblocking-IO）"><a href="#1-3-2-非阻塞-IO-模型（Nonblocking-IO）" class="headerlink" title="1.3.2. 非阻塞 IO 模型（Nonblocking IO）"></a>1.3.2. 非阻塞 IO 模型（Nonblocking IO）</h4><p>在非阻塞 I/O 模型中，当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。期间用户线程会继续不断重试直到数据准备好为止。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035047.png" alt=""></p>
<p>所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，但会一直占用 CPU。典型的非阻塞 IO 模型实现一般如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    data = socket.read();</span><br><span class="line">    <span class="keyword">if</span> (data != error) &#123;</span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，非阻塞 IO 有一个非常严重的缺点，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。</p>
<p>非阻塞 IO 可以一个线程处理多个流事件，只要不停地询所有流事件即可。当然这种方式也不好，当大多数流没数据时，也是会大量浪费 CPU 资源。为了避免 CPU 空转，引进代理(select 和 poll，两种方式相差不大)，代理可以观察多个流 I/O 事件，空闲时会把当前线程阻塞掉，当有一个或多个 I/O 事件时，就从阻塞态醒过来，把所有 IO 流都轮询一遍，于是没有 IO 事件时程序就阻塞在 select 方法处，即便这样依然存在问题，但从 select 处只是知道是否有 IO 事件发生，却不知道是哪几个流，还是只能轮询所有流，epoll 这样的代理就可以把哪个流发生怎样的 IO 事件通知用户线程。</p>
<h4 id="1-3-3-多路复用-IO-模型（IO-multiplexing）"><a href="#1-3-3-多路复用-IO-模型（IO-multiplexing）" class="headerlink" title="1.3.3. 多路复用 IO 模型（IO multiplexing）"></a>1.3.3. 多路复用 IO 模型（IO multiplexing）</h4><p>多路复用 IO 模型是目前使用得比较多的模型。<strong>Java NIO 实际上就是多路复用 IO 模型</strong>。</p>
<p>在 Java NIO 中，是通过 <code>selector.select()</code> 去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035048.png" alt=""></p>
<p>因此<strong>IO 多路复用的特点是：通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符(套接字描述符)其中任意一个进入就绪状态，select 函数就可以返回</strong>。</p>
<p>在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。因此，多路复用 IO 比较适合连接数比较多的情况。</p>
<p>另外多路复用 IO 之所以比非阻塞 IO 模型的效率高，是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行；而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。</p>
<p>不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<blockquote>
<p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p>
<ul>
<li><strong>select 调用</strong>：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li>
<li><strong>epoll 调用</strong>：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li>
</ul>
</blockquote>
<h4 id="1-3-4-信号驱动-IO-模型"><a href="#1-3-4-信号驱动-IO-模型" class="headerlink" title="1.3.4. 信号驱动 IO 模型"></a>1.3.4. 信号驱动 IO 模型</h4><p>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行；当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035049.png" alt=""></p>
<p><strong>信号驱动 IO 模型的特点是：等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知。既可以是数据已准备好被处理，也可以是数据报已准备好被读取</strong>。</p>
<h4 id="1-3-5-异步-IO-模型（asynchronous-IO）"><a href="#1-3-5-异步-IO-模型（asynchronous-IO）" class="headerlink" title="1.3.5. 异步 IO 模型（asynchronous IO）"></a>1.3.5. 异步 IO 模型（asynchronous IO）</h4><p>异步 IO 模型是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，再将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035050.png" alt=""></p>
<p>在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。</p>
<blockquote>
<p>Tips: 异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。</p>
</blockquote>
<h2 id="2-File-类"><a href="#2-File-类" class="headerlink" title="2. File 类"></a>2. File 类</h2><h3 id="2-1-File-简述"><a href="#2-1-File-简述" class="headerlink" title="2.1. File 简述"></a>2.1. File 简述</h3><p><code>File</code> 类：文件和目录路径名的抽象表示形式。即，Java 中把文件或者目录（文件夹）都封装成 <code>File</code> 对象。</p>
<p>可以用来操作硬盘上的文件或文件夹。也就是说如果要去操作硬盘上的文件，或者文件夹只要找到 <code>File</code> 这个类即可。</p>
<ul>
<li>文件可以持久化地存储数据</li>
<li><code>File</code> 的一个对象就代表一个文件或文件夹(自己简单地定义，方便记忆的说法)</li>
<li>文档上说明 <code>File</code> 类代表文件或文件夹路径，但是我们可以通过路径找到对应的文件或文件夹。</li>
<li>可以认为 <code>File</code> 类就代表文件或文件夹(通过路径找到)</li>
</ul>
<h3 id="2-2-相对路径与绝对路径"><a href="#2-2-相对路径与绝对路径" class="headerlink" title="2.2. 相对路径与绝对路径"></a>2.2. 相对路径与绝对路径</h3><p><strong>绝对路径</strong></p>
<ul>
<li>以盘符开始到文件的全路径</li>
<li>在整个系统中，<font color=red><strong>具有唯一性</strong></font></li>
</ul>
<p><strong>相对路径</strong></p>
<ul>
<li>从某个参照目录开始到指定文件所经过的路径</li>
<li>在整个系统中，<font color=red><strong>不具有唯一性</strong></font></li>
<li>相对路径一般是在 Eclipse 中的某个项目当中创建一个文件夹(目录)开始。如 a.txt 相对于 myIO 项目根目录经过了 <code>a/b/a.txt</code>，则 <code>a/b/a.txt</code> 就是该文件的相对路径</li>
</ul>
<h3 id="2-3-File-类的使用"><a href="#2-3-File-类的使用" class="headerlink" title="2.3. File 类的使用"></a>2.3. File 类的使用</h3><h4 id="2-3-1-成员变量"><a href="#2-3-1-成员变量" class="headerlink" title="2.3.1. 成员变量"></a>2.3.1. 成员变量</h4><ul>
<li>与系统有关的路径分隔符，window是“<code>;</code>”，mac与lunix是“<code>:</code>”</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String pathSeparator</span><br></pre></td></tr></table></figure>
<ul>
<li>与系统有关的默认名称分隔符(目录分隔符)，跨平台的。window是“<code>\</code>”，mac与lunix是“<code>/</code>”。应该是需要跨平台，所以不能直接将分隔符写成一种类型。目前JDK版本已经可以自动识别。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String separator</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：静态成员变量，直接用<code>file.成员变量名</code>使用</p>
</blockquote>
<h4 id="2-3-2-构造方法"><a href="#2-3-2-构造方法" class="headerlink" title="2.3.2. 构造方法"></a>2.3.2. 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String pathname)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据文件或文件夹路径字符串创建文件对象，通过路径找到对应的文件或文件夹</li>
<li><blockquote>
<p>API描述：通过将给定路径名字符串转换为抽象路径名来创建一个新 <code>File</code> 实例。如果给定字符串是空字符串，那么结果是空抽象路径名。</p>
</blockquote>
</li>
<li>例：<code>File f = new File(&quot;E:\\documents\\aaa.txt&quot;);</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(String parent, String child)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>parent 指的是父级目录路径字符串，child 指的是子级目录（子级文件）路径字符串。根据父文件夹路径和子文件夹（子文件）路径创建文件对象。</li>
<li>例：<code>File f = new File(&quot;E:\\documents\\&quot;, &quot;aaa.txt&quot;);</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">File</span><span class="params">(File parent, String child)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>parent 为 File 类型，为了使用 <code>File</code> 类中的方法</li>
<li>例：<code>File f = new File(new File(&quot;E:\\documents\\&quot;), &quot;aaa.txt&quot;);</code></li>
</ul>
<font color=red>**注意：File的构造方法不会去判断路径是否存在，需要自己去调用方法处理**</font>

<h4 id="2-3-3-文件创建"><a href="#2-3-3-文件创建" class="headerlink" title="2.3.3. 文件创建"></a>2.3.3. 文件创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<p>根据构造方法指定的路径创建文件，如果文件已经存在，则什么不做。如果文件不存在，则创建文件。</p>
<font color=red>**只能用来创建文件，不能创建文件夹**</font>。在创建文件时，如果文件所在的文件夹不存在，则报错系统找不到指定的路径。<font color=red>**创建文件时，必须确保文件夹已经存在**</font>。

#### 2.3.4. 文件夹创建

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 根据路径字符串创建文件夹（<font color=red>**单级目录，下面不能再创建新的目录**</font>）
- 如果文件夹存在，则什么不做；如果文件夹不存在，则创建。创建成功返回`true`，否则返回`false`
- 需要注意：<font color=red>**只能用来创建文件夹，不能创建文件**</font>
- 使用`mkdir`方法创建文件夹时，必须保证其所在文件夹已经存在，否则创建失败(不会报错)

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 一次性创建多级文件夹（最常用）。如果父文件夹不存在，则会先创建父文件夹。
- 创建成功返回`true`，否则返回`false`
- 需要注意：<font color=red>**只能用来创建文件夹，不能创建文件**</font>

<h4 id="2-3-5-文件-文件夹删除"><a href="#2-3-5-文件-文件夹删除" class="headerlink" title="2.3.5. 文件/文件夹删除"></a>2.3.5. 文件/文件夹删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>删除此抽象路径名表示的文件或目录。如果删除成功返回<code>true</code>；如果不成功则返回<code>false</code>。</p>
<ul>
<li><code>File</code>对象是文件：直接删除文件(<font color=red><strong>Java 删除时，不会使用 windows 的回收站</strong></font>)</li>
<li><code>File</code>对象是文件夹：只删定义路径中最后一个文件夹且只能删除空文件夹，如果不是空文件夹，即不能删除。</li>
</ul>
<h4 id="2-3-6-获取文件-文件夹信息"><a href="#2-3-6-获取文件-文件夹信息" class="headerlink" title="2.3.6. 获取文件/文件夹信息"></a>2.3.6. 获取文件/文件夹信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">length</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获得文件大小，单位：字符。<font color=red><strong>只能是文件，不能是文件夹</strong></font>。</li>
<li><blockquote>
<p>API: 返回由此抽象路径名表示的文件的长度（单位：字符）。如果此路径名表示一个目录，则返回值是不确定的(<font color=red><strong>垃圾值</strong></font>)。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取文件/文件夹的名称</li>
<li><blockquote>
<p>API: 返回由此抽象路径名表示的文件或目录的名称。该名称是路径名名称序列中的最后一个名称。如果路径名名称序列为空，则返回空字符串。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getAbsolutePath</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取绝对路径字符串，返回此抽象路径名的绝对路径名字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File <span class="title function_">getAbsoluteFile</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取绝对路径的对象</li>
<li><blockquote>
<p>API: 返回此抽象路径名的绝对路径名形式。等同于<code>new File(this.getAbsolutePath())</code>。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getParent</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得上一级文件路径字符串；</li>
<li><blockquote>
<p>API: 返回所在文件夹路径(根据创建对象时是否为绝对路径/相对路径)</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File <span class="title function_">getParentFile</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获得上一级文件路径对象；（<font color=blue><strong>应该是用于返回上一级目录再继续进行其他操作</strong></font>）</li>
<li><blockquote>
<p>API: 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getPath</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取路径(用什么方式创建的对象,就返回什么方式的路径(绝对路径/相对路径))</li>
<li><blockquote>
<p>API: 将此抽象路径名转换为一个路径名字符串。所得字符串使用默认名称分隔符分隔名称序列中的名称。</p>
</blockquote>
</li>
</ul>
<p>获取文件/文件夹信息示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取 E 盘 aaa 文件夹中 b.txt 文件的文件名，文件大小，文件的绝对路径和父路径等信息，</span></span><br><span class="line"><span class="comment"> * 	并将信息输出在控制台。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetFileInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 E 盘 aaa 文件夹中 b.txt对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\aaa\\b.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断对象是否文件</span></span><br><span class="line">    System.out.println(<span class="string">&quot;对象是否为文件：&quot;</span> + file.isFile());</span><br><span class="line">    <span class="comment">// 获取文件的大小,单位：字节</span></span><br><span class="line">    System.out.println(<span class="string">&quot;对象文件的大小 ：&quot;</span> + file.length());</span><br><span class="line">    <span class="comment">// 获取文件名</span></span><br><span class="line">    System.out.println(<span class="string">&quot;对象文件的名称：&quot;</span> + file.getName());</span><br><span class="line">    <span class="comment">// 获取文件的绝对路径</span></span><br><span class="line">    System.out.println(<span class="string">&quot;对象的绝对路径是：&quot;</span> + file.getAbsolutePath());</span><br><span class="line">    <span class="comment">// 获取父路径信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;对象的父路径是：&quot;</span> + file.getParent());</span><br><span class="line">    <span class="comment">// 获取路径</span></span><br><span class="line">    System.out.println(<span class="string">&quot;对象的路径是(用什么方式创建的对象,就返回什么方式的路径)：&quot;</span> + file.getPath());</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;qq.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取这个相对路径的对象的绝对路径</span></span><br><span class="line">    System.out.println(<span class="string">&quot;相对路径对象的绝对路径是：&quot;</span> + file2.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">对象是否为文件：true</span><br><span class="line">对象文件的大小 ：44</span><br><span class="line">对象文件的名称：b.txt</span><br><span class="line">对象的绝对路径是：e:\aaa\b.txt</span><br><span class="line">对象的父路径是：e:\aaa</span><br><span class="line">对象的路径是(用什么方式创建的对象,就返回什么方式的路径)：e:\aaa\b.txt</span><br><span class="line">相对路径对象的绝对路径是：D:\code\java-technology-stack\java-basic-api\qq.txt</span><br></pre></td></tr></table></figure>
<h4 id="2-3-7-判断文件-文件夹"><a href="#2-3-7-判断文件-文件夹" class="headerlink" title="2.3.7. 判断文件/文件夹"></a>2.3.7. 判断文件/文件夹</h4><p>此部分的API是用于判断该 <code>File</code> 对象是否存在或者判断该 <code>File</code> 对象代表一个文件还是代表一个文件夹</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断文件/文件夹是否存在。存在则返回<code>true</code>，否则返回<code>false</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断<code>File</code>对象是否为文件夹，是文件夹则则返回<code>true</code>，否则返回<code>false</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断File对象是否为文件，是文件则返回<code>true</code>，否则返回<code>false</code></li>
</ul>
<h4 id="2-3-8-获取文件-文件夹列表（重点）"><a href="#2-3-8-获取文件-文件夹列表（重点）" class="headerlink" title="2.3.8. 获取文件/文件夹列表（重点）"></a>2.3.8. 获取文件/文件夹列表（重点）</h4><p>需要注意：<font color=red><strong>File 对象必须是文件夹</strong></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list()</span><br></pre></td></tr></table></figure>
<ul>
<li>获得当前文件夹对象下所有文件（子文件和子文件夹），返回字符串数组。</li>
<li><blockquote>
<p>API: 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles();</span><br></pre></td></tr></table></figure>
<ul>
<li>获得当前文件夹对象下所有文件（子文件和子文件夹），返回 <code>File</code> 对象数组。</li>
<li><blockquote>
<p>API: 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</p>
</blockquote>
</li>
</ul>
<font color=red>**注意：如果是`File`对象是文件，则返回去的数组为`null`。所以在使用List获取方法前，需要判断`File`对象是否是文件夹。**</font>

<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetFileList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建文件夹对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\00-Downloads\\test\\&quot;</span>);</span><br><span class="line">    String[] list = file.list();</span><br><span class="line">    <span class="comment">// 输出该文件夹里的文件列表</span></span><br><span class="line">    System.out.println(Arrays.toString(list));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件对象（非文件夹）</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\00-Downloads\\a.txt&quot;</span>);</span><br><span class="line">    String[] list2 = file2.list();</span><br><span class="line">    <span class="comment">// 输出null</span></span><br><span class="line">    System.out.println(Arrays.toString(list2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[a - 副本 (2).txt, a - 副本 (3).txt, a - 副本 (4).txt, a - 副本 (5).txt, a - 副本.txt, a.txt]</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<h3 id="2-4-File-类基础应用案例"><a href="#2-4-File-类基础应用案例" class="headerlink" title="2.4. File 类基础应用案例"></a>2.4. File 类基础应用案例</h3><h4 id="2-4-1-读取指定文件夹下的所有文件（多个文件夹）"><a href="#2-4-1-读取指定文件夹下的所有文件（多个文件夹）" class="headerlink" title="2.4.1. 读取指定文件夹下的所有文件（多个文件夹）"></a>2.4.1. 读取指定文件夹下的所有文件（多个文件夹）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonZero</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建文件夹对象</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\temp&quot;</span>);</span><br><span class="line">		<span class="comment">// 调用读取所有文件的方法</span></span><br><span class="line">		printAllFile(file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建读取当前文件夹下的的有文件递归方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAllFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取当前文件夹下所有文件的list对象数组</span></span><br><span class="line">		File[] list = file.listFiles();</span><br><span class="line">		<span class="comment">// 利用增强for遍历File对象数组</span></span><br><span class="line">		<span class="keyword">for</span> (File f : list) &#123;</span><br><span class="line">			<span class="comment">// 再判断是否是文件，如果是文件，直接输出（递归的出口）</span></span><br><span class="line">			<span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">				<span class="comment">// 直接输出对像是绝对路径，是因为File重写了toString方法</span></span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 不是文件，则就是文件夹，就进行递归，继续执行。</span></span><br><span class="line">				printAllFile(f);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-统计指定文件夹所有文件的大小总和（文件夹下有多个文件夹）"><a href="#2-4-2-统计指定文件夹所有文件的大小总和（文件夹下有多个文件夹）" class="headerlink" title="2.4.2. 统计指定文件夹所有文件的大小总和（文件夹下有多个文件夹）"></a>2.4.2. 统计指定文件夹所有文件的大小总和（文件夹下有多个文件夹）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关卡2训练案例2</span></span><br><span class="line"><span class="comment"> * 	键盘录入一个文件路径，根据文件路径创建文件对象，判断是文件还是文件夹</span></span><br><span class="line"><span class="comment"> * 	如果是文件，则输出文件的大小</span></span><br><span class="line"><span class="comment"> * 	如果是文件夹则计算该文件夹下所有文件大小之和并输出(不包含子文件夹)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2_02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请录入一个文件路径：&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(input.nextLine());</span><br><span class="line">		<span class="comment">// 判断是文件还是文件夹</span></span><br><span class="line">		<span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;输入的文件路径是文件！&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;\&quot;&quot;</span> + file.getName() + <span class="string">&quot;\&quot;的大小是：&quot;</span> + file.length());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;输入的文件路径是文件夹！&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;输入的文件夹里的所有文件清单：&quot;</span>);</span><br><span class="line">			<span class="comment">// 增加将子文件夹都算进去，调用递归方法来统计所有文件的大小</span></span><br><span class="line">			<span class="comment">// 创建一个新的集合，用来存放递归所有文件的File对像。</span></span><br><span class="line">			ArrayList&lt;File&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;File&gt;();</span><br><span class="line">			findAllFile(file, array);</span><br><span class="line">			<span class="comment">// 将递归接收所有的文件的集合再使用迭代器遍历</span></span><br><span class="line">			Iterator&lt;File&gt; it = array.iterator();</span><br><span class="line">			<span class="comment">// 定义一个long变量用来统计所有文件的大小</span></span><br><span class="line">			<span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">				<span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> it.next();</span><br><span class="line">				System.out.println(f.getName());</span><br><span class="line">				sum += f.length();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;文件夹中的所有文件的大小之和是：&quot;</span> + sum);</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findAllFile</span><span class="params">(File file, ArrayList&lt;File&gt; array)</span> &#123;</span><br><span class="line">		<span class="comment">// 使用listFiles方法，获取File对象数组。</span></span><br><span class="line">		File[] fileArr = file.listFiles();</span><br><span class="line">		<span class="keyword">for</span> (File f : fileArr) &#123;</span><br><span class="line">			<span class="comment">// 判断，如果是文件，直接输出统计大小，如果是文件夹，再进行递归遍历</span></span><br><span class="line">			<span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">				array.add(f);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				findAllFile(f, array);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-删除指定文件夹下的所有文件（多个文件夹）"><a href="#2-4-3-删除指定文件夹下的所有文件（多个文件夹）" class="headerlink" title="2.4.3. 删除指定文件夹下的所有文件（多个文件夹）"></a>2.4.3. 删除指定文件夹下的所有文件（多个文件夹）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关卡3训练案例2</span></span><br><span class="line"><span class="comment"> * 	键盘录入一个文件夹路径，删除该路径下的文件夹。</span></span><br><span class="line"><span class="comment"> * 	要求：文件夹中包含有子文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3_02</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建键盘录入对象</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入一个文件夹路径：&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(input.nextLine());</span><br><span class="line">		<span class="comment">// 调用递归方法，对当前文件夹进行删除操作。</span></span><br><span class="line">		deleteFile(file);</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取file对象数组</span></span><br><span class="line">		File[] list = file.listFiles();</span><br><span class="line">		<span class="comment">// 遍历数组</span></span><br><span class="line">		<span class="keyword">for</span> (File f : list) &#123;</span><br><span class="line">			<span class="comment">// 进行判断是否为文件，如果文件直接删除</span></span><br><span class="line">			<span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">				<span class="comment">// 将文件删除后才能将文件夹删除</span></span><br><span class="line">				f.delete();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果是文件夹，再递归，然后里面的文件都删除。</span></span><br><span class="line">				deleteFile(f);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 再对文件夹进行删除，上一步递归后，已经将里面的文件夹和文件都删除</span></span><br><span class="line">		file.delete();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-FileFilter-文件过滤器-难点、重点"><a href="#3-FileFilter-文件过滤器-难点、重点" class="headerlink" title="3. FileFilter 文件过滤器(难点、重点)"></a>3. FileFilter 文件过滤器(难点、重点)</h2><h3 id="3-1-FileFilter-概述"><a href="#3-1-FileFilter-概述" class="headerlink" title="3.1. FileFilter 概述"></a>3.1. FileFilter 概述</h3><p><code>FileFilter</code> 过滤器是一个函数式接口，用于抽象路径名的过滤器。使用时候要创建一个接口的实现类。<strong>（通常使用匿名内部类或者lambda表达式来完成，因为一般该接口只适用于本次的过滤需求，没有广泛的适用性。）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests whether or not the specified abstract pathname should be</span></span><br><span class="line"><span class="comment">     * included in a pathname list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  pathname  The abstract pathname to be tested</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;pathname&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *          should be included</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FileFilter</code> 接口的唯一方法<code>accept</code>，作用是测试指定抽象路径名是否应该包含在某个路径名列表中。</p>
<h3 id="3-2-接口的调用时机"><a href="#3-2-接口的调用时机" class="headerlink" title="3.2. 接口的调用时机"></a>3.2. 接口的调用时机</h3><p>每当遍历获得一个子文件或子文件夹时，系统内部会创建一个文件对象，然后将该文件对象作为参数调用，文件过滤的<code>accept</code>方法，由<code>accept</code>的返回值决定该文件是否要过滤。<font color=red><strong>返回<code>false</code>表示过滤该文件，<code>ture</code>则不过滤</strong></font>。</p>
<h3 id="3-3-File-类使用过滤器的方法"><a href="#3-3-File-类使用过滤器的方法" class="headerlink" title="3.3. File 类使用过滤器的方法"></a>3.3. File 类使用过滤器的方法</h3><p>根据指定文件过滤器获得当前文件夹下的过滤后的所有文件的<code>File</code>对象数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles(FileFilter filter)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>API: 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。除了返回数组中的路径名必须满足过滤器外，此方法的行为与 <code>listFiles()</code> 方法相同。如果给定 <code>filter</code> 为 <code>null</code>，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的<code>FileFilter.accept(java.io.File)</code> 方法返回 <code>true</code> 时，该路径名才满足过滤器。</p>
</blockquote>
<h3 id="3-4-文件过滤器的使用步骤与示例"><a href="#3-4-文件过滤器的使用步骤与示例" class="headerlink" title="3.4. 文件过滤器的使用步骤与示例"></a>3.4. 文件过滤器的使用步骤与示例</h3><ol>
<li>定义一个类实现<code>FileFilter</code>接口<strong>（通常使用匿名内部类或者lambda表达式来完成）</strong></li>
<li>重写<code>accept</code>方法,满足条件的返回<code>true</code>,不满足条件的返回<code>false</code></li>
<li>创建<code>FileFilter</code>接口的实现类对象</li>
<li><code>file.listFiles()</code>方法参数中传入过滤器</li>
</ol>
<p>使用文件过滤器示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：只输出文件夹中所有的.pptx文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonZero</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建文件夹对象</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\temp&quot;</span>);</span><br><span class="line">		<span class="comment">// 调用读取所有文件的方法</span></span><br><span class="line">		printAllFile(file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建读取当前文件夹下的的有文件递归方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAllFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建FileFilter接口的实现类对象</span></span><br><span class="line">		<span class="type">FileFilterDemo</span> <span class="variable">ff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileFilterDemo</span>();</span><br><span class="line">		<span class="comment">// 使用File[] listFiles(FileFilter filter)方法，获取过滤后的File对象数组</span></span><br><span class="line">		File[] list = file.listFiles(ff);</span><br><span class="line">		<span class="comment">// 利用增强for遍历File对象数组</span></span><br><span class="line">		<span class="keyword">for</span> (File f : list) &#123;</span><br><span class="line">			<span class="comment">// 再判断是否是文件，如果是文件，直接输出（递归的出口）</span></span><br><span class="line">			<span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">				<span class="comment">// 直接输出对像是绝对路径，是因为File重写了toString方法</span></span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 不是文件，则就是文件夹，就进行递归，继续执行。</span></span><br><span class="line">				printAllFile(f);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类实现FileFilter接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileFilterDemo</span> <span class="keyword">implements</span> <span class="title class_">FileFilter</span> &#123;</span><br><span class="line">	<span class="comment">// 重写过滤器 FileFilter的accept抽象方法，</span></span><br><span class="line">	<span class="comment">// 根据需求定义过滤的条件</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span> &#123;</span><br><span class="line">		<span class="comment">// 要先判断传入的File对象是文件还是文件夹</span></span><br><span class="line">		<span class="comment">// 如果是文件夹则直接不过滤，如果是文件，则进行判断过滤。</span></span><br><span class="line">		<span class="keyword">if</span> (pathname.isDirectory()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> pathname.getName().endsWith(<span class="string">&quot;.pptx&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 另一种简单写法</span></span><br><span class="line">		<span class="comment">// return (pathname.isDirectory()) || (pathname.getName().endsWith(&quot;.pptx&quot;));</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用文件过滤器示例2:(使用匿名内部类)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需求：只输出文件夹中所有的.pptx文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonZero</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建文件夹对象</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\temp&quot;</span>);</span><br><span class="line">		<span class="comment">// 调用读取所有文件的方法</span></span><br><span class="line">		printAllFile(file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建读取当前文件夹下的的有文件递归方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printAllFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">		<span class="comment">// 使用File[] listFiles(FileFilter filter)方法，获取过滤后的File对象数组</span></span><br><span class="line">		File[] list = file.listFiles(<span class="keyword">new</span> <span class="title class_">FileFilter</span>() &#123;</span><br><span class="line">			<span class="comment">// 创建FileFilter接口的匿名内部类，直接重写accept抽象方法</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File pathname)</span> &#123;</span><br><span class="line">				<span class="comment">// 要先判断传入的File对象是文件还是文件夹</span></span><br><span class="line">				<span class="comment">// 如果是文件夹则直接不过滤，如果是文件，则进行判断过滤。</span></span><br><span class="line">				<span class="keyword">return</span> (pathname.isDirectory()) || (pathname.getName().endsWith(<span class="string">&quot;.pptx&quot;</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">// 利用增强for遍历File对象数组</span></span><br><span class="line">		<span class="keyword">for</span> (File f : list) &#123;</span><br><span class="line">			<span class="comment">// 再判断是否是文件，如果是文件，直接输出（递归的出口）</span></span><br><span class="line">			<span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">				<span class="comment">// 直接输出对像是绝对路径，是因为File重写了toString方法</span></span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 不是文件，则就是文件夹，就进行递归，继续执行。</span></span><br><span class="line">				printAllFile(f);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4. 字符流"></a>4. 字符流</h2><h3 id="4-1-字符流概述"><a href="#4-1-字符流概述" class="headerlink" title="4.1. 字符流概述"></a>4.1. 字符流概述</h3><p>IO 流用来处理设备之间的数据传输。Java 对数据的操作是通过流的方式，用于操作流的类都在 IO 包中。</p>
<p>在 IO 开发过程中，传输最频繁的数据为字符，而以字节方式传输字符需要每次将字符串转换成字节再处理，而且也丧失了程序员对数据内容的判断。所以，为了方便对字符进行操作，Java 提供了专门以字符作为操作单位的类——『字符流』，但其底层仍然为字节流。</p>
<blockquote>
<p>注意：<font color=red><strong>字符流只能操作字符，无法操作其他数据，如声音、视频等</strong></font>。</p>
</blockquote>
<h3 id="4-2-FileWriter-输出字符流"><a href="#4-2-FileWriter-输出字符流" class="headerlink" title="4.2. FileWriter 输出字符流"></a>4.2. FileWriter 输出字符流</h3><p><code>FileWriter</code> 输出字符流在 <code>java.io</code> 包中，用于写数据，属于输出流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-1-FileWriter-向文件中写数据操作步骤"><a href="#4-2-1-FileWriter-向文件中写数据操作步骤" class="headerlink" title="4.2.1. FileWriter 向文件中写数据操作步骤"></a>4.2.1. FileWriter 向文件中写数据操作步骤</h4><ol>
<li>使用 FileWriter 流关联文件</li>
<li>利用 FileWriter 的写方法写数据</li>
<li>利用 FileWriter 的刷新方法将数据从内存刷到硬盘上</li>
<li>利用 FileWriter 的关流方法将释放占用的系统底层资源</li>
</ol>
<h4 id="4-2-2-构造方法"><a href="#4-2-2-构造方法" class="headerlink" title="4.2.2. 构造方法"></a>4.2.2. 构造方法</h4><p>创建输出流对象时，做了哪些事情:</p>
<ol>
<li>调用系统资源创建了一个文件</li>
<li>创建输出流对象</li>
<li>把输出流对象指向文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>传入一个文件的路径和名称创建输出流，此类输出流<strong>无法追加写入</strong>。如：<code>FileWriter fw = new FileWriter(&quot;d:\\a.txt&quot;)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String fileName, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>传入一个文件的路径和名称创建输出流，根据 append 参数判断是否可追加写入数据。true 表示可以追加写入。默认是 false 无追加。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>根据给定的 File 对象构造一个 FileWriter 对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>根据给定的 File 对象构造一个 FileWriter 对象。并且可以通过 append 参数指定是否追加写入。</li>
</ul>
<h4 id="4-2-3-常用方法"><a href="#4-2-3-常用方法" class="headerlink" title="4.2.3. 常用方法"></a>4.2.3. 常用方法</h4><blockquote>
<p>Notes: 以下 5 种 write 写数据方法，均调用输出流对象的写数据的方法，向文件对象写入数据，但数据没有直接写到文件，只是写到了内存缓冲区。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>向文件写入一个字符串数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>向文件写入指定字符串中的一部分数据。<ul>
<li>str：待写入的字符串数据</li>
<li>off：指定待写入的字符串开始截取的位置索引</li>
<li>len：写入的长度（注意不是索引）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写入一个字符数据，这里写 int 类型的好处是既可以写 char类 型的数据，也可以写 char 对应的 int 类型的值。如 <code>&#39;a&#39;</code> 就是 97</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException </span><br></pre></td></tr></table></figure>
<ul>
<li>写入一个字符数组数据。继承自 <code>Writer</code> 类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写入一个字符数组的一部分数据<ul>
<li>cbuf[]：待写入的字符数组</li>
<li>off：指定待写入的字符数组开始截取的位置索引</li>
<li>len：写入的长度（注意不是索引）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>将内存中的数据刷新到文件中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>通知系统释放和该文件相关的资源关闭流，释放系统底层资源。</li>
</ul>
<h4 id="4-2-4-close-和-flush-方法的区别"><a href="#4-2-4-close-和-flush-方法的区别" class="headerlink" title="4.2.4. close() 和 flush() 方法的区别"></a>4.2.4. close() 和 flush() 方法的区别</h4><ul>
<li>flush(): 刷新缓冲区。流对象还可以继续使用。</li>
<li>close(): 先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<h3 id="4-3-FileReader-输入字符流"><a href="#4-3-FileReader-输入字符流" class="headerlink" title="4.3. FileReader 输入字符流"></a>4.3. FileReader 输入字符流</h3><p><code>FileReader</code> 输出字符流在 <code>java.io</code> 包中，从文件中读数据，属于输入流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-1-输入流读文件的步骤"><a href="#4-3-1-输入流读文件的步骤" class="headerlink" title="4.3.1. 输入流读文件的步骤"></a>4.3.1. 输入流读文件的步骤</h4><ol>
<li>创建输入流对象</li>
<li>调用输入流对象的读数据方法</li>
<li>释放资源</li>
</ol>
<h4 id="4-3-2-构造方法"><a href="#4-3-2-构造方法" class="headerlink" title="4.3.2. 构造方法"></a>4.3.2. 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>根据传递文件名称，创建文件输入流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>在给定从中读取数据的 File 的情况下创建一个新 FileReader。</li>
</ul>
<h4 id="4-3-3-常用方法"><a href="#4-3-3-常用方法" class="headerlink" title="4.3.3. 常用方法"></a>4.3.3. 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>一次读取一个字符，如果读取数据的返回值是-1的时候，就说明没有可读取的数据了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>一次读取一个字符数组的数据并保存到 cbuf 数组中，返回的是实际读取的字符个数</li>
</ul>
<h4 id="4-3-4-读数据方式1：一次读取一个字符"><a href="#4-3-4-读数据方式1：一次读取一个字符" class="headerlink" title="4.3.4. 读数据方式1：一次读取一个字符"></a>4.3.4. 读数据方式1：一次读取一个字符</h4><p>调用输入流对象的读数据方法，一次读取一个字符。循环去就读取文件的数据，通过测试，如果读取数据的返回值是-1的时候，就说明没有数据了，这也作为循环的结束条件。读取出来的是字符的 ASCII 码，所以需要(char)强转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\a.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 定义 ch 变量，是实际读取的数据，也是当返回-1的时候代表没有可读取数据</span></span><br><span class="line"><span class="type">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 额外内容</span></span><br><span class="line">    <span class="comment">// Thread.sleep(100); // 这个可以减缓读取的速度</span></span><br><span class="line">    System.out.print((<span class="type">char</span>) ch); <span class="comment">// 示例打印输出是不换行的字符，不要输出&quot;ln&quot;换行。因为如果文档有换行的话，一样可以读取到换行的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-5-读数据方式2：一次读取一个字符数组"><a href="#4-3-5-读数据方式2：一次读取一个字符数组" class="headerlink" title="4.3.5. 读数据方式2：一次读取一个字符数组"></a>4.3.5. 读数据方式2：一次读取一个字符数组</h4><p>调用输入流对象的读数据方法，一次读取一个字符数组，通常读取的字符数量为1024及其整数倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\a.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 1.初始化读取的字符数数组，一般可以是1024及其整数倍</span></span><br><span class="line"><span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 定义 len 变量，是实际读取的数据数量，也是当返回-1的时候代表没有可读取数据</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len = fr.read(chs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chs, <span class="number">0</span>, len)); <span class="comment">// 如果文档有换行的话，一样可以读取到换行的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-6-read-和-read-char-cbuf-的区别"><a href="#4-3-6-read-和-read-char-cbuf-的区别" class="headerlink" title="4.3.6. read() 和 read(char cbuf[]) 的区别"></a>4.3.6. read() 和 read(char cbuf[]) 的区别</h4><p>如果文件中的数据是”a”，两种方法区别如下：</p>
<ul>
<li><code>int len = fr.read();</code>，结果是 <code>len = 97</code>，数据保存在 len 中</li>
<li><code>int len = fr.read(arr);</code>，结果是 <code>len = 1</code>，代表的是只读一个数据，实际的数据是保存在 arr 数组中。</li>
</ul>
<h3 id="4-4-BufferedWriter-BufferedReader（缓冲字符流）"><a href="#4-4-BufferedWriter-BufferedReader（缓冲字符流）" class="headerlink" title="4.4. BufferedWriter / BufferedReader（缓冲字符流）"></a>4.4. BufferedWriter / BufferedReader（缓冲字符流）</h3><h4 id="4-4-1-BufferedWriter"><a href="#4-4-1-BufferedWriter" class="headerlink" title="4.4.1. BufferedWriter"></a>4.4.1. BufferedWriter</h4><p><code>BufferedWriter</code> 带缓冲的输出字符流在 <code>java.io</code> 包中，是文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: <font color=red><strong>缓冲流一样是用基本流的方法，只是创建对象的比较麻烦，但缓冲流的效率会比较高，一般都是使用缓冲流。</strong></font></p>
</blockquote>
<h5 id="4-4-1-1-构造方法"><a href="#4-4-1-1-构造方法" class="headerlink" title="4.4.1.1. 构造方法"></a>4.4.1.1. 构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedWriter</span><span class="params">(Writer out)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个使用默认大小输出缓冲区的缓冲字符输出流。</li>
</ul>
<p><code>BufferedWriter</code> 用法与 <code>FileWriter</code> 是一样的，只是创建对象的时候不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;xxx.txt&quot;</span>));   </span><br></pre></td></tr></table></figure>
<h5 id="4-4-1-2-特有方法"><a href="#4-4-1-2-特有方法" class="headerlink" title="4.4.1.2. 特有方法"></a>4.4.1.2. 特有方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写一个换行符，此换行符由系统决定，不同的操作系统使用的换行符不同。</li>
</ul>
<h4 id="4-4-2-BufferedReader"><a href="#4-4-2-BufferedReader" class="headerlink" title="4.4.2. BufferedReader"></a>4.4.2. BufferedReader</h4><p><code>BufferedReader</code> 带缓冲的输出字符流在 <code>java.io</code> 包中，从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> </span><br></pre></td></tr></table></figure>
<h5 id="4-4-2-1-构造方法"><a href="#4-4-2-1-构造方法" class="headerlink" title="4.4.2.1. 构造方法"></a>4.4.2.1. 构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedReader</span><span class="params">(Reader in)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个使用默认大小输入缓冲区的缓冲字符输入流。</li>
</ul>
<p><code>BufferedReader</code> 用法与 <code>FileReader</code> 是一样的，但创建对象的时候不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;xxx.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h5 id="4-4-2-2-特有方法"><a href="#4-4-2-2-特有方法" class="headerlink" title="4.4.2.2. 特有方法"></a>4.4.2.2. 特有方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>一次读取一行数据，但是不读取换行符。基础使用示例如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;xxx.txt&quot;</span>));</span><br><span class="line">String line;</span><br><span class="line"><span class="comment">// 将 br.readLine() 方法返回是 null，说明已经无数据可读取</span></span><br><span class="line"><span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// readLine是不读取换行符的，所以示例打印加“ln”</span></span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-IO-字符流复制文本文件5种实现方式示例"><a href="#4-5-IO-字符流复制文本文件5种实现方式示例" class="headerlink" title="4.5. IO 字符流复制文本文件5种实现方式示例"></a>4.5. IO 字符流复制文本文件5种实现方式示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 复制文本文件(5种方式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">srcFileName</span> <span class="operator">=</span> <span class="string">&quot;FileWriterDemo.java&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">destFileName</span> <span class="operator">=</span> <span class="string">&quot;Copy.java&quot;</span>;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		method1(srcFileName,destFileName);</span></span><br><span class="line"><span class="comment">//		method2(srcFileName,destFileName);</span></span><br><span class="line">		method3(srcFileName,destFileName);</span><br><span class="line"><span class="comment">//		method4(srcFileName,destFileName);</span></span><br><span class="line"><span class="comment">//		method5(srcFileName,destFileName);</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//缓冲流一次读写一行字符串</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">(String srcFileName,String destFileName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">//创建输入缓冲流对象</span></span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFileName));</span><br><span class="line">		<span class="comment">//创建输出缓冲流对象</span></span><br><span class="line">		<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFileName));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//一次读写一个字符串</span></span><br><span class="line">		String line;</span><br><span class="line">		<span class="keyword">while</span>((line=br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">			bw.write(line);</span><br><span class="line">			bw.newLine();</span><br><span class="line">			bw.flush();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//释放资源</span></span><br><span class="line">		bw.close();</span><br><span class="line">		br.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//缓冲流一次读写一个字符数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">(String srcFileName,String destFileName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">//创建输入缓冲流对象</span></span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFileName));</span><br><span class="line">		<span class="comment">//创建输出缓冲流对象</span></span><br><span class="line">		<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFileName));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//一次读写一个字符数组</span></span><br><span class="line">		<span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		<span class="keyword">while</span>((len=br.read(chs))!=-<span class="number">1</span>) &#123;</span><br><span class="line">			bw.write(chs,<span class="number">0</span>,len);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//释放资源</span></span><br><span class="line">		bw.close();</span><br><span class="line">		br.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//缓冲流一次读写一个字符</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(String srcFileName,String destFileName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">//创建输入缓冲流对象</span></span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFileName));</span><br><span class="line">		<span class="comment">//创建输出缓冲流对象</span></span><br><span class="line">		<span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFileName));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//一次读写一个字符</span></span><br><span class="line">		<span class="type">int</span> ch;</span><br><span class="line">		<span class="keyword">while</span>((ch=br.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">			bw.write(ch);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//释放资源</span></span><br><span class="line">		bw.close();</span><br><span class="line">		br.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//基本流一次读写一个字符数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String srcFileName,String destFileName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">//创建输入流对象</span></span><br><span class="line">		<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFileName);</span><br><span class="line">		<span class="comment">//创建输出流对象</span></span><br><span class="line">		<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFileName);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//一次读写一个字符数组</span></span><br><span class="line">		<span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		<span class="keyword">while</span>((len=fr.read(chs))!=-<span class="number">1</span>) &#123;</span><br><span class="line">			fw.write(chs,<span class="number">0</span>,len);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//释放资源</span></span><br><span class="line">		fw.close();</span><br><span class="line">		fr.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//基本流一次读写一个字符</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(String srcFileName,String destFileName)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">//创建输入流对象</span></span><br><span class="line">		<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFileName);</span><br><span class="line">		<span class="comment">//创建输出流对象</span></span><br><span class="line">		<span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFileName);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//一次读写一个字符</span></span><br><span class="line">		<span class="type">int</span> ch;</span><br><span class="line">		<span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">			fw.write(ch);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//释放资源</span></span><br><span class="line">		fw.close();</span><br><span class="line">		fr.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-字节流"><a href="#5-字节流" class="headerlink" title="5. 字节流"></a>5. 字节流</h2><h3 id="5-1-字符流存在的问题"><a href="#5-1-字符流存在的问题" class="headerlink" title="5.1. 字符流存在的问题"></a>5.1. 字符流存在的问题</h3><p>字符输入和输出流只能操作文本文件，如果操作的是非文本文件（图片，视频，音频…）就会出现数据丢失的问题。</p>
<h3 id="5-2-OutputStream-字节输出流"><a href="#5-2-OutputStream-字节输出流" class="headerlink" title="5.2. OutputStream 字节输出流"></a>5.2. OutputStream 字节输出流</h3><h4 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1. 概述"></a>5.2.1. 概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OutputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span>, Flushable</span><br></pre></td></tr></table></figure>
<p><code>OutputStream</code> 字节输出流在 <code>java.io</code> 包中，是一个抽象类。字节输出流的根类，定义了所有字节输出流应该具备的方法。</p>
<p>此抽象类表示是所有字节输出流类的超类/父类/基类，常用子类有：</p>
<ul>
<li><code>java.io.FileOutputStream</code></li>
<li><code>java.io.BufferedOutputStream</code></li>
</ul>
<h4 id="5-2-2-常用方法"><a href="#5-2-2-常用方法" class="headerlink" title="5.2.2. 常用方法"></a>5.2.2. 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出一个字节。如果整数b超出一个字节，也是写入一个字节的内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>输出一个字节数组。如果写入字符串，将字符串转成字节数组。如：<code>new FileOutputStream(&quot;a.txt&quot;).write(&quot;你好&quot;.getByte());</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>输出字节数组的一部分。<ul>
<li><code>byte b[]</code>：待写出的字节数组</li>
<li><code>int off</code>：从字节数组的哪个位置开始</li>
<li><code>int len</code>：写出多少个字节</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭流释放资源。释放 IO 占用的 windows 底层资源</li>
</ul>
<h4 id="5-2-3-常用子类：FileOutputStream-文件字节输出流"><a href="#5-2-3-常用子类：FileOutputStream-文件字节输出流" class="headerlink" title="5.2.3. 常用子类：FileOutputStream (文件字节输出流)"></a>5.2.3. 常用子类：FileOutputStream (文件字节输出流)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span></span><br></pre></td></tr></table></figure>
<p><code>java.io.FileOutputStream</code> 是 <code>OutputStream</code> 的一个常用子类，其构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>通过字符串路径创建 <code>FileOutputStream</code> 对象。创建一个向具有指定名称的文件中写入数据的输出文件流。默认是以覆盖方式写入内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(String name, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>通过字符串路径创建 <code>FileOutputStream</code> 对象。参数 <code>append</code> 为 true 代表每次写入都向文件末尾追加，默认为 false 则每次都以覆盖方式写入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>File</code> 对象创建 <code>FileOutputStream</code> 对象。默认是以覆盖方式写入内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileOutputStream</span><span class="params">(File file, <span class="type">boolean</span> append)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>File</code> 对象创建 <code>FileOutputStream</code> 对象。参数 <code>append</code> 为 true 代表每次写入都向文件末尾追加，默认为 false 则每次都以覆盖方式写入。</li>
</ul>
<blockquote>
<p>Notes: <font color=red><strong>直接 <code>new FileOutputStream(file)</code> 创建对象，写入数据，会覆盖原有的文件</strong></font>。</p>
</blockquote>
<h4 id="5-2-4-字节输出流的使用步骤"><a href="#5-2-4-字节输出流的使用步骤" class="headerlink" title="5.2.4. 字节输出流的使用步骤"></a>5.2.4. 字节输出流的使用步骤</h4><ol>
<li>创建字节输出流对象并关联目标文件</li>
<li>调用 <code>write()</code> 方法写出数据：写一个字节，写一个字节数组，写一个字节数组的一部分。</li>
<li>关闭流释放资源。</li>
</ol>
<h4 id="5-2-5-字节输出流注意事项"><a href="#5-2-5-字节输出流注意事项" class="headerlink" title="5.2.5. 字节输出流注意事项"></a>5.2.5. 字节输出流注意事项</h4><ul>
<li>如果文件不存在，则会自动创建该文件。</li>
<li>如果不是追加写出，则默认会先将文件内容清空再输出新内容。</li>
<li>如果需要给文件追加写出，则在构造方法指定参数 <code>append</code> 为 true，实现追加输入的效果。</li>
<li>实现内容换行，可以使用 <code>String</code> 类的方法，将字符串转成 <code>byte</code> 数组，在写完数据后加上<code>&quot;\r\n&quot;</code>（这里的换行方式是windows系统）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// ...写入相关内容后再进行换行，</span></span><br><span class="line">fos.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>
<h4 id="5-2-6-异常的处理"><a href="#5-2-6-异常的处理" class="headerlink" title="5.2.6. 异常的处理"></a>5.2.6. 异常的处理</h4><ol>
<li>假设在 <code>FileOutputStream fos = new FileOutputStream(&quot;c.txt&quot;);</code> 出现异常</li>
<li>使用 try-catch 捕获 <code>FileNotFoundException</code> 异常</li>
<li>在 finally 中关流，此时可能会访问不到 fos 变量，因此需要在 try 外面定义 fos</li>
<li>在 finally 要先判断 fos 是否为空，只有 fos 不等于空才需要关流</li>
<li>调用 <code>fos.close();</code> 时又有异常，接着再进行 try-catch 捕获 <code>IOException</code> 异常</li>
<li>在 try 中调用 <code>fos.write();</code> 会有 <code>IOException</code>，添加一个新的 catch 分支捕获即可。<em>其实可以合并成一个 <code>IOException</code> 分支即可，分开只是为了更清晰问题</em></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;c.txt&quot;</span>);</span><br><span class="line">    fos.write(<span class="string">&quot;写点东西&quot;</span>.getBytes());</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// 关闭流失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-InputStream-字节输入流"><a href="#5-3-InputStream-字节输入流" class="headerlink" title="5.3. InputStream 字节输入流"></a>5.3. InputStream 字节输入流</h3><h4 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1. 概述"></a>5.3.1. 概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> </span><br></pre></td></tr></table></figure>
<p><code>InputStream</code> 字节输入流在 <code>java.io</code> 包中，是一个抽象类。字节输入流的根类，定义了所有字节输入流应该具备的方法。</p>
<p>此抽象类表示是所有字节输入流类的超类/父类/基类，常用子类有：</p>
<ul>
<li><code>java.io.FileInputStream</code></li>
<li><code>java.io.BufferedInputStream</code></li>
</ul>
<h4 id="5-3-2-常用方法"><a href="#5-3-2-常用方法" class="headerlink" title="5.3.2. 常用方法"></a>5.3.2. 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>
<ul>
<li>读取一个字节，返回的是字节内容本身，读取到末尾返回 <code>-1</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>将读取到字节输出存储到字节数组b 中，返回实际读取的字节个数。返回 <code>-1</code> 表示读到文件末尾。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>将读取到字节输出存储的字节数组b 中，返回实际读取的字节个数<ul>
<li><code>byte b[]</code>：存储读取的内容字节数组</li>
<li><code>int off</code>：从哪个位置开始存储</li>
<li><code>int len</code>：存几个字符</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>释放 IO 占用的系统底层资源</li>
</ul>
<h4 id="5-3-3-常用子类：FileInputStream-文件字节输入流"><a href="#5-3-3-常用子类：FileInputStream-文件字节输入流" class="headerlink" title="5.3.3. 常用子类：FileInputStream (文件字节输入流)"></a>5.3.3. 常用子类：FileInputStream (文件字节输入流)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStream</span> <span class="keyword">extends</span> <span class="title class_">InputStream</span></span><br></pre></td></tr></table></figure>
<p><code>java.io.FileInputStream</code> 是 <code>InputStream</code> 的一个常用子类，用于从文件中读取字节数据。其构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>通过字符串路径创建 <code>FileInputStream</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>File</code> 对象创建 <code>FileInputStream</code></li>
</ul>
<h4 id="5-3-4-字节输入流的使用步骤"><a href="#5-3-4-字节输入流的使用步骤" class="headerlink" title="5.3.4. 字节输入流的使用步骤"></a>5.3.4. 字节输入流的使用步骤</h4><ol>
<li>创建字节输入流对象并关联目标文件</li>
<li>调用 <code>read()</code> 方法读取数据：读一个字节，读一个字节数组，读一个字节数组的一部分。</li>
<li>关闭流释放资源。</li>
</ol>
<h4 id="5-3-5-字节输入流注意事项"><a href="#5-3-5-字节输入流注意事项" class="headerlink" title="5.3.5. 字节输入流注意事项"></a>5.3.5. 字节输入流注意事项</h4><ul>
<li>如果输入流关联的文件不存在，则会抛出异常。</li>
</ul>
<h4 id="5-3-6-基础示例"><a href="#5-3-6-基础示例" class="headerlink" title="5.3.6. 基础示例"></a>5.3.6. 基础示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关卡1训练案例5</span></span><br><span class="line"><span class="comment"> * 	利用字节输入流读取 C 盘文件 b.txt 的内容，</span></span><br><span class="line"><span class="comment"> * 	使用循环读取，一次读取一个字节数组，直到读取到文件末尾，</span></span><br><span class="line"><span class="comment"> * 	将读取到的字节数组转换成字符串输出到控制台。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_05</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 创建字节输入流对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;D:\\b.txt&quot;</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">        <span class="comment">// 定义一个字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-BufferedOutputStream-BufferedInputStream（字节缓冲流）"><a href="#5-4-BufferedOutputStream-BufferedInputStream（字节缓冲流）" class="headerlink" title="5.4. BufferedOutputStream / BufferedInputStream（字节缓冲流）"></a>5.4. BufferedOutputStream / BufferedInputStream（字节缓冲流）</h3><h4 id="5-4-1-缓冲流高效原理"><a href="#5-4-1-缓冲流高效原理" class="headerlink" title="5.4.1. 缓冲流高效原理"></a>5.4.1. 缓冲流高效原理</h4><p>利用缓冲区临时存储多个数据，统一调用底层资源将数据写入到目标文件中。Java 在常规 IO 流的基础上，提供了更为高效的缓冲流，如下：</p>
<ul>
<li>高效流使用普通流对象作为构造方法参数。将普通流包装，提供高效的装饰。<font color=red><strong>即在读写还是用到普通流来实现，高效流只提供了缓冲区（缓冲区就新建一个字节数组，而默认的数组长度是8192）</strong></font>。</li>
<li>高效流 <code>write</code> 写出数据时，写出位置为缓冲区，并非目标资源。需要通过 <code>flush</code> 刷新方法将缓冲区的内容写出到目标文件中。</li>
<li>高效输出流的关闭 <code>close</code> 方法先会自动调用 <code>flush</code> 方法，再关闭流。</li>
<li>都通减少调用底层资源的使用资料来达到高效</li>
</ul>
<p><strong>高效缓冲流除了创建对象的时候与普通字节流不一样，其他使用方式都和普通字节流一样</strong>。JDK1.5 后，高效缓冲流就高于普通字节流。</p>
<blockquote>
<p>Tips: 凡是字节流都没有 <code>write.newLine()</code> 和 <code>readLine()</code> 这个方法。</p>
</blockquote>
<h4 id="5-4-2-BufferedOutputStream（缓冲输出流、写数据）"><a href="#5-4-2-BufferedOutputStream（缓冲输出流、写数据）" class="headerlink" title="5.4.2. BufferedOutputStream（缓冲输出流、写数据）"></a>5.4.2. BufferedOutputStream（缓冲输出流、写数据）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedOutputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span> </span><br></pre></td></tr></table></figure>
<p><code>BufferedOutputStream</code> 继承了 <code>FilterOutputStream</code> 最终是继承 <code>OutputStream</code>。</p>
<h5 id="5-4-2-1-构造方法"><a href="#5-4-2-1-构造方法" class="headerlink" title="5.4.2.1. 构造方法"></a>5.4.2.1. 构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(OutputStream out)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 OutputStream 对象来创建 BufferedOutputStream。如：<code>new BufferedOutputStream(new FileOutputStream(&quot;xxx&quot;));</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedOutputStream</span><span class="params">(OutputStream out, <span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以传递任意的字节输出流对象，可以指定缓冲区大小。</li>
</ul>
<h5 id="5-4-2-2-普通方法"><a href="#5-4-2-2-普通方法" class="headerlink" title="5.4.2.2. 普通方法"></a>5.4.2.2. 普通方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写一个字节</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写字节数组，继承自 <code>FilterOutputStream</code> 类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写字节数组的一部分</li>
</ul>
<h4 id="5-4-3-BufferedInputStream（缓冲输入流、读数据）"><a href="#5-4-3-BufferedInputStream（缓冲输入流、读数据）" class="headerlink" title="5.4.3. BufferedInputStream（缓冲输入流、读数据）"></a>5.4.3. BufferedInputStream（缓冲输入流、读数据）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span></span><br></pre></td></tr></table></figure>
<p><code>BufferedInputStream</code> 继承了 <code>FilterInputStream</code> 最终是继承 <code>InputStream</code>。</p>
<h5 id="5-4-3-1-构造方法"><a href="#5-4-3-1-构造方法" class="headerlink" title="5.4.3.1. 构造方法"></a>5.4.3.1. 构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 InputStream 对象来创建一个 BufferedInputStream。如：<code>new BufferedInputStream(new FileInputStream(&quot;xxx&quot;));</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以传递任意的字节输入流对象，可以指定缓冲区大小。</li>
</ul>
<h5 id="5-4-3-2-普通方法"><a href="#5-4-3-2-普通方法" class="headerlink" title="5.4.3.2. 普通方法"></a>5.4.3.2. 普通方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>读取一个字节</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>读取一个字节数组，继承自 <code>FilterInputStream</code> 类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">read1</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>读取数组的部分</li>
</ul>
<h3 id="5-5-字节流综合案例"><a href="#5-5-字节流综合案例" class="headerlink" title="5.5. 字节流综合案例"></a>5.5. 字节流综合案例</h3><h4 id="5-5-1-案例1：4-种字节流复制文件"><a href="#5-5-1-案例1：4-种字节流复制文件" class="headerlink" title="5.5.1. 案例1：4 种字节流复制文件"></a>5.5.1. 案例1：4 种字节流复制文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关卡1训练案例12</span></span><br><span class="line"><span class="comment"> * 	四种复制文件方式比较</span></span><br><span class="line"><span class="comment"> * 		1.字节流复制文件一次读写一个字节</span></span><br><span class="line"><span class="comment"> * 		2.字节流复制文件一次读写一个字节数组</span></span><br><span class="line"><span class="comment"> * 		3.高效流复制文件一次读写一个字节</span></span><br><span class="line"><span class="comment"> * 		4.高效流复制文件一次读取一个字节数组</span></span><br><span class="line"><span class="comment"> * 	利用上面四种方式复制同一个文件，输出每一种复制方式花费的时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_12</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 创建复制的源文件路径对象和目标文件路径对象</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\abc.zip&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">copy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\我是复制品，Please kill me~2.zip&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">copy3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\我是复制品，Please kill me~3.zip&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">copy4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\我是复制品，Please kill me~4.zip&quot;</span>);</span><br><span class="line"></span><br><span class="line">		method04(src, copy4);</span><br><span class="line">		method03(src, copy3);</span><br><span class="line">		method02(src, copy2);</span><br><span class="line">		<span class="comment">// method01(src, copy);</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高效流复制文件一次读取一个字节数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method04</span><span class="params">(File src, File copy4)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 记录当前系统时间毫秒值</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建高效字节输入输出流对象</span></span><br><span class="line">		<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src));</span><br><span class="line">		<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(copy4));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 高效流复制文件一次读取一个字节数组</span></span><br><span class="line">		<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		<span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		bos.close();</span><br><span class="line">		bis.close();</span><br><span class="line">		<span class="comment">// 输出完成复制需要的时间</span></span><br><span class="line">		System.out.println(<span class="string">&quot;高效流复制文件一次读取一个字节数组耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高效流复制文件一次读写一个字节</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method03</span><span class="params">(File src, File copy)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 记录当前系统时间毫秒值</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建高效字节输入输出流对象</span></span><br><span class="line">		<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src));</span><br><span class="line">		<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(copy));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 高效流复制文件一次读写一个字节</span></span><br><span class="line">		<span class="type">int</span> b;</span><br><span class="line">		<span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">			bos.write(b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		bos.close();</span><br><span class="line">		bis.close();</span><br><span class="line">		<span class="comment">// 输出完成复制需要的时间</span></span><br><span class="line">		System.out.println(<span class="string">&quot;高效流复制文件一次读写一个字节耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 字节流复制文件一次读写一个字节数组</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method02</span><span class="params">(File src, File copy)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 记录当前系统时间毫秒值</span></span><br><span class="line">		<span class="type">Long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建字节输入输出流对象</span></span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">		<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(copy);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 字节流复制文件一次读写一个字节数组</span></span><br><span class="line">		<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		<span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			fos.write(b, <span class="number">0</span>, len);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		fos.close();</span><br><span class="line">		fis.close();</span><br><span class="line">		<span class="comment">// 输出完成复制需要的时间</span></span><br><span class="line">		System.out.println(<span class="string">&quot;字节流复制文件一次读写一个字节数组耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 字节流复制文件一次读写一个字节</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method01</span><span class="params">(File src, File copy)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 记录当前系统时间毫秒值</span></span><br><span class="line">		<span class="type">Long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 创建字节输入输出流对象</span></span><br><span class="line">		<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">		<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(copy);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 字节流复制文件一次读写一个字节</span></span><br><span class="line">		<span class="type">int</span> b;</span><br><span class="line">		<span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">			fos.write(b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		fos.close();</span><br><span class="line">		fis.close();</span><br><span class="line">		<span class="comment">// 输出完成复制需要的时间</span></span><br><span class="line">		System.out.println(<span class="string">&quot;字节流复制文件一次读写一个字节耗时：&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-5-2-案例2：字节流组合-File-类，复制文件夹下所有文件（包括文件夹与文件）"><a href="#5-5-2-案例2：字节流组合-File-类，复制文件夹下所有文件（包括文件夹与文件）" class="headerlink" title="5.5.2. 案例2：字节流组合 File 类，复制文件夹下所有文件（包括文件夹与文件）"></a>5.5.2. 案例2：字节流组合 File 类，复制文件夹下所有文件（包括文件夹与文件）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关卡2训练案例3(增加需要，指定文件夹下有多个文件夹，将所有文件（含文件夹复制到目标文件夹中）)</span></span><br><span class="line"><span class="comment"> * 	在 C 盘下创建一个目录 d1,在目录 d1 下创建创建若干个文本文件，</span></span><br><span class="line"><span class="comment"> * 	并在每一个文本文件中添加若干内容。利用字节高效流将该目录下的所有文件复制到 C 盘下的 d2 目录下。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2_03</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 创建复制源和目标路径对象</span></span><br><span class="line">		<span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\srcFile&quot;</span>);</span><br><span class="line">		<span class="type">File</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\copyFile&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用复制所有文件的方法</span></span><br><span class="line">		copyAllfile(src, copy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 递归方法读取源路径中的所有文件</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">	 *            源文件路径</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> copy</span></span><br><span class="line"><span class="comment">	 *            目标文件路径</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyAllfile</span><span class="params">(File src, File copy)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 先判断目标路径的文件是否存在，如果不存在，就创建文件夹</span></span><br><span class="line">		<span class="keyword">if</span> (!copy.exists()) &#123;</span><br><span class="line">			copy.mkdirs();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用listFiles方法获取当前文件下所有file对象的数组</span></span><br><span class="line">		File[] list = src.listFiles();</span><br><span class="line">		<span class="comment">// 遍历数组，判断如果是文件，直接判断到目标文件路径中</span></span><br><span class="line">		<span class="keyword">for</span> (File f : list) &#123;</span><br><span class="line">			<span class="comment">// 将目标路径修改成需要的路径</span></span><br><span class="line">			<span class="type">File</span> <span class="variable">copyNewFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(copy, f.getName());</span><br><span class="line">			<span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">				<span class="comment">// 调用复制文件的方法进行文件复制</span></span><br><span class="line">				copyFile(f, copyNewFile);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				copyAllfile(f, copyNewFile);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 复制文件到目标路径的方法</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">	 *            源文件路径</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> copy</span></span><br><span class="line"><span class="comment">	 *            目标文件路径</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File src, File copy)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 创建高效字节输入输出流对象</span></span><br><span class="line">		<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src));</span><br><span class="line">		<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(copy));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用一次读取数组的方式复制文件</span></span><br><span class="line">		<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="type">int</span> len;</span><br><span class="line">		<span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">			bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 释放资源</span></span><br><span class="line">		bis.close();</span><br><span class="line">		bos.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-转换流"><a href="#6-转换流" class="headerlink" title="6. 转换流"></a>6. 转换流</h2><h3 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1. 概念"></a>6.1. 概念</h3><p>为什么要使用转换流？因为使用 <code>FileReader</code> 或 <code>BufferedReader</code> 读取文件时，<strong>默认使用的编码是 GBK</strong>。如果读取的文件的编码格式是 UTF-8 时，则不能使用 <code>FileReader</code> 或 <code>BufferedReader</code> 读取。此时就需要利用转换流读取文件的内容。</p>
<p>转换流的作用：字节流和字符流相互转换的桥梁。</p>
<p>转换流是字符流的一种，创建对象时传入对应字节流对象即可完成转换动作。转换流同样使用了包装的思想，其构造方法接收的同样为 IO 流对象，并非某个文件资源。关闭转换流的同时即关闭了对应的字节流。</p>
<font color=purple>**构造方法传入字节流对象自身调用字符流的方法**</font>

<h3 id="6-2-字符编码表"><a href="#6-2-字符编码表" class="headerlink" title="6.2. 字符编码表"></a>6.2. 字符编码表</h3><h4 id="6-2-1-什么是编码表"><a href="#6-2-1-什么是编码表" class="headerlink" title="6.2.1. 什么是编码表"></a>6.2.1. 什么是编码表</h4><p>将现实生活中的文字对应数字，存储的是数字的二进制。</p>
<p><strong>编码表</strong>：就是生活中字符和计算机二进制的对应关系表。</p>
<h4 id="6-2-2-ASCII-码表"><a href="#6-2-2-ASCII-码表" class="headerlink" title="6.2.2. ASCII 码表"></a>6.2.2. ASCII 码表</h4><p>ASCII 码表：American Standard Code for Information Interchange/美国信息交换标准代码</p>
<p>一个字节中的 7 位就可以表示。对应的字节都是正数。<code>0 ~ xxxxxx</code></p>
<p>其他常见码表有：ASCII, ISO-8859-1, GBK, UTF-8</p>
<h4 id="6-2-3-支持中文的码表"><a href="#6-2-3-支持中文的码表" class="headerlink" title="6.2.3. 支持中文的码表"></a>6.2.3. 支持中文的码表</h4><ul>
<li>GB2312：简体中文码表。兼容 ASCII 码表，并加入了中文字符，包含 6000~7000 中文和符号。用两个字节表示。两个字节第一个字节是负数,第二个字节可能是正数</li>
<li>GBK：目前最常用的中文码表，兼容 GB2312 码表，2 万的中文和符号。用两个字节表示，其中的一部分文字，第一个字节开头是 1，第二字节开头是 0</li>
<li>GB18030：最新的中文码表，目前还没有正式使用。</li>
<li>Unicode码表：国际码表，包含各国大多数常用字符，每个字符都占 2 个字节，因此有 65536 个字符映射关系。Java 语言使用的 char 类型就是使用 Unicode 码表，如 <code>char c = &#39;a&#39;;</code> 占两个字节。</li>
<li>UTF-8：基于 unicode，一个字节就可以存储数据，不要用两个字节存储，而且这个码表更加的标准化 中文一般使用 3 个字节表示</li>
</ul>
<h4 id="6-2-4-编码-解码"><a href="#6-2-4-编码-解码" class="headerlink" title="6.2.4. 编码/解码"></a>6.2.4. 编码/解码</h4><ul>
<li>编码：将文字对应到数字，如：<code>a -&gt; 97</code></li>
<li>解码: 将数字对应到文字，如：<code>97 -&gt; a</code></li>
</ul>
<h4 id="6-2-5-乱码"><a href="#6-2-5-乱码" class="headerlink" title="6.2.5. 乱码"></a>6.2.5. 乱码</h4><p>乱码，是指因为文本在存储时使用的映射码表和在读取时使用的码表不一致造成的。</p>
<p>当将字符串转为对应的数字字节时，需要指定码表，则存储了为该字符该码表对应的数字字节，如果使用了其他码表重写翻译回字符串，则拼写的新字符串会乱码。</p>
<p>对于 IO 操作，与字符串编码表使用类似，当以某个码表写出字节数据时，又使用另外码表展示，会出现乱码。</p>
<h3 id="6-3-OutputStreamWriter（输出转换流）"><a href="#6-3-OutputStreamWriter（输出转换流）" class="headerlink" title="6.3. OutputStreamWriter（输出转换流）"></a>6.3. OutputStreamWriter（输出转换流）</h3><h4 id="6-3-1-继承体系"><a href="#6-3-1-继承体系" class="headerlink" title="6.3.1. 继承体系"></a>6.3.1. 继承体系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span></span><br></pre></td></tr></table></figure>
<p>OutputStreamWriter 是<font color=red><strong>字符流通向字节流</strong></font>的桥梁：可使用<font color=red><strong>指定的 charset 将要写入流中的字符编码成字节</strong></font>。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035051.jpg" alt=""></p>
<h4 id="6-3-2-构造方法"><a href="#6-3-2-构造方法" class="headerlink" title="6.3.2. 构造方法"></a>6.3.2. 构造方法</h4><p>通过构造函数看出，可以完成<strong>字节输出流转换为字符输出流</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用默认的编码表创建 <code>OutputStreamWriter</code>。默认是 GBK</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out, String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException</span><br></pre></td></tr></table></figure>
<ul>
<li>使用指定的编码表创建 <code>OutputStreamWrite</code>，参数 <code>charsetName</code> 可选值如：gbk/GBK, utf-8/UTF-8 等等。默认是 GBK，通常在使用 UTF-8 的时候才需要指定。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方式1:</span></span><br><span class="line"><span class="comment">// 1.创建字节输出流</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 2.将字节流转为字符流，即通过字节流对象创建转换流对象</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos);</span><br><span class="line"><span class="comment">// 构造方式2（常用）:</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-常用方法"><a href="#6-3-3-常用方法" class="headerlink" title="6.3.3. 常用方法"></a>6.3.3. 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> <span class="keyword">throws</span> IOException </span><br></pre></td></tr></table></figure>
<ul>
<li>写入单个字符。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写入字符数组。继承自 <code>Writer</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写入字符数组的某一部分。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写入字符串。继承自 <code>Writer</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>写入字符串的某一部分。</li>
</ul>
<h4 id="6-3-4-字符流转字节流的过程"><a href="#6-3-4-字符流转字节流的过程" class="headerlink" title="6.3.4. 字符流转字节流的过程"></a>6.3.4. 字符流转字节流的过程</h4><ol>
<li>首先通过 <code>OutputStreamWriter</code> 查询指定码表，将要输出的内容转换成对应的字节。</li>
<li>然后将转换的字节交给 <code>FileOutputStream</code> 输出到文件。</li>
<li>最后关闭流释放资源。</li>
</ol>
<h3 id="6-4-InputStreamReader（输入转换流）"><a href="#6-4-InputStreamReader（输入转换流）" class="headerlink" title="6.4. InputStreamReader（输入转换流）"></a>6.4. InputStreamReader（输入转换流）</h3><h4 id="6-4-1-继承体系"><a href="#6-4-1-继承体系" class="headerlink" title="6.4.1. 继承体系"></a>6.4.1. 继承体系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span></span><br></pre></td></tr></table></figure>
<p>InputStreamReader 是<font color=red><strong>字节流通向字符流的桥梁</strong></font>：它使用<font color=red><strong>指定的 charset 读取字节并将其解码为字符</strong></font></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035052.jpg" alt=""></p>
<h4 id="6-4-2-构造方法"><a href="#6-4-2-构造方法" class="headerlink" title="6.4.2. 构造方法"></a>6.4.2. 构造方法</h4><p>通过构造函数看出，可以完成<strong>字节输入流转换为字符输入流</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用默认的编码表创建 InputStreamReader</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in, String charsetName)</span> <span class="keyword">throws</span> UnsupportedEncodingException</span><br></pre></td></tr></table></figure>
<ul>
<li>使用指定的编码表创建 InputStreamReader，参数 <code>charsetName</code> 可选值：GBK/UTF-8</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方式1:</span></span><br><span class="line"><span class="comment">// 1.创建字节输入流</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 2.将字节流转为字符流，即通过字节流对象创建转换流对象</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);</span><br><span class="line"><span class="comment">// 构造方式2（常用）:</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;a.txt&quot;</span>), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>
<h4 id="6-4-3-常用方法"><a href="#6-4-3-常用方法" class="headerlink" title="6.4.3. 常用方法"></a>6.4.3. 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>读取单个字符。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>将字符读入数组。继承自 <code>Reader</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<ul>
<li>将字符读入数组中的某一部分。</li>
</ul>
<h4 id="6-4-4-字节流转换字符流的过程"><a href="#6-4-4-字节流转换字符流的过程" class="headerlink" title="6.4.4. 字节流转换字符流的过程"></a>6.4.4. 字节流转换字符流的过程</h4><ol>
<li>由字节输入流去目标文件中读取数据，获得对应的字节。</li>
<li>然后将字节交给转换流去查询对应的编码表，得到对应的字符。</li>
<li>最后关闭流释放资源。</li>
</ol>
<h3 id="6-5-转换流与字符流子类"><a href="#6-5-转换流与字符流子类" class="headerlink" title="6.5. 转换流与字符流子类"></a>6.5. 转换流与字符流子类</h3><h4 id="6-5-1-两者的区别"><a href="#6-5-1-两者的区别" class="headerlink" title="6.5.1. 两者的区别"></a>6.5.1. 两者的区别</h4><p><code>Writer</code> 字符输出流：</p>
<ul>
<li><code>OutputStreamWriter</code>：转换流写入数据，可以指定字符编码表。</li>
<li><code>FileWriter</code>：字符输出流，采用默认的字符编码表（GBK）。</li>
</ul>
<p><code>Reader</code> 字符输入流：</p>
<ul>
<li><code>InputStreamReader</code>：转换流读取数据，可以指定字符编码表。</li>
<li><code>FileReader</code>：字符输入流，采用默认的字符编码表（GBK）。</li>
</ul>
<h4 id="6-5-2-FileReader-FileWriter-原理"><a href="#6-5-2-FileReader-FileWriter-原理" class="headerlink" title="6.5.2. FileReader / FileWriter 原理"></a>6.5.2. FileReader / FileWriter 原理</h4><p>FileReader / FileWriter 构造方法实际上使用的是 InputStreamReader / OutputStreamWriter 的构造方法中的默认码表。</p>
<p>字符流其实用的就是转换流，只是使用默认码表，不能指定编码表而已。</p>
<h4 id="6-5-3-转换流与字符流使用选择"><a href="#6-5-3-转换流与字符流使用选择" class="headerlink" title="6.5.3. 转换流与字符流使用选择"></a>6.5.3. 转换流与字符流使用选择</h4><p>什么时候使用转换流，什么时候使用字符流 FileReader / FileWriter？</p>
<ul>
<li>如果需要修改默认的码表，必须使用转换流（默认的码表是：GBK）。可以使用转换流包装字节缓冲输入输出流。</li>
<li>如果不需要指定码表，使用 FileReader / FileWriter (代码简单一点)</li>
</ul>
<h2 id="7-打印流"><a href="#7-打印流" class="headerlink" title="7. 打印流"></a>7. 打印流</h2><h3 id="7-1-打印流的概念与分类"><a href="#7-1-打印流的概念与分类" class="headerlink" title="7.1. 打印流的概念与分类"></a>7.1. 打印流的概念与分类</h3><p>打印流的作用是：为其他流添加功能，使其能方便输出各种数据类型的值。其最大的特点是：<font color=red><strong>只有输出数据的流，没有读取数据的流</strong></font>。分成以下两类：</p>
<ul>
<li>字节打印流: <code>java.io.PrintStream</code>，继承了 <code>FilterOutputStream</code>，顶层父类是 <code>OutputStream</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream</span> <span class="keyword">extends</span> <span class="title class_">FilterOutputStream</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, Closeable</span><br></pre></td></tr></table></figure>
<ul>
<li>字符打印流: <code>java.io.PrintWriter</code>， 继承 Writer</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tips: 以上两种流的方法使用是一样的。</p>
</blockquote>
<h3 id="7-2-打印流使用方法"><a href="#7-2-打印流使用方法" class="headerlink" title="7.2. 打印流使用方法"></a>7.2. 打印流使用方法</h3><blockquote>
<p><code>PrintWrite</code> 与 <code>PrintStream</code> 使用方法一样，下面以 <code>PrintStream</code> 为示例说明</p>
</blockquote>
<h4 id="7-2-1-PrintStream-类构造方法"><a href="#7-2-1-PrintStream-类构造方法" class="headerlink" title="7.2.1. PrintStream 类构造方法"></a>7.2.1. PrintStream 类构造方法</h4><p><code>PrintStream</code> 类有很多构造方法，以下是常用的构造方法介绍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>创建具有指定文件名称且不带自动行刷新的新打印流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure>
<ul>
<li>创建具有指定文件且不带自动行刷新的新打印流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush)</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>根据字节输入流出，并可以指定是否自动行刷新，创建打印流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush, String encoding)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根据字节输入流出，并可以指定是否自动行刷新、指定字符编码，创建打印流</li>
</ul>
<p>示例：在创建字节流时指定可以追加输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果需要追加输出，也可以在创建 FileOutputStream 对象时指定 append 参数为 true</span></span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ps.txt&quot;</span>,<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<h4 id="7-2-2-PrintStream-类成员方法"><a href="#7-2-2-PrintStream-类成员方法" class="headerlink" title="7.2.2. PrintStream 类成员方法"></a>7.2.2. PrintStream 类成员方法</h4><p>PrintStream 类常用的成员方法主要是 <code>print</code> 与 <code>println</code>，并有大量的重载方法</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035053.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(数据类型 变量名)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将指定数据类型的值打印到流关联目标文件中，不换行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(数据类型 变量名)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将指定数据类型的值打印到流关联目标文件中，换行。</li>
</ul>
<h2 id="8-IO-流总结（字符流和字节流）"><a href="#8-IO-流总结（字符流和字节流）" class="headerlink" title="8. IO 流总结（字符流和字节流）"></a>8. IO 流总结（字符流和字节流）</h2><h3 id="8-1-Java-IO-体系图"><a href="#8-1-Java-IO-体系图" class="headerlink" title="8.1. Java IO 体系图"></a>8.1. Java IO 体系图</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035054.png" alt="Java IO体系.xmind"></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035055.jpg" alt="Java IO 分类总结.drawio"></p>
<h3 id="8-2-字节流与字符流的区别"><a href="#8-2-字节流与字符流的区别" class="headerlink" title="8.2. 字节流与字符流的区别"></a>8.2. 字节流与字符流的区别</h3><ul>
<li>字节流：以字节为单位输入输出数据，按照 8 位传输。</li>
<li>字符流：以字符为单位输入输出数据，按照 16 位传输。</li>
<li>字节流可以处理所有格式的文件。</li>
<li><font color=red><strong>字符流在处理文本的效率比字节流高</strong></font>。</li>
</ul>
<p>在 Java 中，可以根据结尾来判断是字节流还是字符流。</p>
<ul>
<li><code>InputStream</code>/<code>OutputStream</code>：字节流</li>
<li><code>Writer</code>/<code>Reader</code>：字符流</li>
</ul>
<h4 id="8-2-1-字节流和字符流的选择"><a href="#8-2-1-字节流和字符流的选择" class="headerlink" title="8.2.1. 字节流和字符流的选择"></a>8.2.1. 字节流和字符流的选择</h4><ul>
<li>绝大多数情况下使用字节流会更好，因为字节流是字符流的包装，而大多数时候 IO 操作都是直接操作磁盘文件，所以这些流在传输时都是以字节的方式进行的（图片等都是按字节存储的）。</li>
<li>如果操作需要通过 IO 在内存中频繁处理字符串的情况，使用字符流会比较好，因为字符流具备缓冲区，提高了性能。</li>
</ul>
<h2 id="9-BIO-编程"><a href="#9-BIO-编程" class="headerlink" title="9. BIO 编程"></a>9. BIO 编程</h2><p>BIO 有的称之为 basic(基本) IO，有的称之为 block(阻塞) IO，主要应用于文件 IO 和网络 IO。</p>
<p>BIO 主要的 API 在 <code>java.io</code> 包中，其中重点包含 5 个类（<code>File</code>、<code>OutputStream</code>、<code>InputStream</code>、<code>Writer</code>、<code>Reader</code>）和 1 个接口（<code>Serializable</code>）。</p>
<h3 id="9-1-基于-BIO-的网络-IO"><a href="#9-1-基于-BIO-的网络-IO" class="headerlink" title="9.1. 基于 BIO 的网络 IO"></a>9.1. 基于 BIO 的网络 IO</h3><p>在 JDK1.4 之前，我们建立网络连接的时候只能采用 BIO，需要先在服务端启动一个 ServerSocket，然后在客户端启动 Socket 来对服务端进行通信，默认情况下服务端需要对每个请求建立一个线程等待请求，而客户端发送请求后，先咨询服务端是否有线程响应，如果没有则会一直等待或者遭到拒绝，如果有的话，客户端线程会等待请求结束后才继续执行，这就是阻塞式 IO</p>
<h3 id="9-2-基本用法示例（基于-TCP）"><a href="#9-2-基本用法示例（基于-TCP）" class="headerlink" title="9.2. 基本用法示例（基于 TCP）"></a>9.2. 基本用法示例（基于 TCP）</h3><ul>
<li>编写TCP服务端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.system.testmodule.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BIO 编程测试 - TCP服务器端程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建ServerSocket对象，设置端口号为9999</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 监听客户端</span></span><br><span class="line">            System.out.println(<span class="string">&quot;serverSocket.accept()执行前&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();  <span class="comment">// 阻塞，等客户端启动</span></span><br><span class="line">            System.out.println(<span class="string">&quot;serverSocket.accept()执行完&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 从连接中取出输入流来接收消息</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();  <span class="comment">// 阻塞，等待接收客户端发出的消息</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            inputStream.read(bytes);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">clientIP</span> <span class="operator">=</span> socket.getInetAddress().getHostAddress();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%s说：%s&quot;</span>, clientIP, <span class="keyword">new</span> <span class="title class_">String</span>(bytes).trim()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 从连接中取出输出流并回话</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">&quot;TCPServer收到消息&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  5. 关闭socket</span></span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码编写了一个服务器端程序，绑定端口号 9999，accept 方法用来监听客户端连接，如果没有客户端连接，就一直等待，程序会阻塞在<code>serverSocket.accept()</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.system.testmodule.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BIO 编程测试 - TCP客户端程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.创建Socket对象，连接9999端口</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.从连接中取出输出流并发消息</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入:&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            outputStream.write(msg.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.从连接中取出输入流并接收回话</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream(); <span class="comment">// 阻塞，一直等待服务端的响应</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">            is.read(bytes);</span><br><span class="line">            System.out.println(<span class="string">&quot;TCPServer回复：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(bytes).trim());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.关闭</span></span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码编写了一个客户端程序，通过 9999 端口连接服务器端，getInputStream 方法用来等待服务器端返回数据，如果没有返回，就一直等待，程序会阻塞在<code>socket.getInputStream()</code>方法</li>
</ul>
<h2 id="10-NIO-编程"><a href="#10-NIO-编程" class="headerlink" title="10. NIO 编程"></a>10. NIO 编程</h2><h3 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1. 概述"></a>10.1. 概述</h3><p>java.nio 全称 java non-blocking IO，是指 JDK 提供的新 API。从 JDK1.4 开始，Java 提供了一系列改进的输入/输出的新特性，被统称为 NIO(即 New IO)。新增了许多用于处理输入输出的类，这些类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写，新增了满足 NIO 的功能。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035056.png" alt=""></p>
<h4 id="10-1-1-Java-NIO-和传统-I-O-的区别"><a href="#10-1-1-Java-NIO-和传统-I-O-的区别" class="headerlink" title="10.1.1. Java NIO 和传统 I/O 的区别"></a>10.1.1. Java NIO 和传统 I/O 的区别</h4><p>Java NIO 和 传统的 BIO 有着相同的目的和作用，但还是有以下的区别：</p>
<ol>
<li>实现方式不同：传统 I/O 是面向流的，以流的方式处理数据；NIO 是面向缓冲区的，以块的方式处理数据。在流的操作中，数据只能在一个流中连续进行读写，数据没有缓冲；而面向缓冲区的操作，数据可以从一个 Channel 读取到一个 Buffer 中，再从 Buffer 写入 CHannel 中，可以方便地在缓冲区中进行数据的前后移动等操作。块 I/O 的效率比流 I/O 高很多，这种功能在应用层主要用于数据的粘包、拆包等操作。</li>
<li>传统 I/O 的流操作是阻塞模式的，NIO 是基于多路复用 I/O 模型实现非阻塞模式的。传统的 I/O 中，用户线程调用 <code>read()</code> 或者 <code>write()</code> 进行 I/O 读写操作时，该线程将一直阻塞，直到数据读写完成；而 NIO 通过 Selector 监听 Channel 上事件的变化，在 Channel 上有数据变化时通知该线程进行读写操作。</li>
</ol>
<h4 id="10-1-2-NIO-三大核心组件"><a href="#10-1-2-NIO-三大核心组件" class="headerlink" title="10.1.2. NIO 三大核心组件"></a>10.1.2. NIO 三大核心组件</h4><font color=red>**NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector(选择器)**</font>。

传统的 BIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。

#### 10.1.3. NIO 的非阻塞

传统 IO 的各种流是阻塞的。即当一个线程调用 `read()` 或 `write()` 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再做任何事情了。

NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不会保持线程阻塞。所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写数据也一样，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。

线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

#### 10.1.4. NIO 和 IO 适用场景

NIO 是为弥补传统 IO 的不足而诞生的，但 NIO 也有自身的缺点。因为 NIO 是面向缓冲区的操作，每一次的数据处理都是对缓冲区进行的，那么在数据处理之前必须要判断缓冲区的数据是否完整或者已经读取完毕，如果没有，假设数据只读取了一部分，那么对不完整的数据处理没有任何意义。所以每次数据处理之前都要检测缓冲区数据。

NIO 和 IO 各适用的场景：

- 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，此时使用 NIO 处理数据可能是个很好的选择。
- 而如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的 IO 更合适。

使用哪种类型来处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作比较来权衡选择。

### 10.2. 通道（Channel）

#### 10.2.1. 概述

通道（Channel）类似于 BIO 中的 Stream(流)。只是 Stream(流)是单向，分为 InputStream(输入流)和 OutputStream(输出流)；而 **NIO 中的通道(Channel)是双向的**，既可以用来进行读操作，也可以用来进行写操作。

> Notes: **BIO 中的 stream 是单向的**，例如 `FileInputStream` 用来建立到目标（文件，网络套接字，硬件设备等）的一个连接，对象只能进行读取数据的操作。

#### 10.2.2. Channel 接口实现类

NIO 中常用的 `Channel` 实现类有：

|     Channel 实现类     |               作用               |
| --------------------- | ------------------------------- |
| `FileChannel`         | 用于文件的数据读写                 |
| `DatagramChannel`     | 用于 UDP 协议网络通信的数据读写     |
| `ServerSocketChannel` | Socket Server 用于 TCP 的数据读写 |
| `SocketChannel`       | Socket Client 用于 TCP 的数据读写 |

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035057.png)

#### 10.2.3. FileChannel（文件的数据读写）

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FileChannel</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractInterruptibleChannel</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">SeekableByteChannel</span>, GatheringByteChannel, ScatteringByteChannel</span><br></pre></td></tr></table></figure>

该类主要用来对本地文件进行 IO 操作，主要方法如下

- 从通道读取数据并放到缓冲区中

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span>;</span><br></pre></td></tr></table></figure>

- 把缓冲区的数据写到通道中

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(ByteBuffer src)</span>;</span><br></pre></td></tr></table></figure>

- 从目标通道中复制数据到当前通道

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferFrom</span><span class="params">(ReadableByteChannel src, <span class="type">long</span> position, <span class="type">long</span> count)</span>;</span><br></pre></td></tr></table></figure>

- 把数据从当前通道复制给目标通道

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">transferTo</span><span class="params">(<span class="type">long</span> position, <span class="type">long</span> count, WritableByteChannel target)</span>;</span><br></pre></td></tr></table></figure>

#### 10.2.4. ServerSocketChannel（服务 TCP 的数据读写）

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ServerSocketChannel</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSelectableChannel</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NetworkChannel</span></span><br></pre></td></tr></table></figure>

ServerSocketChannel，用来在服务器端监听新的客户端 Socket 连接。常用方法如下

- 得到一个 ServerSocketChannel 通道

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title function_">open</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 设置服务器端端口号

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title function_">bind</span><span class="params">(SocketAddress local)</span></span><br></pre></td></tr></table></figure>

- 设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title function_">configureBlocking</span><span class="params">(<span class="type">boolean</span> block)</span></span><br></pre></td></tr></table></figure>

- 接受一个连接，返回代表这个连接的通道对象

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SocketChannel <span class="title function_">accept</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 注册一个选择器并设置监听事件

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops)</span></span><br></pre></td></tr></table></figure>

#### 10.2.5. SocketChannel（客户端 TCP 的数据读写）

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SocketChannel</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSelectableChannel</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ByteChannel</span>, ScatteringByteChannel, GatheringByteChannel, NetworkChannel</span><br></pre></td></tr></table></figure>

SocketChannel，网络 IO 通道，具体负责进行读写操作。NIO 总是把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。常用方法如下所示

- 得到一个 SocketChannel 通道

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title function_">open</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title function_">configureBlocking</span><span class="params">(<span class="type">boolean</span> block)</span></span><br></pre></td></tr></table></figure>

- 连接服务器

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connect</span><span class="params">(SocketAddress remote)</span></span><br></pre></td></tr></table></figure>

- 如果上面的方法连接失败，接下来就要通过该方法完成连接操作

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">finishConnect</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 往通道里写数据

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(ByteBuffer src)</span></span><br></pre></td></tr></table></figure>

- 从通道里读数据

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(ByteBuffer dst)</span></span><br></pre></td></tr></table></figure>

- 注册一个选择器并设置监听事件，最后一个参数可以设置共享数据

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title function_">register</span><span class="params">(Selector sel, <span class="type">int</span> ops, Object att)</span></span><br></pre></td></tr></table></figure>

- 关闭通道

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

### 10.3. 缓冲区（Buffer）

#### 10.3.1. 概述

Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它也不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 

而 NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

缓冲区（Buffer）：实际上是一个容器，其内部通过一个连续的字节数组存储 I/O 上的数据。缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。**Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer**，如下图所示（以文件读写为例）：

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035058.png)

#### 10.3.2. Buffer 抽象实现类

在 NIO 中，`java.nio.Buffer` 是一个顶层抽象类，对于 Java 中的不同的基本数据类型都有一个 `Buffer` 类型实现与之相对应。常用的 `Buffer` 子类如下：

|   Buffer 子类   |       作用类型       |
| -------------- | ------------------- |
| `ByteBuffer`   | 存储字节数据到缓冲区   |
| `ShortBuffer`  | 存储字符串数据到缓冲区 |
| `CharBuffer`   | 存储字符数据到缓冲区   |
| `IntBuffer`    | 存储整数数据到缓冲区   |
| `LongBuffer`   | 存储长整型数据到缓冲区 |
| `DoubleBuffer` | 存储小数到缓冲区      |
| `FloatBuffer`  | 存储小数到缓冲区      |

#### 10.3.3. ByteBuffer（存储字节数据）

最常用的自然是 ByteBuffer 类（二进制数据），该类的主要方法如下所示

- 存储字节数据到缓冲区

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">put</span><span class="params">(<span class="type">byte</span>[] b)</span>;</span><br></pre></td></tr></table></figure>

- 从缓冲区获得字节数据

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">byte</span>[] get();</span><br></pre></td></tr></table></figure>

- 把缓冲区数据转换成字节数组

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">byte</span>[] array();</span><br></pre></td></tr></table></figure>

- 设置缓冲区的初始容量

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocate</span><span class="params">(<span class="type">int</span> capacity)</span>;</span><br></pre></td></tr></table></figure>

- 把一个现成的数组放到缓冲区中使用

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">wrap</span><span class="params">(<span class="type">byte</span>[] array)</span>;</span><br></pre></td></tr></table></figure>

- 翻转缓冲区，重置位置到初始位置。相当于切换模式，如：『写模式切换成读模式』或者『读模式切换成写模式』 

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 清空整个缓冲区数据。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Buffer <span class="title function_">clear</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 清空缓冲区部分数据。只清除已经读取的数据，未读取的数据会被移到 buffer 的开头，此时写入数据会从当前数据的末尾开始。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title function_">compact</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

### 10.4. 选择器（Selector）

#### 10.4.1. 概述

一般的 IO 操作，如果用阻塞 I/O，需要多线程（浪费内存）；如果用非阻塞 I/O，需要不断重试（耗费CPU）。

Selector（选择器），能够检测多个注册的 Channel 通道上是否有 I/O 事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应和处理。因此只用一个 Selector 单线程去管理多个通道，也就是管理多个连接，并且不必为每个连接都创建一个线程，避免了多线程之间的上下文切换导致的开销。同时，Selector 只有在 Channel 有真正有读写事件发生时，才会调用 I/O 函数来进行读写，从而大大地减少了系统开销。

#### 10.4.2. Selector 类关系图

`Selector` 类关系图如下：

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035059.png)

#### 10.4.3. Selector 常用方法

- 得到一个选择器对象

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title function_">open</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 监控所有注册的通道，当其中有 IO 操作可以进行时，将对应的 SelectionKey 加入到内部集合中并返回，参数用来设置超时时间

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">long</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

- 从内部集合中得到所有的 SelectionKey

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title function_">selectedKeys</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 获取所有准备就绪的网络通道

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;SelectionKey&gt; <span class="title function_">keys</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

#### 10.4.4. SelectionKey 类(网络通道key)

`SelectionKey`，代表了 `Selector` 和网络通道的注册关系，一共四种：

- `int OP_ACCEPT`：有新的网络连接可以接受，值为 16
- `int OP_CONNECT`：代表连接已经建立，值为 8
- `int OP_READ`：代表读操作，值为 1
- `int OP_WRITE`：代表写操作，值为 4

该类的常用方法如下所示：

- 得到与之关联的 Selector 对象

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title function_">selector</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 得到与之关联的通道

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title function_">channel</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 得到与之关联的共享数据

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">attachment</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 设置或改变监听事件

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title function_">interestOps</span><span class="params">(<span class="type">int</span> ops)</span></span><br></pre></td></tr></table></figure>

- 是否可以 accept

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isAcceptable</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 是否可以读

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isReadable</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 是否可以写

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isWritable</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

### 10.5. 文件 NIO 示例

测试使用 NIO 进行本地文件的读、写和复制操作，和 BIO 进行对比

#### 10.5.1. 往本地文件中写数据

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 往本地文件中写数据 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWrite</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 创建输出流</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\moon.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 从流中得到一个通道</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">    <span class="comment">// 3. 提供一个缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 4. 往缓冲区中存入数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello,nio&quot;</span>;</span><br><span class="line">    buffer.put(str.getBytes());</span><br><span class="line">    <span class="comment">// 5. 翻转缓冲区</span></span><br><span class="line">    buffer.flip();</span><br><span class="line">    <span class="comment">// 6. 把缓冲区写到通道中</span></span><br><span class="line">    fileChannel.write(buffer);</span><br><span class="line">    <span class="comment">// 7. 关闭</span></span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

> NIO 中的通道是从输出流对象里通过 `getChannel` 方法获取到的，该通道是双向的，既可以读，又可以写。在往通道里写数据之前，必须通过 put 方法把数据存到 `ByteBuffer` 中，然后通过通道的 `write` 方法写数据。在 `write` 之前，需要调用 `flip` 方法翻转缓冲区，把内部重置到初始位置，这样在接下来写数据时才能把所有数据写到通道里

#### 10.5.2. 从本地文件中读数据

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从本地文件中读取数据 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\moon.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 1. 创建输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">    <span class="comment">// 2. 得到一个通道</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">    <span class="comment">// 3. 准备一个缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate((<span class="type">int</span>) file.length());</span><br><span class="line">    <span class="comment">// 4. 从通道里读取数据并存到缓冲区中</span></span><br><span class="line">    fileChannel.read(buffer);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">    <span class="comment">// 5. 关闭</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

> 上面示例从输入流中获得一个通道，然后提供 ByteBuffer 缓冲区，该缓冲区的初始容量和文件的大小一样，最后通过通道的 read 方法把数据读取出来并存储到了 ByteBuffer 中

#### 10.5.3. 复制本地文件

以下示例通过传统的 BIO 复制一个文件，分别通过输入流和输出流实现了文件的复制

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用 BIO 实现文件复制 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBioCopy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 创建两个流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\moon.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\moon_copy.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 定义字节数组，使用一次读取数组方式复制文件</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fileOutputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 关闭资源</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

以下示例使用 NIO 实现文件复制，分别从两个流中得到两个通道，sourceCh 负责读数据，destCh 负责写数据，然后直接调用 transferFrom 方法一步到位实现了文件复制

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用 NIO 实现文件复制 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNioCopy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1. 创建两个流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\moon.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:\\moon_copy.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 得到两个通道</span></span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileInChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileOutChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">    <span class="comment">// 3. 复制</span></span><br><span class="line">    fileOutChannel.transferFrom(fileInChannel, <span class="number">0</span>, fileInChannel.size());</span><br><span class="line">    <span class="comment">// 4. 关闭</span></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 10.6. 网络 IO

#### 10.6.1. 概述

Java NIO 中的网络通道是非阻塞 IO 的实现，基于事件驱动，非常适用于服务器需要维持大量连接，但是数据交换量不大的情况，例如一些即时通信的服务等等...

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035060.png)

如下图描述，从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035061.png)

在 Java 中编写 Socket 服务器，通常有以下几种模式：

- 一个客户端连接用一个线程。
    - 优点：程序编写简单。
    - 缺点：如果连接非常多，分配的线程也会非常多，服务器可能会因为资源耗尽而崩溃。
- 将每一个客户端连接交给一个拥有固定数量线程的连接池。
    - 优点：程序编写相对简单，可以处理大量的连接。
    - 缺点：线程的开销非常大，连接如果非常多，排队现象会比较严重。
- <font color=red>**【推荐】**</font>使用 Java 的 NIO，用非阻塞的 IO 方式处理。这种模式可以用一个线程，处理大量的客户端连接

#### 10.6.2. 基础示例

需求分析：实现服务器端和客户端之间的数据通信（非阻塞）。

- 网络服务器端程序。用 NIO 实现了一个服务器端程序，能不断接受客户端连接并读取客户端发过来的数据。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.system.testmodule.nio.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO案例 - 网络服务器端程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 得到一个ServerSocketChannel对象</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 2. 得到一个Selector对象</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 3. 绑定一个端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 4. 设置非阻塞方式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 5. 把ServerSocketChannel对象注册给Selector对象</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 6. 处理逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 6.1 监控客户端</span></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">2000</span>) == <span class="number">0</span>) &#123;  <span class="comment">// nio非阻塞式的优势</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Server:没有客户端搭理我，我就干点别的事&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 6.2 得到SelectionKey,判断通道里的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                <span class="comment">// 客户端连接请求事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;OP_ACCEPT&quot;</span>);</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">// 将每个新连接的通道注册给Selector对象</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 读取客户端数据事件</span></span><br><span class="line">                <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 获取客户端发送的附件，读取数据放到缓冲区</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端发来数据：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 6.3 手动从集合中移除当前key,防止重复处理</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 网络客户端程序。通过 NIO 实现了一个客户端程序，连接上服务器端后发送了一条数据。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.system.testmodule.nio.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO案例 - 网络客户端程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 得到一个网络通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        <span class="comment">// 2. 设置非阻塞方式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 3. 提供服务器端的IP地址和端口号</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">// 4. 连接服务器端</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(address)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect()) &#123;  <span class="comment">// nio作为非阻塞式的优势</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Client:连接服务器端的同时，我还可以干别的一些事情&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 得到一个缓冲区并存入数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello,Server&quot;</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        <span class="comment">// 6. 发送数据</span></span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line">        System.in.read();   <span class="comment">// 为了不让程序停止（因为客户端停止，服务端会抛出异常，暂时不想多做处理），特意设置等待输入，让程序阻塞在此处</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

NIO 示例运行效果：

![NIO示例运行效果](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035063.png)

#### 10.6.3. 网络聊天案例

需求：使用NIO实现多人聊天

- 使用 NIO 编写了一个聊天程序的服务器端，可以接受客户端发来的数据，并能把数据广播给所有客户端

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.system.testmodule.nio.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO案例 - 聊天程序服务器端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义监听通道 */</span></span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenerChannel;</span><br><span class="line">    <span class="comment">/* 选择器对象 */</span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="comment">/* 服务器端口 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">    <span class="comment">/* 缓冲区字节数组大小 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BYTE_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建基于JDK1.8的DateTimeFormatter（线程安全）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DateTimeFormatter</span> <span class="variable">DATE_TIME_FORMATTER</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义构造方法，初始化相关设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 得到监听通道</span></span><br><span class="line">            listenerChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">// 2. 得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">// 3. 绑定端口</span></span><br><span class="line">            listenerChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(PORT));</span><br><span class="line">            <span class="comment">// 4. 设置为非阻塞模式</span></span><br><span class="line">            listenerChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 5. 将选择器绑定到监听通道并监听accept事件</span></span><br><span class="line">            listenerChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            printInfo(<span class="string">&quot;Chat Server is ready.......&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端的相关业务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/* 循环不停的监控 */</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 判断是否有新的客户端连接</span></span><br><span class="line">                <span class="keyword">if</span> (selector.select(<span class="number">2000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Server:暂无新客户端连接，可进行其他业务逻辑&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有的网络通道key</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="comment">// 迭代所有网络通道</span></span><br><span class="line">                <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 客户端连接请求事件</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 获取客户端连接通道对象</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> listenerChannel.accept();</span><br><span class="line">                        <span class="comment">// 设置非阻塞方式</span></span><br><span class="line">                        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        <span class="comment">// 将每个新连接的通道注册给Selector对象</span></span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        <span class="comment">// 做客户端连接成功后的相关业务逻辑...</span></span><br><span class="line">                        System.out.println(socketChannel.getRemoteAddress().toString().substring(<span class="number">1</span>) + <span class="string">&quot;上线了...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 读取客户端数据事件</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        readMsg(selectionKey);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 手动从集合中移除当前key,防止重复处理</span></span><br><span class="line">                    keyIterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发来的消息并广播出去</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectionKey 网络通道key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readMsg</span><span class="params">(SelectionKey selectionKey)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 根据key获取客户端连接通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 创建缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(BYTE_SIZE);</span><br><span class="line">        <span class="comment">// 获取客户端发送的附件，读取数据放到缓冲区</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">        <span class="comment">// 判断是否读取到客户端消息</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">            <span class="comment">// 打印消息</span></span><br><span class="line">            <span class="built_in">this</span>.printInfo(msg);</span><br><span class="line">            <span class="comment">// 将消息发送广播</span></span><br><span class="line">            broadCast(channel, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给所有的客户端发广播</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 客户端连接通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg     消息字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">broadCast</span><span class="params">(SocketChannel channel, String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器发送了广播...&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 过Selector对象以下方法，获取所有准备就绪的网络，循环所有客户端网络通道key</span></span><br><span class="line"><span class="comment">         *  public abstract Set&lt;SelectionKey&gt; keys();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">this</span>.selector.keys().forEach(key -&gt; &#123;</span><br><span class="line">            <span class="comment">// 获取其他客户端的连接通道对象</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> key.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断排除本身以内的其他客户端连接通道</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != channel) &#123;</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">destChannel</span> <span class="operator">=</span> (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">// 获取缓冲区</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过连接通道，发送信息</span></span><br><span class="line">                    destChannel.write(buffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往控制台打印消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str 输入的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + DATE_TIME_FORMATTER.format(LocalDateTime.now()) + <span class="string">&quot;] -&gt; &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ChatServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 通过 NIO 编写了一个聊天程序的客户端，可以向服务器端发送数据，并能接收服务器广播的数据

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.moon.system.testmodule.nio.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NIO案例 - 聊天程序客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义服务器地址 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="comment">/* 定义服务器端口 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">    <span class="comment">/* 定义网络通道 */</span></span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="comment">/* 聊天用户名 */</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 缓冲区字节数组大小 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BYTE_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义构造方法，初始化业务设置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 得到一个网络通道</span></span><br><span class="line">        socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">// 2. 设置非阻塞方式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 3. 提供服务器端的IP地址和端口号</span></span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(HOST, PORT);</span><br><span class="line">        <span class="comment">// 4. 连接服务器端</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(address)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Client:连接服务器端的同时，我还可以干别的一些事情&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 得到客户端IP地址和端口信息，作为聊天用户名使用</span></span><br><span class="line">        userName = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------Client(&quot;</span> + userName + <span class="string">&quot;) is ready---------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向服务器端发送数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 消息字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(String msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 定义结束聊天的信息</span></span><br><span class="line">        <span class="keyword">if</span> (msg.equalsIgnoreCase(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">            socketChannel.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给服务端发送数据</span></span><br><span class="line">        msg = userName + <span class="string">&quot;说：&quot;</span> + msg;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从服务器端接收数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取字节缓冲区</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(BYTE_SIZE);</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果有接收数据，进行相关业务逻辑处理</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.array());</span><br><span class="line">            System.out.println(msg.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 运行了聊天程序的客户端，并在主线程中发送数据，在另一个线程中不断接收服务器端的广播数据，该代码运行一次就是一个聊天客户端，可以同时运行多个聊天客户端

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 启动客户端</span></span><br><span class="line">        <span class="type">ChatClient</span> <span class="variable">chatClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatClient</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独开一个线程不断的接收服务器端广播的数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 接收服务端发送的数据</span></span><br><span class="line">                    chatClient.receiveMsg();</span><br><span class="line">                    <span class="comment">// 休眠2秒</span></span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟客户端输入消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="comment">// 向服务端发送消息</span></span><br><span class="line">            chatClient.sendMsg(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 11. AIO 编程

JDK 7 引入了 Asynchronous I/O，即 AIO（也称 NIO 2.0），叫做异步不阻塞的 IO 模型，是基于事件和回调机制实现。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，一个有效的请求才启动一个线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。

在进行 I/O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理。

> *目前 AIO 还没有广泛应用。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为 Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。*

## 12. 不同类型的 IO 对比总结

IO 的方式通常分为几种：同步阻塞的 BIO、同步非阻塞的 NIO、异步非阻塞的 AIO。

- **BIO 方式**适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。
- **NIO 方式**适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。
- **AIO 方式**使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。

|   对比总结   |   BIO   |        NIO         |   AIO    |
| ----------- | ------- | ------------------- | -------- |
| IO 方式     | 同步阻塞 | 同步非阻塞（多路复用） | 异步非阻塞 |
| API 使用难度 | 简单    | 复杂                | 复杂      |
| 可靠性       | 差      | 好                  | 好        |
| 吞吐量       | 低      | 高                  | 高        |

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035064.png)

> 举个例子再理解一下：
>
> - 同步阻塞：你到饭馆点餐，然后在那等着，啥都干不了，饭馆没做好，你就必须等着！
> - 同步非阻塞：你在饭馆点完餐，就去玩儿了。不过玩一会儿，就回饭馆问一声：好了没啊！
> - 异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心玩儿就可以了，类似于现在的外卖。

## 13. Properties 类

### 13.1. Properties 概述

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt; </span><br></pre></td></tr></table></figure>

`java.util.Properties` 类继承 `Hashtable`，实现了 `Map` 接口，是属性集合（完全可以当成双列集合使用）。

使用时不需要指定泛型变量，<font color=red>**键和值默认都是字符串类型**</font>。可以与 IO 流技术相结合，实现从文件中读取数据到集合中，也可以直接将集合的数据保存到文件中。

`Properies` 类特点：键和值必须是 `String` 类型，不支持泛型。与 IO 有关的集合类，对文件进行操作，文件就叫属性文件。

### 13.2. Properties 属性文件

属性文件是 Java 中常用的一种文件类型，其扩展名必须是 `properties`。如：`applicatioin.properties`

**属性文件内容格式要求**：

- 一个键值对占一行，格式是：`键=值`。

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">MooNkirA</span></span><br><span class="line"><span class="attr">age</span>=<span class="string">18</span></span><br></pre></td></tr></table></figure>

- 文件中可以使用注释，以 `#` 开头就是注释行。

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我是一行注释</span></span><br><span class="line"><span class="attr">key</span>=<span class="string">abc</span></span><br></pre></td></tr></table></figure>

- **文件中如果有空行，则会被忽略**。

### 13.3. 构造方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 创建一个无默认值的空属性列表。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Properties</span><span class="params">(Properties defaults)</span></span><br></pre></td></tr></table></figure>

- 创建一个有默认值的空属性列表。

### 13.4. 属性值操作相关方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">setProperty</span><span class="params">(String key, String value)</span></span><br></pre></td></tr></table></figure>

- 存储键值对，如果键存在，则替换旧的键值对，并返回旧的value值。也可以使用 `put` 方法设置键值，但一般建议使用 `setProperty` 方法。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span></span><br></pre></td></tr></table></figure>

- 根据key(键)得到相应的属性值，如果key(键)不存在，则返回 null。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key, String defaultValue)</span></span><br></pre></td></tr></table></figure>

- 通过属性名（key 键）得到属性值，如果属性值不存在，则返回方法参数的 defaultValue，从而保证一定可以得到一个属性值。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">remove</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure>

- 根据key(键)删除对应的值。继承自 `HashTable`

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 得到 Properties 集合的键值对个数。继承自 `HashTable`

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">stringPropertyNames</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 返回此属性列表中的所有属性名（key 键）的 Set 集合

### 13.5. 将集合中内容存储到文件

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">store</span><span class="params">(OutputStream out, String comments)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

- 通过字节流，将集合中的数据(属性列表)保存到流关联的目标文件中，并加上注释（comments），还会加上保存的时间，汉字使用的是 Unicode 编码。参数 `comments` 是描述信息，一般给 null 即可

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">store</span><span class="params">(Writer writer, String comments)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

- 保存属性到字符流中，并加上注释。还会加上保存的时间。字符流汉字直接写入。

### 13.6. 读取文件中的数据并保存到属性集合

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(InputStream inStream)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
- 从字节输入流中读取属性列表（属性名和属性值）

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(Reader reader)</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

- 从字符输入流中读取属性列表（属性名和属性值）

## 14. 序列化与反序列化

### 14.1. 概述

> 引用维基百科对于“序列化”的介绍：
>
> 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。

一般情况下，只有当 JVM 处于运行时，创建的对象就存活在内存中，但对象会随着 JVM 的关闭而消失（即对象的生命周期不会比 JVM 的生命周期更长）。在有些实际情况需要在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。另外对象并不只是存在内存中，还需要在传输网络或者持久化到文件，下次再加载出来用，这些场景都需要用到 Java 序列化技术。

**Java 序列化技术**正是将对象转变成一串由二进制字节组成的数组，可以通过将二进制数据保存到磁盘或者传输网络，磁盘或者网络接收者可以在对象的属类的模板上来反序列化类的对象，达到对象持久化的目的。

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035065.png)

- <font color=red>**序列化：将数据结构或对象转换成二进制字节流的过程**</font>。要实现对象的序列化需要使用的流：`ObjectOutputStream` 继承 `OutputStream`
- <font color=red>**反序列化：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程**</font>。要实现对象的反序列化需要使用的流：`ObjectInputStream` 继承 `InputStream`

#### 14.1.1. 序列化协议对应于 TCP/IP 四层模型中的层级

网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型如下：

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035066.png)

如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。因此，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以**序列化协议属于 TCP/IP 协议应用层的一部分**。

#### 14.1.2. 实际开发中序列化和反序列化的应用场景

1. 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化
2. 将对象存储到文件中的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化
3. 将对象存储到缓存数据库（如 Redis）时需要用到序列化，将对象从缓存数据库中读取出来需要反序列化

#### 14.1.3. 常见序列化协议

常见的序列化协议有：JDK 自带的序列化，比较常用第三方的序列化协议：hessian、kyro、protostuff。

其中 JDK 自带的序列化一般很少用，因为序列化效率低并且部分版本有安全漏洞，主要原因有两个：

- 不支持跨语言调用：如果调用的是其他语言开发的服务的时候就不支持了。
- 性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。

### 14.2. Serializable 接口

#### 14.2.1. 概述

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

`Serializable`接口，没有任何方法，该接口属于标记性接口，仅用于标识可序列化的语义。接口的作用是，能够保证实现了该接口的类的对象可以直接被序列化到文件中

> Notes: <font color=red>**被保存的对象要求实现 `Serializable` 接口，否则不能直接保存到文件中。否则会出现`java.io.NotSerializableException`。**</font>

<h4 id="14-2-2-serialVersionUID"><a href="#14-2-2-serialVersionUID" class="headerlink" title="14.2.2. serialVersionUID"></a>14.2.2. serialVersionUID</h4><p>序列化是将对象的状态信息转换为可存储或传输的形式的过程。虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致，这个所谓的序列化 ID，就是在代码中定义的 <code>serialVersionUID</code>。</p>
<p>序列化号 serialVersionUID 属于版本控制的作用。序列化的时候 serialVersionUID 也会被写入二级制序列，当反序列化时会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的序列化号。</p>
<h4 id="14-2-3-Externalizable"><a href="#14-2-3-Externalizable" class="headerlink" title="14.2.3. Externalizable"></a>14.2.3. Externalizable</h4><p>Java 中还提供了 <code>Externalizable</code> 接口，也可以实现它来提供序列化能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Externalizable</span> <span class="keyword">extends</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Externalizable</code> 继承自 Serializable，该接口中定义了两个抽象方法：<code>writeExternal()</code> 与 <code>readExternal()</code>。当使用 <code>Externalizable</code> 接口来进行序列化与反序列化的时候需要开发人员重写该方法。否则所有变量的值都会变成默认值。</p>
<h3 id="14-3-ObjectOutputStream（对象序列化流）"><a href="#14-3-ObjectOutputStream（对象序列化流）" class="headerlink" title="14.3. ObjectOutputStream（对象序列化流）"></a>14.3. ObjectOutputStream（对象序列化流）</h3><h4 id="14-3-1-ObjectOutputStream-的作用"><a href="#14-3-1-ObjectOutputStream-的作用" class="headerlink" title="14.3.1. ObjectOutputStream 的作用"></a>14.3.1. ObjectOutputStream 的作用</h4><p>对象输出流，将 Java 的对象保存到文件中</p>
<h4 id="14-3-2-构造方法"><a href="#14-3-2-构造方法" class="headerlink" title="14.3.2. 构造方法"></a>14.3.2. 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span>;</span><br></pre></td></tr></table></figure>
<p>根据指定的字节输出<code>OutputStream</code>对象来创建<code>ObjectOutputStream</code>。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;stu.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="14-3-3-相关方法"><a href="#14-3-3-相关方法" class="headerlink" title="14.3.3. 相关方法"></a>14.3.3. 相关方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span></span><br></pre></td></tr></table></figure>
<p>将对象Obj写出到流关联的目标文件中</p>
<h4 id="14-3-4-序列化步骤"><a href="#14-3-4-序列化步骤" class="headerlink" title="14.3.4. 序列化步骤"></a>14.3.4. 序列化步骤</h4><ol>
<li>定义类，实现 <code>Serializable</code> 接口，自定义一个 <code>serialVersionUID</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6286083484798000168L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建对象</li>
<li>使用一个输出流(如：<code>FileOutputStream</code>)来构建 <code>ObjectOutputStream</code> （对象流）对象</li>
<li>调用 <code>ObjectOutputStream</code> 对象的 <code>writeObject</code> 将对象写入文件中(即保存其状态)</li>
<li>关流</li>
</ol>
<h3 id="14-4-ObjectInputStream（对象反序列化流）"><a href="#14-4-ObjectInputStream（对象反序列化流）" class="headerlink" title="14.4. ObjectInputStream（对象反序列化流）"></a>14.4. ObjectInputStream（对象反序列化流）</h3><h4 id="14-4-1-ObjectInputStream-的作用"><a href="#14-4-1-ObjectInputStream-的作用" class="headerlink" title="14.4.1. ObjectInputStream 的作用"></a>14.4.1. ObjectInputStream 的作用</h4><p>将文件中的对象读取到程序中，将对象从文件中读取出来，实现对象的反序列化操作。</p>
<h4 id="14-4-2-构造方法"><a href="#14-4-2-构造方法" class="headerlink" title="14.4.2. 构造方法"></a>14.4.2. 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream(InputStream in)</span><br></pre></td></tr></table></figure>
<p>通过字节输入<code>InputStream</code>对象创建<code>ObjectInputStream</code></p>
<h4 id="14-4-3-普通方法"><a href="#14-4-3-普通方法" class="headerlink" title="14.4.3. 普通方法"></a>14.4.3. 普通方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>从流关联的的文件中读取对象</p>
<h4 id="14-4-4-反序列化步骤"><a href="#14-4-4-反序列化步骤" class="headerlink" title="14.4.4. 反序列化步骤"></a>14.4.4. 反序列化步骤</h4><ol>
<li>创建对象输入流</li>
<li>调用<code>readObject()</code>方法读取对象</li>
<li>关流</li>
</ol>
<h3 id="14-5-自定义对象输出流-了解"><a href="#14-5-自定义对象输出流-了解" class="headerlink" title="14.5. 自定义对象输出流(了解)"></a>14.5. 自定义对象输出流(了解)</h3><h4 id="14-5-1-概念"><a href="#14-5-1-概念" class="headerlink" title="14.5.1. 概念"></a>14.5.1. 概念</h4><p>要自定义对象输出流，就让新建的类继承 <code>ObjectOutputStream</code></p>
<h4 id="14-5-2-WriteStreamHeader-方法的调用时机"><a href="#14-5-2-WriteStreamHeader-方法的调用时机" class="headerlink" title="14.5.2. WriteStreamHeader 方法的调用时机"></a>14.5.2. WriteStreamHeader 方法的调用时机</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStream</span> <span class="keyword">extends</span> <span class="title class_">OutputStream</span> <span class="keyword">implements</span> <span class="title class_">ObjectOutput</span>, ObjectStreamConstants &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        verifySubclass();</span><br><span class="line">        bout = <span class="keyword">new</span> <span class="title class_">BlockDataOutputStream</span>(out);</span><br><span class="line">        handles = <span class="keyword">new</span> <span class="title class_">HandleTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line">        subs = <span class="keyword">new</span> <span class="title class_">ReplaceTable</span>(<span class="number">10</span>, (<span class="type">float</span>) <span class="number">3.00</span>);</span><br><span class="line">        enableOverride = <span class="literal">false</span>;</span><br><span class="line">        writeStreamHeader();</span><br><span class="line">        bout.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack = <span class="keyword">new</span> <span class="title class_">DebugTraceInfoStack</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            debugInfoStack = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeStreamHeader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        bout.writeShort(STREAM_MAGIC);</span><br><span class="line">        bout.writeShort(STREAM_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WriteStreamHeader()</code> 方法中 <code>ObjectOutputStream</code> 类中的成员方法，每当创建 <code>ObjectOutputStream</code> 对象时，在 <code>ObjectOutputStream</code> 的构造方法中调用。</p>
<h4 id="14-5-3-WriteStreamHeader-方法的作用"><a href="#14-5-3-WriteStreamHeader-方法的作用" class="headerlink" title="14.5.3. WriteStreamHeader 方法的作用"></a>14.5.3. WriteStreamHeader 方法的作用</h4><p><code>WriteStreamHeader()</code> 方法作用是，写入一个头部信息，如果是要追加写入，则要求第一个对象写入一个头部信息，其他对象则不能写入头部信息。</p>
<p>判断文件是否存在，或文件长度是0，如果是就表示第一次保存对象。调用了 <code>ObjectInputStream</code> 中的方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>
<p>返回可以不受阻塞地读取的字节数。</p>
<h3 id="14-6-瞬态关键字-transient"><a href="#14-6-瞬态关键字-transient" class="headerlink" title="14.6. 瞬态关键字 transient"></a>14.6. 瞬态关键字 transient</h3><h4 id="14-6-1-transient-的作用"><a href="#14-6-1-transient-的作用" class="headerlink" title="14.6.1. transient 的作用"></a>14.6.1. transient 的作用</h4><p>序列化对象时，如果不想保存某一个成员变量的值，该如何处理？<code>transient</code> 关键字作用就是用于指定<strong>序列化对象时不保存某个成员变量的值</strong>。</p>
<p>用 <code>transient</code> 修饰成员变量，能够保证该成员变量的值不能被序列化到文件中。当对象被反序列化时，被 <code>transient</code> 修饰的变量值会设为初始值，如 int 型的是 0，对象型的是 null。</p>
<h4 id="14-6-2-使用-static-修饰的成员变量（不建议使用）"><a href="#14-6-2-使用-static-修饰的成员变量（不建议使用）" class="headerlink" title="14.6.2. 使用 static 修饰的成员变量（不建议使用）"></a>14.6.2. 使用 static 修饰的成员变量（不建议使用）</h4><p>可以将该成员变量定义为静态的成员变量。因为对象序列化只会保存对象自己的信息，静态成员变量是属于类的信息，所有不会被保存。<strong>但不建议使用</strong>。</p>
<h4 id="14-6-3-注意点"><a href="#14-6-3-注意点" class="headerlink" title="14.6.3. 注意点"></a>14.6.3. 注意点</h4><p><code>transient</code> 只能修饰变量，不能修饰类和方法</p>
<h3 id="14-7-序列化的常见问题与注意事项"><a href="#14-7-序列化的常见问题与注意事项" class="headerlink" title="14.7. 序列化的常见问题与注意事项"></a>14.7. 序列化的常见问题与注意事项</h3><h4 id="14-7-1-InvalidClassException-异常"><a href="#14-7-1-InvalidClassException-异常" class="headerlink" title="14.7.1. InvalidClassException 异常"></a>14.7.1. InvalidClassException 异常</h4><p><code>java.io.InvalidClassException</code>: 无效的类异常。此异常是<font color=red><strong>序列号冲突</strong></font>。</p>
<ul>
<li>出错的核心问题：<strong>类改变后，类的序列化号也改变，就和文件中的序列化号不一样</strong></li>
<li>解决方法：<strong>修改类的时候，让序列化号不变，自定义一个序列号，不要系统随机生成序列号。</strong></li>
</ul>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251035067.png" alt=""></p>
<h4 id="14-7-2-注意事项总结"><a href="#14-7-2-注意事项总结" class="headerlink" title="14.7.2. 注意事项总结"></a>14.7.2. 注意事项总结</h4><ul>
<li>序列化对象必须实现序列化接口。</li>
<li>序列化对象里面的属性是对象的话也要实现序列化接口。</li>
<li>类的对象序列化后，类的序列化ID(<code>serialVersionUID</code>)不能轻易修改，不然反序列化会失败。</li>
<li>类的对象序列化后，类的属性有增加或者删除不会影响序列化，只是值会丢失。</li>
<li>如果父类实现了序列化接口，子类会继承父类的序列化，子类无需添加序列化接口。</li>
<li>如果父类没有实现序列化接口，而子类序列化了，子类中的属性能正常序列化，但父类的属性会丢失，不能序列化。</li>
<li>用 Java 序列化的二进制字节数据只能由 Java 反序列化，不能被其他语言反序列化。如果要进行前后端或者不同语言之间的交互一般需要将对象转变成 Json/Xml 通用格式的数据，再恢复原来的对象。</li>
<li>如果某个字段不想被序列化，在该字段前加上 <code>transient</code> 关键字即可。在被反序列化后，<code>transient</code> 修饰的变量值会被设为对应类型的初始值，例如，int 类型变量的值是 0，对象类型变量的值是 null。</li>
<li><font color=red><strong>序列化不会保存静态变量</strong></font>。</li>
<li>序列化对象会将其状态保存为一组字节；反序列化时，再将这些字节组装成对象。</li>
</ul>
<h3 id="14-8-扩展"><a href="#14-8-扩展" class="headerlink" title="14.8. 扩展"></a>14.8. 扩展</h3><h4 id="14-8-1-其他序列化转换对象的方式"><a href="#14-8-1-其他序列化转换对象的方式" class="headerlink" title="14.8.1. 其他序列化转换对象的方式"></a>14.8.1. 其他序列化转换对象的方式</h4><p>除了使用 Java 自带的序列化机制，通过实现 <code>Serializable</code> 接口并重写 <code>readObject</code> 和 <code>writeObject</code> 方法，将对象转换成字节序列，或将字节序列转换成对象。使用 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> 进行读写操作。还有以下序列化转换对象的方式：</p>
<ol>
<li>使用 JSON 序列化框架，如 Jackson、Gson 等，通过将对象转换成 JSON 字符串，或将 JSON 字符串转换成对象。使用 ObjectMapper 进行读写操作。</li>
<li>使用 XML 序列化框架，如 JAXB、XStream 等，通过将对象转换成 XML 格式，或将 XML 格式转换成对象。使用 Marshaller 和 Unmarshaller 进行读写操作。</li>
<li>使用 Protobuf 序列化框架，通过定义<code>.proto</code>文件来描述数据结构，然后使用编译器生成 Java 代码，使用这些生成的代码进行读写操作。</li>
</ol>
<h4 id="14-8-2-序列化对象案例"><a href="#14-8-2-序列化对象案例" class="headerlink" title="14.8.2. 序列化对象案例"></a>14.8.2. 序列化对象案例</h4><p>要序列化一个对象，这个对象所在类就必须实现Java序列化的接口：<code>java.io.Serializable</code>。</p>
<h5 id="14-8-2-1-类添加序列化接口"><a href="#14-8-2-1-类添加序列化接口" class="headerlink" title="14.8.2.1. 类添加序列化接口"></a>14.8.2.1. 类添加序列化接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8475669200846811112L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="14-8-2-2-序列化-反序列化"><a href="#14-8-2-2-序列化-反序列化" class="headerlink" title="14.8.2.2. 序列化/反序列化"></a>14.8.2.2. 序列化/反序列化</h5><p>可以借助commons-lang3工具包里面的类实现对象的序列化及反序列化，无需自己写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.SerializationUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        user.setAddress(<span class="string">&quot;China&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bytes = SerializationUtils.serialize(user);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> SerializationUtils.deserialize(bytes);</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;username=&#x27;Java&#x27;, address=&#x27;China&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>上例通过序列化对象字节到内存然后反序列化，当然里面也提供了序列化磁盘然后再反序列化的方法，原理都是一样的，只是目标地不一样。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io">蓝桉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io/posts/4c92022d.html">https://ktzxy.github.io/posts/4c92022d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ktzxy.github.io" target="_blank">蓝桉`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/bg/Image00008.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src="/img/wechat.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src="/img/alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/b7433c83.html" title="Java基础-JDK"><img class="cover" src="/bg/Image00028.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java基础-JDK</div></div><div class="info-2"><div class="info-item-1">1. JDK 概述JDK (Java Development Kit) 是 Java 语言的软件开发工具包(SDK)，主要用于移动设备、嵌入式设备上的 Java 应用程序。JDK 是整个 Java 开发的核心，它包含了 JAVA 的运行环境（JVM+Java 系统类库）和 JAVA 工具。  JDK 官网：https://www.oracle.com/java/  2. windows 系统安装 JDK2.1. JDK变量环境配置最好的配置方式：将位置切割成两段，一段用JAVA_HOME保存，一段用\bin保存。如下例： 12JAVA_HOME = C:\Program Files\Java\jdk1.8.0_91%JAVA_HOME%\bin  相等于 --&gt; C:\Program Files\Java\jdk1.8.0_91\bin  2.2. 安装多个 JDK安装过程都一样。只是配置环境变量时改动一下。分别将多个不同版本的jdk设置一个环境变量，然后最终让JAVA_HOME指定当前需要使用的版本的变量即可 123JAVA_HOME_8 = D:\development...</div></div></div></a><a class="pagination-related" href="/posts/8eb2595.html" title="Day-14-JVM入门"><img class="cover" src="/bg/Image00011.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Day-14-JVM入门</div></div><div class="info-2"><div class="info-item-1">Day-14-JVM入门JVM入门面试常见：  请你谈谈你对JVM的理解? java8虚拟机和之前的变化更新? 什么是OOM，什么是栈溢出StackOverFlowError? 怎么分析? JVM的常用调优参数有哪些? 内存快照如何抓取？怎么分析Dump文件？ 谈谈JVM中，类加载器你的认识？  1.JVM的位置 三种JVM:  Sun公司：HotSpot 用的最多 BEA：JRockit IBM：J9VM  我们学习都是：HotSpot 2.JVM的体系结构  jvm调优：99%都是在方法区和堆，大部分时间调堆。 JNI（java native interface）本地方法接口。      3.类加载器 作用：加载Class文件——如果new Student();（具体实例在堆里，引用变量名放栈里） 。 先来看看一个类加载到 JVM 的一个基本结构：    类是模板，对象是具体的，通过new来实例化对象。car1，car2，car3，名字在栈里面，真正的实例，具体的数据在堆里面，栈只是引用地址。   虚拟机自带的加载器 启动类（根）加载器 扩展类加载器 应用程序加载器  123...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/4e9c3100.html" title="Java基础-网络编程"><img class="cover" src="/bg/Image00026.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Java基础-网络编程</div></div><div class="info-2"><div class="info-item-1">1. 网络编程概述在计算机领域中，网络是信息传输、接收、共享的虚拟平台，将各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络编程的作用：解决计算机与计算机数据传输的问题。 网络体系大致分为三种：OSI七层模型、TCP/IP四层模型和五层模型。  Tips: 一般面试的时候考察比较多的是五层模型。  1.1. 网络通讯三要素1.1.1. IP地址IP 是每台电脑在互联网上的唯一标识符。一个 IPV4 的地址是由四段 0—255 的数字组成：192.168.0.100，每一段的取值范围由8位二进制数据组成。 IPv6 使用 16 个字节表示 IP 地址，它所拥有的地址容量约是 IPv4 的 8×1028倍，达到 2128个。  Notes:   127.0.0.1 为本地主机地址(本地回环地址)，与 localhost 类似，均代表本机地址 xxx.xxx.xxx.255 广播地址，即该网段下所有用户均可以被通知到   例如在 windows 系统中，可以通过以下命令来获取 ip 与网络相关内容： 1ipconfig  用于DOS获取计算机IP设置  1ping ip地址 ...</div></div></div></a><a class="pagination-related" href="/posts/2af7de89.html" title="Day-0-IDEA简单学习"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-0-IDEA简单学习</div></div><div class="info-2"><div class="info-item-1">﻿# Day-0-IDEA简单学习 1.设置主题 2.编辑区的字体变大或者变小：（ctrl+鼠标滚轮） 3.鼠标悬浮在代码上有提示： 4.自动导包和优化多余的包：手动导包：快捷键：alt+enter自动导包和优化多余的包：  5.显示行号 ，  方法和方法间的分隔符： 6.忽略大小写，进行提示： 7.修改代码中注释的字体颜色： 8.修改类头的文档注释信息：注意：对新建的类才有效/**  @Auther: XXX @Date: ${DATE} - ${MONTH} - ${DAY} - ${TIME}  @Description: ${PACKAGE_NAME} @version: 1.0*/   8.自动编译： 9.常用快捷键【1】创建内容：alt+insert 【2】main方法：psvm 【3】输出语句：sout 【4】复制行：ctrl+d 【5】删除行：ctrl+y 【6】代码向上/下移动：Ctrl + Shift + Up / Down 【7】搜索类：  ctrl+n 【8】生成代码  ：alt + Insert（如构造函数等，getter,setter,hashCode...</div></div></div></a><a class="pagination-related" href="/posts/72ba03f7.html" title="Day-02-java基础语法"><img class="cover" src="/bg/Image00027.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-02-java基础语法</div></div><div class="info-2"><div class="info-item-1">﻿ Day-02-java基础语法快捷键操作 psvm —&gt;快速生成public static void main(String[] args) {} sout —&gt;快速生成System.out.println();  可能会遇到的问题  每个单词的大小不能出现问题，==Java是大小写敏感的==； 尽量使用英文； 文件名和类名必须保证一致，并且首字母大写； 符号使用的了中文。   Java运行机制  编译型 解释型    注释：Java中的注释有三种： 12345678910注释：    单行注释：    //我是单行注释    多行注释      /*我是多行注释*/    文档注释    /**    *@description  HelloWrold    *@Author 作者    */ 标识符：关键字 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 标识符注意点 所有的标识符都应该以字母(A-Z或者a-z),美元符（$)、数字或者下划线(_)开始首字符之后可以是字母（A-Z或者a-z),美元符（$)、下划线(_)或数字的任何字符...</div></div></div></a><a class="pagination-related" href="/posts/369b2118.html" title="Day-03-java流程控制"><img class="cover" src="/bg/Image00020.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-03-java流程控制</div></div><div class="info-2"><div class="info-item-1">﻿ Day-03-java流程控制Scanner对象java.util.Scanner是Java5的新特性，我们可以通过Scanner类来获取用户的输入。 基本语法 1Scanner s = new Scanner(System.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext() 与hasNextLine()判断是否还有输入的数据。 12345678910111213public static void main(String[] args) &#123;    //创建一个扫描对象，用于接受键盘数据    Scanner scanner = new Scanner(System.in);    System.out.println(&quot;使用next方式接受：&quot;);    //判断用户有没有输入字符串    if (scanner.hasNext())&#123;        //使用next方式接受        String str = scanner.next();     ...</div></div></div></a><a class="pagination-related" href="/posts/bbaa91bf.html" title="Day-04-java方法详解"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-04-java方法详解</div></div><div class="info-2"><div class="info-item-1">﻿ Day-04-java方法详解何谓方法？​    System.out.println(),那么它是什么呢? ​    调用系统类里的标准输出对象out中的方法println ​    Java方法是语句的集合，它们在一起执行一个功能。 ​    方法是解决一类问题的步骤的有序组合 ​    方法包含于类或对象中，方法和方法是并列的关系，所以我们定义的方法不能写到main方法中 ​    方法在程序中被创建，在其他地方被引用 ​    设计方法的原则:方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。 方法的定义Java的方法类似争其它语言的函数,是一段用来完成特定功能的代码片段，一股情况卜，定义一个方法包含以下语法: 方法包含一个方法头和一个方法体。 下面是一个方法的所有部分: 修饰符:修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型∶方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。...</div></div></div></a><a class="pagination-related" href="/posts/cccc6599.html" title="Day-06-java面向对象"><img class="cover" src="/bg/Image00022.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-06-java面向对象</div></div><div class="info-2"><div class="info-item-1">﻿ Day-06-java面向对象什么是面向对象面向对象编程(Object-Oriented Programming, OOP) 面向对象编程的本质就是:==以类的方式组织代码，以对象的组织(封装)数据。== 抽象 三大特性: ​        封装 ​        继承 ​        多态从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象 从代码运行角度考虑是先有类后有对象。类是对象的模板。 回顾方法及加深方法的定义 修饰符 返回类型 ==break: 跳出switch，结束循环和return的区别方法名== 参数列表 异常抛出 方法的调用        静态方法 ​        非静态方法 ​        形参和实参 ​        值传递和引用传递 ​        this关键字 12345678910111213141516171819202122232425//demo1  类public class demo1 &#123;    //main方法    public static void main(String[] a...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">蓝桉</div><div class="author-info-description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">生活、学习、技术</b>相关的问题和看法，还有<b style="color:#fff">文章教程</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ktzxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/ktzxy" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2251511764@qq.com" target="_blank" title="Email"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-RSS"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/496148176" target="_blank" title="BiliBili"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QX-BILIBILI"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2251511764&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-IO-%E6%B5%81"><span class="toc-number">1.</span> <span class="toc-text">1. IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 数据在计算机的表现形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-IO-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. IO 的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-IO-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1. IO 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-IO-%E6%B5%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2. IO 流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-IO-%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. IO 模型分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E9%98%BB%E5%A1%9E-IO-%E6%A8%A1%E5%9E%8B%EF%BC%88Blocking-IO%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1. 阻塞 IO 模型（Blocking IO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E9%9D%9E%E9%98%BB%E5%A1%9E-IO-%E6%A8%A1%E5%9E%8B%EF%BC%88Nonblocking-IO%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2. 非阻塞 IO 模型（Nonblocking IO）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-IO-%E6%A8%A1%E5%9E%8B%EF%BC%88IO-multiplexing%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3. 多路复用 IO 模型（IO multiplexing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-IO-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4. 信号驱动 IO 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-%E5%BC%82%E6%AD%A5-IO-%E6%A8%A1%E5%9E%8B%EF%BC%88asynchronous-IO%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">1.3.5. 异步 IO 模型（asynchronous IO）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-File-%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">2. File 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-File-%E7%AE%80%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. File 简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 相对路径与绝对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-File-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. File 类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3. 文件创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%A0%E9%99%A4"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.5. 文件&#x2F;文件夹删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-6-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.3.6. 获取文件&#x2F;文件夹信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-7-%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.3.6.</span> <span class="toc-text">2.3.7. 判断文件&#x2F;文件夹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-8-%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%88%97%E8%A1%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.3.7.</span> <span class="toc-text">2.3.8. 获取文件&#x2F;文件夹列表（重点）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-File-%E7%B1%BB%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. File 类基础应用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%88%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. 读取指定文件夹下的所有文件（多个文件夹）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%BB%9F%E8%AE%A1%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%80%BB%E5%92%8C%EF%BC%88%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. 统计指定文件夹所有文件的大小总和（文件夹下有多个文件夹）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%88%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%89"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3. 删除指定文件夹下的所有文件（多个文件夹）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-FileFilter-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8-%E9%9A%BE%E7%82%B9%E3%80%81%E9%87%8D%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">3. FileFilter 文件过滤器(难点、重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-FileFilter-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. FileFilter 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 接口的调用时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-File-%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. File 类使用过滤器的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. 文件过滤器的使用步骤与示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">4.</span> <span class="toc-text">4. 字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AD%97%E7%AC%A6%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 字符流概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-FileWriter-%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. FileWriter 输出字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-FileWriter-%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E5%86%99%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1. FileWriter 向文件中写数据操作步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-close-%E5%92%8C-flush-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4. close() 和 flush() 方法的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-FileReader-%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. FileReader 输入字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E8%BE%93%E5%85%A5%E6%B5%81%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1. 输入流读文件的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F1%EF%BC%9A%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4. 读数据方式1：一次读取一个字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F2%EF%BC%9A%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="toc-number">4.3.5.</span> <span class="toc-text">4.3.5. 读数据方式2：一次读取一个字符数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-read-%E5%92%8C-read-char-cbuf-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.6.</span> <span class="toc-text">4.3.6. read() 和 read(char cbuf[]) 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-BufferedWriter-BufferedReader%EF%BC%88%E7%BC%93%E5%86%B2%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. BufferedWriter &#x2F; BufferedReader（缓冲字符流）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-BufferedWriter"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1. BufferedWriter</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-1-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">4.4.1.1. 构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-1-2-%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">4.4.1.2. 特有方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-BufferedReader"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2. BufferedReader</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">4.4.2.1. 构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-2-2-%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.2.2.</span> <span class="toc-text">4.4.2.2. 特有方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-IO-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B65%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. IO 字符流复制文本文件5种实现方式示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">5.</span> <span class="toc-text">5. 字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 字符流存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-OutputStream-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. OutputStream 字节输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E5%B8%B8%E7%94%A8%E5%AD%90%E7%B1%BB%EF%BC%9AFileOutputStream-%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3. 常用子类：FileOutputStream (文件字节输出流)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4. 字节输出流的使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.2.5.</span> <span class="toc-text">5.2.5. 字节输出流注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-6-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.2.6.</span> <span class="toc-text">5.2.6. 异常的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-InputStream-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. InputStream 字节输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E5%B8%B8%E7%94%A8%E5%AD%90%E7%B1%BB%EF%BC%9AFileInputStream-%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3. 常用子类：FileInputStream (文件字节输入流)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.3.4.</span> <span class="toc-text">5.3.4. 字节输入流的使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-5-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.3.5.</span> <span class="toc-text">5.3.5. 字节输入流注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-6-%E5%9F%BA%E7%A1%80%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.3.6.</span> <span class="toc-text">5.3.6. 基础示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-BufferedOutputStream-BufferedInputStream%EF%BC%88%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. BufferedOutputStream &#x2F; BufferedInputStream（字节缓冲流）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E7%BC%93%E5%86%B2%E6%B5%81%E9%AB%98%E6%95%88%E5%8E%9F%E7%90%86"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1. 缓冲流高效原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-BufferedOutputStream%EF%BC%88%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%E6%B5%81%E3%80%81%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2. BufferedOutputStream（缓冲输出流、写数据）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">5.4.2.1. 构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-2-%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">5.4.2.2. 普通方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-BufferedInputStream%EF%BC%88%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%B5%81%E3%80%81%E8%AF%BB%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3. BufferedInputStream（缓冲输入流、读数据）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-1-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">5.4.3.1. 构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-2-%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">5.4.3.2. 普通方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%AD%97%E8%8A%82%E6%B5%81%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 字节流综合案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-%E6%A1%88%E4%BE%8B1%EF%BC%9A4-%E7%A7%8D%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1. 案例1：4 种字节流复制文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-%E6%A1%88%E4%BE%8B2%EF%BC%9A%E5%AD%97%E8%8A%82%E6%B5%81%E7%BB%84%E5%90%88-File-%E7%B1%BB%EF%BC%8C%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%88%E5%8C%85%E6%8B%AC%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8E%E6%96%87%E4%BB%B6%EF%BC%89"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2. 案例2：字节流组合 File 类，复制文件夹下所有文件（包括文件夹与文件）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">6.</span> <span class="toc-text">6. 转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 字符编码表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">6.2.1. 什么是编码表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-ASCII-%E7%A0%81%E8%A1%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">6.2.2. ASCII 码表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E7%A0%81%E8%A1%A8"><span class="toc-number">6.2.3.</span> <span class="toc-text">6.2.3. 支持中文的码表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-%E7%BC%96%E7%A0%81-%E8%A7%A3%E7%A0%81"><span class="toc-number">6.2.4.</span> <span class="toc-text">6.2.4. 编码&#x2F;解码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5-%E4%B9%B1%E7%A0%81"><span class="toc-number">6.2.5.</span> <span class="toc-text">6.2.5. 乱码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-OutputStreamWriter%EF%BC%88%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E6%B5%81%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. OutputStreamWriter（输出转换流）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">6.3.1.</span> <span class="toc-text">6.3.1. 继承体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.2.</span> <span class="toc-text">6.3.2. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.3.</span> <span class="toc-text">6.3.3. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-%E5%AD%97%E7%AC%A6%E6%B5%81%E8%BD%AC%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.3.4.</span> <span class="toc-text">6.3.4. 字符流转字节流的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-InputStreamReader%EF%BC%88%E8%BE%93%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%B5%81%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. InputStreamReader（输入转换流）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1. 继承体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.2.</span> <span class="toc-text">6.4.2. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.3.</span> <span class="toc-text">6.4.3. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-4-%E5%AD%97%E8%8A%82%E6%B5%81%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.4.4.</span> <span class="toc-text">6.4.4. 字节流转换字符流的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E8%BD%AC%E6%8D%A2%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E5%AD%90%E7%B1%BB"><span class="toc-number">6.5.</span> <span class="toc-text">6.5. 转换流与字符流子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1-%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.5.1.</span> <span class="toc-text">6.5.1. 两者的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-FileReader-FileWriter-%E5%8E%9F%E7%90%86"><span class="toc-number">6.5.2.</span> <span class="toc-text">6.5.2. FileReader &#x2F; FileWriter 原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-3-%E8%BD%AC%E6%8D%A2%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9"><span class="toc-number">6.5.3.</span> <span class="toc-text">6.5.3. 转换流与字符流使用选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">7.</span> <span class="toc-text">7. 打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%89%93%E5%8D%B0%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. 打印流的概念与分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%89%93%E5%8D%B0%E6%B5%81%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. 打印流使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-PrintStream-%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1. PrintStream 类构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-PrintStream-%E7%B1%BB%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2. PrintStream 类成员方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-IO-%E6%B5%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">8. IO 流总结（字符流和字节流）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Java-IO-%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. Java IO 体系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. 字节流与字符流的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1. 字节流和字符流的选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-BIO-%E7%BC%96%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">9. BIO 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%9F%BA%E4%BA%8E-BIO-%E7%9A%84%E7%BD%91%E7%BB%9C-IO"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. 基于 BIO 的网络 IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%9F%BA%E4%BA%8E-TCP%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. 基本用法示例（基于 TCP）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-NIO-%E7%BC%96%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">10. NIO 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">10.1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-Java-NIO-%E5%92%8C%E4%BC%A0%E7%BB%9F-I-O-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.1.1.</span> <span class="toc-text">10.1.1. Java NIO 和传统 I&#x2F;O 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-NIO-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">10.1.2.</span> <span class="toc-text">10.1.2. NIO 三大核心组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-2-serialVersionUID"><span class="toc-number">10.1.3.</span> <span class="toc-text">14.2.2. serialVersionUID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-3-Externalizable"><span class="toc-number">10.1.4.</span> <span class="toc-text">14.2.3. Externalizable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-ObjectOutputStream%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">14.3. ObjectOutputStream（对象序列化流）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-1-ObjectOutputStream-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">10.2.1.</span> <span class="toc-text">14.3.1. ObjectOutputStream 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.2.</span> <span class="toc-text">14.3.2. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-3-%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.3.</span> <span class="toc-text">14.3.3. 相关方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-4-%E5%BA%8F%E5%88%97%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.2.4.</span> <span class="toc-text">14.3.4. 序列化步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-ObjectInputStream%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">14.4. ObjectInputStream（对象反序列化流）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-1-ObjectInputStream-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">10.3.1.</span> <span class="toc-text">14.4.1. ObjectInputStream 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.2.</span> <span class="toc-text">14.4.2. 构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-3-%E6%99%AE%E9%80%9A%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.3.</span> <span class="toc-text">14.4.3. 普通方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.3.4.</span> <span class="toc-text">14.4.4. 反序列化步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-number">10.4.</span> <span class="toc-text">14.5. 自定义对象输出流(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">10.4.1.</span> <span class="toc-text">14.5.1. 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-2-WriteStreamHeader-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">10.4.2.</span> <span class="toc-text">14.5.2. WriteStreamHeader 方法的调用时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-3-WriteStreamHeader-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">10.4.3.</span> <span class="toc-text">14.5.3. WriteStreamHeader 方法的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E7%9E%AC%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97-transient"><span class="toc-number">10.5.</span> <span class="toc-text">14.6. 瞬态关键字 transient</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-1-transient-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">10.5.1.</span> <span class="toc-text">14.6.1. transient 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-2-%E4%BD%BF%E7%94%A8-static-%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">10.5.2.</span> <span class="toc-text">14.6.2. 使用 static 修饰的成员变量（不建议使用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-3-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">10.5.3.</span> <span class="toc-text">14.6.3. 注意点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.6.</span> <span class="toc-text">14.7. 序列化的常见问题与注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-1-InvalidClassException-%E5%BC%82%E5%B8%B8"><span class="toc-number">10.6.1.</span> <span class="toc-text">14.7.1. InvalidClassException 异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93"><span class="toc-number">10.6.2.</span> <span class="toc-text">14.7.2. 注意事项总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-8-%E6%89%A9%E5%B1%95"><span class="toc-number">10.7.</span> <span class="toc-text">14.8. 扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-1-%E5%85%B6%E4%BB%96%E5%BA%8F%E5%88%97%E5%8C%96%E8%BD%AC%E6%8D%A2%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">10.7.1.</span> <span class="toc-text">14.8.1. 其他序列化转换对象的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-2-%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%E6%A1%88%E4%BE%8B"><span class="toc-number">10.7.2.</span> <span class="toc-text">14.8.2. 序列化对象案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#14-8-2-1-%E7%B1%BB%E6%B7%BB%E5%8A%A0%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.7.2.1.</span> <span class="toc-text">14.8.2.1. 类添加序列化接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-8-2-2-%E5%BA%8F%E5%88%97%E5%8C%96-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">10.7.2.2.</span> <span class="toc-text">14.8.2.2. 序列化&#x2F;反序列化</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img src="/bg/Image00018.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库150道高频面试题"/></a><div class="content"><a class="title" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题">MySQL数据库150道高频面试题</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术同学必会的MySQL设计规约"/></a><div class="content"><a class="title" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约">技术同学必会的MySQL设计规约</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dfdfdf4.html" title="数据库概述"><img src="/bg/Image00002.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库概述"/></a><div class="content"><a class="title" href="/posts/dfdfdf4.html" title="数据库概述">数据库概述</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/490575ab.html" title="24工厂模式俗话解释"><img src="/bg/Image00024.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24工厂模式俗话解释"/></a><div class="content"><a class="title" href="/posts/490575ab.html" title="24工厂模式俗话解释">24工厂模式俗话解释</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/364ea8cc.html" title="设计模式"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/364ea8cc.html" title="设计模式">设计模式</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2020 - 2025 By 蓝桉</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8152976493" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat/cat.js"></script><script async data-pjax src="/js/meting/music_lanan.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/day/lunar.js"></script><script defer src="/js/day/day.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '10a7db1c41b6489db9c830c668a18304';
  var gaud_map_key = '82a64bc994fb6494830f157f319f9f69';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime/runtime.min.js"></script><script async src="/js/font/ali_font_all.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>
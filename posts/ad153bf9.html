<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础-集合 | 蓝桉`Blog</title><meta name="author" content="蓝桉,kt_zxh@163.com"><meta name="copyright" content="蓝桉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 集合框架支持两种不同类型的集合：  Collection（单列集合） Map（双列集合）    Notes:   本笔记所有方法和示例基于 jdk1.8 JDK 提供的线程安全的并发容器，如：BlockingQueue 等，详见《并发编程 - 并发容器》笔记   1. Collection 接口（单列集合）1.1. 概述Collection 是所有单列集合的父接口（父类），集合的项层的接">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础-集合">
<meta property="og:url" content="https://ktzxy.github.io/posts/ad153bf9.html">
<meta property="og:site_name" content="蓝桉&#96;Blog">
<meta property="og:description" content="Java 集合框架支持两种不同类型的集合：  Collection（单列集合） Map（双列集合）    Notes:   本笔记所有方法和示例基于 jdk1.8 JDK 提供的线程安全的并发容器，如：BlockingQueue 等，详见《并发编程 - 并发容器》笔记   1. Collection 接口（单列集合）1.1. 概述Collection 是所有单列集合的父接口（父类），集合的项层的接">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ktzxy.github.io/bg/Image00012.webp">
<meta property="article:published_time" content="2025-07-09T17:28:45.000Z">
<meta property="article:modified_time" content="2025-07-13T15:45:18.463Z">
<meta property="article:author" content="蓝桉">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ktzxy.github.io/bg/Image00012.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础-集合",
  "url": "https://ktzxy.github.io/posts/ad153bf9.html",
  "image": "https://ktzxy.github.io/bg/Image00012.webp",
  "datePublished": "2025-07-09T17:28:45.000Z",
  "dateModified": "2025-07-13T15:45:18.463Z",
  "author": [
    {
      "@type": "Person",
      "name": "蓝桉",
      "url": "https://ktzxy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ktzxy.github.io/posts/ad153bf9.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础-集合',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/windmill/windmill.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/meting/music_lanan.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="蓝桉`Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/bg.webp);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/bg/Image00012.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">蓝桉`Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础-集合</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java基础-集合</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-09T17:28:45.000Z" title="发表于 2025-07-09 17:28:45">2025-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-13T15:45:18.463Z" title="更新于 2025-07-13 15:45:18">2025-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Java 集合框架支持两种不同类型的集合：</p>
<ul>
<li><code>Collection</code>（单列集合）</li>
<li><code>Map</code>（双列集合）</li>
</ul>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251038721.png" alt=""></p>
<blockquote>
<p>Notes: </p>
<ul>
<li><strong>本笔记所有方法和示例基于 jdk1.8</strong></li>
<li>JDK 提供的线程安全的并发容器，如：<code>BlockingQueue</code> 等，详见<a href="/并发编程/并发编程-并发容器">《并发编程 - 并发容器》笔记</a></li>
</ul>
</blockquote>
<h2 id="1-Collection-接口（单列集合）"><a href="#1-Collection-接口（单列集合）" class="headerlink" title="1. Collection 接口（单列集合）"></a>1. Collection 接口（单列集合）</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h3><p><code>Collection</code> 是所有单列集合的父接口（父类），集合的项层的接口。Collection 接口本身是没有索引的，但它的子体系中有支持<strong>重复的，唯一的，有序的，无序的</strong>等不同类型的实现。<code>Collection</code> 框架支持以下三种主要类型：</p>
<ul>
<li><strong><code>Set</code>（规则集）</strong>：用于存储一组不重复的元素。</li>
<li><strong><code>List</code>（线性表）</strong>：用于存储一个由元素构成的有序集合。</li>
<li><strong><code>Queue</code>（队列）</strong>：用于存储先进先出方式处理的对象。</li>
</ul>
<blockquote>
<p>Tips: 这些集合的通用特性都被定义在 <code>java.util.Collection</code> 接口中，相应的集合类型的特性定义以上各自的接口中，并提供了各自不同实现类来实现具体的功能。</p>
</blockquote>
<h3 id="1-2-Collection-继承体系图"><a href="#1-2-Collection-继承体系图" class="headerlink" title="1.2. Collection 继承体系图"></a>1.2. Collection 继承体系图</h3><p><code>Collection</code> 是所有单列集合的直接或间接接口，其指定了所有集合应该具备的基本功能。</p>
<ul>
<li><code>List</code> 接口：元素可重复，有序，带索引。<ul>
<li>ArrayList(重要)：底层是数组结构。ArrayList 的出现替代了 Vector，增删慢，查找快。</li>
<li>LinkedList(重要)：底层是链表结构。同时对元素的增删操作效率很高。</li>
</ul>
</li>
<li><code>Set</code> 接口： 元素不能重复，无序，没有索引。<ul>
<li>HashSet(重要)：底层是哈希表结构。在不重复的基础上无序。</li>
<li>LinkedHashSet：底层是哈希表结构结合链表结构。在不重复的基础上可预测迭代顺序。</li>
</ul>
</li>
</ul>
<p><strong>单列集合体系图</strong></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251038722.jpg" alt="Java 集合框架图.drawio"></p>
<h3 id="1-3-Collection-集合接口的常用方法"><a href="#1-3-Collection-集合接口的常用方法" class="headerlink" title="1.3. Collection 集合接口的常用方法"></a>1.3. Collection 集合接口的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>Collection 是接口，定义了集合相关的方法。<strong>其实 <code>ArrayList</code> 等实现类就是实现 <code>Collection</code> 的以下的方法</strong></p>
<h4 id="1-3-1-添加元素"><a href="#1-3-1-添加元素" class="headerlink" title="1.3.1. 添加元素"></a>1.3.1. 添加元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。</li>
</ul>
<h4 id="1-3-2-删除元素"><a href="#1-3-2-删除元素" class="headerlink" title="1.3.2. 删除元素"></a>1.3.2. 删除元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>移除此集合中首次出现的指定元素（如果存在），返回删除是否成功(true/false)。<font color=red><strong>删除元素是影响本来的集合</strong></font>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>移除此集合中所有包含在指定的集合中所有元素（如果存在），返回删除是否成功(true/false)</li>
</ul>
<h4 id="1-3-3-获取集合信息"><a href="#1-3-3-获取集合信息" class="headerlink" title="1.3.3. 获取集合信息"></a>1.3.3. 获取集合信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回集合中的元素的个数</li>
</ul>
<h4 id="1-3-4-清空集合"><a href="#1-3-4-清空集合" class="headerlink" title="1.3.4. 清空集合"></a>1.3.4. 清空集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>移除此集合中的所有元素。此调用返回后，集合将为空。</li>
</ul>
<h4 id="1-3-5-判断功能"><a href="#1-3-5-判断功能" class="headerlink" title="1.3.5. 判断功能"></a>1.3.5. 判断功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断集合是否为空。如果此列表中没有元素，则返回 true。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断此集合中是否包含指定的元素，包含则返回 true。</li>
</ul>
<h4 id="1-3-6-类型转换功能"><a href="#1-3-6-类型转换功能" class="headerlink" title="1.3.6. 类型转换功能"></a>1.3.6. 类型转换功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray();</span><br></pre></td></tr></table></figure>
<ul>
<li>按适当顺序（从第一个到最后一个元素）返回包含此集合中所有元素的数组。</li>
</ul>
<h3 id="1-4-综合示例"><a href="#1-4-综合示例" class="headerlink" title="1.4. 综合示例"></a>1.4. 综合示例</h3><p>Code Demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关卡1训练案例 1</span></span><br><span class="line"><span class="comment"> * 	Collection 基本用法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建Collection对象，因Collection是接口，只能通过子类去创建对象</span></span><br><span class="line">		Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">		<span class="comment">// 往集合中添加对象元素</span></span><br><span class="line">		c.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		c.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">		c.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">		c.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">		c.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">		<span class="comment">// 输出集合[a, b, c, d, e]</span></span><br><span class="line">		System.out.println(c);</span><br><span class="line">		<span class="comment">// 删除元素</span></span><br><span class="line">		c.remove(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">		<span class="comment">// remove不存在的元素，不报错，没有效果</span></span><br><span class="line">		c.remove(<span class="string">&quot;f&quot;</span>);</span><br><span class="line">		<span class="comment">//输出集合[a, b, d, e]</span></span><br><span class="line">		System.out.println(c);</span><br><span class="line">		<span class="comment">// 获取集合大小：4</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Collection集合的大小是：&quot;</span> + c.size());</span><br><span class="line">		<span class="comment">// 清空集合+判断集合是否是空 输出 false</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Collectiong集合是否为空：&quot;</span> + c.isEmpty());</span><br><span class="line">		c.clear();</span><br><span class="line">		<span class="comment">//输出true</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Collectiong集合是否为空：&quot;</span> + c.isEmpty());</span><br><span class="line">		<span class="comment">// 输出集合内容 []</span></span><br><span class="line">		System.out.println(c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-List-接口"><a href="#2-List-接口" class="headerlink" title="2. List 接口"></a>2. List 接口</h2><p>List 接口用来定义有序(存取顺序一致)，有索引，元素可重复的集合</p>
<h3 id="2-1-接口概述"><a href="#2-1-接口概述" class="headerlink" title="2.1. 接口概述"></a>2.1. 接口概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>List 是一个元素存取有序、带有索引、并且可以存储重复元素的集合。例如：存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的；通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）</p>
<p>由于 List 集合拥有索引，因此 List 集合迭代方式除了使用迭代器之外，还可以使用索引进行迭代。遍历方法分别是：<font color=red><strong>普通for，增强for，迭代器</strong></font>。</p>
<h3 id="2-2-List-集合存储数据的结构"><a href="#2-2-List-集合存储数据的结构" class="headerlink" title="2.2. List 集合存储数据的结构"></a>2.2. List 集合存储数据的结构</h3><p>List 接口下有很多个集合实现，它们存储元素所采用的结构方式是不同的，这样就导致了这些集合有它们各自的特点，供给开发者在不同的环境下进行使用。接口的常见实现类</p>
<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector</li>
</ul>
<h3 id="2-3-接口常用的方法"><a href="#2-3-接口常用的方法" class="headerlink" title="2.3. 接口常用的方法"></a>2.3. 接口常用的方法</h3><h4 id="2-3-1-增加元素"><a href="#2-3-1-增加元素" class="headerlink" title="2.3.1. 增加元素"></a>2.3.1. 增加元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>向集合末尾处，添加指定的元素 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>向集合指定索引处，添加指定的元素，原有元素依次后移</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。向右移动当前位于该位置的元素（如果有）以及所有后续元素（增加其索引）。新元素将按照指定 collection 的迭代器所返回的元素顺序出现在列表中。</li>
</ul>
<h4 id="2-3-2-删除元素"><a href="#2-3-2-删除元素" class="headerlink" title="2.3.2. 删除元素"></a>2.3.2. 删除元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object e)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将指定元素对象，从集合中删除，返回值为被删除的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>从集合中删除将指定索引处的元素，并返回被删除的元素。<font color=red><strong>值得注意的是，若调用方法时传入的参数 index 是 <code>Integer</code> 类型的，调用的是 <code>remove(Object object)</code> 方法，而不是 <code>remove(int index)</code>，所以会出现无法删除指定的索引处的元素的情况，传入的一定要是基本数据类型哦!</strong></font></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>清空集合</li>
</ul>
<h4 id="2-3-3-替换元素"><a href="#2-3-3-替换元素" class="headerlink" title="2.3.3. 替换元素"></a>2.3.3. 替换元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将指定索引处的元素，替换成指定的元素，返回值为替换前的元素</li>
</ul>
<h4 id="2-3-4-获取元素"><a href="#2-3-4-获取元素" class="headerlink" title="2.3.4. 获取元素"></a>2.3.4. 获取元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取指定索引处的元素，并返回该元素。(获取元素是不会改变本来的集合)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回此集合中首次出现的指定元素的索引；如果此集合不包含元素，则返回 -1。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回此集合中最后一次出现的指定元素的索引；如果此集合不包含索引，则返回 -1。</li>
</ul>
<h3 id="2-4-ArrayList"><a href="#2-4-ArrayList" class="headerlink" title="2.4. ArrayList"></a>2.4. ArrayList</h3><h4 id="2-4-1-简介"><a href="#2-4-1-简介" class="headerlink" title="2.4.1. 简介"></a>2.4.1. 简介</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<font color=red>**ArrayList 集合底层数据存储的结构是数组结构。数组实现的特点：<u>元素查询快，增删慢，线程不安全（效率高）</u>**</font>。ArrayList 是一个长度可变的高级的数组，可以在集合中存储任意**对象类型**的数据，集合本身也是一个对象。由于日常开发中使用最多的功能为查询数据、遍历数据，所以 ArrayList 是最常用的集合。

> Notes: <font color=red>**集合只能存储对象（引用类型）的数据，不能存在基本数据类型**</font>。

需要注意**线程安全性**：对 ArrayList 的操作一般分为两个步骤，改变位置(size)和操作元素(e)。所以这个过程在多线程的环境下是不能保证具有原子性的，因此 ArrayList 在多线程的环境下是线程不安全的。

> Tips: 开发时随意地使用 ArrayList 完成任何需求，并不严谨，这种用法不提倡。

#### 2.4.2. RandomAccess 接口

Java Collections 框架中提供了一个 `RandomAccess` 接口，用来标记 List 实现是否支持 Random Access。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如 `ArrayList`
- 如果没有实现该接口，表示不支持 Random Access，如 `LinkedList`

#### 2.4.3. ArrayList 优缺点

优点：

1. 因为其底层是数组，所以修改和查询效率高。
2. 可自动扩容(1.5倍)。

缺点：

1. 插入和删除效率不高。
2. 线程不安全。

ArrayList 比较适合顺序添加、随机访问的场景。

#### 2.4.4. ArrayList 的特有方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>

- 重写 `AbstractList` 抽象父类的方法，移除集合中索引在 `fromIndex`（包括）和 `toIndex`（不包括）之间的所有元素。向左移动所有后续元素（减小其索引）。此调用将列表缩短了 (`toIndex - fromIndex`) 个元素。如果 `toIndex == fromIndex`，则此操作无效。

#### 2.4.5. 集合的遍历示例

ArrayList 集合的遍历最经典是，通过 `size()` 和 `get()` 配合实现的

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最标准的用法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; array.size(); x++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> array.get(x);    <span class="comment">// 目的是为了以后能再对集合里的元素进行使用</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

#### 2.4.6. ArrayList 底层原理

##### 2.4.6.1. ArrayList 数组实现的原理

数组实现的特点：查询快，增删慢，线程不安全（效率高）。原因：

- <font color=red>**查询快**</font>：由于数组的索引支持，那么可以通过索引直接计算出元素的地址值，因此就可以直接通过元素的地址值获取到指定的元素
- <font color=red>**增删慢**</font>：由于在添加元素的时候，实际上底层会先创建一个新数组(新数组的长度为原数组的长度+1)，那么在添加新元素的时候，先需要对数组中原有的数据进行拷贝，其次在末尾进行添加新的元素。因此，这样操作的效率的极低的(删除元素刚好和添加的操作相反)

> Tips: 增删慢的情况是基于，数组的原长度不够，并且非在数组尾部插入数据的情况。若数组的长度足够并且在尾部插入新的元素，其他操作的效率甚至比链表更快。

##### 2.4.6.2. ArrayList 的 contains 方法判断元素（自定义类型）是否存在的原理

ArrayList 的 `contains` 方法，会调用方法传入的元素的 equals 方法依次与集合中的旧元素所比较，从而根据返回的布尔值判断是否有重复元素。

当 ArrayList 存放**自定义类型**时，由于自定义类型在未重写 equals 方法前，判断是否重复的依据是比较对象的地址值，所以<font color=red>**如果想根据内容判断是否为重复元素，需要重写元素的 equals 方法**</font>

<h3 id="2-5-LinkedList"><a href="#2-5-LinkedList" class="headerlink" title="2.5. LinkedList"></a>2.5. LinkedList</h3><h4 id="2-5-1-概述"><a href="#2-5-1-概述" class="headerlink" title="2.5.1. 概述"></a>2.5.1. 概述</h4><font color=red>**LinkedList 集合底层数据存储的实现是双向链表结构，<u>查询慢，增删快，线程不安全（效率高）</u>**</font>。

> Notes: 数据结构基础之双向链表。双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。

LinkedList 与 ArrayList 不同的是，在对 LinkedList 进行插入和删除操作时，只需在对应的节点上插入或删除元素，并将前后的节点元素的指针指向该节点即可，数据不需要进行复制移动，因此随机插入和删除效率很高。

LinkedList 还提供了在 List 接口中未定义，<font color=red>用于操作链表头部和尾部的元素</font>的方法，因此有时也可以被当作堆栈、队列或双向队列使用。

#### 2.5.2. LinkedList 链表实现的原理

链表结构：查询慢，增删快，线程不安全（效率高）。其原因：

- <font color=red>**查询慢**</font>：由于不能直接找到元素的地址，需要上一个元素推导出下一个元素的地址，因为在进行随机访问时，需要从链表头部一直遍历到要查找的节点为止，这种查询速度较慢。
- <font color=red>**增删快**</font>：在添加的时候，只需要更改元素所记录的地址值即可

链表查询元素是判断索引是否大于集合元素个数的一半来决定从表头还是表尾开始查询。如果大于一半，则从表尾开始查找，否则从表头开始查找。

#### 2.5.3. LinkedList 常用特有方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>;</span><br></pre></td></tr></table></figure>

- 将指定元素添加到链表头

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>;</span><br></pre></td></tr></table></figure>

- 将指定元素添加到链表尾

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 移除并返回此列表的第一个元素。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

- 移除并返回此列表的最后一个元素。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 返回此列表的第一个元素。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 返回此列表的最后一个元素。

### 2.6. Vector（了解）

`Vector` 集合数据存储的结构是数组结构，为 JDK 中最早提供的集合。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>

`Vector` 中提供了一个独特的取出方式，就是枚举 `Enumeration`，它其实就是早期的迭代器。此接口 `Enumeration` 的功能与 `Iterator` 接口的功能是类似的。`Vector` 集合已被 `ArrayList` 替代。枚举 `Enumeration` 已被迭代器 `Iterator` 替代。

`Vector` 最大的特点是线程安全但效率低，因为 Vector 类的所有方法（如 `add`、`set`、`delete` 等）均是 `synchronized` 修饰的同步方法，在多线程访问的情况下，只允许一个线程进行增删改操作。后面已经不再建议使用，而 Arraylist 不是同步的，其效率比较高，在不需要保证线程安全时建议使用 Arraylist。

### 2.7. Stack 栈结构（了解）

#### 2.7.1. 概述

java 提供了一个专门用于栈结构的类：`java.util.Stack`

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

Stack 类表示后进先出（LIFO）的对象堆栈。

#### 2.7.2. 常用方法

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 查看堆栈顶部的对象，但不从堆栈中移除它。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">push</span><span class="params">(E item)</span>;</span><br></pre></td></tr></table></figure>

- 把项压入堆栈顶部。(压栈)

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

- 移除堆栈顶部的对象，并作为此函数的值返回该对象。(弹栈)

### 2.8. 集合与数组之间的转换

#### 2.8.1. 集合转数组( List 类方法)

集合（如：ArrayList）转数组使用的是，Collection 接口的 `toArray()` 方法，ArrayList 和 LinkedList 都有承继该方法。

**方式一**：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray()</span><br></pre></td></tr></table></figure>

- 将集合内容转成一个对象数组。如果需要下一步操作，需要进行向下转型。按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] arr = list.toArray();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) arr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

**方式二**：

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)</span><br></pre></td></tr></table></figure>

- 将集合中的元素添加至指定的数组中。按适当顺序（从第一个到最后一个元素）返回包含此列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。
    - 如果传入的数组的长度大于等于集合元素的个数时，则方法内部直接将集合中元素添加到指定的数组中，并返回该数组。
    - 如果传入的数组的长度小于集合元素的个数时，则方法内部会创建一个新的数组，新数组的类型与传入的数组类型一致，新数组的长度等于集合元素的个数，并且将集合中的元素添加到新数组中，返回新的数组。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[list.size()];</span><br><span class="line">list.toArray(strs);	</span><br></pre></td></tr></table></figure>

#### 2.8.2. 数组转集合（使用 Arrays 工具类方法）

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span>;</span><br></pre></td></tr></table></figure>

Arrays 工具类的静态方法，将数组的内容添加到一个集合中，并返回集合对象。。方法的形参是可变参数类型，可变参数本质也是数组，传入实际数组，将该数组转成集合返回

> Notes: 通过 `asList` 方法将数组转成集合之后，<font color=red>**获得的集合是固定大小的集合，不支持向集合中添加或删除元素。**</font>，否则会抛出 `UnsupportedOperationException` 异常

可以使用有参数构造方法，将其转成可以增删的新的集合

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; array = Arrays.asList(arr);</span><br><span class="line">ArrayList&lt;String&gt; newArray = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(array); <span class="comment">// newArray 是可以增删的。</span></span><br></pre></td></tr></table></figure>

#### 2.8.3. 集合（List）与数组（Array）的区别与选择

两者的区别是：

1. **长度不同**：组的长度是固定的；集合的长度是可变的。
2. **存储元素的数据类型不同**：集合只能存储对象（引用类型）的数据，不能存在基本数据类型；而数组既可以存基本类型的元素，也可以存引用类型的元素。
3. **获取长度的方法不同**：数组是通过 `length` 属性；而集体是通过 `size()` 方法。

通常情况下都会选择集合(如：ArrayList)，因为数据没有提供像集合(List)的那么功能，如：`addAll`、`removeAll`、`iterator` 等。但也有些情况选择数组（Array）比较好用：

1. 如果列表的大小已经指定并且不会变化，大部分情况下是存储和遍历它们。
2. 对于遍历基本数据类型，尽管集合会对基本类型使用自动装箱，但在处理指定大小的基本类型列表时，效率会较低。
3. 对于需要使用多维数组，使用 `[][]` 比 `List<List<xx>>` 更容易。

### 2.9. List 接口相关实现类总结

#### 2.9.1. ArrayList 和 LinkedList 的区别与选择

**区别**：

- **数据结构实现**：ArrayList 是动态数组的数据结构实现；而 LinkedList 是双向链表的数据结构实现。
- **随机访问效率**：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。
- **增加和删除效率**：
    - 在非首尾的增加和删除操作时，LinkedList 和 ArrayList 的时间复杂度是 O(n)。LinkedList 需要遍历链表，但 LinkedList 要比 ArrayList 效率要高，因为 ArrayList 的扩容机制的存在，增删操作时超出存储长度时，需要新建数组，再将原数组中的数据复制到新数组中，并且会影响数组内的其他数据的下标。
    - 在 ArrayList 尾部插入和删除，时间复杂度是O(1)；LinkedList 头尾节点增删时间复杂度也是 O(1)。
    - 如果在 ArrayList 指定了合适的初始容量，并且使用尾部插入数据（没有触发数组的扩展）时，会极大提升性能，甚至超过 LinkedList（增删操作还需要创建大量的 node 对象）的效率
- **内存空间占用**：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。
- **内存存储区域**：ArrayList 是连续内存存储；而 LinkedList 分散在内存中。
- **迭代器性能**：在迭代操作时，ArrayList 使用普通迭代器或增强 for 循环的性能比 LinkedList 更优。因为 ArrayList 的数据存储在连续的内存中，迭代时可以直接访问内存，而 LinkedList 需要通过遍历链表来访问每个元素。
- **线程安全**：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全。*如果需要保证线程安全，有两种方案：*
    1. 在方法内使用，局部变量则是线程安全的
    2. 使用 `Collections` 工具类包装成线程安全的 ArrayList 和 LinkedList

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; syncArrayList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">List&lt;Object&gt; syncLinkedList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>

**类型选择与使用建议**：

- 如果需要大量非首尾增删元素，则建议使用 LinkedList
- 如果只是遍历查询元素，不进行增删操作，则建议使用 ArrayList
- <font color=red>**遍历 LinkedList 必须使用 Iterator 而不使用 for 循环，因为每次 for 循环体内通过 `get(i)` 方法获取指定元素时，需要对整个集合重新进行遍历，性能消耗极大**</font>
- 尽量不要试图使用 `indexOf` 等方法返回元素的索引，并利用其进行遍历。使用 `indexOf` 对集合进行遍历，当结果为空时会遍历整个集合。

#### 2.9.2. ArrayList 和 Vector 的区别

此两个类都实现了 List 接口（List 接口继承了 Collection 接口），它们都是有序集合

- **线程安全**：Vector 使用了 `Synchronized` 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。
- **性能**：ArrayList 在性能方面要优于 Vector。
- **扩容**：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。ArrayList 与 Vector 都可以设置初始的空间大小，但 Vector 还可以设置增长的空间大小，而 ArrayList 没有提供设置增长空间的方法。

> Vector 类的所有方法都是同步的。可以由两个线程安全地访问一个 Vector 对象、但是一个线程访问 Vector 的话代码要在同步操作上耗费大量的时间；而 Arraylist 不是同步的，所以在不需要保证线程安全时时建议使用 Arraylist

## 3. Iterator 迭代器

### 3.1. Iterator 概述

Collection 集合元素的通用获取方式：在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为**迭代**。JDK 集合中把这种取元素的方式描述在 `Iterator` 接口中。

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>

Iterator 迭代器，是一个接口，集合迭代(集合遍历)的工具。可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，并且迭代器允许调用者在迭代过程中移除元素。

> Tips: 不同的容器完成不同方式的数据存储。不同集合的特点不同，ArrayList 有序且可重复且带索引的集合。但是有的集合不带索引。所以如果使用其他集合，可能无法通过 `get+索引` 的方式获取元素。<font color=red>**所有集合的通用获取元素方法并不是通过索引获取，而是通过迭代器获取。**</font>

<h4 id="3-1-1-迭代器的好处"><a href="#3-1-1-迭代器的好处" class="headerlink" title="3.1.1. 迭代器的好处"></a>3.1.1. 迭代器的好处</h4><ul>
<li>屏蔽了不同类型集合的内部实现，将访问逻辑抽象出来，提供了统一遍历方式。</li>
<li>所有的单列集合都可以使用迭代器遍历。</li>
<li>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</li>
</ul>
<h4 id="3-1-2-与-Enumeration-接口的区别"><a href="#3-1-2-与-Enumeration-接口的区别" class="headerlink" title="3.1.2. 与 Enumeration 接口的区别"></a>3.1.2. 与 Enumeration 接口的区别</h4><p>Enumeration 的速度是 Iterator的 两倍，也使用更少的内存。Enumeration 能满足非常基础的需求，与 Iterator 有以下区别：</p>
<ol>
<li>Iterator 更加安全，因为当一个集合正在被遍历的时候，Iterator 会阻止其它线程去修改集合。</li>
<li>迭代器允许调用者从集合中移除元素，而 Enumeration 不能。<em>迭代器已取代了 Java 集合框架中的 Enumeration</em>。</li>
</ol>
<h3 id="3-2-Iterator-常用方法"><a href="#3-2-Iterator-常用方法" class="headerlink" title="3.2. Iterator 常用方法"></a>3.2. Iterator 常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用来判断当前指针指向的位置是否有元素可以迭代。如果返回 true，说明可以迭代。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">next</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用来返回指针指向位置的元素，并把指针向后移动一位。<strong>集合用来持有数据，所有常用集合都具备了可迭代功能 Iterator 方法，该方法用于迭代集合，是最为通用的集合迭代方法。</strong></li>
</ul>
<blockquote>
<p>Notes: 如果集合中没有元素可迭代了，仍然调用 <code>next()</code> 方法，就会抛出异常（<code>java.util.NoSuchElementException</code>）。<font color=red><strong>真正使指针向后移动的是调用 <code>next()</code> 方法</strong></font></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）。</li>
</ul>
<h3 id="3-3-迭代器的基础使用-重点"><a href="#3-3-迭代器的基础使用-重点" class="headerlink" title="3.3. 迭代器的基础使用(重点)"></a>3.3. 迭代器的基础使用(重点)</h3><h4 id="3-3-1-集合的获取迭代器方法"><a href="#3-3-1-集合的获取迭代器方法" class="headerlink" title="3.3.1. 集合的获取迭代器方法"></a>3.3.1. 集合的获取迭代器方法</h4><p>通过子类调用父类 <code>Collection</code> 接口中的 <code>iterator()</code> 方法获得迭代器对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>示例：获取某个集合的迭代器实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-集合元素的迭代"><a href="#3-3-2-集合元素的迭代" class="headerlink" title="3.3.2. 集合元素的迭代"></a>3.3.2. 集合元素的迭代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;e&gt; it = list.iterator()</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">ele</span> <span class="operator">=</span> it.next(); <span class="comment">// 返回指针指向位置的元素，并把指针向后移动一位。</span></span><br><span class="line">	<span class="comment">// ...do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-使用示例"><a href="#3-3-3-使用示例" class="headerlink" title="3.3.3. 使用示例"></a>3.3.3. 使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 案例：往 ArrayList 添加以下元素&quot;abc1&quot;, &quot;abc2&quot;, &quot;abc3&quot;, &quot;abc4&quot;。使用迭代器获取 ArrayList 集合中的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 创建ArrayListc对象,添加元素</span></span><br><span class="line">	ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	array.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">	array.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">	array.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">	array.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line">	System.out.println(array);</span><br><span class="line">	<span class="comment">// 使用迭代器获取ArrayList集合元素</span></span><br><span class="line">	<span class="comment">// 调用父类Collection接口中的iterator()方法创建迭代器对象Iterator</span></span><br><span class="line">	Iterator&lt;String&gt; it = array.iterator();</span><br><span class="line">	<span class="comment">// 使用Iterator迭代集合并输出结果</span></span><br><span class="line">	<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">		System.out.println(it.next());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-迭代器使用注意事项"><a href="#3-4-迭代器使用注意事项" class="headerlink" title="3.4. 迭代器使用注意事项"></a>3.4. 迭代器使用注意事项</h3><h4 id="3-4-1-并发修改异常"><a href="#3-4-1-并发修改异常" class="headerlink" title="3.4.1. 并发修改异常"></a>3.4.1. 并发修改异常</h4><p>在使用迭代器遍历集合的过程中调用了集合的 <code>add</code>、<code>clear</code> 等修改了集合元素的个数时就会出现并发修改异常(<code>java.util.ConcurrentModificationException</code>)。在 API 中对此异常的解释如下：</p>
<blockquote>
<p>public class ConcurrentModificationException extends RuntimeException 此异常可能会被抛出的方法，已检测到的对象的并发修改时，这样的修改是不允许的。例如，它通常是不允许一个线程而另一个线程遍历它修改集合。在一般情况下，迭代的结果是不确定的，在这种情况下。一些迭代器实现（包括所有通用收集实现的JRE提供）可以选择如果检测行为抛出该异常。迭代器这样做被称为快速失败迭代器，因为他们不能迅速、干净，而冒着任意的，非在将来一个不确定的时间确定的行为。</p>
<p>注意，这个例外并不总是表明对象已由一个不同的线程的并发性。如果一个线程问题序列的方法调用，违反合同的对象，对象可能抛出该异常。例如，如果一个线程修改直接收集的则是在一个快速失败迭代器集合的迭代，迭代器将抛出此异常。</p>
<p>注意，快速失败行为不能得到保证的话，一般来说，不可能在不同步的并发修改的存在作出难以保证。快速失败的操作把 ConcurrentModificationException 尽最大努力的基础上。因此，要写一个程序，依靠这一例外的正确性错误：concurrentmodificationexception 只能用来检测错误。</p>
</blockquote>
<p>解决并发修改异常问题有如下几种方式：</p>
<ol>
<li>在集合有索引的情况下，使用普通 for 遍历(不使用Iterator迭代)，如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 集合添加元素...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">    System.out.println(array.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用 <code>ListIterator</code> 迭代器遍历，<font color=red><strong>添加元素时不要调用集合对象的 <code>add</code> 方法，而是调用 <code>ListIterator</code> 对象的 <code>void add(E e)</code> 方法</strong></font></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ListIterator 解决并发修改问题</span></span><br><span class="line">ListIterator&lt;Student&gt; listIt = list.listIterator();</span><br><span class="line"><span class="keyword">while</span> (listIt.hasNext()) &#123;</span><br><span class="line">    <span class="comment">// 获得学生对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> listIt.next();</span><br><span class="line">    <span class="comment">// 判断是否是rose</span></span><br><span class="line">    <span class="keyword">if</span> (stu.getName().equals(<span class="string">&quot;rose&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 添加一个新学生对象</span></span><br><span class="line">        listIt.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;老王&quot;</span>, <span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(stu);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-获取迭代器后遍历前不能对原集合进行结构上修改"><a href="#3-4-2-获取迭代器后遍历前不能对原集合进行结构上修改" class="headerlink" title="3.4.2. 获取迭代器后遍历前不能对原集合进行结构上修改"></a>3.4.2. 获取迭代器后遍历前不能对原集合进行结构上修改</h4><p>如果在创建迭代器后不将创建时的集合输出，如果再增加或者移除元素后，集合的地址值已经改变了，迭代器的指针原来指向的地址应该没有内容，所有没有任何元素可以输出。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251038723.png" alt=""></p>
<h4 id="3-4-3-循环时移除集合中的元素正确方式"><a href="#3-4-3-循环时移除集合中的元素正确方式" class="headerlink" title="3.4.3. 循环时移除集合中的元素正确方式"></a>3.4.3. 循环时移除集合中的元素正确方式</h4><p>若需要在循环中移除集合中的元素，不能使用集合中的 <code>remove</code> 方法，使用 Iterrator 对象中的 <code>remove</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator it=list.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Object e=it.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;b&quot;</span>.equals(e))&#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p>一种最常见的错误代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list)&#123;</span><br><span class="line">    list.remove(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-增强-for-foreach"><a href="#3-5-增强-for-foreach" class="headerlink" title="3.5. 增强 for (foreach)"></a>3.5. 增强 for (foreach)</h3><h4 id="3-5-1-增强-for-概述"><a href="#3-5-1-增强-for-概述" class="headerlink" title="3.5.1. 增强 for 概述"></a>3.5.1. 增强 for 概述</h4><p>增强 for 循环是 JDK1.5 以后出来的一个高级 for 循环，专门用来遍历数组和集合的。</p>
<p>增强 for 的本质就是迭代器，它的内部原理其实是个 <code>Iterator</code> 迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。它用于遍历 <code>Collection</code> 和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<h4 id="3-5-2-增强-for-语法格式"><a href="#3-5-2-增强-for-语法格式" class="headerlink" title="3.5.2. 增强 for 语法格式"></a>3.5.2. 增强 for 语法格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量名 : Collection 集合名或数组名)&#123;</span><br><span class="line">	<span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Code Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span>[] arr = &#123; <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span> &#125;;</span><br><span class="line">	<span class="comment">// 使用增强for遍历数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">		System.out.println(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-3-注意事项"><a href="#3-5-3-注意事项" class="headerlink" title="3.5.3. 注意事项"></a>3.5.3. 注意事项</h4><p>如果使用增强 for 遍历的是引用数据类型的对象时，在循环体内部通过引用变量修改对象的成员变量值会影响集合或数组中对象的值。</p>
<h3 id="3-6-ListIterator"><a href="#3-6-ListIterator" class="headerlink" title="3.6. ListIterator"></a>3.6. ListIterator</h3><h4 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1. 概述"></a>3.6.1. 概述</h4><p><code>ListIterator</code> 是一个更加强大的 <code>Iterator</code> 的子类型，但它只能用于各种 List 类的访问，<code>Iterator</code> 只能单向遍历。而 <code>ListIterator</code> 可以双向遍历（向前/后遍历），它还可以产生相对于迭代器在列表指向的当前位置的前一个和后一个元素的索引。并且可以使用 <code>set()</code> 方法替换它访问过的最后一个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>可以通过集合对象的 <code>listIterator()</code> 方法产生一个指向 List 开始处的 <code>ListIteraor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...添加元素</span></span><br><span class="line">ListIterator&lt;String&gt; it = list.listIterator();</span><br></pre></td></tr></table></figure>
<p>还可以通过调用 <code>ListIterator(n)</code> 方法创建一个一开始就指向索引列表 n 的元素处的 <code>ListIterator</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...添加元素</span></span><br><span class="line">ListIterator&lt;String&gt; it = list.listIterator(list.size()); <span class="comment">// 这里指向了 List 的最后一个元素</span></span><br></pre></td></tr></table></figure>
<h4 id="3-6-2-常用方法"><a href="#3-6-2-常用方法" class="headerlink" title="3.6.2. 常用方法"></a>3.6.2. 常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>检查是否有下一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">next</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回下一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>检查是否有前一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">previous</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回前一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回下一个元素的 Index</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回当前元素的 Index</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>移除一个当前的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E e)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>此方法替换访问过的最后一个元素，注意用 set 设置的是 List 列表的原始值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加一个元素</li>
</ul>
<h4 id="3-6-3-使用示例"><a href="#3-6-3-使用示例" class="headerlink" title="3.6.3. 使用示例"></a>3.6.3. 使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Pet&gt; pets = Pets.arrayList(<span class="number">8</span>);</span><br><span class="line">    ListIterator&lt;Pet&gt; it = pets.listIterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        System.out.print(it.next() + <span class="string">&quot;, &quot;</span> + it.nextIndex() + <span class="string">&quot;, &quot;</span> + it.previousIndex() + <span class="string">&quot;; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backwards:</span></span><br><span class="line">    <span class="keyword">while</span> (it.hasPrevious()) &#123;</span><br><span class="line">        System.out.print(it.previous().id() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(pets);</span><br><span class="line">    it = pets.listIterator(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.set(Pets.randomPet());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(pets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; src = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">    List&lt;Integer&gt; dest = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(src);</span><br><span class="line">    System.out.println(<span class="string">&quot;source: &quot;</span> + src);</span><br><span class="line">    System.out.println(<span class="string">&quot;destination: &quot;</span> + dest);</span><br><span class="line">    ListIterator&lt;Integer&gt; fwd = dest.listIterator();</span><br><span class="line">    ListIterator&lt;Integer&gt; rev = dest.listIterator(dest.size()); <span class="comment">// 这里将rev指向了List的最后一个元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> dest.size() &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mid; i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">tmp</span> <span class="operator">=</span> fwd.next();</span><br><span class="line">        fwd.set(rev.previous());</span><br><span class="line">        rev.set(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;source: &quot;</span> + src);</span><br><span class="line">    System.out.println(<span class="string">&quot;destination: &quot;</span> + dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-4-Iterator-和-ListIterator-的区别-面试题"><a href="#3-6-4-Iterator-和-ListIterator-的区别-面试题" class="headerlink" title="3.6.4. Iterator 和 ListIterator 的区别(面试题)"></a>3.6.4. Iterator 和 ListIterator 的区别(面试题)</h4><p><code>ListIterator</code> 接口继承 <code>Iterator</code> 接口，可以说是 <code>Iterator</code> 的增强版。该接口添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置</p>
<ul>
<li><code>Iterator</code> 可以遍历所有类型的集合；而 <code>ListIterator</code> 只能遍历 <code>List</code> 及其子类。</li>
<li><code>Iterator</code> 只能单向（向后）遍历；而 <code>ListIterator</code> 可以进行双向遍历（向前/后遍历），通过 <code>previous()</code> 和 <code>hasPrevious()</code> 方法进行逆向的遍历。</li>
<li><code>Iterator</code> 不能往集合中添加元素；而 <code>ListIterator</code> 可以通过 <code>add()</code> 方法，可以向 <code>List</code> 集合添加对象。</li>
<li><code>Iterator</code> 无法定位当前的索引位置；而 <code>ListIterator</code> 可以通过 <code>nextIndex()</code> 和 <code>previousIndex()</code> 方法来获取前/后一个元素的索引。</li>
<li><code>Iterator</code> 仅能遍历，不能修改；而 <code>ListIterator</code> 可以通过 <code>set()</code> 方法实现对象的修改。</li>
</ul>
<h2 id="4-Set-接口"><a href="#4-Set-接口" class="headerlink" title="4. Set 接口"></a>4. Set 接口</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1. 概述"></a>4.1. 概述</h3><p>Set 是无序(存取顺序不一致)，无索引，元素不可重复的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>在 Set 集合中，对象元素的相等性比较是通过元素的 <code>equals</code> 与 <code>hashCode</code> 方法来判断。本质上是 Java 依据对象的内存地址计算出对象的 <code>HashCode</code> 值来判断。因此如果需要自定义比较两个对象是否相等，则必须同时重写对象的 <code>hashCode</code> 方法和 <code>equals</code> 方法。</p>
<h3 id="4-2-Set-接口的实现类"><a href="#4-2-Set-接口的实现类" class="headerlink" title="4.2. Set 接口的实现类"></a>4.2. Set 接口的实现类</h3><p>HashSet</p>
<ol>
<li>没有索引</li>
<li>不能重复</li>
<li>存储没有顺序</li>
</ol>
<p>LinkedHashSet(继承HashSet)</p>
<ol>
<li>没有索引</li>
<li>不能重复</li>
<li>存储和取出有顺序</li>
</ol>
<h3 id="4-3-哈希表-数组和链表的组合体"><a href="#4-3-哈希表-数组和链表的组合体" class="headerlink" title="4.3. 哈希表(数组和链表的组合体)"></a>4.3. 哈希表(数组和链表的组合体)</h3><h4 id="4-3-1-对象的哈希值"><a href="#4-3-1-对象的哈希值" class="headerlink" title="4.3.1. 对象的哈希值"></a>4.3.1. 对象的哈希值</h4><p>对象的哈希值，就是一个十进制整数。通过 <code>Object</code> 类的 <code>hashCode()</code> 的方法获得。是对象存储到 <code>HashSet</code> 的依据。子类可以重写该方法自己计算哈希值。</p>
<p>哈希表底层使用的也是数组机制，数组中也存放对象，而这些对象往数组中存放时的位置比较特殊，当需要把这些对象给数组中存放时，那么会根据这些对象的特有数据结合相应的算法，计算出这个对象在数组中的位置，然后把这个对象存放在数组中。而这样的数组就称为哈希数组，即就是哈希表。</p>
<p>当向哈希表中存放元素时，需要根据元素的特有数据结合相应的算法，这个算法其实就是 <code>Object</code> 类中的 <code>hashCode</code> 方法。由于任何对象都是 <code>Object</code> 类的子类，所以任何对象有拥有这个方法。即就是在给哈希表中存放对象时，会调用对象的 <code>hashCode</code> 方法，算出对象在表中的存放位置，这里需要注意，如果两个对象 <code>hashCode</code> 方法算出结果一样，这样现象称为哈希冲突，这时会调用对象的 <code>equals</code> 方法，比较这两个对象是不是同一个对象，如果 <code>equals</code> 方法返回的是 true，那么就不会把第二个对象存放在哈希表中，如果返回的是 false，就会把这个值存放在哈希表中。</p>
<font color=purple>**总结：保证 `HashSet` 集合元素的唯一，其实就是根据对象的 `hashCode` 和 `equals` 方法来决定的。如果往集合中存放自定义的对象，那么保证其唯一则必须重写 `hashCode` 和 `equals` 方法，建立属于当前对象的比较方式。**</font>

<h4 id="4-3-2-Object-的-hashCode-方法"><a href="#4-3-2-Object-的-hashCode-方法" class="headerlink" title="4.3.2. Object 的 hashCode 方法"></a>4.3.2. Object 的 hashCode 方法</h4><p>Object 类的 hashCode 方法，返回值是一个十进值整数，默认是对象的内存地址值（十六进制）。默认情况下内存地址不一样 hashCode 就不一样。</p>
<p>String 类重写了 hashCode，只要字符内容相同，等到的哈希值就相同。</p>
<p>自定义的类如果要放到 HashSet 中，也需要重写 hashCode</p>
<h4 id="4-3-3-哈希表结构的特点"><a href="#4-3-3-哈希表结构的特点" class="headerlink" title="4.3.3. 哈希表结构的特点"></a>4.3.3. 哈希表结构的特点</h4><p>只要看到类名上带有 Hash。说明它底层使用哈希表结构，HashSet 底层使用的是哈希表结构。</p>
<h4 id="4-3-4-哈希表的存储元素详细过程-HashSet-判断元素唯一的原理"><a href="#4-3-4-哈希表的存储元素详细过程-HashSet-判断元素唯一的原理" class="headerlink" title="4.3.4. 哈希表的存储元素详细过程(HashSet 判断元素唯一的原理)"></a>4.3.4. 哈希表的存储元素详细过程(HashSet 判断元素唯一的原理)</h4><ol>
<li>调用对象的 <code>hashCode()</code> 方法，获得要存储元素的哈希值。</li>
<li>将哈希值与表的长度(即数组的长度)进行求余运算得到一个整数值，该值就是新元素要存放的位置(即是索引值)。<ul>
<li>如果索引值对应的位置上没有存储任何元素，则直接将元素存储到该位置上。</li>
<li>如果索引值对应的位置上已经存储了元素，则执行第3步。</li>
</ul>
</li>
<li>遍历该位置上的所有旧元素，依次比较每个旧元素的哈希值和新元素的哈希值是否相同。<ul>
<li>如果有哈希值相同的旧元素，则执行第4步。</li>
<li>如果没有哈希值相同的旧元素，则执行第5步。</li>
</ul>
</li>
<li>比较新元素和旧元素的地址是否相同<ul>
<li>如果地址值相同则用新的元素替换老的元素。停止比较。</li>
<li>如果地址值不同，则新元素调用 equals 方法与旧元素比较内容是否相同。<ul>
<li>如果返回true，用新的元素替换老的元素，停止比较。</li>
<li>如果返回false，则回到第3步继续遍历下一个旧元素。</li>
</ul>
</li>
</ul>
</li>
<li>说明没有重复，则将新元素存放到该位置上并让新元素记住之前该位置的元素。</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251038724.jpg" alt=""></p>
<h4 id="4-3-5-hashCode-注意事项"><a href="#4-3-5-hashCode-注意事项" class="headerlink" title="4.3.5. hashCode 注意事项"></a>4.3.5. hashCode 注意事项</h4><p>假设有两个 <code>Person</code> 对象p1和p2，如果 <code>p1.equals(p2)</code> 为true。则 <code>p1.hashCode() == p2.hashCode()</code> 一定是 true 吗？ 答：一定。hashCode的官方协定：</p>
<ol>
<li>如果根据 <code>equals(Object)</code> 方法，两个对象是相等的。那么对这两个对象中的每个对象调用 <code>hashCode</code> 方法都必须生成相同的整数结果。</li>
<li>如果根据 <code>equals(java.lang.Object)</code> 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 <code>hashCode</code> 方法”不”要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</li>
</ol>
<h3 id="4-4-HashSet-集合"><a href="#4-4-HashSet-集合" class="headerlink" title="4.4. HashSet 集合"></a>4.4. HashSet 集合</h3><h4 id="4-4-1-概述"><a href="#4-4-1-概述" class="headerlink" title="4.4.1. 概述"></a>4.4.1. 概述</h4><p><code>HashSet</code> 集合的底层是哈希表结构，基于 <code>HashTable</code> 实现：查询快，增删快，线程不安全（效率高）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<p><strong>HashSet 特性和基本使用</strong></p>
<ul>
<li>HashSet 是 Set 接口的子类，不包含相同元素，且无序，没有索引</li>
<li>底层是哈希表：数组和链表的组合体。底层采用 HashMap 来保存元素，其元素值都存放在 HashMap 的 key 中，而 value 统一为 PRESENT</li>
<li>哈希表的特点：查询和增删都比较快。</li>
</ul>
<h4 id="4-4-2-HashSet-构造方法分析"><a href="#4-4-2-HashSet-构造方法分析" class="headerlink" title="4.4.2. HashSet 构造方法分析"></a>4.4.2. HashSet 构造方法分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如：<font color=red>加载因子是0.75</font>，数组的长度为16，其中存入<code>16 * 0.75 = 12</code>个元素。如果再存入第十三个(大于12)元素。那么此时会扩充哈希表(再哈希)，底层会开辟一个长度为原长度<font color=red>2倍</font>的数组。把老元素拷贝到新数组中，再把新元素添加数组中。当<code>存入元素数量 &gt; 哈希表长度 * 加载因子</code>，就要扩容，因此加载因子决定扩容时机。</p>
<h4 id="4-4-3-HashSet-保存元素的原理"><a href="#4-4-3-HashSet-保存元素的原理" class="headerlink" title="4.4.3. HashSet 保存元素的原理"></a>4.4.3. HashSet 保存元素的原理</h4><p><code>HashSet</code> 存放的是散列值，它是按照元素的散列值来存取元素的。<code>HashSet</code> 中的 <code>add</code> 方法的底层实现是调用 <code>HashMap</code> 的 <code>put</code> 方法，将元素的散列值（即 HashCode）作为 <code>HashMap</code> 的 key。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 HashMap 的 put 方法, PRESENT 是一个至始至终都相同的虚值</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>元素的散列值是通过元素的 <code>hashCode</code> 方法计算得到的，HashSet 首先判断两个元素的散列值是否相等，如果散列值相等，则接着通过 <code>equals</code> 方法返回的结果（true/false），来判断是否为同一个元素。</p>
<h4 id="4-4-4-HashSet-存储判断元素（自定义类型）重复的原理"><a href="#4-4-4-HashSet-存储判断元素（自定义类型）重复的原理" class="headerlink" title="4.4.4. HashSet 存储判断元素（自定义类型）重复的原理"></a>4.4.4. HashSet 存储判断元素（自定义类型）重复的原理</h4><h5 id="4-4-4-1-HashSet-的-add-contains-等方法判断元素是否重复原理"><a href="#4-4-4-1-HashSet-的-add-contains-等方法判断元素是否重复原理" class="headerlink" title="4.4.4.1. HashSet 的 add/contains 等方法判断元素是否重复原理"></a>4.4.4.1. HashSet 的 add/contains 等方法判断元素是否重复原理</h5><p>Set 集合不能存放重复元素，其添加方法在添加时会判断是否有重复元素，有重复不添加，没重复则添加。</p>
<p>HashSet 集合由于是无序的，其判断唯一的依据是元素类型的 <code>hashCode</code> 与 <code>equals</code> 方法的返回结果。规则如下：</p>
<ol>
<li>先判断新元素与集合内已经有的旧元素的 HashCode 值，如果不同，说明是不同元素，添加到集合</li>
<li>如果 HashCode 值相同，再判断 equals 比较结果。返回 true 则相同元素，不添加；返回 false 则不同元素，添加到集合。</li>
</ol>
<h5 id="4-4-4-2-使用-HashSet-存储自定义类型"><a href="#4-4-4-2-使用-HashSet-存储自定义类型" class="headerlink" title="4.4.4.2. 使用 HashSet 存储自定义类型"></a>4.4.4.2. 使用 HashSet 存储自定义类型</h5><p>当使用HashSet存储<font color=red>自定义类型</font>，如果没有重写该类的 hashCode 与 equals 方法，则判断重复时，使用的是地址值，如果想<font color=red><strong>通过内容比较元素是否相同，需要重写该元素类的 <code>hashcode</code> 与 <code>equals</code> 方法</strong></font></p>
<h3 id="4-5-LinkedHashSet-集合"><a href="#4-5-LinkedHashSet-集合" class="headerlink" title="4.5. LinkedHashSet 集合"></a>4.5. LinkedHashSet 集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<p>LinkedHashSet 继承自 HashSet，底层也是哈希表，由 LinkedHashMap 来实现存储元素，所有的方法和操作与 HashSet 一致，不包含重复元素，没有索引。唯一不同是可预测迭代顺序的 Set 集合。</p>
<p>LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作其实就是直接调用父类 HashSet 相应的方法。</p>
<h3 id="4-6-TreeSet-集合"><a href="#4-6-TreeSet-集合" class="headerlink" title="4.6. TreeSet 集合"></a>4.6. TreeSet 集合</h3><p>TreeSet 基于二叉树的原理对新添加的对象按照指定的顺序排序（升序、降序），每添加一个对象都会进行排序，并将对象插入二叉树指定的位置。</p>
<p>Integer 和 String 等基础对象类型可以直接根据 TreeSet 的默认排序进行存储，而对于自定义的数据类型，TreeSet 要求存放的对象必须实现 <code>Comparable</code> 接口，并重写该接口提供的  <code>compareTo()</code> 比较元素方法，当插入元素时会回调该方法比较元素的大小从而进行排序。若重写该函数，返回 -1（或负整数）则表示升序，即当前对象(this)小于指定对象；返回 1（或正整数）则表示降序，即当前对象(this)大于指定对象</p>
<h3 id="4-7-Set-接口相关实现类总结"><a href="#4-7-Set-接口相关实现类总结" class="headerlink" title="4.7. Set 接口相关实现类总结"></a>4.7. Set 接口相关实现类总结</h3><h4 id="4-7-1-HashSet、LinkedHashSet-和-TreeSet-的区别"><a href="#4-7-1-HashSet、LinkedHashSet-和-TreeSet-的区别" class="headerlink" title="4.7.1. HashSet、LinkedHashSet 和 TreeSet 的区别"></a>4.7.1. HashSet、LinkedHashSet 和 TreeSet 的区别</h4><ul>
<li><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 <code>null</code> 值；</li>
<li><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，能够按照添加的顺序遍历；</li>
<li><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式可以自定义</li>
</ul>
<h2 id="5-Queue-接口"><a href="#5-Queue-接口" class="headerlink" title="5. Queue 接口"></a>5. Queue 接口</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1. 概述"></a>5.1. 概述</h3><p>java 提供了一个专门用于队列结构的接口：<code>java.util.Queue</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; </span><br></pre></td></tr></table></figure>
<p>队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。</p>
<h3 id="5-2-常用方法"><a href="#5-2-常用方法" class="headerlink" title="5.2. 常用方法"></a>5.2. 常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将指定的元素插入此队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">poll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取并移除此队列的头，如果此队列为空，则返回 null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">peek</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取但不移除此队列的头；如果此队列为空，则返回 null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">remove</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取并移除此队列的头。此方法与 poll 唯一的不同在于：当队列为空时将抛出一个 <code>NoSuchElementException</code> 异常。 </li>
</ul>
<h3 id="5-3-ArrayDeque（了解）"><a href="#5-3-ArrayDeque（了解）" class="headerlink" title="5.3. ArrayDeque（了解）"></a>5.3. ArrayDeque（了解）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt;</span><br><span class="line">                           <span class="keyword">implements</span> <span class="title class_">Deque</span>&lt;E&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p><code>ArrayDeque</code> 实现了双端队列，内部使用循环数组实现，默认大小为16。它的特点是：</p>
<ol>
<li>在两端添加、删除元素的效率较高</li>
<li>根据元素内容查找和删除的效率比较低。</li>
<li>没有索引位置的概念，不能根据索引位置进行操作。</li>
</ol>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，如果只需要从两端进行操作，<code>ArrayDeque</code> 效率更高一些。如果同时需要根据索引位置进行操作，或者经常需要在中间进行插入和删除（<code>LinkedList</code> 有相应的 api，如 <code>add(int index, E e)</code>），则应该选 <code>LinkedList</code>。</p>
<p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都是线程不安全的，可以使用 <code>Collections</code> 工具类中 <code>synchronizedXxx()</code> 转换成线程同步。</p>
<h2 id="6-Map-接口（双列集合）"><a href="#6-Map-接口（双列集合）" class="headerlink" title="6. Map 接口（双列集合）"></a>6. Map 接口（双列集合）</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1. 概述"></a>6.1. 概述</h3><p>只要是 Map 接口的实现类，都属于双列集合。将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值</p>
<h4 id="6-1-1-Map（双列集合）继承体系图"><a href="#6-1-1-Map（双列集合）继承体系图" class="headerlink" title="6.1.1. Map（双列集合）继承体系图"></a>6.1.1. Map（双列集合）继承体系图</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251038725.jpg" alt="Java 集合框架图.drawio"></p>
<h4 id="6-1-2-Map-接口的特点-重点"><a href="#6-1-2-Map-接口的特点-重点" class="headerlink" title="6.1.2. Map 接口的特点(重点)"></a>6.1.2. Map 接口的特点(重点)</h4><ul>
<li>每个元素是由两部分组成，一部分称为键(key)，一部分称为值(Value);</li>
<li>键和值称为键值对；</li>
<li>键必须唯一，值可以重复。</li>
<li>Map 集合的数据结构仅仅针对键有效，与值无关。</li>
<li>基于键的 HashCode 值唯一标识一条数据，同时基于键的 HashCode 值进行数据的存取。</li>
</ul>
<h4 id="6-1-3-Map-集合的初始化"><a href="#6-1-3-Map-集合的初始化" class="headerlink" title="6.1.3. Map 集合的初始化"></a>6.1.3. Map 集合的初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>泛型<code>K</code>：此映射所维护的键的类型(key就是键)</li>
<li>泛型<code>V</code>：映射值的类型(values就是值)</li>
</ul>
<blockquote>
<p>Tips: k和v不需要同一种类型，但必须都是引用类型，如int会报错，需要定义为 Integer); Map 集合类似词典索引，通过key可以找到value</p>
</blockquote>
<p>创建对象时，要分别制定键的泛型与值的泛型。以初始化一个HashMap对象为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 最常用此写法</span></span><br><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// 但这种会报警告</span></span><br></pre></td></tr></table></figure>
<h4 id="6-1-4-Map-接口中的常用方法"><a href="#6-1-4-Map-接口中的常用方法" class="headerlink" title="6.1.4. Map 接口中的常用方法"></a>6.1.4. Map 接口中的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 map 中不存在该 key，就添加键值对元素，并返回null。相当于新增功能</li>
<li>如果 map 中存在该 key，就修改键值对元素，并返回旧的值。相当于修改功能</li>
</ul>
<blockquote>
<p>Notes: 在此映射中关联指定值与指定键。如果该映射以前包含了一个该键的映射关系，则旧值被替换。即如果 key 之前已经包含一个 value，再调用 <code>put(k,v)</code>方法，那么旧的value就被替换成新的value，并返回与 key 关联的旧值；如果 key 没有任何映射关系，则返回 null。（返回 null 还可能表示该映射之前将 null 与 key 关联。）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据指定的键获取到相应的值。如果键不存在，则返回 null</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>根据键删除这个元素，键和值都删除。并返回被删的键对应的值。如果键不存在，则没有效果并返回 null</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取键值对的数量(元素的个数)，返回此映射中的键-值映射关系数。(即目前集合中已经存了多少对键值对元素)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果此映射包含对于指定键的映射关系，则返回 true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果此映射将一个或多个键映射到指定值，则返回 true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果Map集合为空，则返回 true</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>清空Map集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取 Map 中所有的键，返回此映射中所包含的键的 Set 视图。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Map 获取所有的值，返回此映射所包含的值的 Collection 视图。</li>
</ul>
<h3 id="6-2-Entry-接口"><a href="#6-2-Entry-接口" class="headerlink" title="6.2. Entry 接口"></a>6.2. Entry 接口</h3><h4 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1. 概述"></a>6.2.1. 概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Entry&lt;K,V&gt;</code> 是 Map 的内部接口(嵌套接口，看做普通接口)，将一个键和值封装成了 Entry 对象，并存储在 Set 集合中。可以使用 <code>Map.Entry&lt;K,V&gt;</code> 来定义变量，从一个 Entry 对象中获取一个键值对的键与值。</p>
<blockquote>
<p>Tips: Entry 其中一个实现是 HashMap 的内部类。</p>
</blockquote>
<p>通过调用 Map 对象 <code>entrySet</code> 方法，返回某个集合所有的键值对对象(Entry)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 此方式导包 import java.util.Map.Entry;</span></span><br><span class="line">Set&lt;Entry&lt;K,V&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方式，不需要额外导包</span></span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = map.entrySet();</span><br></pre></td></tr></table></figure>
<h4 id="6-2-2-Entry-接口常用方法"><a href="#6-2-2-Entry-接口常用方法" class="headerlink" title="6.2.2. Entry 接口常用方法"></a>6.2.2. Entry 接口常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k <span class="title function_">getKey</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得 Entry 类对象的键</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">V <span class="title function_">getValue</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得 Entry 类对象的值</li>
</ul>
<h3 id="6-3-遍历-Map-集合的方式"><a href="#6-3-遍历-Map-集合的方式" class="headerlink" title="6.3. 遍历 Map 集合的方式"></a>6.3. 遍历 Map 集合的方式</h3><blockquote>
<p>Notes: <font color=red><strong>不能直接使用增强 for 或迭代器遍历，因为 Map 没有继承 <code>Iterable&lt;E&gt;</code> 接口</strong></font>。以下三种遍历方式，若 Map 本身的变化会影响其遍历的结果。</p>
</blockquote>
<h4 id="6-3-1-通过-keySet-方法遍历"><a href="#6-3-1-通过-keySet-方法遍历" class="headerlink" title="6.3.1. 通过 keySet 方法遍历"></a>6.3.1. 通过 keySet 方法遍历</h4><p>Map 没有迭代器方法，最常用的遍历方法：先获取所有键的集合，迭代该集合，依次获取每一个键，通过键找值。使用 <code>keySet()</code> 方法遍历流程：</p>
<ol>
<li>使用 <code>Set&lt;K&gt; keySet()</code> 方法，获取所有的键的 Set 集合。</li>
<li>使用增强 for 或者迭代器遍历键的 Set 集合。</li>
<li>通过 <code>V get(Object key)</code> 方法，获取每个键对应的值。</li>
</ol>
<h4 id="6-3-2-通过-entrySet-方法遍历"><a href="#6-3-2-通过-entrySet-方法遍历" class="headerlink" title="6.3.2. 通过 entrySet 方法遍历"></a>6.3.2. 通过 entrySet 方法遍历</h4><p>使用 <code>entrySet()</code> 方法获取某个集合所有的键值对对象，再进行遍历：</p>
<ol>
<li>通过 <code>entrySet()</code> 方法，获取所有的键值对对象的 Set 集合</li>
<li>使用增强 for 或者迭代器遍历获取到每一个键值对对象</li>
<li>通过键值对对象的 <code>getKey()</code> 拿到键</li>
<li>通过键值对对象的 <code>getValue()</code> 拿到值</li>
</ol>
<p>Code Demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EntrySetTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建HashMap对象</span></span><br><span class="line">		HashMap&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		hm.put(<span class="string">&quot;剑圣主宰&quot;</span>, <span class="string">&quot;敌法师&quot;</span>);</span><br><span class="line">		hm.put(<span class="string">&quot;风暴之灵&quot;</span>, <span class="string">&quot;灰烬之灵&quot;</span>);</span><br><span class="line">		hm.put(<span class="string">&quot;炼金术士&quot;</span>, <span class="string">&quot;剧毒术士&quot;</span>);</span><br><span class="line">		hm.put(<span class="string">&quot;齐天大圣&quot;</span>, <span class="string">&quot;矮人火枪手&quot;</span>);</span><br><span class="line">		hm.put(<span class="string">&quot;斧王&quot;</span>, <span class="string">&quot;幽鬼&quot;</span>);</span><br><span class="line">		<span class="comment">// 输出HashMap集合</span></span><br><span class="line">		System.out.println(hm);</span><br><span class="line">		System.out.println(<span class="string">&quot;==Collection&lt;V&gt; values()，直接获得HashMap集合的值==&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过Collection&lt;V&gt; values()，直接获得HashMap集合的值</span></span><br><span class="line">		Collection&lt;String&gt; coll = hm.values();</span><br><span class="line">		<span class="keyword">for</span> (String s : coll) &#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;=====第1种方法遍历获取HashMap集合的键值对=====&quot;</span>);</span><br><span class="line">		<span class="comment">// 第1种遍历Map集合值的方法：通过keySet()方法</span></span><br><span class="line">		Set&lt;String&gt; key = hm.keySet();</span><br><span class="line">		<span class="comment">// 输出所有key的Set集合</span></span><br><span class="line">		System.out.println(<span class="string">&quot;HashMap集合的键：&quot;</span> + key);</span><br><span class="line">		<span class="comment">// 使用增强for遍历set集合，通过key拿到value值</span></span><br><span class="line">		<span class="keyword">for</span> (String s : key) &#123;</span><br><span class="line">			System.out.println(s + <span class="string">&quot;==&quot;</span> + hm.get(s));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第2种遍历Map集合值的方法：通过entrySet()方法</span></span><br><span class="line">		<span class="comment">// 创建Entry类对象的Set集合</span></span><br><span class="line">		System.out.println(<span class="string">&quot;=====第2种方法遍历获取HashMap集合的键值对=====&quot;</span>);</span><br><span class="line">		Set&lt;Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line">		<span class="keyword">for</span> (Entry&lt;String, String&gt; e : entrySet) &#123;</span><br><span class="line">			System.out.println(e.getKey() + <span class="string">&quot;==&quot;</span> + e.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-3-通过-Values-方法遍历"><a href="#6-3-3-通过-Values-方法遍历" class="headerlink" title="6.3.3. 通过 Values 方法遍历"></a>6.3.3. 通过 Values 方法遍历</h4><p>通过 Map 对象的 <code>Values()</code> 方法获取所有值的 Collection 集合，再使用增加 for 循环遍历。</p>
<h3 id="6-4-HashMap"><a href="#6-4-HashMap" class="headerlink" title="6.4. HashMap"></a>6.4. HashMap</h3><h4 id="6-4-1-概述"><a href="#6-4-1-概述" class="headerlink" title="6.4.1. 概述"></a>6.4.1. 概述</h4><p>HashMap：基于哈希表的 Map 接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<p>HashMap 有如下特点：</p>
<ul>
<li>键是唯一，基于键的 HashCode 值唯一标识一条数据，同时基于键的 HashCode 值进行数据的存取。</li>
<li><font color=red><strong>存储和取出无法保证顺序一致</strong></font>。</li>
<li>非线程安全。同一时间有多个线程同时对 HashMap 进行写操作，将可能导致数据的不一致。<em>如需要满足线程安全的条件，可使用 <code>Collections</code> 的 <code>synchronizedMap</code> 方法使 HashMap 具有线程安全的能力，或者使用 <code>ConcurrentHashMap</code></em>。</li>
<li>允许使用 <code>null</code> 的值和 <code>null</code> 的键（<font color=purple><strong>HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null</strong></font>）</li>
</ul>
<blockquote>
<p>Tips: 更多实现原理详见<a href="/Java/Java扩展-集合类源码分析">《Java扩展-集合类源码分析》笔记</a></p>
</blockquote>
<h5 id="6-4-1-1-存储结构"><a href="#6-4-1-1-存储结构" class="headerlink" title="6.4.1.1. 存储结构"></a>6.4.1.1. 存储结构</h5><p>HashMap 在 JDK 1.7 以前的数据存储结构是『数组+链表』。</p>
<p>为了减少链表遍历的开销，JDK 1.8 开始对 HashMap 进行了优化，增加了红黑树部分，将数据存储结构修改为『数组+链表+红黑树』。当链表长度大于8（<code>TREEIFY_THRESHOLD</code>）时，会把链表转换为红黑树，红黑树节点个数小于6（<code>UNTREEIFY_THRESHOLD</code>）时才转化为链表，防止频繁的转化。</p>
<p>HashMap 将链表结构转换为红黑树结构后，提高了查询效率，因此其时间复杂度为 <code>O(log N)</code>。</p>
<h5 id="6-4-1-2-类的主要参数"><a href="#6-4-1-2-类的主要参数" class="headerlink" title="6.4.1.2. 类的主要参数"></a>6.4.1.2. 类的主要参数</h5><ul>
<li>capacity：当前数组的容量，默认为 16，可以扩容，扩容后数组的大小为当前的两倍，因此该值始终为2<sup>n</sup>。</li>
<li>loadFactor：负载因子，默认为 0.75。</li>
<li>threshold：扩容的阈值，其值等于 <code>capacity × loadFactor</code>。</li>
</ul>
<h4 id="6-4-2-一般用什么类型作为-HashMap-的-key"><a href="#6-4-2-一般用什么类型作为-HashMap-的-key" class="headerlink" title="6.4.2. 一般用什么类型作为 HashMap 的 key"></a>6.4.2. 一般用什么类型作为 HashMap 的 key</h4><p>一般用 <code>Integer</code>、<code>String</code> 这些不可变类当 HashMap 当 key。</p>
<p>因为 String 是不可变的，所以在它创建的时候<code>hashcode</code>就被缓存了，不需要重新计算。这就是 HashMap 中的 key 经常使用字符串的原因。获取对象的时候要用到 <code>equals()</code> 和 <code>hashCode()</code> 方法，而 Integer、String 都已经重写了此两个方法，不需要程序员去重写。</p>
<h4 id="6-4-3-HashMap-线程不安全的情况"><a href="#6-4-3-HashMap-线程不安全的情况" class="headerlink" title="6.4.3. HashMap 线程不安全的情况"></a>6.4.3. HashMap 线程不安全的情况</h4><ul>
<li>JDK 7 时多线程下扩容会造成死循环。</li>
<li>多线程的 put 方法可能导致元素的丢失。</li>
<li>put 和 get 在并发时，可能导致 get 的值为 null。原因是 hashcode 可能发生改变，导致 put 进去的值，无法 get 获取。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">objectValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">changeMap.put(list, objectValue);</span><br><span class="line">System.out.println(changeMap.get(list)); <span class="comment">// 输出结果：java.lang.Object@74a14482</span></span><br><span class="line">list.add(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// hashcode发生了改变</span></span><br><span class="line">System.out.println(changeMap.get(list)); <span class="comment">// 输出结果：null</span></span><br></pre></td></tr></table></figure>
<h3 id="6-5-LinkedHashMap"><a href="#6-5-LinkedHashMap" class="headerlink" title="6.5. LinkedHashMap"></a>6.5. LinkedHashMap</h3><p><code>LinkedHashMap</code> 继承 <code>HashMap</code>，是 <code>Map</code> 接口的实现类，并允许使用 null 值和 null 键，<font color=red><strong>键是唯一，存储和取出有顺序</strong></font>。</p>
<p><code>LinkedHashMap</code> 是基于哈希表(HashTable)的数据结构，该结构保证 key 唯一；使用链表(Linked)结构保存元素，从而保证元素有序性，怎么存就怎么取。<em>注：这些约束都是针对键起作用</em></p>
<blockquote>
<p>Tips: 其他与 HashMap 的功能与用法一样。</p>
</blockquote>
<h3 id="6-6-TreeMap"><a href="#6-6-TreeMap" class="headerlink" title="6.6. TreeMap"></a>6.6. TreeMap</h3><h4 id="6-6-1-概述"><a href="#6-6-1-概述" class="headerlink" title="6.6.1. 概述"></a>6.6.1. 概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<p>TreeMap 是基于二叉树数据结构存储数据。从功能上讲，有比 HashMap 更为强大的功能，它实现了 <code>SortedMap</code> 接口，即可以对元素进行排序，默认按键值的升序排序，也可以自定义排序比较器。</p>
<p>TreeMap 要求存放的键值对所映射的键对象必须实现 <code>Comparable</code> 接口，重写 <code>compareTo</code> 方法，从而根据键对元素进行排序。否则会抛出 <code>java.lang.ClassCastException</code> 异常。</p>
<p>TreeMap 的性能略微低于 HashMap。如果在开发中需要对元素进行<font color=red>排序</font>，那么使用 HashMap 便无法实现这种功能，使用 TreeMap 的迭代输出将会以元素顺序进行。</p>
<h4 id="6-6-2-继承结构"><a href="#6-6-2-继承结构" class="headerlink" title="6.6.2. 继承结构"></a>6.6.2. 继承结构</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251038726.png" alt=""></p>
<h4 id="6-6-3-特点"><a href="#6-6-3-特点" class="headerlink" title="6.6.3. 特点"></a>6.6.3. 特点</h4><ul>
<li><code>TreeMap</code> 是有序的 key-value 集合，通过红黑树实现。根据键的自然顺序进行排序或根据提供的 <code>Comparator</code> 进行排序。</li>
<li><code>TreeMap</code> 继承了 <code>AbstractMap</code>，实现了 <code>NavigableMap</code> 接口，支持一系列的导航方法，给定具体搜索目标，可以返回最接近的匹配项。如 <code>floorEntry()</code>、<code>ceilingEntry()</code> 分别返回小于等于、大于等于给定键关联的 <code>Map.Entry()</code> 对象，不存在则返回 null。<code>lowerKey()</code>、<code>floorKey</code>、<code>ceilingKey</code>、<code>higherKey()</code> 只返回关联的 key。</li>
</ul>
<h3 id="6-7-Hashtable"><a href="#6-7-Hashtable" class="headerlink" title="6.7. Hashtable"></a>6.7. Hashtable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<p><code>HashTable</code> 是旧版本的遗留类，很多映射的常用功能都与 <code>HashMap</code> 类似，不同的是它继承自 <code>Dictionary</code> 类，并且是线程安全的，同一时刻只允许一个线程对 <code>HashTable</code> 进行写操作，并发性不如 <code>ConcurrentHashMap</code>。</p>
<blockquote>
<p>Tips: <code>Hashtable</code> 不建议使用，不需要线程安全的场景可以用 HashMap 替换，需要线程安全的场景可以用 ConcurrentHashMap 替换。</p>
</blockquote>
<h3 id="6-8-ConcurrentHashMap（网络资料，未整理）"><a href="#6-8-ConcurrentHashMap（网络资料，未整理）" class="headerlink" title="6.8. ConcurrentHashMap（网络资料，未整理）"></a>6.8. ConcurrentHashMap（网络资料，未整理）</h3><h4 id="6-8-1-常用-API（整理中）"><a href="#6-8-1-常用-API（整理中）" class="headerlink" title="6.8.1. 常用 API（整理中）"></a>6.8.1. 常用 API（整理中）</h4><blockquote>
<p>TODO: 整理中</p>
</blockquote>
<h4 id="6-8-2-ConcurrentHashMap-实现原理"><a href="#6-8-2-ConcurrentHashMap-实现原理" class="headerlink" title="6.8.2. ConcurrentHashMap 实现原理"></a>6.8.2. ConcurrentHashMap 实现原理</h4><blockquote>
<p>Notes: 本章节内容详见<a href="/并发编程/并发编程-原理篇">《并发编程 - 原理篇》笔记</a>中的『ConcurrentHashMap 原理』章节</p>
</blockquote>
<h3 id="6-9-Map-接口相关实现类总结"><a href="#6-9-Map-接口相关实现类总结" class="headerlink" title="6.9. Map 接口相关实现类总结"></a>6.9. Map 接口相关实现类总结</h3><h4 id="6-9-1-Hashtable-和-HashMap-的区别-面试题"><a href="#6-9-1-Hashtable-和-HashMap-的区别-面试题" class="headerlink" title="6.9.1. Hashtable 和 HashMap 的区别(面试题)"></a>6.9.1. Hashtable 和 HashMap 的区别(面试题)</h4><p>Hashtable 与 HashMap 都是 Map 接口的实现类。</p>
<ul>
<li><strong>是否支持 null 为作为 key</strong>：HashMap 可以接受为 null 的 key 和 value，key 为 null 的键值对放在下标为 0 的头结点的链表中，并且只允许存在一个；而 Hashtable 则不能。</li>
<li><strong>线程安全</strong>：HashMap 是非线程安全的；HashTable 是线程安全的。Jdk 1.5 提供了 ConcurrentHashMap，它是 HashTable 的替代。</li>
<li><strong>执行效率</strong>：Hashtable 很多方法是同步方法，在单线程环境下它效率低，比 HashMap 要低。</li>
<li><strong>哈希值</strong>：HashTable 直接使用对象的 hashCode；而 HashMap 重新计算 hash 值。</li>
<li><strong>fail-fast 机制</strong>：<code>HashMap</code> 获取的 keySet 是使用 Iterator 遍历，支持 fail-fast 机制；而 HashTable 的 keySet 是使用 Enumeration 遍历，不支持 fail-fast 机制。</li>
</ul>
<h4 id="6-9-2-SynchronizedMap-和-ConcurrentHashMap-有什么区别"><a href="#6-9-2-SynchronizedMap-和-ConcurrentHashMap-有什么区别" class="headerlink" title="6.9.2. SynchronizedMap 和 ConcurrentHashMap 有什么区别"></a>6.9.2. SynchronizedMap 和 ConcurrentHashMap 有什么区别</h4><p><code>SynchronizedMap</code> 是 <code>Collections</code> 集合工具类的内部类，一次锁住整张表来保证线程安全，所以每次只能有一个线程来访问 map。</p>
<p>JDK1.8 <code>ConcurrentHashMap</code> 采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构采用数组+链表/红黑二叉树。<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，支持并发访问、修改。另外 <code>ConcurrentHashMap</code> 使用了一种不同的迭代方式。当 <code>iterator</code> 被创建后集合再发生改变就不再是抛出 <code>ConcurrentModificationException</code>，取而代之的是在改变时 new 新的数据从而不影响原有的数据，<code>iterator</code> 完成后再将头指针替换为新的数据，这样 <code>iterator</code> 线程可以使用原来老的数据，而写线程也可以并发的完成改变。</p>
<h4 id="6-9-3-TreeMap-与-LinkedHashMap-的区别"><a href="#6-9-3-TreeMap-与-LinkedHashMap-的区别" class="headerlink" title="6.9.3. TreeMap 与 LinkedHashMap 的区别"></a>6.9.3. TreeMap 与 LinkedHashMap 的区别</h4><ul>
<li>LinkedHashMap 是基于元素进入集合的顺序或者被访问的先后顺序排序。</li>
<li>TreeMap 则是基于元素的 key 固有顺序(由 Comparator 或者 Comparable 确定)进行排序。</li>
</ul>
<h2 id="7-自定义比较器：Comparator-与-Comparable"><a href="#7-自定义比较器：Comparator-与-Comparable" class="headerlink" title="7. 自定义比较器：Comparator 与 Comparable"></a>7. 自定义比较器：Comparator 与 Comparable</h2><h3 id="7-1-Comparator-接口"><a href="#7-1-Comparator-接口" class="headerlink" title="7.1. Comparator 接口"></a>7.1. Comparator 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="comment">// ...省略其他的 default 与 static 方法   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.util.Comparator</code>，是 JDK 提供的比较器接口，强行对某个对象 collection 进行整体排序的比较函数。它是函数式接口，可以使用 lambda 表达式来实现 <code>compare(T o1, T o2)</code> 方法。</p>
<p>其中 <code>int compare(T o1, T o2);</code> 方法是比较用来排序的两个参数。根据第一个参数小于、等于或大于第二个参数分别返回负整数、零或正整数。返回值代表的含义如下：</p>
<ul>
<li><strong>返回零</strong>：表示两个元素相同</li>
<li><strong>返回负数</strong>：左边小于右边</li>
<li><strong>返回正数</strong>：左边大于右边</li>
</ul>
<blockquote>
<p>Notes: <font color=red><strong>如果用两个不是整数类型的相减做为判断，需要强转。字符串可以用自带的方法 <code>compareTo</code> 进行比较</strong></font></p>
</blockquote>
<h3 id="7-2-Comparable-接口"><a href="#7-2-Comparable-接口" class="headerlink" title="7.2. Comparable 接口"></a>7.2. Comparable 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.lang.Comparable</code> 接口是用于对象的自然排序。其中 <code>compareTo</code> 关键方法就是实现排序的规则，方法返回 int 类型数值。例如：<code>i = x.compareTo(y);</code></p>
<ul>
<li>如果返回数值为 0，也表明两个对象排序上是相等的(<font color=red><strong>并非意味 <code>equals</code> 方法为 true，但是jdk api上强烈建议这样处理</strong></font>)</li>
<li>如果返回数值大于0，则表示 x &gt; y</li>
<li>如果返回数值小于0，则表示 x &lt; y</li>
</ul>
<h3 id="7-3-Comparator-与-Comparable-的区别"><a href="#7-3-Comparator-与-Comparable-的区别" class="headerlink" title="7.3. Comparator 与 Comparable 的区别"></a>7.3. Comparator 与 Comparable 的区别</h3><p>Comparator 和 Comparable 接口都是用于对象集合或者数组排序，两者主要的区别是：</p>
<ul>
<li>Comparator 接口是用于提供<strong>不同的排序算法</strong>，可以选择需要使用的该接口来对给定的对象集合进行排序。</li>
<li>Comparable 接口是用于提供对象的<strong>自然排序</strong>，可以使用它来提供基于单个逻辑的排序。</li>
</ul>
<h3 id="7-4-Collections-工具类的-sort-方法"><a href="#7-4-Collections-工具类的-sort-方法" class="headerlink" title="7.4. Collections 工具类的 sort 方法"></a>7.4. Collections 工具类的 sort 方法</h3><h4 id="7-4-1-简介"><a href="#7-4-1-简介" class="headerlink" title="7.4.1. 简介"></a>7.4.1. 简介</h4><p><code>Collections</code> 工具类中的 <code>sort</code> 方法就是使用了 <code>Comparator</code> 接口来对集合中的元素进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">    list.sort(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法作用：根据指定比较器现实的顺序，对指定列表进行排序。使用此工具类的排序方法，通过自定义比较器接口 <code>Comparator</code> 可以对 List 类集合排序，一般通过匿名内部类使用。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//...设置集合一些测试数据后</span></span><br><span class="line"><span class="comment">// Comparator接口排序，使用匿名内部类</span></span><br><span class="line">Collections.sort(array, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="comment">// 重写compare方法，可以根据学生类的某个属性去比较</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getScore() - o2.getScore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator接口排序，使用 lambda 表达式</span></span><br><span class="line">Collections.sort(array, Comparator.comparingInt(Student::getScore));</span><br></pre></td></tr></table></figure>
<h4 id="7-4-2-基础示例"><a href="#7-4-2-基础示例" class="headerlink" title="7.4.2. 基础示例"></a>7.4.2. 基础示例</h4><p>对基本数据类型的集合进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonZero</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(array, <span class="number">15</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">44</span>, <span class="number">4</span>, <span class="number">145</span>, <span class="number">54</span>, <span class="number">83</span>, <span class="number">41</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">13</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + array);</span><br><span class="line">        <span class="comment">// Comparator接口排序,使用匿名内部类</span></span><br><span class="line">        Collections.sort(array, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="comment">// 重写 compare 方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + array);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象集合进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonZero</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		ArrayList&lt;Student&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        array.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;004&quot;</span>, <span class="string">&quot;矮人火枪手&quot;</span>, <span class="number">20</span>, <span class="number">99</span>));</span><br><span class="line">        array.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;003&quot;</span>, <span class="string">&quot;敌法师&quot;</span>, <span class="number">21</span>, <span class="number">88</span>));</span><br><span class="line">        array.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;005&quot;</span>, <span class="string">&quot;剑圣主宰&quot;</span>, <span class="number">20</span>, <span class="number">80</span>));</span><br><span class="line">        array.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;001&quot;</span>, <span class="string">&quot;斧王&quot;</span>, <span class="number">22</span>, <span class="number">70</span>));</span><br><span class="line">        array.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;002&quot;</span>, <span class="string">&quot;幽鬼&quot;</span>, <span class="number">22</span>, <span class="number">30</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + array);</span><br><span class="line">        <span class="comment">// Comparator接口排序,使用匿名内部类</span></span><br><span class="line">        Collections.sort(array, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="comment">// 重写compare方法，可以根据学生类的某个属性去比较</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 按String类型的学号排序 字符串可以用自带的方法compareTo进行比较</span></span><br><span class="line">                <span class="comment">// return o1.getId().compareTo(o2.getId());</span></span><br><span class="line">                <span class="comment">// 按Double类型的成绩排序 因为返回值必须为整数，所以要做一个强转</span></span><br><span class="line">                <span class="keyword">return</span> (<span class="type">int</span>) (o1.getScore() - o2.getScore());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + array);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-集合相关的工具类-API"><a href="#8-集合相关的工具类-API" class="headerlink" title="8. 集合相关的工具类 API"></a>8. 集合相关的工具类 API</h2><h3 id="8-1-Collections-工具类"><a href="#8-1-Collections-工具类" class="headerlink" title="8.1. Collections 工具类"></a>8.1. Collections 工具类</h3><p>Collection 集合的工具类，提供了大量的方法操作单列集合。里面都是静态方法。直接用<code>类名.静态方法</code>使用</p>
<p><strong>注：Collections是工具类，Collection是接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... elements)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将数组中的所有元素添加到指定的集合中。例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Collections.addAll(array, <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;?&gt; list,T key)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此方法使用二分查找法(折半查找)查找指定元素</li>
<li>要求：二分法查询必须要求集合中的元素排好顺序(从小到大排序)</li>
<li>在集合List中查找指定的元素key,如果找到返回key在集合中的索引值(位置)</li>
<li>如果没找到，则返回= -插入点-1（插入点=-(返回值+1)）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对集合中的元素进行乱序操作（传入是List，只针对有顺序的集合）。使用默认随机源对指定列表进行置换。所有置换发生的可能性都是大致相等的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对集合元素进行排序，默认是升序排序。</li>
<li>有顺序(有序)：第一个元素是多少，第二个元素是多少，第几个元素对应的是第几，顺序不变。</li>
<li>排序：不管是第几个放的，只要到集合中(以 Integer 集合为例)，就按照一定的顺序重新排列了。</li>
<li>根据元素的自然顺序 对指定列表按升序进行排序。列表中的所有元素都必须实现 Comparable 接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对集合元素进行排序，集合的元素不需要实现 <code>Comparable</code> 接口，通过第二个参数 <code>Comparator</code> 来定义排序的逻辑。<em>可以使用 lambda 表达式来定义 <code>Comparator</code> 接口实现，更多介绍详细前面章节。</em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将集合中索引i和索引j位置交换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List&lt;?&gt; list)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>反转指定列表中元素的顺序。</li>
</ul>
<h4 id="8-1-1-创建不能修改的集合"><a href="#8-1-1-创建不能修改的集合" class="headerlink" title="8.1.1. 创建不能修改的集合"></a>8.1.1. 创建不能修改的集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span></span><br></pre></td></tr></table></figure>
<p>创建一个只读集合，改变该集合的任何操作都会抛出 <code>java.lang.UnsupportedOperationException</code> 异常。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;x&quot;</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections.unmodifiableCollection(list);</span><br><span class="line">clist.add(<span class="string">&quot;y&quot;</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System.out.println(list.size());</span><br></pre></td></tr></table></figure>
<h4 id="8-1-2-创建线程安全的-List、Set、Map-集合"><a href="#8-1-2-创建线程安全的-List、Set、Map-集合" class="headerlink" title="8.1.2. 创建线程安全的 List、Set、Map 集合"></a>8.1.2. 创建线程安全的 List、Set、Map 集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span><br></pre></td></tr></table></figure>
<p>将指定的集合转化成支持的同步（线程安全的）集合。</p>
<p>参数说明：</p>
<ul>
<li><code>list</code>：被”包装”在同步列表中的列表。 </li>
</ul>
<p>示例：</p>
<p>```</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io">蓝桉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io/posts/ad153bf9.html">https://ktzxy.github.io/posts/ad153bf9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ktzxy.github.io" target="_blank">蓝桉`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/bg/Image00012.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src="/img/wechat.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src="/img/alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/61ace049.html" title="Java扩展-代码简洁之道"><img class="cover" src="/bg/Image00029.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java扩展-代码简洁之道</div></div><div class="info-2"><div class="info-item-1"> 本笔记收集与总结一些 Java 程序编写的最佳实践  1. 代码最佳样板1.1. 定义工具类常见的工具类定义如下： 12345678910/** 工具类示例 */public class CodeSample &#123;    /** 常量值 */    public final static int CONST_VALUE = 123;    /** 静态工具方法 */    public static int sum(int a, int b) &#123;        return a + b;    &#125;&#125; 以上工具类定义存在的问题：  修饰符顺序不规范。Java 语言规范建议使用“static final”，而不是“final static”。记住这么一条规则：静态常量，静态（static）在前，常量（final）在后。 工具类可以被继承覆盖。如果定义一个类继承 CodeSample，就可以对其工具类中的常量和方法进行覆盖，导致不能确定是否使用了原工具类中的常量和方法。例如：对于 Apache 提供的工具类，很多程序员都喜欢定义相同名称的工具类，...</div></div></div></a><a class="pagination-related" href="/posts/9a327bc4.html" title="Java基础-语法"><img class="cover" src="/bg/Image00018.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java基础-语法</div></div><div class="info-2"><div class="info-item-1">1. Java 概述一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。一个基础的程序涉及如下的概念：  对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。  1.1. Java 程序12345678public class HelloWorld &#123;    /* 第一个Java程序     * 它将输出字符串 Hello World     */    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;); // 输出 Hello World    &#125;&#125;   Notes: main 是特殊的方法名...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/4e9c3100.html" title="Java基础-网络编程"><img class="cover" src="/bg/Image00026.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Java基础-网络编程</div></div><div class="info-2"><div class="info-item-1">1. 网络编程概述在计算机领域中，网络是信息传输、接收、共享的虚拟平台，将各个点、面、体的信息联系到一起，从而实现这些资源的共享。网络编程的作用：解决计算机与计算机数据传输的问题。 网络体系大致分为三种：OSI七层模型、TCP/IP四层模型和五层模型。  Tips: 一般面试的时候考察比较多的是五层模型。  1.1. 网络通讯三要素1.1.1. IP地址IP 是每台电脑在互联网上的唯一标识符。一个 IPV4 的地址是由四段 0—255 的数字组成：192.168.0.100，每一段的取值范围由8位二进制数据组成。 IPv6 使用 16 个字节表示 IP 地址，它所拥有的地址容量约是 IPv4 的 8×1028倍，达到 2128个。  Notes:   127.0.0.1 为本地主机地址(本地回环地址)，与 localhost 类似，均代表本机地址 xxx.xxx.xxx.255 广播地址，即该网段下所有用户均可以被通知到   例如在 windows 系统中，可以通过以下命令来获取 ip 与网络相关内容： 1ipconfig  用于DOS获取计算机IP设置  1ping ip地址 ...</div></div></div></a><a class="pagination-related" href="/posts/2af7de89.html" title="Day-0-IDEA简单学习"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-0-IDEA简单学习</div></div><div class="info-2"><div class="info-item-1">﻿# Day-0-IDEA简单学习 1.设置主题 2.编辑区的字体变大或者变小：（ctrl+鼠标滚轮） 3.鼠标悬浮在代码上有提示： 4.自动导包和优化多余的包：手动导包：快捷键：alt+enter自动导包和优化多余的包：  5.显示行号 ，  方法和方法间的分隔符： 6.忽略大小写，进行提示： 7.修改代码中注释的字体颜色： 8.修改类头的文档注释信息：注意：对新建的类才有效/**  @Auther: XXX @Date: ${DATE} - ${MONTH} - ${DAY} - ${TIME}  @Description: ${PACKAGE_NAME} @version: 1.0*/   8.自动编译： 9.常用快捷键【1】创建内容：alt+insert 【2】main方法：psvm 【3】输出语句：sout 【4】复制行：ctrl+d 【5】删除行：ctrl+y 【6】代码向上/下移动：Ctrl + Shift + Up / Down 【7】搜索类：  ctrl+n 【8】生成代码  ：alt + Insert（如构造函数等，getter,setter,hashCode...</div></div></div></a><a class="pagination-related" href="/posts/72ba03f7.html" title="Day-02-java基础语法"><img class="cover" src="/bg/Image00027.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-02-java基础语法</div></div><div class="info-2"><div class="info-item-1">﻿ Day-02-java基础语法快捷键操作 psvm —&gt;快速生成public static void main(String[] args) {} sout —&gt;快速生成System.out.println();  可能会遇到的问题  每个单词的大小不能出现问题，==Java是大小写敏感的==； 尽量使用英文； 文件名和类名必须保证一致，并且首字母大写； 符号使用的了中文。   Java运行机制  编译型 解释型    注释：Java中的注释有三种： 12345678910注释：    单行注释：    //我是单行注释    多行注释      /*我是多行注释*/    文档注释    /**    *@description  HelloWrold    *@Author 作者    */ 标识符：关键字 Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 标识符注意点 所有的标识符都应该以字母(A-Z或者a-z),美元符（$)、数字或者下划线(_)开始首字符之后可以是字母（A-Z或者a-z),美元符（$)、下划线(_)或数字的任何字符...</div></div></div></a><a class="pagination-related" href="/posts/369b2118.html" title="Day-03-java流程控制"><img class="cover" src="/bg/Image00020.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-03-java流程控制</div></div><div class="info-2"><div class="info-item-1">﻿ Day-03-java流程控制Scanner对象java.util.Scanner是Java5的新特性，我们可以通过Scanner类来获取用户的输入。 基本语法 1Scanner s = new Scanner(System.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext() 与hasNextLine()判断是否还有输入的数据。 12345678910111213public static void main(String[] args) &#123;    //创建一个扫描对象，用于接受键盘数据    Scanner scanner = new Scanner(System.in);    System.out.println(&quot;使用next方式接受：&quot;);    //判断用户有没有输入字符串    if (scanner.hasNext())&#123;        //使用next方式接受        String str = scanner.next();     ...</div></div></div></a><a class="pagination-related" href="/posts/bbaa91bf.html" title="Day-04-java方法详解"><img class="cover" src="/bg/Image00021.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-04-java方法详解</div></div><div class="info-2"><div class="info-item-1">﻿ Day-04-java方法详解何谓方法？​    System.out.println(),那么它是什么呢? ​    调用系统类里的标准输出对象out中的方法println ​    Java方法是语句的集合，它们在一起执行一个功能。 ​    方法是解决一类问题的步骤的有序组合 ​    方法包含于类或对象中，方法和方法是并列的关系，所以我们定义的方法不能写到main方法中 ​    方法在程序中被创建，在其他地方被引用 ​    设计方法的原则:方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。 方法的定义Java的方法类似争其它语言的函数,是一段用来完成特定功能的代码片段，一股情况卜，定义一个方法包含以下语法: 方法包含一个方法头和一个方法体。 下面是一个方法的所有部分: 修饰符:修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。 返回值类型∶方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。...</div></div></div></a><a class="pagination-related" href="/posts/cccc6599.html" title="Day-06-java面向对象"><img class="cover" src="/bg/Image00022.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Day-06-java面向对象</div></div><div class="info-2"><div class="info-item-1">﻿ Day-06-java面向对象什么是面向对象面向对象编程(Object-Oriented Programming, OOP) 面向对象编程的本质就是:==以类的方式组织代码，以对象的组织(封装)数据。== 抽象 三大特性: ​        封装 ​        继承 ​        多态从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象 从代码运行角度考虑是先有类后有对象。类是对象的模板。 回顾方法及加深方法的定义 修饰符 返回类型 ==break: 跳出switch，结束循环和return的区别方法名== 参数列表 异常抛出 方法的调用        静态方法 ​        非静态方法 ​        形参和实参 ​        值传递和引用传递 ​        this关键字 12345678910111213141516171819202122232425//demo1  类public class demo1 &#123;    //main方法    public static void main(String[] a...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">蓝桉</div><div class="author-info-description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">生活、学习、技术</b>相关的问题和看法，还有<b style="color:#fff">文章教程</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ktzxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/ktzxy" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2251511764@qq.com" target="_blank" title="Email"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-RSS"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/496148176" target="_blank" title="BiliBili"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QX-BILIBILI"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2251511764&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Collection-%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">1. Collection 接口（单列集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Collection-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. Collection 继承体系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Collection-%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. Collection 集合接口的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1. 添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2. 删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E8%8E%B7%E5%8F%96%E9%9B%86%E5%90%88%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3. 获取集合信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-%E6%B8%85%E7%A9%BA%E9%9B%86%E5%90%88"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4. 清空集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.5.</span> <span class="toc-text">1.3.5. 判断功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.6.</span> <span class="toc-text">1.3.6. 类型转换功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. 综合示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-List-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.</span> <span class="toc-text">2. List 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 接口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-List-%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. List 集合存储数据的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 接口常用的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 增加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3. 替换元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4. 获取元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-ArrayList"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. 简介</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-LinkedList"><span class="toc-number">2.5.</span> <span class="toc-text">2.5. LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.5.2.</span> <span class="toc-text">3.1.1. 迭代器的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E4%B8%8E-Enumeration-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.3.</span> <span class="toc-text">3.1.2. 与 Enumeration 接口的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Iterator-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">3.2. Iterator 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8-%E9%87%8D%E7%82%B9"><span class="toc-number">2.7.</span> <span class="toc-text">3.3. 迭代器的基础使用(重点)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E9%9B%86%E5%90%88%E7%9A%84%E8%8E%B7%E5%8F%96%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.1.</span> <span class="toc-text">3.3.1. 集合的获取迭代器方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E8%BF%AD%E4%BB%A3"><span class="toc-number">2.7.2.</span> <span class="toc-text">3.3.2. 集合元素的迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.7.3.</span> <span class="toc-text">3.3.3. 使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.8.</span> <span class="toc-text">3.4. 迭代器使用注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8"><span class="toc-number">2.8.1.</span> <span class="toc-text">3.4.1. 并发修改异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E8%8E%B7%E5%8F%96%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%90%8E%E9%81%8D%E5%8E%86%E5%89%8D%E4%B8%8D%E8%83%BD%E5%AF%B9%E5%8E%9F%E9%9B%86%E5%90%88%E8%BF%9B%E8%A1%8C%E7%BB%93%E6%9E%84%E4%B8%8A%E4%BF%AE%E6%94%B9"><span class="toc-number">2.8.2.</span> <span class="toc-text">3.4.2. 获取迭代器后遍历前不能对原集合进行结构上修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E5%BE%AA%E7%8E%AF%E6%97%B6%E7%A7%BB%E9%99%A4%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">2.8.3.</span> <span class="toc-text">3.4.3. 循环时移除集合中的元素正确方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%A2%9E%E5%BC%BA-for-foreach"><span class="toc-number">2.9.</span> <span class="toc-text">3.5. 增强 for (foreach)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E5%A2%9E%E5%BC%BA-for-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.9.1.</span> <span class="toc-text">3.5.1. 增强 for 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E5%A2%9E%E5%BC%BA-for-%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.9.2.</span> <span class="toc-text">3.5.2. 增强 for 语法格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.9.3.</span> <span class="toc-text">3.5.3. 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-ListIterator"><span class="toc-number">2.10.</span> <span class="toc-text">3.6. ListIterator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.10.1.</span> <span class="toc-text">3.6.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.10.2.</span> <span class="toc-text">3.6.2. 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.10.3.</span> <span class="toc-text">3.6.3. 使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-4-Iterator-%E5%92%8C-ListIterator-%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.10.4.</span> <span class="toc-text">3.6.4. Iterator 和 ListIterator 的区别(面试题)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Set-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.</span> <span class="toc-text">4. Set 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">4.1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Set-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">4.2. Set 接口的实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%93"><span class="toc-number">3.3.</span> <span class="toc-text">4.3. 哈希表(数组和链表的组合体)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">3.3.1.</span> <span class="toc-text">4.3.1. 对象的哈希值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-Object-%E7%9A%84-hashCode-%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">4.3.2. Object 的 hashCode 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.3.3.</span> <span class="toc-text">4.3.3. 哈希表结构的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B-HashSet-%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E5%94%AF%E4%B8%80%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.4.</span> <span class="toc-text">4.3.4. 哈希表的存储元素详细过程(HashSet 判断元素唯一的原理)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-hashCode-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.5.</span> <span class="toc-text">4.3.5. hashCode 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-HashSet-%E9%9B%86%E5%90%88"><span class="toc-number">3.4.</span> <span class="toc-text">4.4. HashSet 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">4.4.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-HashSet-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">3.4.2.</span> <span class="toc-text">4.4.2. HashSet 构造方法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-HashSet-%E4%BF%9D%E5%AD%98%E5%85%83%E7%B4%A0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.3.</span> <span class="toc-text">4.4.3. HashSet 保存元素的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-HashSet-%E5%AD%98%E5%82%A8%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%89%E9%87%8D%E5%A4%8D%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.4.</span> <span class="toc-text">4.4.4. HashSet 存储判断元素（自定义类型）重复的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-4-1-HashSet-%E7%9A%84-add-contains-%E7%AD%89%E6%96%B9%E6%B3%95%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E9%87%8D%E5%A4%8D%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">4.4.4.1. HashSet 的 add&#x2F;contains 等方法判断元素是否重复原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-4-2-%E4%BD%BF%E7%94%A8-HashSet-%E5%AD%98%E5%82%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">4.4.4.2. 使用 HashSet 存储自定义类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-LinkedHashSet-%E9%9B%86%E5%90%88"><span class="toc-number">3.5.</span> <span class="toc-text">4.5. LinkedHashSet 集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-TreeSet-%E9%9B%86%E5%90%88"><span class="toc-number">3.6.</span> <span class="toc-text">4.6. TreeSet 集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-Set-%E6%8E%A5%E5%8F%A3%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="toc-number">3.7.</span> <span class="toc-text">4.7. Set 接口相关实现类总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-1-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.1.</span> <span class="toc-text">4.7.1. HashSet、LinkedHashSet 和 TreeSet 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Queue-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">5. Queue 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">5.1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">5.2. 常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-ArrayDeque%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">5.3. ArrayDeque（了解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Map-%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">6. Map 接口（双列集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">6.1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-Map%EF%BC%88%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%EF%BC%89%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E5%9B%BE"><span class="toc-number">5.1.1.</span> <span class="toc-text">6.1.1. Map（双列集合）继承体系图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-Map-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9-%E9%87%8D%E7%82%B9"><span class="toc-number">5.1.2.</span> <span class="toc-text">6.1.2. Map 接口的特点(重点)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-Map-%E9%9B%86%E5%90%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">5.1.3.</span> <span class="toc-text">6.1.3. Map 集合的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-4-Map-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">6.1.4. Map 接口中的常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Entry-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.</span> <span class="toc-text">6.2. Entry 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">6.2.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-Entry-%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">6.2.2. Entry 接口常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E9%81%8D%E5%8E%86-Map-%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">6.3. 遍历 Map 集合的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E9%80%9A%E8%BF%87-keySet-%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">6.3.1. 通过 keySet 方法遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E9%80%9A%E8%BF%87-entrySet-%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.2.</span> <span class="toc-text">6.3.2. 通过 entrySet 方法遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E9%80%9A%E8%BF%87-Values-%E6%96%B9%E6%B3%95%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.3.</span> <span class="toc-text">6.3.3. 通过 Values 方法遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-HashMap"><span class="toc-number">5.4.</span> <span class="toc-text">6.4. HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">6.4.1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-1-1-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">6.4.1.1. 存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-4-1-2-%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">6.4.1.2. 类的主要参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E4%B8%80%E8%88%AC%E7%94%A8%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E4%BD%9C%E4%B8%BA-HashMap-%E7%9A%84-key"><span class="toc-number">5.4.2.</span> <span class="toc-text">6.4.2. 一般用什么类型作为 HashMap 的 key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-HashMap-%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">5.4.3.</span> <span class="toc-text">6.4.3. HashMap 线程不安全的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-LinkedHashMap"><span class="toc-number">5.5.</span> <span class="toc-text">6.5. LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-TreeMap"><span class="toc-number">5.6.</span> <span class="toc-text">6.6. TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">5.6.1.</span> <span class="toc-text">6.6.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">5.6.2.</span> <span class="toc-text">6.6.2. 继承结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-%E7%89%B9%E7%82%B9"><span class="toc-number">5.6.3.</span> <span class="toc-text">6.6.3. 特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-Hashtable"><span class="toc-number">5.7.</span> <span class="toc-text">6.7. Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-ConcurrentHashMap%EF%BC%88%E7%BD%91%E7%BB%9C%E8%B5%84%E6%96%99%EF%BC%8C%E6%9C%AA%E6%95%B4%E7%90%86%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">6.8. ConcurrentHashMap（网络资料，未整理）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-1-%E5%B8%B8%E7%94%A8-API%EF%BC%88%E6%95%B4%E7%90%86%E4%B8%AD%EF%BC%89"><span class="toc-number">5.8.1.</span> <span class="toc-text">6.8.1. 常用 API（整理中）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-2-ConcurrentHashMap-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.8.2.</span> <span class="toc-text">6.8.2. ConcurrentHashMap 实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-Map-%E6%8E%A5%E5%8F%A3%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="toc-number">5.9.</span> <span class="toc-text">6.9. Map 接口相关实现类总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-1-Hashtable-%E5%92%8C-HashMap-%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.9.1.</span> <span class="toc-text">6.9.1. Hashtable 和 HashMap 的区别(面试题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-2-SynchronizedMap-%E5%92%8C-ConcurrentHashMap-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.9.2.</span> <span class="toc-text">6.9.2. SynchronizedMap 和 ConcurrentHashMap 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9-3-TreeMap-%E4%B8%8E-LinkedHashMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.9.3.</span> <span class="toc-text">6.9.3. TreeMap 与 LinkedHashMap 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8%EF%BC%9AComparator-%E4%B8%8E-Comparable"><span class="toc-number">6.</span> <span class="toc-text">7. 自定义比较器：Comparator 与 Comparable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-Comparator-%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">7.1. Comparator 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-Comparable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.</span> <span class="toc-text">7.2. Comparable 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-Comparator-%E4%B8%8E-Comparable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">7.3. Comparator 与 Comparable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84-sort-%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">7.4. Collections 工具类的 sort 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.4.1.</span> <span class="toc-text">7.4.1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-%E5%9F%BA%E7%A1%80%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.4.2.</span> <span class="toc-text">7.4.2. 基础示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB-API"><span class="toc-number">7.</span> <span class="toc-text">8. 集合相关的工具类 API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">8.1. Collections 工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E5%88%9B%E5%BB%BA%E4%B8%8D%E8%83%BD%E4%BF%AE%E6%94%B9%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">7.1.1.</span> <span class="toc-text">8.1.1. 创建不能修改的集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-List%E3%80%81Set%E3%80%81Map-%E9%9B%86%E5%90%88"><span class="toc-number">7.1.2.</span> <span class="toc-text">8.1.2. 创建线程安全的 List、Set、Map 集合</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img src="/bg/Image00018.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库150道高频面试题"/></a><div class="content"><a class="title" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题">MySQL数据库150道高频面试题</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术同学必会的MySQL设计规约"/></a><div class="content"><a class="title" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约">技术同学必会的MySQL设计规约</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dfdfdf4.html" title="数据库概述"><img src="/bg/Image00002.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库概述"/></a><div class="content"><a class="title" href="/posts/dfdfdf4.html" title="数据库概述">数据库概述</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/490575ab.html" title="24工厂模式俗话解释"><img src="/bg/Image00024.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24工厂模式俗话解释"/></a><div class="content"><a class="title" href="/posts/490575ab.html" title="24工厂模式俗话解释">24工厂模式俗话解释</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/364ea8cc.html" title="设计模式"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/364ea8cc.html" title="设计模式">设计模式</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2020 - 2025 By 蓝桉</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8152976493" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat/cat.js"></script><script async data-pjax src="/js/meting/music_lanan.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/day/lunar.js"></script><script defer src="/js/day/day.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '10a7db1c41b6489db9c830c668a18304';
  var gaud_map_key = '82a64bc994fb6494830f157f319f9f69';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime/runtime.min.js"></script><script async src="/js/font/ali_font_all.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>
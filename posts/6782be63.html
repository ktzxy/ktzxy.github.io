<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker学习 | 蓝桉`Blog</title><meta name="author" content="蓝桉,kt_zxh@163.com"><meta name="copyright" content="蓝桉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Docker学习笔记@[toc] Docker介绍Docker简介Docker简介以及Docker历史http:&#x2F;&#x2F;c.biancheng.net&#x2F;view&#x2F;3118.html docker官网https:&#x2F;&#x2F;www.docker.com&#x2F; Docker是一个开源的应用容器引擎，基于LXC（Linux Container）内核虚拟化技术实现，提供一系列更强的功能，比如镜像、 Dockerfile等">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker学习">
<meta property="og:url" content="https://ktzxy.github.io/posts/6782be63.html">
<meta property="og:site_name" content="蓝桉&#96;Blog">
<meta property="og:description" content="Docker学习笔记@[toc] Docker介绍Docker简介Docker简介以及Docker历史http:&#x2F;&#x2F;c.biancheng.net&#x2F;view&#x2F;3118.html docker官网https:&#x2F;&#x2F;www.docker.com&#x2F; Docker是一个开源的应用容器引擎，基于LXC（Linux Container）内核虚拟化技术实现，提供一系列更强的功能，比如镜像、 Dockerfile等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ktzxy.github.io/bg/Image00017.webp">
<meta property="article:published_time" content="2025-07-09T17:28:45.000Z">
<meta property="article:modified_time" content="2025-07-13T15:45:18.457Z">
<meta property="article:author" content="蓝桉">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ktzxy.github.io/bg/Image00017.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker学习",
  "url": "https://ktzxy.github.io/posts/6782be63.html",
  "image": "https://ktzxy.github.io/bg/Image00017.webp",
  "datePublished": "2025-07-09T17:28:45.000Z",
  "dateModified": "2025-07-13T15:45:18.457Z",
  "author": [
    {
      "@type": "Person",
      "name": "蓝桉",
      "url": "https://ktzxy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ktzxy.github.io/posts/6782be63.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker学习',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/windmill/windmill.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/meting/music_lanan.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="蓝桉`Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/bg.webp);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/bg/Image00017.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">蓝桉`Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Docker学习</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Docker学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-09T17:28:45.000Z" title="发表于 2025-07-09 17:28:45">2025-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-13T15:45:18.457Z" title="更新于 2025-07-13 15:45:18">2025-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><p>@[toc]</p>
<h1 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h1><h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><p>Docker简介以及Docker历史<br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3118.html">http://c.biancheng.net/view/3118.html</a></p>
<p>docker官网<br><a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>Docker是一个开源的应用容器引擎，基于LXC（Linux Container）内核虚拟化技术实现，提供一系列更强的功能，比如镜像、 Dockerfile等； </p>
<p>Docker理念是将应用及依赖包打包到一个可移植的容器中，可发布到任意Linux发行版Docker引擎上。使用沙箱机制运行程序， 程序之间相互隔离； Docker使用Go语言开发。</p>
<h3 id="Docker架构与内部组件"><a href="#Docker架构与内部组件" class="headerlink" title="Docker架构与内部组件"></a>Docker架构与内部组件</h3><p>Docker采用C/S架构，Dcoker daemon作为服务端接受来自客户端请求，并处理这些请求，比如创建、运行容器等。客户端为用 户提供一系列指令与Docker daemon交互。</p>
<p>Docker的架构图<br><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241614778.png" alt="在这里插入图片描述"></p>
<ul>
<li>Docker Client：客户端 </li>
<li>Ddocker Daemon：守护进程 </li>
<li>Docker Images：镜像 </li>
<li>Docker Container：容器 </li>
<li>Docker Registry：镜像仓库</li>
</ul>
<p>LXC：Linux容器技术，共享内核，容器共享宿主机资源，使用namespace和cgroups对资源限制与隔离。 Cgroups（control groups）：Linux内核提供的一种限制单进程或者多进程资源的机制；比如CPU、内存等资源的使用限制。 NameSpace：命名空间，也称名字空间，Linux内核提供的一种限制单进程或者多进程资源隔离机制；一个进程可以属于多个命 名空间。Linux内核提供了六种NameSpace：UTS、IPC、PID、Network、Mount和User。 </p>
<p>AUFS（advanced multi layered unification filesystem）：高级多层统一文件系统，是UFS的一种，每个branch可以指定readonly（ro 只读）、readwrite（读写）和whiteout-able（wo隐藏）权限；一般情况下，aufs只有最上层的branch才有读写权限，其他branch 均为只读权限。</p>
<p> UFS（UnionFS）：联合文件系统，支持将不同位置的目录挂载到同一虚拟文件系统，形成一种分层的模型；成员目录称为虚拟 文件系统的一个分支（branch）。<br><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241614549.png" alt="在这里插入图片描述"></p>
<p>Docker 包括三个基本概念</p>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<p><strong>镜像( image)</strong>：<br>Docker镜像(工mage)就是一个只读的模板。镜像可以用来创建 Docker容器镜像可以创建很多容器。容器从镜像启动的时候，会在镜像的最上层创建一个可写层。就好似]ava中的类和对象,类就是镜像,容器就是对象。</p>
<p><strong>容器( container)</strong>:</p>
<p>1.Docker利用容器( Container)独立运行的一个或一组应用。容器是用镜像创建的运行实例<br>2.它可以被启动、开始、停止、除。每个容器都是相互隔高的,保证安全的平台<br>3.可以把音器看做是一个简易版的Linux环境(色括root用户权限、进程空间、用户空间和网空间等)和运行在具其中的应用程序<br>4.容器的定义和镜像几手ー模一样,也是一堆层的统一视角,唯一区别在于容器的最上面那一层是可读可写的</p>
<p><strong>仓库( repository)</strong>:<br>1.仓库( Repository)是集中存放镜像文件的场所<br>2.仓库( Repository)和仓库注册服务器( Registry)是有区别的。仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的标签(tag)<br>3.仓库分为公开仓库(Pub1ic)和私有仓库( Private)两种形式<br>4.最大的公开仓库是DockerHub(<a target="_blank" rel="noopener" href="https://hub.docker.com/)存放了数量度大的镜像供用户下载">https://hub.docker.com/)存放了数量度大的镜像供用户下载</a><br>5.国内的公开仓库包括阿里云、网易云等<br>*注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p>
<h3 id="Docker有什么优点"><a href="#Docker有什么优点" class="headerlink" title="Docker有什么优点"></a>Docker有什么优点</h3><p> 持续集成 </p>
<p>在项目快速迭代情况下，轻量级容器对项目快速构建、环境打包、发布等流程就能提高工作效率。 </p>
<p> 版本控制 </p>
<p>每个镜像就是一个版本，在一个项目多个版本时可以很方便管理。 </p>
<p> 可移植性 </p>
<p>容器可以移动到任意一台Docker主机上，而不需要过多关注底层系统。</p>
<p> 标准化 </p>
<p>应用程序环境及依赖、操作系统等问题，增加了生产环境故障率，容器保证了所有配置、依赖始终不变。 </p>
<p> 隔离性与安全 </p>
<p>容器之间的进程是相互隔离的，一个容器出现问题不会影响其他容器。</p>
<h3 id="虚拟机与容器区别"><a href="#虚拟机与容器区别" class="headerlink" title="虚拟机与容器区别"></a>虚拟机与容器区别</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241614387.png" alt="在这里插入图片描述"></p>
<p>以KVM举例，与Docker对比 </p>
<p> 启动时间 </p>
<p>Docker秒级，KVM分钟级。 </p>
<p> 轻量级 </p>
<p>容器镜像大小通常以M为单位，虚拟机以G为单位。 容器资源占用小，要比虚拟机部署更快速。 </p>
<p> 性能 </p>
<p>容器共享宿主机内核，系统级虚拟化，占用资源少，没有Hypervisor层开销，容器性能基本接近物理机； 虚拟机需要Hypervisor层支持，虚拟化一些设备，具有完整的GuestOS，虚拟化开销大，因而降低性能，没有容器性能好。 </p>
<p> 安全性 </p>
<p>由于共享宿主机内核，只是进程级隔离，因此隔离性和稳定性不如虚拟机，容器具有一定权限访问宿主机内核，存在一定安全 隐患。 </p>
<p> 使用要求 </p>
<p>KVM基于硬件的完全虚拟化，需要硬件CPU虚拟化技术支持； 容器共享宿主机内核，可运行在主流的Linux发行版，不用考虑CPU是否支持虚拟化技术。</p>
<p> 应用打包与部署自动化 </p>
<p>构建标准化的运行环境； 现在大多方案是在物理机和虚拟机上部署运行环境，面临问题是环境杂乱、完整性迁移难度高等问题，容器即开即用。 </p>
<p> 自动化测试和持续集成/部署 </p>
<p>自动化构建镜像和良好的REST API，能够很好的集成到持续集成/部署环境来。 </p>
<p> 部署与弹性扩展 </p>
<p>由于容器是应用级的，资源占用小，弹性扩展部署速度要更快。 </p>
<p> 微服务 </p>
<p>Docker这种容器华隔离技术，正式应对了微服务理念，将业务模块放到容器中运行，容器的可复用性大大增加了业务模块扩展 性。<br><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241614273.png" alt="在这里插入图片描述"></p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><blockquote>
<p>Docker是怎么工作的</p>
</blockquote>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问。</p>
<p>DockerServer接受到Docker-Client的指令，就会执行这个命令！</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241614244.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Docker为什么比VM快？</p>
</blockquote>
<p>1.Docker有着比虚拟机更少的抽象层</p>
<p>2.Docker利用的是宿主机的内核，vm需要的时Guest OS。<br><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241614296.png" alt="在这里插入图片描述"></p>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><blockquote>
<p><strong>查看Linux版本内核</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.查看Linux版本内核</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Docker最低支持CentOS 7，Docker 需要安装在 64 位的平台，并且内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。</span><br><span class="line">2.yum安装gcc相关环境（确保虚拟机可以上外网）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">yum -y install gcc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>安装</strong></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.卸载旧的版本</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> yum remove docker \</span></span><br><span class="line"><span class="language-bash">                  docker-client \</span></span><br><span class="line"><span class="language-bash">                  docker-client-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-common \</span></span><br><span class="line"><span class="language-bash">                  docker-latest \</span></span><br><span class="line"><span class="language-bash">                  docker-latest-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-logrotate \</span></span><br><span class="line"><span class="language-bash">                  docker-engine</span></span><br><span class="line">2.需要的安装包</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> yum install -y yum-utils</span></span><br><span class="line">3.设置镜像的仓库（官方）</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> yum-config-manager \</span></span><br><span class="line"><span class="language-bash">    --add-repo \</span></span><br><span class="line"><span class="language-bash">    https://download.docker.com/linux/centos/docker-ce.repo  （官网速度慢）</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> yum-config-manager \</span></span><br><span class="line"><span class="language-bash">    --add-repo \</span></span><br><span class="line"><span class="language-bash">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（推荐使用，阿里云速度快）</span></span><br><span class="line">4.更新yum软件包索引</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> yum makecache fast</span></span><br><span class="line">5.安装docker  docker-ce 社区版  docker-ee 企业版</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> yum install docker-ce docker-ce-cli containerd.io</span></span><br><span class="line">6.启动docker</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> systemctl start docker</span></span><br><span class="line">7.查看docker是否安装成功</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> docker version</span></span><br></pre></td></tr></table></figure>
<p>卸载Docker</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.卸载依赖</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> yum remove docker-ce docker-ce-cli containerd.io</span></span><br><span class="line">2.删除资源</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/var/lib/docker     docker的默认工作路径</span></span><br></pre></td></tr></table></figure>
<h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">配置镜像加速器</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://f2k3b83v.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<h3 id="设置开机自动启动"><a href="#设置开机自动启动" class="headerlink" title="设置开机自动启动"></a>设置开机自动启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">systemctl <span class="built_in">enable</span> docker</span></span><br></pre></td></tr></table></figure>
<h3 id="查看docker服务状态"><a href="#查看docker服务状态" class="headerlink" title="查看docker服务状态"></a>查看docker服务状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">systemctl status docker</span></span><br></pre></td></tr></table></figure>
<h3 id="查看docker具体信息"><a href="#查看docker具体信息" class="headerlink" title="查看docker具体信息"></a>查看docker具体信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker info</span></span><br></pre></td></tr></table></figure>
<h1 id="镜像使用"><a href="#镜像使用" class="headerlink" title="镜像使用"></a>镜像使用</h1><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker images</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>REPOSITORY**</strong>：表示镜像的仓库源</li>
<li><strong>TAG<em>**</em></strong>：**镜像的标签</li>
<li><strong>IMAGE ID**</strong>：**镜像ID</li>
<li><strong>CREATED**</strong>：**镜像创建时间</li>
<li><strong>SIZE**</strong>：**镜像大小</li>
</ul>
<ol>
<li>只显示镜像ID<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker images –q</span></span><br></pre></td></tr></table></figure></li>
<li>直接列出镜像结果，并且只包含镜像ID和仓库名<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker images --format <span class="string">&quot;&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker pull REPOSITORY:TAG</span></span><br></pre></td></tr></table></figure>
<h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker search REPOSITORY:TAG</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>NAME:</strong> 镜像仓库源的名称</li>
<li><strong>DESCRIPTION</strong>: 镜像的描述</li>
<li><strong>OFFICIAL</strong>: 是否 docker 官方发布</li>
<li><strong>stars</strong>: 类似 Github 里面的 star，表示点赞、喜欢的意思。</li>
<li><strong>AUTOMATED</strong>: 自动构建。</li>
</ul>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker rmi REPOSITORY</span></span><br></pre></td></tr></table></figure>
<h3 id="使用某镜像来启动一个容器"><a href="#使用某镜像来启动一个容器" class="headerlink" title="使用某镜像来启动一个容器"></a>使用某镜像来启动一个容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -t -i REPOSITORY:TAG /bin/bash</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>-i</strong>: 交互式操作</p>
</li>
<li><p><strong>-t</strong>: 终端。</p>
</li>
<li><p><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</p>
<p>如果你不指定一个镜像的版本标签，docker 将默认使用 REPOSITORY:latest 镜像。</p>
</li>
</ul>
<h3 id="更新镜像（更新前需要创建一个容器）"><a href="#更新镜像（更新前需要创建一个容器）" class="headerlink" title="更新镜像（更新前需要创建一个容器）"></a>更新镜像（更新前需要创建一个容器）</h3><ol>
<li><p>在运行的容器内使用 <strong>apt-get update</strong> 命令进行更新。</p>
</li>
<li><p>在完成操作之后，输入 exit 命令来退出这个容器。</p>
</li>
<li><p>通过commit命令来提交（将容器保存为镜像）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker commit -m=<span class="string">&quot;描述信息&quot;</span> -a=<span class="string">&quot;镜像作者&quot;</span> 容器名/容器ID REPOSITORY：创建的目标镜像名</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="设置镜像标签"><a href="#设置镜像标签" class="headerlink" title="设置镜像标签"></a>设置镜像标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker tag  镜像ID REPOSITORY:新的标签名</span></span><br></pre></td></tr></table></figure>
<h3 id="镜像的导入导出"><a href="#镜像的导入导出" class="headerlink" title="镜像的导入导出"></a>镜像的导入导出</h3><ol>
<li><p>如果因为网络原因可以通过硬盘的方式传输镜像，虽然不规范，但是有效，但是这种方式导出的镜像名称和版本都是null，需要手动修改</p>
</li>
<li><p>将本地的镜像导出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker save -o 导出的路径 镜像<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加载本地的镜像文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker load -i 镜像文件</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>镜像既没有仓库名，也没有标签，均为 <none>：这类无标签镜像也被称为虚悬镜像（dangling image），可以用下面的命令专门显示这类镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker images -f dangling=<span class="literal">true</span></span></span><br></pre></td></tr></table></figure>
<p>可以用下面的命令删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker rmi $（docker images -q -f dangling=<span class="literal">true</span>）</span></span><br></pre></td></tr></table></figure>
<h3 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h3><p>现在以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run --name webserver -d -p 80:80 nginx</span></span><br></pre></td></tr></table></figure>
<p>这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样可以用浏览器去访问这个 nginx 服务器。直接用浏览器访问的话，会看到默认的 Nginx 欢迎页面。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615047.png" alt="在这里插入图片描述"></p>
<p>现在，假设非常不喜欢这个欢迎页面，希望改成欢迎 Docker 的文字，可以使用 docker exec命令进入容器，修改其内容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">exec</span> -it webserver bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cd</span> /usr/share/nginx/html/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt;index.html</span> </span><br></pre></td></tr></table></figure>
<h3 id="上传本地镜像到共有仓库"><a href="#上传本地镜像到共有仓库" class="headerlink" title="上传本地镜像到共有仓库"></a>上传本地镜像到共有仓库</h3><ol>
<li><p><strong>在</strong> <a target="_blank" rel="noopener" href="https://hub.docker.com/"><strong>https://hub.docker.com</strong></a> 免费注册一个 Docker 账号。</p>
</li>
<li><p>登录</p>
<p>启动 docker 服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">systemctl start docker</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker login</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">logout</span>(退出)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看本地镜像</p>
<p>通过docker push 命令将自己的镜像推送到Docker HuB</p>
<p>使用tag标记镜像需要上传到的仓库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker tag hello-world:latest username/hello-world:latest</span></span><br></pre></td></tr></table></figure>
<p>使用push 上传镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker push username/hello-world:latest</span></span><br></pre></td></tr></table></figure>
<p>登陆hub.docker.com 查看上传结果</p>
</li>
</ol>
<h3 id="私有仓库的搭建并上传镜像至私有仓库"><a href="#私有仓库的搭建并上传镜像至私有仓库" class="headerlink" title="私有仓库的搭建并上传镜像至私有仓库"></a>私有仓库的搭建并上传镜像至私有仓库</h3><ol>
<li><p>查找并下载 私有仓库的镜像 <strong>registry</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker search registry</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker pull registry</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建镜像的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --name myregistry registry:2</span></span><br></pre></td></tr></table></figure>
<p>Registry服务默认会将上传的镜像保存在容器的/var/lib/registry，我们将主机的/opt/registry目录挂载到该目录，即可实现将镜像保存到主机的/opt/registry目录了。</p>
</li>
<li><p>浏览器访问<a target="_blank" rel="noopener" href="http://127.0.0.1:5000/v2，出现下面情况说明registry运行正常。">http://127.0.0.1:5000/v2，出现下面情况说明registry运行正常。</a></p>
</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615845.png" alt="在这里插入图片描述"></p>
<ol>
<li><p>上传镜像至私有仓库</p>
<p>要通过docker tag将该镜像标志为要推送到私有仓库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker tag nginx:latest localhost:5000/nginx:latest</span></span><br></pre></td></tr></table></figure>
<p>通过 docker push 命令将 nginx 镜像 push到私有仓库中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker push localhost:5000/nginx:latest</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问 <a target="_blank" rel="noopener" href="http://127.0.0.1:5000/v2/_catalog">http://127.0.0.1:5000/v2/_catalog</a> 查看私有仓库目录，可以看到刚上传的镜像了：</p>
</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615867.png" alt="在这里插入图片描述"></p>
<p>   可能出现的异常</p>
<p>   received unexpected HTTP status:500 Internal Server Error</p>
<p>   解决方案：设置防火墙的权限</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setenforce 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">getenforce</span></span><br><span class="line">Permissive</span><br></pre></td></tr></table></figure>
<h1 id="容器的操作"><a href="#容器的操作" class="headerlink" title="容器的操作"></a>容器的操作</h1><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615463.png" alt="在这里插入图片描述"></p>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><ol>
<li><p>运行容器需要定制具体镜像，如果镜像不存在，会直接下载</p>
</li>
<li><p>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]</span> </span><br></pre></td></tr></table></figure>
<p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
</li>
<li><p>常用的参数</p>
<ul>
<li><p>-d:代表后台运行容器</p>
</li>
<li><p>-it 使用交互方式运行，进入容器查看内容</p>
</li>
<li><p>-p 宿主机端口:容器端口：为了映射当前Linux的端口和容器的端口</p>
</li>
<li><p>—name 容器名称:指定容器的名称</p>
<p>我们也可以使用 <strong>-p</strong> 标识来指定容器端口绑定到主机端口。</p>
<p>两种方式的区别是:</p>
</li>
<li><p><strong>-P :</strong>是容器内部端口<strong>随机</strong>映射到主机的高端口。</p>
</li>
<li><p><strong>-p :</strong> 是容器内部端口绑定到<strong>指定</strong>的主机端口。</p>
</li>
</ul>
</li>
</ol>
<h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><p>查看全部正在运行的容器信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker ps [-qa]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>-a 查看全部的容器，包括没有运行</p>
</li>
<li><p>-q 只查看容器的标识</p>
</li>
</ul>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><p>查看容器日志，以查看容器运行的信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker logs -f 容器<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>-f：可以滚动查看日志的最后几行</li>
<li>—tail number   要显示日志条数</li>
</ul>
<h3 id="进入容器的内部"><a href="#进入容器的内部" class="headerlink" title="进入容器的内部"></a>进入容器的内部</h3><p>可以进入容器的内部进行操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> /bin/bash</span></span><br></pre></td></tr></table></figure>
<h3 id="复制内容到容器"><a href="#复制内容到容器" class="headerlink" title="复制内容到容器"></a>复制内容到容器</h3><p>将宿主机的文件复制到容器内部的指定目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">cp</span> 文件名称 容器<span class="built_in">id</span>:容器内部路径</span></span><br></pre></td></tr></table></figure>
<h3 id="重启-amp-启动-amp-停止-amp-删除容器-amp-退出容器"><a href="#重启-amp-启动-amp-停止-amp-删除容器-amp-退出容器" class="headerlink" title="重启&amp;启动&amp;停止&amp;删除容器&amp;退出容器"></a>重启&amp;启动&amp;停止&amp;删除容器&amp;退出容器</h3><h5 id="重新启动容器"><a href="#重新启动容器" class="headerlink" title="重新启动容器"></a>重新启动容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker restart 容器<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<h5 id="启动停止运行的容器"><a href="#启动停止运行的容器" class="headerlink" title="启动停止运行的容器"></a>启动停止运行的容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker start/run 容器<span class="built_in">id</span></span> </span><br></pre></td></tr></table></figure>
<ul>
<li>-d  后台运行</li>
<li>-i  交换式运行</li>
<li>—name  添加名字</li>
<li>-t  添加标签</li>
<li>-v  添加数据卷</li>
<li>-rm 容器删除后清除缓存</li>
</ul>
<h5 id="停止指定的容器-删除容器前，需要先停止容器"><a href="#停止指定的容器-删除容器前，需要先停止容器" class="headerlink" title="停止指定的容器(删除容器前，需要先停止容器)"></a>停止指定的容器(删除容器前，需要先停止容器)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker stop 容器<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<h5 id="停止全部容器"><a href="#停止全部容器" class="headerlink" title="停止全部容器"></a>停止全部容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker stop $(docker ps -qa)</span></span><br></pre></td></tr></table></figure>
<h5 id="删除指定容器"><a href="#删除指定容器" class="headerlink" title="删除指定容器"></a>删除指定容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">rm</span> 容器<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<h5 id="强制停止当前容器"><a href="#强制停止当前容器" class="headerlink" title="强制停止当前容器"></a>强制停止当前容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<h5 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">exit</span>  <span class="comment">#直接容器停止并退出</span></span></span><br><span class="line">Ctrl +P + Q  #容器不停止退出</span><br></pre></td></tr></table></figure>
<h5 id="删除全部容器"><a href="#删除全部容器" class="headerlink" title="删除全部容器"></a>删除全部容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">rm</span> $(docker ps -qa)</span></span><br></pre></td></tr></table></figure>
<h5 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker export 容器ID &gt; 存储路径</span></span><br></pre></td></tr></table></figure>
<h5 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#docker import 容器快照/指定URL/某个目录</span></span><br></pre></td></tr></table></figure>
<p>*注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h3 id="将website1发到nginx的容器中去"><a href="#将website1发到nginx的容器中去" class="headerlink" title="将website1发到nginx的容器中去"></a>将website1发到nginx的容器中去</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker volume create 卷名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -d -p 5000:80 -v 卷名：/usr/share/nginx/html --name 容器名 docker.io/nginx:latest</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cd</span> /var/lib/docker/volumes/卷名/_data/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vi index.html</span></span><br><span class="line">web访问ip:5000</span><br></pre></td></tr></table></figure>
<h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615508.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615669.png" alt="在这里插入图片描述"></p>
<h1 id="Docker图形界面管理"><a href="#Docker图形界面管理" class="headerlink" title="Docker图形界面管理"></a>Docker图形界面管理</h1><h3 id="DockerUI"><a href="#DockerUI" class="headerlink" title="DockerUI"></a>DockerUI</h3><p>DockerUI是一个基于Docker API提供图形化页面简单的容器管理系统，支持容器管理、镜像管理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-d \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-v /var/run/docker.sock:/docker.sock \</span><br><span class="line">--name dockerui abh1nav/dockerui:latest \</span><br><span class="line">-e=<span class="string">&quot;/docker.sock&quot;</span></span><br><span class="line">也可以通过Rest API管理：</span><br><span class="line">docker run \</span><br><span class="line">-d \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">--name dockerui \</span><br><span class="line">-e <span class="string">&quot;http://&lt;dockerd host ip&gt;:2375&quot;</span></span><br><span class="line">abh1nav/dockerui:latest</span><br><span class="line">http://&lt;dockerd host ip&gt;:9000</span><br></pre></td></tr></table></figure>
<h3 id="Shipyard"><a href="#Shipyard" class="headerlink" title="Shipyard"></a>Shipyard</h3><p>Shipyard也是基于Docker API实现的容器图形管理系统，支持container、images、engine、cluster等功能，可满足我 们基本的容器部署需求。 Shipyard分为手动部署和自动部署。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615138.png" alt="在这里插入图片描述"></p>
<p>官方部署文档：<a target="_blank" rel="noopener" href="https://www.shipyard-project.com/docs/deploy/">https://www.shipyard-project.com/docs/deploy/</a></p>
<h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><p><a target="_blank" rel="noopener" href="http://www.yunweipai.com/34991.html">http://www.yunweipai.com/34991.html</a></p>
<h1 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h1><h3 id="UnionFS（联合文件系统）"><a href="#UnionFS（联合文件系统）" class="headerlink" title="UnionFS（联合文件系统）"></a>UnionFS（联合文件系统）</h3><p>我们下载的时候看到的一层层就是这个！</p>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统得修改，作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统对包含所有底层的文件和目录。</p>
<h3 id="Docker镜像加载原理-1"><a href="#Docker镜像加载原理-1" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h3><p>docker的镜像实际上由一层一层的文件系统组成，这种层次的文件系统UnionFS。</p>
<p>boots（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会加载bootfs。</p>
<p>rootfs（root file system），在bootfs之上。包含的就是典型Linux系统中的/dev/，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615691.png" alt="在这里插入图片描述"></p>
<h1 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h1><p>所有的 Docker镜像都起始于一个基础镜像层,当进行修改或增加新的内容时,就会在当前镜像层之上,创建新的镜像层。</p>
<p>举一个简单的例子,假如基于 Ubuntu Linux16.04创建一个新的镜像,这就是新镜像的第一层;如果在该镜像中添加 Python’包,就会在基础镜像层之上创建第二个镜像层;如果继续添加一个安补丁,就会创建第三个镜像层该镜像当前已经包含3个镜像层,如下图所示(这只是一个用于演示的很简单的例子)。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615014.png" alt=""></p>
<p>在添加额外的镜像层的同时,镜像始终保持是当前所有镜像的组合,理解这一点非常重要。下图中举了一个简单的例子,每个镜像层包含3个文件,而镜像包含了来自两个镜像层的6个文件。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241615431.png" alt="在这里插入图片描述"></p>
<p>上图中的镜像层跟之前图中的略有区别,主要目的是便于展示文件。下图中展示了一个稍微复杂的三层镜像,在外部看来整个镜像只有6个文件,这是因为最上层中的文件7是文件5的一个更新版本</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616328.png" alt="在这里插入图片描述"></p>
<p>这种情况下,上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为—个新镜像层添加到镜像当中。Docker通过存储引擎(新版本采用快照机制)的方式来实现镜像层堆栈,并保证多镜像层对外展示为统-的文件系统。</p>
<p>Linux上可用的存储引擎有AUFS、 Overlay2、 Device Mapper、Bts以及zFS。顾名思义,每种存储引擎都基于 Linux中对应的又仵系统或者块设备技术,并且每种存储引擎都有其独有的性能特点。</p>
<p>Docker在 Windows上仅支持 windowsfilter—种存储引擎,该引擎基于NTFS文件系统之上实现了分层和CoW[1]。下图展示了与系统显示相同的三层镜像。所有镜像层堆并合并,对外提供统-的视图.</p>
<p>特点：</p>
<p>Docker镜像都是只读的,当容器启动时,—个新的可写层被加载到镜像的顶部这一层就是我们通常说的容器层,容器之下的都叫镜像层!</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616246.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201205184054243.png#pic_center" alt="在这里插入图片描述"></p>
<h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>卷会一直存在，直到没有容器使用</li>
</ul>
<p>*数据卷的使用，类似于 Linux 下对目录或文件进行 mount。</p>
<h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><p>创建数据卷后，默认会存放在一个目录下/var/lib/docker/volumes/数据卷名称/_data</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker volume create 数据卷名称</span></span><br></pre></td></tr></table></figure>
<h3 id="查看全部数据卷"><a href="#查看全部数据卷" class="headerlink" title="查看全部数据卷"></a>查看全部数据卷</h3><p>查看全部数据卷信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker volume <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>
<h3 id="查看数据卷详情"><a href="#查看数据卷详情" class="headerlink" title="查看数据卷详情"></a>查看数据卷详情</h3><p>查看数据卷的详细信息，可以查询到存放的路径，创建时间等等</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker volume inspect 数据卷名称</span></span><br></pre></td></tr></table></figure>
<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><p>删除指定的数据卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker volume <span class="built_in">rm</span> 数据卷名称</span></span><br></pre></td></tr></table></figure>
<h3 id="Docker数据卷容器"><a href="#Docker数据卷容器" class="headerlink" title="Docker数据卷容器"></a>Docker数据卷容器</h3><p>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。</p>
<p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。</p>
<p>首先，创建一个命名的数据卷容器 dbdata：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> docker run -d -v /数据卷容器名称 --name 数据卷容器名称 镜像的标识|镜像名称[:tag]</span></span><br></pre></td></tr></table></figure>
<p>然后，在其他容器中使用 —volumes-from 来挂载 dbdata 容器中的数据卷。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> docker run -d --volumes-from 数据卷容器名称 --name db1</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> docker run -d --volumes-from 数据卷容器名称 --name db2</span> </span><br></pre></td></tr></table></figure>
<p>还可以使用多个 —volumes-from 参数来从多个容器挂载多个数据卷。</p>
<p>也可以从其他已经挂载了数据卷的容器来挂载数据卷。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> docker run -d --name db3 --volumes-from db1</span> </span><br></pre></td></tr></table></figure>
<p>*注意：使用 —volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。</p>
<p>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 docker rm -v 命令来指定同时删除关联的容器。</p>
<h3 id="容器映射数据卷"><a href="#容器映射数据卷" class="headerlink" title="容器映射数据卷"></a>容器映射数据卷</h3><p>通过数据卷名称映射，如果数据卷不存在。Docker会帮你自动创建，会将容器内部自带的文件，存储在默认的存放路径中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -d -p 8080:8080 --name tomcat -v 数据卷名称:容器内部的路径 镜像<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<p>通过路径映射数据卷，直接指定一个路径作为数据卷的存放位置。但是这个路径下是空的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -d -p 8080:8080 --name tomcat -v 路径(/root/自己创建的文件夹):容器内部的路径 镜像<span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616753.png" alt=""></p>
<h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> docker run -d -p 5000:5000 镜像的标识|镜像名称</span></span><br></pre></td></tr></table></figure>
<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> docker run -d -p 127.0.0.1:5000:5000 镜像的标识|镜像名称</span></span><br></pre></td></tr></table></figure>
<h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> docker run -d -p 127.0.0.1::5000 镜像的标识|镜像名称</span></span><br></pre></td></tr></table></figure>
<p>还可以使用 udp 标记来指定 udp 端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> docker run -d -p 127.0.0.1:5000:5000/udp 镜像的标识|镜像名称</span></span><br></pre></td></tr></table></figure>
<h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker port nostalgic_morse 5000</span></span><br><span class="line">127.0.0.1:49155.</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</p>
<p>-p 标记可以多次使用来绑定多个端口</p>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> docker run -d -p 5000:5000  -p 3000:80 镜像的标识|镜像名称</span></span><br></pre></td></tr></table></figure>
<h3 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h3><ol>
<li><h5 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -d -P --name 容器名 -v 容器内路径 镜像名</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -d -P --name 容器名 -v 卷名：容器内路径 镜像名</span></span><br></pre></td></tr></table></figure>
<p>所有的docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxx/_data</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如何确定是具名挂载还是匿名挂载，还是指定路径挂载</span></span><br><span class="line">-v 容器内路径    #匿名挂载</span><br><span class="line">-v 卷名：容器内路径   #具名挂载</span><br><span class="line">-v /宿主机路径：：容器内路径  #指定路径挂载</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过 -v 容器内路径，ro rw 改变读写权限</span></span><br><span class="line">ro readonly #只读</span><br><span class="line">rw readwrite #可读可写</span><br><span class="line">docker run -d -p --name nginx2 -v mynginx:/etc/nginx:ro nginx</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>将数据从宿主机挂载到容器中的三种方式</p>
</blockquote>
<p>Docker提供三种方式将数据从宿主机挂载到容器中：</p>
<p> • volumes：Docker管理宿主机文件系统的一部分（/var/lib/docker/volumes）。保存数据的最佳方式。 </p>
<p>• bind mounts-：将宿主机上的任意位置的文件或者目录挂载到容器中。</p>
<p> • tmpfs：挂载存储在主机系统的内存中，而不会写入主机的文件系统。如果不希望将数据持久存储在任何位置，可以使用 tmpfs，同时避免写入容器可写层提高性能。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616301.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Volume特点：</p>
</blockquote>
<p> • 多个运行容器之间共享数据，多个容器可以同时挂载相同的卷。 </p>
<p>• 当容器停止或被移除时，该卷依然存在。 </p>
<p>• 当明确删除卷时，卷才会被删除。 </p>
<p>• 将容器的数据存储在远程主机或其他存储上（间接） </p>
<p>• 将数据从一台Docker主机迁移到另一台时，先停止容器，然后备份卷的目录（/var/lib/docker/volumes/）</p>
<p>Bind Mounts特点： </p>
<p>• 从主机共享配置文件到容器。默认情况下，挂载主机/etc/resolv.conf到每个容器，提供DNS解析。 </p>
<p>• 在Docker主机上的开发环境和容器之间共享源代码。例如，可以将Maven target目录挂载到容器中，每次在Docker主机 上构建Maven项目时，容器都可以访问构建的项目包。</p>
<p> • 当Docker主机的文件或目录结构保证与容器所需的绑定挂载一致时</p>
<h1 id="Dockerfile自定义镜像"><a href="#Dockerfile自定义镜像" class="headerlink" title="Dockerfile自定义镜像"></a>Dockerfile自定义镜像</h1><h3 id="实战一"><a href="#实战一" class="headerlink" title="实战一"></a>实战一</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个dockerfile文件，名字可以随机 建议Dockerfile</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">文件中的内容 指令（大写） 参数</span></span><br><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line">CMD echo &quot;---end---&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">FROM:指定当前自定义镜像依赖的环境</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">MAINTAINER：镜像作者 姓名+邮箱</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">COPY：将相对路径下的内容复制到自定义镜像中</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">WORKDIR:声明镜像的默认工作目录</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">VOLUME：挂载的目录</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">EXPOSE：保留端口配置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">RUN：执行的命令，可以编写多个</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">CMD：指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span></span><br><span class="line">类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</span><br><span class="line">CMD 在docker run 时运行。</span><br><span class="line">RUN 是在 docker build。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ENTRYPOINT：指定这个容器启动的时候要运行的命令，可以追加命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ONBUILD：当构建一个被继承Dockerfile 这个时候就会运行ONBUILD的指令，触发指令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ENV：构建的时候设置环境变量</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker build -f 文件存储路径 -t 容器名[：TAG]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER zzz&lt;2251@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line"></span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line"></span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line"></span><br><span class="line">CMD echo /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="实战二（Tomcat）"><a href="#实战二（Tomcat）" class="headerlink" title="实战二（Tomcat）"></a>实战二（Tomcat）</h3><ol>
<li><p>准备镜像文件tomcat压缩包，jdk的压缩包</p>
</li>
<li><p>编写dockerfile文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f 制定了！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER zzz&lt;2251@qq.com&gt;</span><br><span class="line">COPY readme.txt /usr/Local/readme.txt</span><br><span class="line">ADD jdk-8u11-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat-9.0.22.tar.gz /usr/Local/</span><br><span class="line">RUN yum-y install vim</span><br><span class="line">ENV MYPATH /usr/Local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">ENV JAVA_HOME /usr/Local/idk.8.0_11</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/Lib/dt.jar:$JAVA_HOME/Lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/Local/apache-tomcat-9.0.22</span><br><span class="line">ENV CATALINA_BASH /usr/Local/apache-tomcat-9.0.22</span><br><span class="line">ENV PATH $PATH: $JAVA_HOME/bin:$CATALINA_HOME/Lib:$CATALINA_HOME/bin</span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD /usr/Local/apache-tomcat-90.22/bin/startup.sh &amp;&amp; tail -F /usr/Local/apache-tomcat-9022/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker build -t diytomcat .</span></span><br><span class="line"> . 是上下文路径</span><br><span class="line"> 上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</span><br><span class="line"> 由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。</span><br><span class="line">如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -d 9090：8080 --name zzzcomcat -v 本地目录路径：容器内部目录路径 本地目录路径：容器内部目录路径（日志挂载）镜像名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-d 后台运行</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-p 指定端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>访问测试</p>
</li>
<li><p>发布项目</p>
<p>出现资源拒绝访问，解决办法，增加一个tag</p>
</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616011.png" alt="在这里插入图片描述"></p>
<h3 id="构建PHP网站环境镜像"><a href="#构建PHP网站环境镜像" class="headerlink" title="构建PHP网站环境镜像"></a>构建PHP网站环境镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:6</span><br><span class="line">MAINTAINER zzz</span><br><span class="line">RUN yum install -y httpd php php-gd php-mysql mysql mysql-server</span><br><span class="line">ENV MYSQL_ROOT_PASSWORD 123456</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&quot;&lt;?php phpinfo()?&gt;&quot;</span> &gt; /var/www/html/index.php</span><br><span class="line">ADD start.sh /start.sh</span><br><span class="line">RUN <span class="built_in">chmod</span> +x /start.sh</span><br><span class="line">ADD https://cn.wordpress.org/wordpress-4.7.4-zh_CN.tar.gz /var/www/html</span><br><span class="line">COPY wp-config.php /var/www/html/wordpress</span><br><span class="line">VOLUME [<span class="string">&quot;/var/lib/mysql&quot;</span>]</span><br><span class="line">CMD /start.sh</span><br><span class="line">EXPOSE 80 3306</span><br><span class="line"><span class="comment"># cat start.sh</span></span><br><span class="line">service httpd start</span><br><span class="line">service mysqld start</span><br><span class="line">mysqladmin -uroot password <span class="variable">$MYSQL_ROOT_PASSWORD</span></span><br><span class="line"><span class="built_in">tail</span> -f</span><br></pre></td></tr></table></figure>
<h3 id="构建JAVA网站环境镜像"><a href="#构建JAVA网站环境镜像" class="headerlink" title="构建JAVA网站环境镜像"></a>构建JAVA网站环境镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:6</span><br><span class="line">MAINTAINER zzz</span><br><span class="line">ADD jdk-8u45-linux-x64.tar.gz /usr/local</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_45</span><br><span class="line">ADD http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.0.45/bin/apachetomcat-8.0.45.tar.gz /usr/local</span><br><span class="line">WORKDIR /usr/local/apache-tomcat-8.0.45</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;bin/catalina.sh&quot;</span>, <span class="string">&quot;run&quot;</span>]</span><br><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure>
<h3 id="构建支持SSH服务的镜像"><a href="#构建支持SSH服务的镜像" class="headerlink" title="构建支持SSH服务的镜像"></a>构建支持SSH服务的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:6</span><br><span class="line">MAINTAINER zzz</span><br><span class="line">ENV ROOT_PASSWORD 123456</span><br><span class="line">RUN yum install -y openssh-server</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="variable">$ROOT_PASSWORD</span> |passwd --stdin root</span><br><span class="line">RUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key</span><br><span class="line">RUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span><br><span class="line">CMD [<span class="string">&quot;/usr/sbin/sshd&quot;</span>, <span class="string">&quot;-D&quot;</span>]</span><br><span class="line">EXPOSE 22</span><br></pre></td></tr></table></figure>
<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><p>当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616421.png" alt="Docker 网络"></p>
<p>接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p>
<h3 id="快速配置指南"><a href="#快速配置指南" class="headerlink" title="快速配置指南"></a>快速配置指南</h3><p>下面是一个跟 Docker 网络相关的命令列表。</p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p>
<ul>
<li>-b BRIDGE or —bridge=BRIDGE —指定容器挂载的网桥</li>
<li>—bip=CIDR —定制 docker0 的掩码</li>
<li>-H SOCKET… or —host=SOCKET… —Docker 服务端接收命令的通道</li>
<li>—icc=true|false —是否支持容器之间进行通信</li>
<li>—ip-forward=true|false —请看下文容器之间的通信</li>
<li>—iptables=true|false —禁止 Docker 添加 iptables 规则</li>
<li>—mtu=BYTES —容器网络中的 MTU</li>
</ul>
<p>下面2个命令选项既可以在启动服务时指定，也可以 Docker 容器启动（docker run）时候指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 docker run 时可以覆盖设置的默认值。</p>
<ul>
<li>—dns=IP_ADDRESS… —使用指定的DNS服务器</li>
<li>—dns-search=DOMAIN… —指定DNS搜索域</li>
</ul>
<p>最后这些选项只有在 docker run 执行时使用，因为它是针对容器的特性内容。</p>
<ul>
<li>-h HOSTNAME or —hostname=HOSTNAME —配置容器主机名</li>
<li>—link=CONTAINER_NAME:ALIAS —添加到另一个容器的连接</li>
<li>—net=bridge|none|container:NAME_or_ID|host —配置容器的桥接模式</li>
<li>-p SPEC or —publish=SPEC —映射容器端口到宿主主机</li>
<li>-P or —publish-all=true|false —映射容器所有端口到宿主主机</li>
</ul>
<h3 id="Docker配置DNS"><a href="#Docker配置DNS" class="headerlink" title="Docker配置DNS"></a>Docker配置DNS</h3><p>Docker 没有为每个容器专门定制镜像，那么怎么自定义配置容器的主机名和 DNS 配置呢？</p>
<p>秘诀就是它利用虚拟文件来挂载到来容器的 3 个相关配置文件。</p>
<p>在容器中使用 mount 命令可以看到挂载信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount</span></span><br><span class="line">...</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 ...</span><br><span class="line">/dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...</span><br><span class="line">tmpfs on /etc/resolv.conf type tmpfs ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 dns 配置通过 /etc/resolv.conf 文件立刻得到更新。</p>
<p>如果用户想要手动指定容器的配置，可以利用下面的选项。</p>
<p>-h HOSTNAME or —hostname=HOSTNAME</p>
<p>设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。但它在容器外部看不到，既不会在 docker ps 中显示，也不会在其他的容器的 /etc/hosts 看到。</p>
<p>—link=CONTAINER_NAME:ALIAS</p>
<p>选项会在创建容器的时候，添加一个其他容器的主机名到 /etc/hosts 文件中，让新容器的进程可以使用主机名 ALIAS 就可以连接它。</p>
<p>—dns=IP_ADDRESS</p>
<p>添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p>
<p>—dns-search=DOMAIN</p>
<p>设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索host，还会搜索 host.example.com。</p>
<p>注意：如果没有上述最后 2 个选项，Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。</p>
<h3 id="Docker容器访问控制"><a href="#Docker容器访问控制" class="headerlink" title="Docker容器访问控制"></a>Docker容器访问控制</h3><p>容器的访问控制，主要通过 Linux 上的 iptables 防火墙来进行管理和实现。iptables 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sysctl net.ipv4.ip_forward</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
<p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">sysctl -w net.ipv4.ip_forward=1</span></span><br></pre></td></tr></table></figure>
<p>如果在启动 Docker 服务的时候设定 —ip-forward=true, Docker 就会自动设定系统的 ip_forward 参数为 1。</p>
<h3 id="容器之间访问"><a href="#容器之间访问" class="headerlink" title="容器之间访问"></a>容器之间访问</h3><p>容器之间相互访问，需要两方面的支持。</p>
<p>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 docker0 网桥上。</p>
<p>本地系统的防火墙软件 — iptables 是否允许通过。</p>
<h3 id="访问所有端口"><a href="#访问所有端口" class="headerlink" title="访问所有端口"></a>访问所有端口</h3><p>当启动 Docker 服务时候，默认会添加一条转发策略到 iptables 的 FORWARD 链上。策略为通过（ACCEPT）还是禁止（DROP）取决于配置—icc=true（缺省值）还是 —icc=false。当然，如果手动指定 —iptables=false 则不会添加 iptables 规则。</p>
<p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 /etc/default/docker 文件中配置 DOCKER_OPTS=—icc=false 来禁止它。</p>
<h3 id="访问指定端口"><a href="#访问指定端口" class="headerlink" title="访问指定端口"></a>访问指定端口</h3><p>在通过 -icc=false 关闭网络访问后，还可以通过 —link=CONTAINER_NAME:ALIAS 选项来访问容器的开放端口。</p>
<p>例如，在启动 Docker 服务时，可以同时使用 icc=false —iptables=true 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 iptables 规则。</p>
<p>此时，系统中的 iptables 规则可能是类似</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> iptables -nL</span></span><br><span class="line">...</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>之后，启动容器（docker run）时使用 —link=CONTAINER_NAME:ALIAS 选项。Docker 会在 iptable 中为 两个容器分别添加一条 ACCEPT 规则，允许相互访问开放的端口（取决于 Dockerfile 中的 EXPOSE 行）。</p>
<p>当添加了 —link=CONTAINER_NAME:ALIAS 选项后，添加了 iptables 规则。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> iptables -nL</span></span><br><span class="line">...</span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">ACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80</span><br><span class="line">ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80</span><br><span class="line">DROP       all  --  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>
<p>注意：—link=CONTAINER_NAME:ALIAS 中的 CONTAINER_NAME 目前必须是 Docker 分配的名字，或使用 —name 参数指定的名字。主机名则不会被识别。</p>
<h3 id="Docker端口映射实现"><a href="#Docker端口映射实现" class="headerlink" title="Docker端口映射实现"></a>Docker端口映射实现</h3><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h3 id="容器访问外部实现"><a href="#容器访问外部实现" class="headerlink" title="容器访问外部实现"></a>容器访问外部实现</h3><p>容器所有到外部网络的连接，源地址都会被NAT成本地系统的IP地址。这是使用 iptables 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> iptables -t nat -nL</span></span><br><span class="line">...</span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>其中，上述规则将所有源地址在 172.17.0.0/16 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h3 id="外部访问容器实现"><a href="#外部访问容器实现" class="headerlink" title="外部访问容器实现"></a>外部访问容器实现</h3><p>容器允许外部访问，可以在 docker run 时候通过 -p 或 -P 参数来启用。</p>
<p>不管用那种办法，其实也是在本地的 iptable 的 nat 表中添加相应的规则。</p>
<p>使用 -P 时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t nat -nL</span></span><br><span class="line">...</span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>
<p>使用 -p 80:80 时：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t nat -nL</span></span><br><span class="line">Chain DOCKER (2 references)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>这里的规则映射了 0.0.0.0，意味着将接受主机来自所有接口的流量。用户可以通过 -p IP:host_port:container_port 或 -p IP::port 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</li>
<li>如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 /etc/default/docker 中指定 DOCKER_OPTS=”—ip=IP_ADDRESS”，之后重启 Docker 服务即可生效。</li>
</ul>
<h3 id="配置docker0网桥"><a href="#配置docker0网桥" class="headerlink" title="配置docker0网桥"></a>配置docker0网桥</h3><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<ul>
<li>—bip=CIDR — IP 地址加掩码格式，例如 192.168.1.5/24</li>
<li>—mtu=BYTES — 覆盖默认的 Docker mtu 配置</li>
</ul>
<p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</p>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 brctl show 来查看网桥和端口连接信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">docker0         8000.3a1d7362b4ee       no              veth65f9</span><br><span class="line">                                             vethdda6</span><br></pre></td></tr></table></figure>
<p>*注：brctl 命令在 Debian、Ubuntu 中可以使用 sudo apt-get install bridge-utils 来安装。</p>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> docker run -i -t --<span class="built_in">rm</span> base /bin/bash</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip addr show eth0</span></span><br><span class="line">24: eth0: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.3/16 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::306f:e0ff:fe35:5791/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip route</span></span><br><span class="line">default via 172.17.42.1 dev eth0</span><br><span class="line">172.17.0.0/16 dev eth0  proto kernel  scope link  src 172.17.0.3</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure>
<h3 id="Docker自定义网桥"><a href="#Docker自定义网桥" class="headerlink" title="Docker自定义网桥"></a>Docker自定义网桥</h3><p>除了默认的 docker0 网桥，用户也可以指定网桥来连接各个容器。</p>
<p>在启动 Docker 服务的时候，使用 -b BRIDGE或—bridge=BRIDGE 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> service docker stop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev docker0 down</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl delbr docker0</span></span><br></pre></td></tr></table></figure>
<p>然后创建一个网桥 bridge0。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> brctl addbr bridge0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip addr add 192.168.5.1/24 dev bridge0</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> ip <span class="built_in">link</span> <span class="built_in">set</span> dev bridge0 up</span></span><br></pre></td></tr></table></figure>
<p>查看确认网桥创建并启动。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip addr show bridge0</span></span><br><span class="line">4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</span><br><span class="line">    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.5.1/24 scope global bridge0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>配置 Docker 服务，默认桥接到创建的网桥上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;DOCKER_OPTS=&quot;-b=bridge0&quot;&#x27;</span> &gt;&gt; /etc/default/docker</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> service docker start</span></span><br></pre></td></tr></table></figure>
<p>启动 Docker 服务。</p>
<p>新建一个容器，可以看到它已经桥接到了 bridge0 上。</p>
<p>可以继续用 brctl show 命令查看桥接的信息。另外，在容器中可以使用 ip addr 和 ip route 命令来查看 IP 地址配置和路由信息。</p>
<h3 id="容器网络访问原理"><a href="#容器网络访问原理" class="headerlink" title="容器网络访问原理"></a>容器网络访问原理</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616001.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616074.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>Docker 网络模式</p>
</blockquote>
<p>Docker支持五种网络模式 </p>
<p> bridge </p>
<p>默认网络，Docker启动后创建一个docker0网桥，默认创建的容器也是添加到这个网桥中；IP地址段是172.17.0.1/16 </p>
<p> host </p>
<p>容器不会获得一个独立的network namespace，而是与宿主机共用一个。 </p>
<p> none </p>
<p>获取独立的network namespace，但不为容器进行任何网络配置。 </p>
<p> container </p>
<p>与指定的容器使用同一个network namespace，网卡配置也都是相同的。 </p>
<p> 自定义 </p>
<p>自定义网桥，默认与bridge网络一样。</p>
<h3 id="—link"><a href="#—link" class="headerlink" title="—link"></a>—link</h3><p>通过容器名来实现互ping</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">exec</span> -it 容器名2 --<span class="built_in">link</span> 容器名1 容器名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">exec</span> -it 容器名2 ping 容器名1</span></span><br></pre></td></tr></table></figure>
<p>反过来，容器1 ping不通容器2。  其实这个容器2就是在本地配置了容器1的配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看hosts配置，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker <span class="built_in">exec</span> -it 容器2 <span class="built_in">cat</span> /etc/hosts</span></span><br></pre></td></tr></table></figure>
<p>本质探究：—link就是在hosts配置中增加了一个地址</p>
<p>自定义网络，不适用docker0</p>
<p>docker问题:不支持容器名连接访问</p>
<h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>查看所有的网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure>
<p>网络模式</p>
<p>bridge：桥接docker（默认）</p>
<p>none：不配置网络</p>
<p>host：和宿主机共享网络</p>
<p>container：容器网络连通（用的少，局限很大）</p>
<p>自定义一个网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker network create --driver bridge --subnet 子网 --gateway 网关 网络名</span></span><br></pre></td></tr></table></figure>
<h3 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h3><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616340.png" alt="在这里插入图片描述"></p>
<p>实现tomcat-01 连接tomcat-net-01</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker network connect 网络名 容器名</span></span><br></pre></td></tr></table></figure>
<h1 id="Docker安全"><a href="#Docker安全" class="headerlink" title="Docker安全"></a>Docker安全</h1><p>评估 Docker 的安全性时，主要考虑三个方面:</p>
<ul>
<li>由内核的名字空间和控制组机制提供的容器内在安全</li>
<li>Docker程序（特别是服务端）本身的抗攻击性</li>
<li>内核安全性的加强机制对容器安全性的影响</li>
</ul>
<h3 id="内核名字空间"><a href="#内核名字空间" class="headerlink" title="内核名字空间"></a>内核名字空间</h3><p>Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。当用 docker run 启动一个容器时，在后台 Docker 为容器创建了一个独立的名字空间和控制组集合。</p>
<p>名字空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其它容器发现和作用。</p>
<p>每个容器都有自己独有的网络栈，意味着它们不能访问其他容器的 sockets 或接口。不过，如果主机系统上做了相应的设置，容器可以像跟主机交互一样的和其他容器交互。当指定公共端口或使用 links 来连接 2 个容器时，容器就可以相互通信了（可以根据配置来限制通信的策略）。</p>
<p>从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理机器通过物理交换机通信一样。</p>
<p>那么，内核中实现名字空间和私有网络的代码是否足够成熟？</p>
<p>内核名字空间从 2.6.15 版本（2008 年 7 月发布）之后被引入，数年间，这些机制的可靠性在诸多大型生产系统中被实践验证。</p>
<p>实际上，名字空间的想法和设计提出的时间要更早，最初是为了在内核中引入一种机制来实现 OpenVZ 的特性。</p>
<p>而 OpenVZ 项目早在 2005 年就发布了，其设计和实现都已经十分成熟。</p>
<h3 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h3><p>控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。</p>
<p>它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、CPU、磁盘 IO 等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p>
<p>尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务（DDOS）攻击方面是必不可少的。尤其是在多用户的平台（比如公有或私有的 PaaS）上，控制组十分重要。例如，当某些应用程序表现异常的时候，可以保证一致地正常运行和性能。</p>
<p>控制组机制始于 2006 年，内核从 2.6.24 版本开始被引入。</p>
<h3 id="Docker服务端的防护"><a href="#Docker服务端的防护" class="headerlink" title="Docker服务端的防护"></a>Docker服务端的防护</h3><p>运行一个容器或应用程序的核心是通过 Docker 服务端。Docker 服务的运行目前需要 root 权限，因此其安全性十分关键。</p>
<p>首先，确保只有可信的用户才可以访问 Docker 服务。Docker 允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限制。例如，恶意用户启动容器的时候将主机的根目录/映射到容器的 /host 目录中，那么容器理论上就可以对主机的文件系统进行任意修改了。这听起来很疯狂？但是事实上几乎所有虚拟化系统都允许类似的资源共享，而没法禁止用户共享主机根文件系统到虚拟机系统。</p>
<p>这将会造成很严重的安全后果。因此，当提供容器创建服务时（例如通过一个 web 服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一些破坏性的容器</p>
<p>为了加强对服务端的保护，Docker 的 REST API（客户端用来跟服务端通信）在 0.5.2 之后使用本地的 Unix 套接字机制替代了原先绑定在 127.0.0.1 上的 TCP 套接字，因为后者容易遭受跨站脚本攻击。现在用户使用 Unix 权限检查来加强套接字的访问安全。</p>
<p>用户仍可以利用 HTTP 提供 REST API 访问。建议使用安全机制，确保只有可信的网络或 VPN，或证书保护机制（例如受保护的 stunnel 和 ssl 认证）下的访问可以进行。此外，还可以使用 HTTPS 和证书来加强保护。</p>
<p>最近改进的 Linux 名字空间机制将可以实现使用非 root 用户来运行全功能的容器。这将从根本上解决了容器和主机之间共享文件系统而引起的安全问题。</p>
<p>终极目标是改进 2 个重要的安全特性：</p>
<ul>
<li>将容器的 root 用户映射到本地主机上的非 root 用户，减轻容器和主机之间因权限提升而引起的安全问题；</li>
<li>允许 Docker 服务端在非 root 权限下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</li>
</ul>
<p>最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容器中去运行。</p>
<h3 id="内核能力机制"><a href="#内核能力机制" class="headerlink" title="内核能力机制"></a>内核能力机制</h3><p>能力机制（Capability）是 Linux 内核一个强大的特性，可以提供细粒度的权限访问控制。</p>
<p>Linux 内核自 2.2 版本起就支持能力机制，它将权限划分为更加细粒度的操作能力，既可以作用在进程上，也可以作用在文件上。</p>
<p>例如，一个 Web 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 root 权限。那么它只需要被授权 net_bind_service 能力即可。此外，还有很多其他的类似能力来避免进程获取 root 权限。</p>
<p>默认情况下，Docker 启动的容器被严格限制只允许使用内核的一部分能力。</p>
<p>使用能力机制对加强 Docker 容器的安全有很多好处。通常，在服务器上会运行一堆需要特权权限的进程，包括有 ssh、cron、syslogd、硬件管理工具模块（例如负载模块）、网络配置工具等等。容器跟这些进程是不同的，因为几乎所有的特权进程都由容器以外的支持系统来进行管理。</p>
<ul>
<li>ssh 访问被主机上ssh服务来管理；</li>
<li>cron 通常应该作为用户进程执行，权限交给使用它服务的应用来处理；</li>
<li>日志系统可由 Docker 或第三方服务管理；</li>
<li>硬件管理无关紧要，容器中也就无需执行 udevd 以及类似服务；</li>
<li>网络管理也都在主机上设置，除非特殊需求，容器不需要对网络进行配置。</li>
</ul>
<p>从上面的例子可以看出，大部分情况下，容器并不需要“真正的” root 权限，容器只需要少数的能力即可。为了加强安全，容器可以禁用一些没必要的权限。</p>
<ul>
<li>完全禁止任何 mount 操作；</li>
<li>禁止直接访问本地主机的套接字；</li>
<li>禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；</li>
<li>禁止模块加载。</li>
</ul>
<p>这样，就算攻击者在容器中取得了 root 权限，也不能获得本地主机的较高权限，能进行的破坏也有限。</p>
<p>默认情况下，Docker采用 白名单 机制，禁用 必需功能 之外的其它权限。</p>
<p>当然，用户也可以根据自身需求来为 Docker 容器启用额外的权限。</p>
<h3 id="其它安全特性"><a href="#其它安全特性" class="headerlink" title="其它安全特性"></a>其它安全特性</h3><p>除了能力机制之外，还可以利用一些现有的安全机制来增强使用 Docker 的安全性，例如 TOMOYO, AppArmor, SELinux, GRSEC 等。</p>
<p>Docker 当前默认只启用了能力机制。用户可以采用多种方案来加强 Docker 主机的安全，例如：</p>
<ul>
<li>在内核中启用 GRSEC 和 PAX，这将增加很多编译和运行时的安全检查；通过地址随机化避免恶意探测等。并且，启用该特性不需要 Docker 进行任何配置。</li>
<li>使用一些有增强安全特性的容器模板，比如带 AppArmor 的模板和 Redhat 带 SELinux 策略的模板。这些模板提供了额外的安全特性。</li>
<li>用户可以自定义访问控制机制来定制安全策略。</li>
</ul>
<p>跟其它添加到 Docker 容器的第三方工具一样（比如网络拓扑和文件系统共享），有很多类似的机制，在不改变 Docker 内核情况下就可以加固现有的容器。</p>
<p>总体来看，Docker 容器还是十分安全的，特别是在容器内不使用 root 权限来运行进程的话。</p>
<p>另外，用户可以使用现有工具，比如 Apparmor, SELinux, GRSEC 来增强安全性；甚至自己在内核中实现更复杂的安全机制。</p>
<h3 id="Prometheus监控Docker主机"><a href="#Prometheus监控Docker主机" class="headerlink" title="Prometheus监控Docker主机"></a>Prometheus监控Docker主机</h3><h4 id="Prometheus-概述"><a href="#Prometheus-概述" class="headerlink" title="Prometheus 概述"></a>Prometheus 概述</h4><p>Prometheus（普罗米修斯）是一个最初在SoundCloud上构建的监控系统。自2012年成为社区 开源项目，拥有非常活跃的开发人员和用户社区。为强调开源及独立维护，Prometheus于2016 年加入云原生云计算基金会（CNCF），成为继Kubernetes之后的第二个托管项目。</p>
<p> <a target="_blank" rel="noopener" href="https://prometheus.io">https://prometheus.io</a> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/prometheus">https://github.com/prometheus</a></p>
<p>Prometheus 特点： </p>
<p>• 多维数据模型：由度量名称和键值对标识的时间序列数据 </p>
<p>• PromQL：一种灵活的查询语言，可以利用多维数据完成复杂的查询 </p>
<p>• 不依赖分布式存储，单个服务器节点可直接工作 </p>
<p>• 基于HTTP的pull方式采集时间序列数据 </p>
<p>• 推送时间序列数据通过PushGateway组件支持 </p>
<p>• 通过服务发现或静态配置发现目标 </p>
<p>• 多种图形模式及仪表盘支持（grafana）</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241616746.png" alt="在这里插入图片描述"></p>
<p>•Prometheus Server：收集指标和存储时间序列数据，并提供查询接口 </p>
<p>• ClientLibrary：客户端库 </p>
<p>• Push Gateway：短期存储指标数据。主要用于临时性的任务 </p>
<p>• Exporters：采集已有的第三方服务监控指标并暴露metrics </p>
<p>• Alertmanager：告警 </p>
<p>• Web UI：简单的Web控制台</p>
<h4 id="Prometheus-部署"><a href="#Prometheus-部署" class="headerlink" title="Prometheus 部署"></a>Prometheus 部署</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Docker部署：https://prometheus.io/docs/prometheus/latest/installation/</span><br><span class="line">docker run -d \</span><br><span class="line">--name=prometheus \</span><br><span class="line">-p 9090:9090 \</span><br><span class="line">-v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">prom/prometheus</span><br></pre></td></tr></table></figure>
<h3 id="构建容器监控系统"><a href="#构建容器监控系统" class="headerlink" title="构建容器监控系统"></a>构建容器监控系统</h3><h4 id="cAdvisor-InfluxDB-Grafana"><a href="#cAdvisor-InfluxDB-Grafana" class="headerlink" title="cAdvisor+InfluxDB+Grafana"></a>cAdvisor+InfluxDB+Grafana</h4><p>cAdvisor：Google开源的工具，用于监控Docker主机和容器系统资源，通过图形页面实时显示数据，但不存储；它通过 宿主机/proc、/sys、/var/lib/docker等目录下文件获取宿主机和容器运行信息。 InfluxDB：是一个分布式的时间序列数据库，用来存储cAdvisor收集的系统资源数据。 Grafana：可视化展示平台，可做仪表盘，并图表页面操作很方面，数据源支持zabbix、Graphite、InfluxDB、 OpenTSDB、Elasticsearch等 </p>
<p>它们之间关系： cAdvisor容器数据采集-&gt;InfluxDB容器数据存储-&gt;Grafana可视化展示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">部署</span><br><span class="line">influxdb</span><br><span class="line">docker run \</span><br><span class="line">-d \</span><br><span class="line">-p 8083:8083 \</span><br><span class="line">-p 8086:8086 \</span><br><span class="line">--name influxdb tutum/influxdb</span><br><span class="line"></span><br><span class="line">cadvisor</span><br><span class="line">docker run -d \</span><br><span class="line">--volume=/:/rootfs:ro \</span><br><span class="line">--volume=/var/run:/var/run:rw \</span><br><span class="line">--volume=/sys:/sys:ro \</span><br><span class="line">--volume=/var/lib/docker/:/var/lib/docker:ro \</span><br><span class="line">--<span class="built_in">link</span> influxdb:influxdb \</span><br><span class="line">-p 8081:8080 \</span><br><span class="line">--name=cadvisor \</span><br><span class="line">google/cadvisor:latest \</span><br><span class="line">-storage_driver=influxdb \</span><br><span class="line">-storage_driver_db=cadvisor \</span><br><span class="line">-storage_driver_host=influxdb:8086</span><br><span class="line"></span><br><span class="line">grafana</span><br><span class="line">docker run -d \</span><br><span class="line">-p 3000:3000 \</span><br><span class="line">-e INFLUXDB_HOST=influxdb \</span><br><span class="line">-e INFLUXDB_PORT=8086 \</span><br><span class="line">-e INFLUXDB_NAME=cadvisor \</span><br><span class="line">-e INFLUXDB_USER=cadvisor \</span><br><span class="line">-e INFLUXDB_PASS=cadvisor \</span><br><span class="line">--<span class="built_in">link</span> influxdb:influxsrv \</span><br><span class="line">--name grafana \</span><br><span class="line">grafana/grafana</span><br></pre></td></tr></table></figure>
<h1 id="企业级镜像仓库Harbor"><a href="#企业级镜像仓库Harbor" class="headerlink" title="企业级镜像仓库Harbor"></a>企业级镜像仓库Harbor</h1><h3 id="Harbor概述"><a href="#Harbor概述" class="headerlink" title="Harbor概述"></a>Harbor概述</h3><p>Habor是由VMWare公司开源的容器镜像仓库。事实上，Habor是在Docker Registry上进行了相应的 企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访 问控制 ，AD/LDAP集成以及审计日志等，足以满足基本企业需求。 官方地址：<a target="_blank" rel="noopener" href="https://vmware.github.io/harbor/cn/">https://vmware.github.io/harbor/cn/</a></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617342.png" alt="在这里插入图片描述"></p>
<h3 id="Harbor部署"><a href="#Harbor部署" class="headerlink" title="Harbor部署"></a>Harbor部署</h3><p>Harbor安装有3种方式：</p>
<p> • 在线安装：从Docker Hub下载Harbor相关镜像，因此安装软件包非常小 </p>
<p>• 离线安装：安装包包含部署的相关镜像，因此安装包比较大 </p>
<p>• OVA安装程序：当用户具有vCenter环境时，使用此安装程序，在部署OVA后启动Harbor</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tar zxvf harbor-offline-installer-v1.6.1.tgz</span></span><br><span class="line"><span class="comment"># cd harbor</span></span><br><span class="line"><span class="comment"># vi harbor.cfg</span></span><br><span class="line">hostname = 10.206.240.188</span><br><span class="line">ui_url_protocol = http</span><br><span class="line">harbor_admin_password = 123456</span><br><span class="line"><span class="comment"># ./prepare</span></span><br><span class="line"><span class="comment"># ./install.sh</span></span><br></pre></td></tr></table></figure>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、配置http镜像仓库可信任</span><br><span class="line"><span class="comment"># vi /etc/docker/daemon.json</span></span><br><span class="line">&#123;<span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;reg.ctnrs.com&quot;</span>]&#125;</span><br><span class="line"><span class="comment"># systemctl restart docker</span></span><br><span class="line">2、打标签</span><br><span class="line"><span class="comment"># docker tag centos:6 reg.ctnrs.com/library/centos:6</span></span><br><span class="line">3、上传</span><br><span class="line"><span class="comment"># docker push reg.ctnrs.com/library/centos:6</span></span><br><span class="line">4、下载</span><br><span class="line"><span class="comment"># docker pull reg.ctnrs.com/library/centos:6</span></span><br></pre></td></tr></table></figure>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h1><p>Docker-compose是用于定义和运行多容器 Docker 应用程序的工具。使用”Docker-compose”，您可以使用 YAML 文件来配置应用程序的服务。然后，通过单个命令，从配置创建和启动所有服务。</p>
<p>在所有环境中Docker-compose作品：生产、暂存、开发、测试以及 CI 工作流。</p>
<p>使用Docker-compose基本上是一个三步过程：</p>
<ol>
<li>使用 定义应用的环境，以便可以在任何地方复制。<code>Dockerfile</code></li>
<li>定义在中管理应用的服务，以便它们可以在隔离环境中一起运行。<code>docker-compose.yml</code></li>
<li>运行和Docker-compose启动并运行整个应用。<code>docker-compose up</code></li>
</ol>
<h3 id="下载并安装Docker-Compose"><a href="#下载并安装Docker-Compose" class="headerlink" title="下载并安装Docker-Compose"></a>下载并安装<strong>Docker-Compose</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.	官方下载（下载很慢）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.27.4/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span></span><br><span class="line">2.快速下载</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span></span><br><span class="line">3.Docke-compose设置权文件的权限</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span></span><br><span class="line">4。测试</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker-compose version</span></span><br><span class="line">5.配置环境变量（可以省略）</span><br><span class="line">  方便后期操作，配置一个环境变量</span><br><span class="line">   将docker-compose文件移动到了/usr/local/bin，修改了/etc/profile文件，给/usr/local/bin配置到了PATH中</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="built_in">mv</span> docker-compose /usr/local/bin</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">vi /etc/profile</span></span><br><span class="line">  添加内容：export PATH=$JAVA_HOME:/usr/local/bin:$PATH</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br><span class="line">6.卸载</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">rm</span> /usr/local/bin/docker-compose</span></span><br></pre></td></tr></table></figure>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p>python应用：计数器。</p>
<p>1.应用app.py</p>
<p>2.Dockerfile应用打包为镜像</p>
<p>3.Docker-compose yaml文件（定义整个服务依赖的环境，web，redis，完整的上线服务）</p>
<p>4.启动compose项目</p>
<ol>
<li><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">yum install python-pip   <span class="comment">#pip是python包管理工具</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">yum install epel-release  <span class="comment">#报错的话执行</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="为项目创建目录"><a href="#为项目创建目录" class="headerlink" title="为项目创建目录"></a>为项目创建目录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">mkdir</span> composetest</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cd</span> composetest</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="在项目目录中创建一个名为app-py文件，内容如下"><a href="#在项目目录中创建一个名为app-py文件，内容如下" class="headerlink" title="在项目目录中创建一个名为app.py文件，内容如下"></a>在项目目录中创建一个名为app.py文件，内容如下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">import redis</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)</span><br><span class="line"></span><br><span class="line">def get_hit_count():</span><br><span class="line">    retries = 5</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            return cache.incr(&#x27;hits&#x27;)</span><br><span class="line">        except redis.exceptions.ConnectionError as exc:</span><br><span class="line">            if retries == 0:</span><br><span class="line">                raise exc</span><br><span class="line">            retries -= 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    return &#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;.format(count)</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="在项目目录中创建一个名为requirements-txt文件，内容如下"><a href="#在项目目录中创建一个名为requirements-txt文件，内容如下" class="headerlink" title="在项目目录中创建一个名为requirements.txt文件，内容如下"></a>在项目目录中创建一个名为requirements.txt文件，内容如下</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="在项目目录中创建一个名为Dockerfile文件"><a href="#在项目目录中创建一个名为Dockerfile文件" class="headerlink" title="在项目目录中创建一个名为Dockerfile文件"></a>在项目目录中创建一个名为Dockerfile文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这告诉docker</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  从Python 3.6镜像开始构建镜像。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	将当前目录添加. 到/code镜像中的路径中。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	将工作目录设置为/code</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	安装Python依赖项</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	将容器的默认命令设置为python app.py.</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="在项目目录中创建一个名为docker-compose-yml文件"><a href="#在项目目录中创建一个名为docker-compose-yml文件" class="headerlink" title="在项目目录中创建一个名为docker-compose.yml文件"></a>在项目目录中创建一个名为docker-compose.yml文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5000:5000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - .:/code</span><br><span class="line">  redis:</span><br><span class="line">    image: &quot;redis:alpine&quot;</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此Compose文件定义了俩个服务，web和redis。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用从Dockerfile当前目录中构建的图像</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将容器上的公共端口5000转发到主机上的端口5000。我们使用Flask Web服务器的默认端口5000</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该redis服务使用从Docker Hub注册表中提取的公共 Redis镜像</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="使用Compose构建和运行应用程序，在项目目录中，通过运行docker-compose-up-启动应用程序"><a href="#使用Compose构建和运行应用程序，在项目目录中，通过运行docker-compose-up-启动应用程序" class="headerlink" title="使用Compose构建和运行应用程序，在项目目录中，通过运行docker-compose up 启动应用程序"></a>使用Compose构建和运行应用程序，在项目目录中，通过运行docker-compose up 启动应用程序</h5></li>
<li><h5 id="YAML文件格式及编写注意事项"><a href="#YAML文件格式及编写注意事项" class="headerlink" title="YAML文件格式及编写注意事项"></a>YAML文件格式及编写注意事项</h5><p>YAML是一种标记语言很直观的数据序列化格式，可读性高。类似于XML数据描述语言，语法比XML简单的很多。 YAML数据结构通过缩进来表示，连续的项目通过减号来表示，键值对用冒号分隔，数组用中括号括起来，hash用花括号括起 来。 </p>
<p>YAML文件格式注意事项： </p>
<ol>
<li>不支持制表符tab键缩进，需要使用空格缩进 </li>
<li>通常开头缩进2个空格 </li>
<li>字符后缩进1个空格，如冒号、逗号、横杆 </li>
<li>用井号注释  </li>
<li>如果包含特殊字符用单引号引起来 </li>
<li>布尔值（true、false、yes、no、on、off）必须用引号括起来，这样分析器会将他们解释为字符串。</li>
</ol>
</li>
</ol>
<h3 id="Docker-Compose管理MySQL和Tomcat容器"><a href="#Docker-Compose管理MySQL和Tomcat容器" class="headerlink" title="Docker-Compose管理MySQL和Tomcat容器"></a>Docker-Compose管理MySQL和Tomcat容器</h3><p>yaml文件编辑</p>
<p>官方案例（<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples）">https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples）</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yml文件以key:value方式来指定配置信息</span><br><span class="line">多个配置信息以换行+缩进的方式来区分</span><br><span class="line">在docker-compose.yml文件中，不要使用制表符 </span><br><span class="line">version: &#x27;3.1&#x27;</span><br><span class="line">services:</span><br><span class="line">  mysql:           # 服务的名称</span><br><span class="line">    restart: always   # 代表只要docker启动，那么这个容器就跟着一起启动</span><br><span class="line">    image: daocloud.io/library/mysql:5.7.4  # 指定镜像路径</span><br><span class="line">    container_name: mysql  # 指定容器名称</span><br><span class="line">    ports:</span><br><span class="line">      - 3306:3306   #  指定端口号的映射</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: root   # 指定MySQL的ROOT用户登录密码</span><br><span class="line">      TZ: Asia/Shanghai        # 指定时区</span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/docker_mysql_tomcat/mysql_data:/var/lib/mysql   # 映射数据卷</span><br><span class="line">  tomcat:</span><br><span class="line">    restart: always</span><br><span class="line">    image: daocloud.io/library/tomcat:8.5.15-jre8</span><br><span class="line">    container_name: tomcat</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/docker_mysql_tomcat/tomcat_webapps:/usr/local/tomcat/webapps</span><br><span class="line">      - /opt/docker_mysql_tomcat/tomcat_logs:/usr/local/tomcat/logs</span><br></pre></td></tr></table></figure>
<h3 id="使用docker-compose命令管理容器"><a href="#使用docker-compose命令管理容器" class="headerlink" title="使用docker-compose命令管理容器"></a>使用docker-compose命令管理容器</h3><p>在使用docker-compose的命令时，默认会在当前目录下找docker-compose.yml文件</p>
<ol>
<li><h5 id="基于docker-compose-yml启动管理的容器"><a href="#基于docker-compose-yml启动管理的容器" class="headerlink" title="基于docker-compose.yml启动管理的容器"></a>基于docker-compose.yml启动管理的容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker-compose up -d</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="关闭并删除容器"><a href="#关闭并删除容器" class="headerlink" title="关闭并删除容器"></a>关闭并删除容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker-compose down</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="开启-关闭-重启容器"><a href="#开启-关闭-重启容器" class="headerlink" title="开启|关闭|重启容器"></a>开启|关闭|重启容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker-compose start|stop|restart</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="查看由docker-compose管理的容器"><a href="#查看由docker-compose管理的容器" class="headerlink" title="查看由docker-compose管理的容器"></a>查看由docker-compose管理的容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker-compose ps</span></span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#docker-compose logs -f</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="docker-compose配合Dockerfile使用（统一在-opt目录下操作）"><a href="#docker-compose配合Dockerfile使用（统一在-opt目录下操作）" class="headerlink" title="docker-compose配合Dockerfile使用（统一在/opt目录下操作）"></a>docker-compose配合Dockerfile使用（统一在/opt目录下操作）</h3><p>使用docker-compose.yml文件以及Dockerfile文件在生成自定义镜像的同时启动当前镜像，并且由docker-compose去管理容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.首先生成一个文件夹，在其内编写docker-compose.yml文件 </span><br><span class="line">version: &#x27;3.1&#x27;</span><br><span class="line">services:</span><br><span class="line">  ssm:</span><br><span class="line">  restart: always</span><br><span class="line">  build:            # 构建自定义镜像</span><br><span class="line">    context: ../      # 指定dockerfile文件的所在路径</span><br><span class="line">    dockerfile: Dockerfile   # 指定Dockerfile文件名称</span><br><span class="line">  image: ssm:1.0.1</span><br><span class="line">  container_name: ssm</span><br><span class="line">  ports:</span><br><span class="line">    - 8081:8080</span><br><span class="line">  environment:</span><br><span class="line">    TZ: Asia/Shanghai</span><br><span class="line">2.编写Dockerfile文件</span><br><span class="line">from docker.io/nginx:latest</span><br><span class="line">copy index.html /usr/share/nginx/html</span><br><span class="line">3.编写index.html(随意编写一个静态网页文件)</span><br><span class="line">4.运行</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h3 id="docker-compose说明"><a href="#docker-compose说明" class="headerlink" title="docker-compose说明"></a>docker-compose说明</h3><p>管理控制容器或是镜像的工具</p>
<ol>
<li><h5 id="管理控制容器"><a href="#管理控制容器" class="headerlink" title="管理控制容器"></a>管理控制容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">直接使用docker-compose.yml文件</span><br><span class="line">	文件的结构</span><br><span class="line">version：版本</span><br><span class="line">services： 服务内容（可以同时存在多个服务）</span><br><span class="line">  servicesname: 服务名称，下级放的是服务相关的属性和设置（如  myweb）</span><br><span class="line">	restart:  服务启动的时机</span><br><span class="line">	image: 创建容器时使用的镜像</span><br><span class="line">    container_name：创建后容器的名称</span><br><span class="line">	ports: 服务涉及到端口（不能和系统中的端口冲突）</span><br><span class="line">	  - 宿主机端口：容器端口</span><br><span class="line">	volumes：指定容器挂载的数据卷</span><br><span class="line">	  - 宿主机路径：容器内的路径</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="管理控制镜像（需要Dockerfile文件的支撑）"><a href="#管理控制镜像（需要Dockerfile文件的支撑）" class="headerlink" title="管理控制镜像（需要Dockerfile文件的支撑）"></a>管理控制镜像（需要Dockerfile文件的支撑）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 创建 Dockerfile文件</span><br><span class="line">	from：指定当前自定义镜像依赖的环境</span><br><span class="line">	copy：将相对路径下的内容复制到自定义镜像中</span><br><span class="line">	workdir：声明镜像的默认工作目录</span><br><span class="line">	run：执行的命令，可以编写多个</span><br><span class="line">	cmd：需要执行的命令（在workdir下执行的，cmd可以写多个，只以最后一个为准）</span><br><span class="line">2 创建Docker-compose.yml文件去调用Dockerfile生成镜像</span><br><span class="line">	version:&#x27;3.1&#x27;   版本</span><br><span class="line">	services:       服务   </span><br><span class="line">	  ssm:          服务名称</span><br><span class="line">		restart:    启动时机</span><br><span class="line">		build:      # 构建自定义镜像时使用  </span><br><span class="line">		  context:../# 指定dockerfile文件的所在路径（相对）    </span><br><span class="line">		  dockerfile:Dockerfile# 指定Dockerfile文件名称 </span><br><span class="line">		image: ssm:1.0.1      #生成后自定义镜像的名称   </span><br><span class="line">		container_name:ssm    #容器名称    </span><br><span class="line">		ports:                    </span><br><span class="line">		  -8081:8080                </span><br><span class="line">		environment:          #系统环境 （语言，时区等的设置）    </span><br><span class="line">		  TZ:Asia/Shanghai</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p>搭建博客（<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/wordpress/）">https://docs.docker.com/compose/wordpress/）</a></p>
<h3 id="Docker-Compose项目"><a href="#Docker-Compose项目" class="headerlink" title="Docker Compose项目"></a>Docker Compose项目</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>首先介绍几个术语。</p>
<p>服务（service）：一个应用容器，实际上可以运行多个相同镜像的实例。</p>
<p>项目(project)：由一组关联的应用容器组成的一个完整业务单元。</p>
<p>可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>下面，我们创建一个经典的 Web 项目：一个 Haproxy，挂载三个 Web 容器。</p>
<p>创建一个 compose-haproxy-web 目录，作为项目工作目录，并在其中分别创建两个子目录：haproxy 和 web。</p>
<h4 id="Web-子目录"><a href="#Web-子目录" class="headerlink" title="Web 子目录"></a>Web 子目录</h4><p>这里用 Python 程序来提供一个简单的 HTTP 服务，打印出访问者的 IP 和 实际的本地 IP。</p>
<h6 id="index-py"><a href="#index-py" class="headerlink" title="index.py"></a>index.py</h6><p>编写一个 index.py 作为服务器文件，代码为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/python</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">authors: yeasy.github.com</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">date</span>: 2013-07-05</span></span><br><span class="line">import sys</span><br><span class="line">import BaseHTTPServer</span><br><span class="line">from SimpleHTTPServer import SimpleHTTPRequestHandler</span><br><span class="line">import socket</span><br><span class="line">import fcntl</span><br><span class="line">import struct</span><br><span class="line">import pickle</span><br><span class="line">from datetime import datetime</span><br><span class="line">from collections import OrderedDict</span><br><span class="line">class HandlerClass(SimpleHTTPRequestHandler):</span><br><span class="line">    def get_ip_address(self,ifname):</span><br><span class="line">        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">        return socket.inet_ntoa(fcntl.ioctl(</span><br><span class="line">            s.fileno(),</span><br><span class="line">            0x8915,  # SIOCGIFADDR</span><br><span class="line">            struct.pack(&#x27;256s&#x27;, ifname[:15])</span><br><span class="line">        )[20:24])</span><br><span class="line">    def log_message(self, format, *args):</span><br><span class="line">        if len(args) &lt; 3 or &quot;200&quot; not in args[1]:</span><br><span class="line">            return</span><br><span class="line">        try:</span><br><span class="line">            request = pickle.load(open(&quot;pickle_data.txt&quot;,&quot;r&quot;))</span><br><span class="line">        except:</span><br><span class="line">            request=OrderedDict()</span><br><span class="line">        time_now = datetime.now()</span><br><span class="line">        ts = time_now.strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)</span><br><span class="line">        server = self.get_ip_address(&#x27;eth0&#x27;)</span><br><span class="line">        host=self.address_string()</span><br><span class="line">        addr_pair = (host,server)</span><br><span class="line">        if addr_pair not in request:</span><br><span class="line">            request[addr_pair]=[1,ts]</span><br><span class="line">        else:</span><br><span class="line">            num = request[addr_pair][0]+1</span><br><span class="line">            del request[addr_pair]</span><br><span class="line">            request[addr_pair]=[num,ts]</span><br><span class="line">        file=open(&quot;index.html&quot;, &quot;w&quot;)</span><br><span class="line">        file.write(&quot;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt;&lt;center&gt;&lt;h1&gt;&lt;font color=\&quot;blue\&quot; face=\&quot;Georgia, Arial\&quot; size=8&gt;&lt;em&gt;HA&lt;/em&gt;&lt;/font&gt; Webpage Visit Results&lt;/h1&gt;&lt;/center&gt;&quot;);</span><br><span class="line">        for pair in request:</span><br><span class="line">            if pair[0] == host:</span><br><span class="line">                guest = &quot;LOCAL: &quot;+pair[0]</span><br><span class="line">            else:</span><br><span class="line">                guest = pair[0]</span><br><span class="line">            if (time_now-datetime.strptime(request[pair][1],&#x27;%Y-%m-%d %H:%M:%S&#x27;)).seconds &lt; 3:</span><br><span class="line">                file.write(&quot;&lt;p style=\&quot;font-size:150%\&quot; &gt;#&quot;+ str(request[pair][1]) +&quot;: &lt;font color=\&quot;red\&quot;&gt;&quot;+str(request[pair][0])+ &quot;&lt;/font&gt; requests &quot; + &quot;from &amp;lt&lt;font color=\&quot;blue\&quot;&gt;&quot;+guest+&quot;&lt;/font&gt;&amp;gt to WebServer &amp;lt&lt;font color=\&quot;blue\&quot;&gt;&quot;+pair[1]+&quot;&lt;/font&gt;&amp;gt&lt;/p&gt;&quot;)</span><br><span class="line">            else:</span><br><span class="line">                file.write(&quot;&lt;p style=\&quot;font-size:150%\&quot; &gt;#&quot;+ str(request[pair][1]) +&quot;: &lt;font color=\&quot;maroon\&quot;&gt;&quot;+str(request[pair][0])+ &quot;&lt;/font&gt; requests &quot; + &quot;from &amp;lt&lt;font color=\&quot;navy\&quot;&gt;&quot;+guest+&quot;&lt;/font&gt;&amp;gt to WebServer &amp;lt&lt;font color=\&quot;navy\&quot;&gt;&quot;+pair[1]+&quot;&lt;/font&gt;&amp;gt&lt;/p&gt;&quot;)</span><br><span class="line">        file.write(&quot;&lt;/body&gt; &lt;/html&gt;&quot;);</span><br><span class="line">        file.close()</span><br><span class="line">        pickle.dump(request,open(&quot;pickle_data.txt&quot;,&quot;w&quot;))</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try:</span><br><span class="line">        ServerClass  = BaseHTTPServer.HTTPServer</span><br><span class="line">        Protocol     = &quot;HTTP/1.0&quot;</span><br><span class="line">        addr = len(sys.argv) &lt; 2 and &quot;0.0.0.0&quot; or sys.argv[1]</span><br><span class="line">        port = len(sys.argv) &lt; 3 and 80 or int(sys.argv[2])</span><br><span class="line">        HandlerClass.protocol_version = Protocol</span><br><span class="line">        httpd = ServerClass((addr, port), HandlerClass)</span><br><span class="line">        sa = httpd.socket.getsockname()</span><br><span class="line">        print &quot;Serving HTTP on&quot;, sa[0], &quot;port&quot;, sa[1], &quot;...&quot;</span><br><span class="line">        httpd.serve_forever()</span><br><span class="line">    except:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure>
<h6 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h6><p>生成一个临时的 index.html 文件，其内容会被 index.py 更新。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">touch</span> index.html</span></span><br></pre></td></tr></table></figure>
<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>生成一个 Dockerfile，内容为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM python:2.7</span><br><span class="line">WORKDIR /code</span><br><span class="line">ADD . /code</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD python index.py</span><br></pre></td></tr></table></figure>
<h4 id="haproxy-目录"><a href="#haproxy-目录" class="headerlink" title="haproxy 目录"></a>haproxy 目录</h4><p>在其中生成一个 haproxy.cfg 文件，内容为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">  log 127.0.0.1 local0</span><br><span class="line">  log 127.0.0.1 local1 notice</span><br><span class="line">defaults</span><br><span class="line">  log global</span><br><span class="line">  mode http</span><br><span class="line">  option httplog</span><br><span class="line">  option dontlognull</span><br><span class="line">  timeout connect 5000ms</span><br><span class="line">  timeout client 50000ms</span><br><span class="line">  timeout server 50000ms</span><br><span class="line">listen stats :70</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /</span><br><span class="line">frontend balancer</span><br><span class="line">    bind 0.0.0.0:80</span><br><span class="line">    mode http</span><br><span class="line">    default_backend web_backends</span><br><span class="line">backend web_backends</span><br><span class="line">    mode http</span><br><span class="line">    option forwardfor</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server weba weba:80 check</span><br><span class="line">    server webb webb:80 check</span><br><span class="line">    server webc webc:80 check</span><br><span class="line">    option httpchk GET /</span><br><span class="line">    http-check expect status 200</span><br></pre></td></tr></table></figure>
<h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><p>编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。内容十分简单，指定 3 个 web 容器，以及 1 个 haproxy 容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">weba:</span><br><span class="line">    build: ./web</span><br><span class="line">    expose:</span><br><span class="line">        - 80</span><br><span class="line">webb:</span><br><span class="line">    build: ./web</span><br><span class="line">    expose:</span><br><span class="line">        - 80</span><br><span class="line">webc:</span><br><span class="line">    build: ./web</span><br><span class="line">    expose:</span><br><span class="line">        - 80</span><br><span class="line">haproxy:</span><br><span class="line">    image: haproxy:latest</span><br><span class="line">    volumes:</span><br><span class="line">        - haproxy:/haproxy-override</span><br><span class="line">        - haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro</span><br><span class="line">    links:</span><br><span class="line">        - weba</span><br><span class="line">        - webb</span><br><span class="line">        - webc</span><br><span class="line">    ports:</span><br><span class="line">        - &quot;80:80&quot;</span><br><span class="line">        - &quot;70:70&quot;</span><br><span class="line">    expose:</span><br><span class="line">        - &quot;80&quot;</span><br><span class="line">        - &quot;70&quot;</span><br></pre></td></tr></table></figure>
<h4 id="运行-compose-项目"><a href="#运行-compose-项目" class="headerlink" title="运行 compose 项目"></a>运行 compose 项目</h4><p>现在 compose-haproxy-web 目录长成下面的样子。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compose-haproxy-web</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── haproxy</span><br><span class="line">│   └── haproxy.cfg</span><br><span class="line">└── web</span><br><span class="line">    ├── Dockerfile</span><br><span class="line">    ├── index.html</span><br><span class="line">    └── index.py</span><br></pre></td></tr></table></figure>
<p>在该目录下执行 docker-compose up 命令，会整合输出所有容器的输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> docker-compose up</span><br><span class="line">Recreating composehaproxyweb_webb_1...</span><br><span class="line">Recreating composehaproxyweb_webc_1...</span><br><span class="line">Recreating composehaproxyweb_weba_1...</span><br><span class="line">Recreating composehaproxyweb_haproxy_1...</span><br><span class="line">Attaching to composehaproxyweb_webb_1, composehaproxyweb_webc_1, composehaproxyweb_weba_1, composehaproxyweb_haproxy_1</span><br></pre></td></tr></table></figure>
<p>此时访问本地的 80 端口，会经过 haproxy 自动转发到后端的某个 web 容器上，刷新页面，可以观察到访问的容器地址的变化。</p>
<p>访问本地 70 端口，可以查看到 haproxy 的统计信息。</p>
<p>当然，还可以使用 consul、etcd 等实现服务发现，这样就可以避免手动指定后端的 web 容器了，更为灵活。</p>
<h1 id="Docker-API"><a href="#Docker-API" class="headerlink" title="Docker API"></a>Docker API</h1><h3 id="三种API"><a href="#三种API" class="headerlink" title="三种API"></a>三种API</h3><p>在Docker的生态系统中，存在下列三种API：</p>
<p>Reistry API：与存储Docker镜像的Registry相关的功能。</p>
<p>Docker Hub API：与Docker Hub相关的功能</p>
<p>Docker Remote API：与Docker守护进程相关的功能。</p>
<p>其中，Docker Remote API是使用最为频繁的API类型</p>
<h3 id="启动Remote-API"><a href="#启动Remote-API" class="headerlink" title="启动Remote API"></a>启动Remote API</h3><p>Remote API主要用于远程访问Docker守护进程从而下达指令的。</p>
<p>因此，我们在启动Docker守护进程时，需要添加-H参数并指定开启的访问端口。 </p>
<p>通常，我们可以通过编辑守护进程的配置文件来实现。</p>
<p>不过对于不同操作系统而言，守护进程启动的配置文件也不尽相同：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu系统：/etc/default/docker文件</span><br><span class="line">Centos系统：/etc/sysconfig/docker文件</span><br><span class="line">在该配置文件最后，添加内容如下：</span><br><span class="line">OPTIONS=&#x27;-H=tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock&#x27;</span><br><span class="line">修改完成后执行如下命令，重启Docker守护进程：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">systemctl restart docker</span></span><br></pre></td></tr></table></figure>
<h3 id="测试Remote-API"><a href="#测试Remote-API" class="headerlink" title="测试Remote API"></a>测试Remote API</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker -H 127.0.0.1:2375 info</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617657.png" alt="在这里插入图片描述"></p>
<p>上面的试验中，我们已经确认了与Docker守护进程之间的连通性。</p>
<p>下面，我们来使用一些Remote API。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://127.0.0.1:2375/info</span></span><br></pre></td></tr></table></figure>
<p>从返回结果看，我们可以得到类似的docker info时的JSON格式的数据。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617606.png" alt="在这里插入图片描述"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过API管理Docker镜像</span><br><span class="line">调用/images/json接口可以获取镜像列表：</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://127.0.0.1:2375/images/json | python -mjson.tool</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617770.png" alt="在这里插入图片描述"></p>
<p>==<strong>Ps：通过python -mjson.tool可以将JSON数据格式化显示。</strong>==</p>
<h3 id="通过API管理Docker容器"><a href="#通过API管理Docker容器" class="headerlink" title="通过API管理Docker容器"></a>通过API管理Docker容器</h3><p>调用/containers/json接口可以获取正在运行中的容器列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://127.0.0.1:2375/containers/json | python -mjson.tool</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617843.png" alt="在这里插入图片描述"></p>
<p>如果想要查询全部的容器（包含不是正在运行的容器）时，可以调用如下接口：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://127.0.0.1:2375/containers/json?all=1 | python -mjson.tool</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617861.png" alt="在这里插入图片描述"></p>
<p>此外，我们还可以使用/containers/create以及/containers/start来创建和启动容器，从而实现docker run的功能。 </p>
<h3 id="创建容器："><a href="#创建容器：" class="headerlink" title="创建容器："></a>创建容器：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -X POST -H <span class="string">&quot;Content-Type:application/json&quot;</span> http://127.0.0.1:2375/containers/create -d <span class="string">&#x27;&#123;&quot;Image&quot;: &quot;docker.io/nginx&quot;&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617986.png" alt="image-20201029164800857.png"></p>
<h1 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h1><h3 id="安装consul"><a href="#安装consul" class="headerlink" title="安装consul"></a>安装consul</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull consul</span><br></pre></td></tr></table></figure>
<h3 id="启动服务-consul1"><a href="#启动服务-consul1" class="headerlink" title="启动服务:consul1"></a>启动服务:consul1</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name consul1 -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600 consul agent -server -bootstrap-expect 2 -ui -bind=0.0.0.0 -client=0.0.0.0</span><br></pre></td></tr></table></figure>
<p>8500 http 端口，用于 http 接口和 web ui</p>
<p>8300 server rpc 端口，同一数据中心 consul server 之间通过该端口通信</p>
<p>8301 serf lan 端口，同一数据中心 consul client 通过该端口通信</p>
<p>8302 serf wan 端口，不同数据中心 consul server 通过该端口通信</p>
<p>8600 dns 端口，用于服务发现</p>
<p>-bbostrap-expect 2: 集群至少两台服务器，才能选举集群leader</p>
<p>-ui：运行 web 控制台</p>
<p>-bind： 监听网口，0.0.0.0 表示所有网口，如果不指定默认未127.0.0.1，则无法和容器通信</p>
<p>-client ： 限制某些网口可以访问</p>
<h3 id="获取-consul-server1-的-ip-地址"><a href="#获取-consul-server1-的-ip-地址" class="headerlink" title="获取 consul server1 的 ip 地址"></a>获取 consul server1 的 ip 地址</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format =&#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; consul1</span><br></pre></td></tr></table></figure>
<h3 id="启动服务：consul2"><a href="#启动服务：consul2" class="headerlink" title="启动服务：consul2"></a>启动服务：consul2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name consul2 -d -p 8501:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 172.17.0.2</span><br></pre></td></tr></table></figure>
<h3 id="启动服务：consul3"><a href="#启动服务：consul3" class="headerlink" title="启动服务：consul3"></a>启动服务：consul3</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name consul3 -d -p 8502:8500 consul agent -server -ui -bind=0.0.0.0 -client=0.0.0.0 -join 172.17.0.2</span><br></pre></td></tr></table></figure>
<h3 id="第四第五略"><a href="#第四第五略" class="headerlink" title="第四第五略"></a>第四第五略</h3><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>宿主机浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8500">http://localhost:8500</a> 或者 <a target="_blank" rel="noopener" href="http://localhost:8501">http://localhost:8501</a> 或者 <a target="_blank" rel="noopener" href="http://localhost:8502">http://localhost:8502</a></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617381.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617722.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>提升</strong></p>
</blockquote>
<p>创建test.json文件，以脚本形式注册服务到consul：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">test.json文件内容如下：</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test-service1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test-service1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;test&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;v1&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Port&quot;</span><span class="punctuation">:</span> <span class="number">8000</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Meta&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;X-TAG&quot;</span><span class="punctuation">:</span> <span class="string">&quot;testtag&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;EnableTagOverride&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Check&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;DeregisterCriticalServiceAfter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;90m&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;HTTP&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://zhihu.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Interval&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10s&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过 http 接口注册服务（端口可以是8500. 8501， 8502等能够正常访问consul的就行）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT --data @test.json http://localhost:8500/v1/agent/service/register</span><br></pre></td></tr></table></figure>
<p>控制台如下所示：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241617382.png" alt="在这里插入图片描述"></p>
<p>宿主机浏览器访问以下链接可以看到所有通过健康检查的可用test-service1服务列表</p>
<p>（任意正常启动consul的端口皆可）：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8501/v1/health/service/test-service1?passing">http://localhost:8501/v1/health/service/test-service1?passing</a></p>
<p> 输出json格式的内容，如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201205185245708.png#pic_center" alt="在这里插入图片描述"></p>
<p>其它应用程序可以通过这种方式轮询获取服务列表，这就是微服务能够动态知道其依赖微服务可用列表的原理。</p>
<p> 解绑定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X PUT http://127.0.0.1:8501/v1/agent/service/deregister/test-service1</span><br></pre></td></tr></table></figure>
<p>集群方式需要至少启动两个consul server，本机调试web应用时，为了方便可以用 -dev 参数方式仅启动一个consul server</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name consul0 -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600 consul:1.2.2 agent -dev -bind=0.0.0.0 -client=0.0.0.0</span><br></pre></td></tr></table></figure>
<h1 id="Rancher"><a href="#Rancher" class="headerlink" title="Rancher"></a>Rancher</h1><h3 id="安装Rancher"><a href="#安装Rancher" class="headerlink" title="安装Rancher"></a>安装Rancher</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker search rancher</span><br><span class="line">docker pull docker.io/rancher/server</span><br><span class="line">docker pull docker.io/rancher/rancher</span><br><span class="line">docker pull docker.io/rancher/agent</span><br></pre></td></tr></table></figure>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --restart=always -p 8080:8080 rancher/server</span><br></pre></td></tr></table></figure>
<h3 id="查看ip地址"><a href="#查看ip地址" class="headerlink" title="查看ip地址"></a>查看ip地址</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure>
<h3 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip:8080</span><br></pre></td></tr></table></figure>
<p>登录到rancher官网，为安全起见，设置管理账户</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618577.png" alt="在这里插入图片描述"></p>
<p>然后进行添加主机操作，根据网站指引操作，生成一条命令，在docker中运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e CATTLE_AGENT_IP=&quot;192.168.200.131&quot;  --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock -v /var/lib/rancher:/var/lib/rancher rancher/agent:v1.2.11 http://192.168.200.131:8080/v1/scripts/6A5FD96A5C2385D994EF:1577750400000:HeMhHq8vWHgMCIHBJoFHGh8U </span><br></pre></td></tr></table></figure>
<p>当在宿主机中运行完成后，网站中会显示成功添加主机</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618918.png" alt="在这里插入图片描述"></p>
<p>Environment在Rancher中被定义为主要用于容器编排和管理的环境，比如Dev或者TEST或者PROD环境等等。<br>目前Rancher支持如下四种：Cattle/Kubernetes/Mesos/Swarm, Cattle是Rancher自己内置的缺省的编排环境，缺省的Default的即为Cattle类型的。</p>
<h3 id="案例：博客部署"><a href="#案例：博客部署" class="headerlink" title="案例：博客部署"></a>案例：博客部署</h3><p>（1）在rancher平台导航栏中，点击应用商店按钮，找到wordpress应用，点击查看详情，示例如图15所示：<br><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618472.png" alt="在这里插入图片描述"></p>
<p>（2）更改WordPress应用的端口号为8088，然后点击页面下方的启动按钮，示例如图16所示：<br> <img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618640.png" alt="在这里插入图片描述"></p>
<p>（3）等待一段时间后出现Active即创建成功，创建成功如图17所示，创建成功后，点击端口8088直接访问WordPress应用，如图18所示：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618388.png" alt="在这里插入图片描述"></p>
<h1 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h1><h3 id="Swarm介绍"><a href="#Swarm介绍" class="headerlink" title="Swarm介绍"></a>Swarm介绍</h3><p>Swarm是什么？ Swarm是Docker公司自研发的容器集群管理系统，Swarm在早期是作为一个独立服务存在，在Docker Engine v1.12中集成了 Swarm的集群管理和编排功能。可以通过初始化Swarm或加入现有Swarm来启用Docker引擎的Swarm模式。 Docker Engine CLI和API包括了管理Swarm节点命令，比如添加、删除节点，以及在Swarm中部署和编排服务。 也增加了服务栈（Stack）、服务（Service）、任务（Task）概念。 </p>
<p>Swarm两种角色： Manager：接收客户端服务定义，将任务发送到worker节点；维护集群期望状态和集群管理功能及Leader选举。默认情况下 manager节点也会运行任务，也可以配置只做管理任务。 Worker：接收并执行从管理节点分配的任务，并报告任务当前状态，以便管理节点维护每个服务期望状态。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618039.png" alt="在这里插入图片描述"></p>
<p>Swarm特点： </p>
<ol>
<li>Docker Engine集成集群管理 使用Docker Engine CLI 创建一个Docker Engine的Swarm模式，在集群中部署应用程序服务。 </li>
<li>去中心化设计 Swarm角色分为Manager和Worker节点，Manager节点故障不影响应用使用。 </li>
<li>扩容缩容 可以声明每个服务运行的容器数量，通过添加或删除容器数自动调整期望的状态。 </li>
<li>期望状态协调 Swarm Manager节点不断监视集群状态，并调整当前状态与期望状态之间的差异。例如，设置一个服务运行10个副本容器，如果两个副本的服 务器节点崩溃，Manager将创建两个新的副本替代崩溃的副本。并将新的副本分配到可用的worker节点。</li>
<li>多主机网络 可以为服务指定overlay网络。当初始化或更新应用程序时，Swarm manager会自动为overlay网络上的容器分配IP地址。</li>
<li>服务发现 Swarm manager节点为集群中的每个服务分配唯一的DNS记录和负载均衡VIP。可以通过Swarm内置的DNS服务器查询集群中每个运行的容器。 </li>
<li>负载均衡 实现服务副本负载均衡，提供入口访问。也可以将服务入口暴露给外部负载均衡器再次负载均衡。 </li>
<li>安全传输 Swarm中的每个节点使用TLS相互验证和加密，确保安全的其他节点通信。</li>
<li>滚动更新 升级时，逐步将应用服务更新到节点，如果出现问题，可以将任务回滚到先前版本。</li>
</ol>
<h3 id="集群部署及节点管理"><a href="#集群部署及节点管理" class="headerlink" title="集群部署及节点管理"></a>集群部署及节点管理</h3><h4 id="阿里云购买四台服务器"><a href="#阿里云购买四台服务器" class="headerlink" title="阿里云购买四台服务器"></a>阿里云购买四台服务器</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618033.png" alt="在这里插入图片描述"></p>
<h4 id="4台机器安装docker"><a href="#4台机器安装docker" class="headerlink" title="4台机器安装docker"></a>4台机器安装docker</h4><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618451.png" alt="在这里插入图片描述"></p>
<h4 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618677.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241618762.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241619808.png" alt="在这里插入图片描述"></p>
<p>初始化docker swarm init</p>
<p>docker swarm join 加入一个节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取令牌</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker swarm join-token manager</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker swarm join-token worker</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241619599.png" alt="在这里插入图片描述"><br>把其他节点也搭建进去</p>
<h1 id="Docker-swarm项目"><a href="#Docker-swarm项目" class="headerlink" title="Docker swarm项目"></a>Docker swarm项目</h1><h3 id="概念学习"><a href="#概念学习" class="headerlink" title="概念学习"></a>概念学习</h3><p>swarm</p>
<p>集的管理和编号, docker可以初始化一个 swarm集群,其他节点可以加入。(管理、工作者)</p>
<p>docker</p>
<p>Node就是一个节点。多个节点就组成了一个网路集,(管理、工作者)</p>
<p>Service</p>
<p>任务,可以在管理节点或者工作节点来运行。核心！用户访问。</p>
<p>Task</p>
<p>容器内的命令,细节任务</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241619912.png" alt="在这里插入图片描述"></p>
<p>命令-&gt;管理-&gt;API-&gt;调度-&gt;工作节点（创建Task容器维护创建）</p>
<h3 id="Docker-Swarm项目安装"><a href="#Docker-Swarm项目安装" class="headerlink" title="Docker Swarm项目安装"></a>Docker Swarm项目安装</h3><p>安装swarm的最简单的方式是使用Docker官方的swarm镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> docker pull swarm</span><br></pre></td></tr></table></figure>
<p>可以使用下面的命令来查看swarm是否成功安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> docker run —<span class="built_in">rm</span> swarm -v</span><br></pre></td></tr></table></figure>
<p>输出下面的形式则表示成功安装(具体输出根据swarm的版本变化)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swarm version 0.2.0 (48fd993)</span><br></pre></td></tr></table></figure>
<h3 id="Docker-Swarm项目使用"><a href="#Docker-Swarm项目使用" class="headerlink" title="Docker Swarm项目使用"></a>Docker Swarm项目使用</h3><p>在使用 swarm 管理集群前，需要把集群中所有的节点的 docker daemon 的监听方式更改为 0.0.0.0:2375。</p>
<p>可以有两种方式达到这个目的，第一种是在启动docker daemon的时候指定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker -H 0.0.0.0:2375&amp;</span><br></pre></td></tr></table></figure>
<p>第二种方式是直接修改 Docker 的配置文件(Ubuntu 上是 /etc/default/docker，其他版本的 Linux 上略有不同)</p>
<p>在文件的最后添加下面这句代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">&quot;-H 0.0.0.0:2375 -H unix:///var/run/docker.sock&quot;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，一定要在所有希望被 Swarm 管理的节点上进行的。修改之后要重启 Docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service docker restart</span><br></pre></td></tr></table></figure>
<p>Docker 集群管理需要使用服务发现(Discovery service backend)功能，Swarm支持以下的几种方式：DockerHub 提供的服务发现功能，本地的文件，etcd，counsel，zookeeper 和 IP 列表，本文会详细讲解前两种方式，其他的用法都是大同小异的。</p>
<p>先说一下本次试验的环境，本次试验包括三台机器，IP地址分别为192.168.1.84,192.168.1.83和192.168.1.124.利用这三台机器组成一个docker集群，其中83这台机器同时充当swarm manager节点。</p>
<h3 id="使用-DockerHub-提供的服务发现功能"><a href="#使用-DockerHub-提供的服务发现功能" class="headerlink" title="使用 DockerHub 提供的服务发现功能"></a>使用 DockerHub 提供的服务发现功能</h3><h3 id="创建集群-token"><a href="#创建集群-token" class="headerlink" title="创建集群 token"></a>创建集群 token</h3><p>在上面三台机器中的任何一台机器上面执行 swarm create 命令来获取一个集群标志。这条命令执行完毕后，Swarm 会前往 DockerHub 上内置的发现服务中获取一个全球唯一的 token，用来标识要管理的集群。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run --<span class="built_in">rm</span> swarm create</span><br></pre></td></tr></table></figure>
<p>我们在84这台机器上执行这条命令，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rio@084:~$ <span class="built_in">sudo</span> docker run --<span class="built_in">rm</span> swarm create</span><br><span class="line">b7625e5a7a2dc7f8c4faacf2b510078e</span><br></pre></td></tr></table></figure>
<p>可以看到我们返回的 token 是 b7625e5a7a2dc7f8c4faacf2b510078e，每次返回的结果都是不一样的。这个 token 一定要记住，后面的操作都会用到这个 token。</p>
<h3 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h3><p>在所有要加入集群的节点上面执行 swarm join 命令，表示要把这台机器加入这个集群当中。在本次试验中，就是要在 83、84 和 124 这三台机器上执行下面的这条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run --<span class="built_in">rm</span> swarm <span class="built_in">join</span> addr=ip_address:2375 token://token_id</span><br></pre></td></tr></table></figure>
<p>其中的 ip_address 换成执行这条命令的机器的 IP，token_id 换成上一步执行 swarm create 返回的 token。</p>
<p>在83这台机器上面的执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rio@083:~$ <span class="built_in">sudo</span> docker run --<span class="built_in">rm</span> swarm <span class="built_in">join</span> --addr=192.168.1.83:2375 token://b7625e5a7a2dc7f8c4faacf2b510078e</span><br><span class="line"><span class="keyword">time</span>=<span class="string">&quot;2015-05-19T11:48:03Z&quot;</span> level=info msg=<span class="string">&quot;Registering on the discovery service  every 25 seconds...&quot;</span> addr=<span class="string">&quot;192.168.1.83:2375&quot;</span> discovery=<span class="string">&quot;token://b7625e5a7a2dc7 f8c4faacf2b510078e&quot;</span></span><br></pre></td></tr></table></figure>
<p>这条命令不会自动返回，要我们自己执行 Ctrl+C 返回。</p>
<h3 id="启动swarm-manager"><a href="#启动swarm-manager" class="headerlink" title="启动swarm manager"></a>启动swarm manager</h3><p>因为我们要使用 83 这台机器充当 swarm 管理节点，所以需要在83这台机器上面执行 swarm manage 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -d -p 2376:2375 swarm manage token://b7625e5a7a2dc7f8c4faacf2b510078e</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rio@083:~$ <span class="built_in">sudo</span> docker run -d -p 2376:2375 swarm manage token://b7625e5a7a2dc7f8c4faacf2b510078e</span><br><span class="line">83de3e9149b7a0ef49916d1dbe073e44e8c31c2fcbe98d962a4f85380ef25f76</span><br></pre></td></tr></table></figure>
<p>这条命令如果执行成功会返回已经启动的 Swarm 的容器的 ID，此时整个集群已经启动起来了。</p>
<p>现在通过 docker ps 命令来看下有没有启动成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rio@083:~$ <span class="built_in">sudo</span> docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">83de3e9149b7        swarm:latest        <span class="string">&quot;/swarm manage token   4 minutes ago       Up 4 minutes        0.0.0.0:2376-&gt;2375/tcp   stupefied_stallman</span></span><br></pre></td></tr></table></figure>
<p>可以看到，Swarm 已经成功启动。</p>
<p>在执行 Swarm manage 这条命令的时候，有几点需要注意的：</p>
<ul>
<li>这条命令需要在充当 swarm 管理者的机器上执行</li>
<li>Swarm 要以 daemon 的形式执行</li>
<li>映射的端口可以使任意的除了 2375 以外的并且是未被占用的端口，但一定不能是 2375 这个端口，因为 2375 已经被 Docker 本身给占用了。</li>
</ul>
<p>集群启动成功以后，现在我们可以在任何一台节点上使用 swarm list 命令查看集群中的节点了，本实验在 124 这台机器上执行 swarm list 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rio@124:~$ <span class="built_in">sudo</span> docker run --<span class="built_in">rm</span> swarm list token://b7625e5a7a2dc7f8c4faacf2b510078e</span><br><span class="line">192.168.1.84:2375</span><br><span class="line">192.168.1.124:2375</span><br><span class="line">192.168.1.83:2375</span><br></pre></td></tr></table></figure>
<p>输出结果列出的IP地址正是我们使用 swarm join 命令加入集群的机器的IP地址。</p>
<p>现在我们可以在任何一台安装了 Docker 的机器上面通过命令(命令中要指明swarm manager机器的IP地址)来在集群中运行container了。</p>
<p>本次试验，我们在 192.168.1.85 这台机器上使用 docker info 命令来查看集群中的节点的信息。</p>
<p>其中 info 也可以换成其他的 Docker 支持的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 info</span><br><span class="line">Containers: 8</span><br><span class="line">Strategy: spread</span><br><span class="line">Filters: affinity, health, constraint, port, dependency</span><br><span class="line">Nodes: 2</span><br><span class="line"> sclu083: 192.168.1.83:2375</span><br><span class="line">  └ Containers: 1</span><br><span class="line">  └ Reserved CPUs: 0 / 2</span><br><span class="line">  └ Reserved Memory: 0 B / 4.054 GiB</span><br><span class="line"> sclu084: 192.168.1.84:2375</span><br><span class="line">  └ Containers: 7</span><br><span class="line">  └ Reserved CPUs: 0 / 2</span><br><span class="line">  └ Reserved Memory: 0 B / 4.053 GiB</span><br></pre></td></tr></table></figure>
<p>结果输出显示这个集群中只有两个节点，IP地址分别是 192.168.1.83 和 192.168.1.84，结果不对呀，我们明明把三台机器加入了这个集群，还有 124 这一台机器呢？</p>
<p>经过排查，发现是忘了修改 124 这台机器上面改 docker daemon 的监听方式，只要按照上面的步骤修改写 docker daemon 的监听方式就可以了。</p>
<p>在使用这个方法的时候，使用swarm create可能会因为网络的原因会出现类似于下面的这个问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rio@227:~$ <span class="built_in">sudo</span> docker run --<span class="built_in">rm</span> swarm create</span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> rio:</span><br><span class="line"><span class="keyword">time</span>=<span class="string">&quot;2015-05-19T12:59:26Z&quot;</span> level=fatal msg=<span class="string">&quot;Post https://discovery-stage.hub.docker.com/v1/clusters: dial tcp: i/o timeout&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用文件"><a href="#使用文件" class="headerlink" title="使用文件"></a>使用文件</h3><p>第二种方法相对于第一种方法要简单得多，也不会出现类似于上面的问题。</p>
<p>第一步：在 swarm 管理节点上新建一个文件，把要加入集群的机器 IP 地址和端口号写入文件中，本次试验就是要在83这台机器上面操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rio@083:~$ <span class="built_in">echo</span> 192.168.1.83:2375 &gt;&gt; cluster</span><br><span class="line">rio@083:~$ <span class="built_in">echo</span> 192.168.1.84:2375 &gt;&gt; cluster</span><br><span class="line">rio@083:~$ <span class="built_in">echo</span> 192.168.1.124:2375 &gt;&gt; cluster</span><br><span class="line">rio@083:~$ <span class="built_in">cat</span> cluster</span><br><span class="line">192.168.1.83:2375</span><br><span class="line">192.168.1.84:2375</span><br><span class="line">192.168.1.124:2375</span><br></pre></td></tr></table></figure>
<p>第二步：在083这台机器上面执行 swarm manage 这条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rio@083:~$ <span class="built_in">sudo</span> docker run -d -p 2376:2375 -v $(<span class="built_in">pwd</span>)/cluster:/tmp/cluster swarm manage file:///tmp/cluster</span><br><span class="line">364af1f25b776f99927b8ae26ca8db5a6fe8ab8cc1e4629a5a68b48951f598ad</span><br></pre></td></tr></table></figure>
<p>使用docker ps来查看有没有启动成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rio@083:~$ <span class="built_in">sudo</span> docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED              STATUS              PORTS                    NAMES</span><br><span class="line">364af1f25b77        swarm:latest        <span class="string">&quot;/swarm manage file:   About a minute ago   Up About a minute   0.0.0.0:2376-&gt;2375/tcp   happy_euclid</span></span><br></pre></td></tr></table></figure>
<p>可以看到，此时整个集群已经启动成功。</p>
<p>在使用这条命令的时候需要注意的是注意：这里一定要使用-v命令，因为cluster文件是在本机上面，启动的容器默认是访问不到的，所以要通过-v命令共享。</p>
<p>接下来的就可以在任何一台安装了docker的机器上面通过命令使用集群，同样的，在85这台机器上执行docker info命令查看集群的节点信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rio@s085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 info</span><br><span class="line">Containers: 9</span><br><span class="line">Strategy: spread</span><br><span class="line">Filters: affinity, health, constraint, port, dependency</span><br><span class="line">Nodes: 3</span><br><span class="line"> atsgxxx: 192.168.1.227:2375</span><br><span class="line">  └ Containers: 0</span><br><span class="line">  └ Reserved CPUs: 0 / 4</span><br><span class="line">  └ Reserved Memory: 0 B / 2.052 GiB</span><br><span class="line"> sclu083: 192.168.1.83:2375</span><br><span class="line">  └ Containers: 2</span><br><span class="line">  └ Reserved CPUs: 0 / 2</span><br><span class="line">  └ Reserved Memory: 0 B / 4.054 GiB</span><br><span class="line"> sclu084: 192.168.1.84:2375</span><br><span class="line">  └ Containers: 7</span><br><span class="line">  └ Reserved CPUs: 0 / 2</span><br><span class="line">  └ Reserved Memory: 0 B / 4.053 GiB</span><br></pre></td></tr></table></figure>
<h3 id="Docker-Swarm项目调度器"><a href="#Docker-Swarm项目调度器" class="headerlink" title="Docker Swarm项目调度器"></a>Docker Swarm项目调度器</h3><p>swarm支持多种调度策略来选择节点。每次在swarm启动container的时候，swarm会根据选择的调度策略来选择节点运行container。目前支持的有:spread,binpack和random。</p>
<p>在执行swarm manage命令启动 swarm 集群的时候可以通过 —strategy 参数来指定，默认的是spread。</p>
<p>spread和binpack策略会根据每台节点的可用CPU，内存以及正在运行的containers的数量来给各个节点分级，而random策略，顾名思义，他不会做任何的计算，只是单纯的随机选择一个节点来启动container。这种策略一般只做调试用。</p>
<p>使用spread策略，swarm会选择一个正在运行的container的数量最少的那个节点来运行container。这种情况会导致启动的container会尽可能的分布在不同的机器上运行，这样的好处就是如果有节点坏掉的时候不会损失太多的container。</p>
<p>binpack 则相反，这种情况下，swarm会尽可能的把所有的容器放在一台节点上面运行。这种策略会避免容器碎片化，因为他会把未使用的机器分配给更大的容器，带来的好处就是swarm会使用最少的节点运行最多的容器。</p>
<h3 id="spread-策略"><a href="#spread-策略" class="headerlink" title="spread 策略"></a>spread 策略</h3><p>先来演示下 spread 策略的情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rio@083:~$ <span class="built_in">sudo</span> docker run -d -p 2376:2375 -v $(<span class="built_in">pwd</span>)/cluster:/tmp/cluster swarm manage --strategy=spread file:///tmp/cluster</span><br><span class="line">7609ac2e463f435c271d17887b7d1db223a5d696bf3f47f86925c781c000cb60</span><br><span class="line">ats@sclu083:~$ <span class="built_in">sudo</span> docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">7609ac2e463f        swarm:latest        <span class="string">&quot;/swarm manage --str   6 seconds ago       Up 5 seconds        0.0.0.0:2376-&gt;2375/tcp   focused_babbage</span></span><br></pre></td></tr></table></figure>
<p>三台机器除了83运行了 Swarm之外，其他的都没有运行任何一个容器，现在在85这台节点上面在swarm集群上启动一个容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name node-1 -d -P redis</span><br><span class="line">2553799f1372b432e9b3311b73e327915d996b6b095a30de3c91a47ff06ce981</span><br><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                  PORTS                          NAMES</span><br><span class="line">2553799f1372        redis:latest        /entrypoint.sh redis   24 minutes ago      Up Less than a second   192.168.1.84:32770-&gt;6379/tcp   084/node-1</span><br></pre></td></tr></table></figure>
<p>启动一个 redis 容器，查看结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name node-2 -d -P redis</span><br><span class="line">7965a17fb943dc6404e2c14fb8585967e114addca068f233fcaf60c13bcf2190</span><br><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 ps</span><br><span class="line">CONTAINER ID        IMAGE                            COMMAND                CREATED                  STATUS              PORTS                           NAMES</span><br><span class="line">7965a17fb943        redis:latest   /entrypoint.sh redis   Less than a second ago   Up 1 seconds        192.168.1.124:49154-&gt;6379/tcp   124/node-2                  </span><br><span class="line">2553799f1372        redis:latest                     /entrypoint.sh redis   29 minutes ago           Up 4 minutes        192.168.1.84:32770-&gt;6379/tcp    084/node-1</span><br></pre></td></tr></table></figure>
<p>再次启动一个 redis 容器，查看结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name node-3 -d -P redis</span><br><span class="line">65e1ed758b53fbf441433a6cb47d288c51235257cf1bf92e04a63a8079e76bee</span><br><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 ps</span><br><span class="line">CONTAINER ID        IMAGE                            COMMAND                CREATED                  STATUS              PORTS                           NAMES</span><br><span class="line">7965a17fb943        redis:latest                     /entrypoint.sh redis   Less than a second ago   Up 4 minutes        192.168.1.227:49154-&gt;6379/tcp   124/node-2</span><br><span class="line">65e1ed758b53        redis:latest                     /entrypoint.sh redis   25 minutes ago           Up 17 seconds       192.168.1.83:32770-&gt;6379/tcp    083/node-3</span><br><span class="line">2553799f1372        redis:latest                     /entrypoint.sh redis   33 minutes ago           Up 8 minutes        192.168.1.84:32770-&gt;6379/tcp    084/node-1</span><br></pre></td></tr></table></figure>
<p>可以看到三个容器都是分布在不同的节点上面的。</p>
<h3 id="binpack-策略"><a href="#binpack-策略" class="headerlink" title="binpack 策略"></a>binpack 策略</h3><p>现在来看看binpack策略下的情况。在083上面执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rio@083:~$ <span class="built_in">sudo</span> docker run -d -p 2376:2375 -v $(<span class="built_in">pwd</span>)/cluster:/tmp/cluster swarm manage --strategy=binpack  file:///tmp/cluster</span><br><span class="line">f1c9affd5a0567870a45a8eae57fec7c78f3825f3a53fd324157011aa0111ac5</span><br></pre></td></tr></table></figure>
<p>现在在集群中启动三个 redis 容器，查看分布情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name node-1 -d -P redis</span><br><span class="line">18ceefa5e86f06025cf7c15919fa64a417a9d865c27d97a0ab4c7315118e348c</span><br><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name node-2 -d -P redis</span><br><span class="line">7e778bde1a99c5cbe4701e06935157a6572fb8093fe21517845f5296c1a91bb2</span><br><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name node-3 -d -P redis</span><br><span class="line">2195086965a783f0c2b2f8af65083c770f8bd454d98b7a94d0f670e73eea05f8</span><br><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                  PORTS                          NAMES</span><br><span class="line">2195086965a7        redis:latest        /entrypoint.sh redis   24 minutes ago      Up Less than a second   192.168.1.83:32773-&gt;6379/tcp   083/node-3</span><br><span class="line">7e778bde1a99        redis:latest        /entrypoint.sh redis   24 minutes ago      Up Less than a second   192.168.1.83:32772-&gt;6379/tcp   083/node-2</span><br><span class="line">18ceefa5e86f        redis:latest        /entrypoint.sh redis   25 minutes ago      Up 22 seconds           192.168.1.83:32771-&gt;6379/tcp   083/node-1</span><br></pre></td></tr></table></figure>
<p>可以看到，所有的容器都是分布在同一个节点上运行的。</p>
<h3 id="Docker-Swarm项目过滤器"><a href="#Docker-Swarm项目过滤器" class="headerlink" title="Docker Swarm项目过滤器"></a>Docker Swarm项目过滤器</h3><p>swarm 的调度器(scheduler)在选择节点运行容器的时候支持几种过滤器 (filter)：Constraint,Affinity,Port,Dependency,Health</p>
<p>可以在执行 swarm manage 命令的时候通过 —filter 选项来设置。</p>
<h3 id="Constraint-Filter"><a href="#Constraint-Filter" class="headerlink" title="Constraint Filter"></a>Constraint Filter</h3><p>constraint 是一个跟具体节点相关联的键值对，可以看做是每个节点的标签，这个标签可以在启动docker daemon的时候指定，比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker -d --label label_name=label01</span><br></pre></td></tr></table></figure>
<p>也可以写在docker的配置文件里面（在ubuntu上面是 /etc/default/docker）。</p>
<p>在本次试验中，给083添加标签—label label_name=083,084添加标签—label label_name=084,124添加标签—label label_name=084,</p>
<p>以083为例，打开/etc/default/docker文件，修改DOCKER_OPTS：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">&quot;-H 0.0.0.0:2375 -H unix:///var/run/docker.sock  --label label_name=083&quot;</span></span><br></pre></td></tr></table></figure>
<p>在使用docker run命令启动容器的时候使用 -e constarint:key=value 的形式，可以指定container运行的节点。</p>
<p>比如我们想在84上面启动一个 redis 容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name redis_1 -d -e constraint:label_name==084 redis</span><br><span class="line">fee1b7b9dde13d64690344c1f1a4c3f5556835be46b41b969e4090a083a6382d</span><br></pre></td></tr></table></figure>
<p>注意，是两个等号，不是一个等号，这一点会经常被忽略。</p>
<p>接下来再在084这台机器上启动一个redis 容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name redis_2 -d -e constraint:label_name==084 redis         4968d617d9cd122fc2e17b3bad2f2c3b5812c0f6f51898024a96c4839fa000e1</span><br></pre></td></tr></table></figure>
<p>然后再在083这台机器上启动另外一个 redis 容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name redis_3 -d -e constraint:label_name==083 redis         7786300b8d2232c2335ac6161c715de23f9179d30eb5c7e9c4f920a4f1d39570</span><br></pre></td></tr></table></figure>
<p>现在来看下执行情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS               NAMES</span><br><span class="line">7786300b8d22        redis:latest        <span class="string">&quot;/entrypoint.sh redi   15 minutes ago      Up 53 seconds       6379/tcp            083/redis_3</span></span><br><span class="line"><span class="string">4968d617d9cd        redis:latest        &quot;</span>/entrypoint.sh redi   16 minutes ago      Up 2 minutes        6379/tcp            084/redis_2</span><br><span class="line">fee1b7b9dde1        redis:latest        <span class="string">&quot;/entrypoint.sh redi   19 minutes ago      Up 5 minutes        6379/tcp            084/redis_1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，执行结果跟预期的一样。</p>
<p>但是如果指定一个不存在的标签的话来运行容器会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run --name redis_0 -d -e constraint:label_name==0 redis</span><br><span class="line">FATA[0000] Error response from daemon: unable to find a node that satisfies label_name==0</span><br></pre></td></tr></table></figure>
<h3 id="Affinity-Filter"><a href="#Affinity-Filter" class="headerlink" title="Affinity Filter"></a>Affinity Filter</h3><p>通过使用 Affinity Filter，可以让一个容器紧挨着另一个容器启动，也就是说让两个容器在同一个节点上面启动。</p>
<p>现在其中一台机器上面启动一个 redis 容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run -d --name redis redis</span><br><span class="line">ea13eddf667992c5d8296557d3c282dd8484bd262c81e2b5af061cdd6c82158d</span><br><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376  ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                  PORTS               NAMES</span><br><span class="line">ea13eddf6679        redis:latest        /entrypoint.sh redis   24 minutes ago      Up Less than a second   6379/tcp            083/redis</span><br></pre></td></tr></table></figure>
<p>然后再次启动两个 redis 容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376  run -d --name redis_1 -e affinity:container==redis redis</span><br><span class="line">bac50c2e955211047a745008fd1086eaa16d7ae4f33c192f50412e8dcd0a14cd</span><br><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376  run -d --name redis_1 -e affinity:container==redis redis</span><br><span class="line">bac50c2e955211047a745008fd1086eaa16d7ae4f33c192f50412e8dcd0a14cd</span><br></pre></td></tr></table></figure>
<p>现在来查看下运行结果,可以看到三个容器都是在一台机器上运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rio@085:~$ <span class="built_in">sudo</span> docker -H 192.168.1.83:2376  ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                  PORTS               NAMES</span><br><span class="line">449ed25ad239        redis:latest        /entrypoint.sh redis   24 minutes ago      Up Less than a second   6379/tcp            083/redis_2</span><br><span class="line">bac50c2e9552        redis:latest        /entrypoint.sh redis   25 minutes ago      Up 10 seconds           6379/tcp            083/redis_1</span><br><span class="line">ea13eddf6679        redis:latest        /entrypoint.sh redis   28 minutes ago      Up 3 minutes            6379/tcp            083/redis</span><br></pre></td></tr></table></figure>
<p>通过 -e affinity:image=image_name 命令可以指定只有已经下载了image_name镜像的机器才运行容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker –H 192.168.1.83:2376 run –name redis1 –d –e affinity:image==redis redis</span><br></pre></td></tr></table></figure>
<p>redis1 这个容器只会在已经下载了 redis 镜像的节点上运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run -d --name redis -e affinity:image==~redis redis</span><br></pre></td></tr></table></figure>
<p>这条命令达到的效果是：在有 redis 镜像的节点上面启动一个名字叫做 redis 的容器，如果每个节点上面都没有 redis 容器，就按照默认的策略启动 redis 容器。</p>
<h3 id="Port-Filter"><a href="#Port-Filter" class="headerlink" title="Port Filter"></a>Port Filter</h3><p>Port 也会被认为是一个唯一的资源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker -H 192.168.1.83:2376 run -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>
<p>执行完这条命令，之后任何使用 80 端口的容器都是启动失败。</p>
<h1 id="实战Redis"><a href="#实战Redis" class="headerlink" title="实战Redis"></a>实战Redis</h1><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241619146.png" alt="在这里插入图片描述"></p>
<p>shell脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建网卡</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker network create redis --subnet 172.38.0.0/16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过脚本创建六个redis配置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">for</span> port <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 6); \</span></span><br><span class="line"><span class="language-bash"><span class="keyword">do</span> \</span></span><br><span class="line"><span class="language-bash"><span class="built_in">mkdir</span> -p /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf</span></span><br><span class="line">touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">cat &lt;&lt; EOF &gt;&gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">Cluster-enabled yes</span><br><span class="line">Cluster-config-file nodes.conf</span><br><span class="line">Cluster-node-timeout 5000</span><br><span class="line">Cluster-announce-ip 172.38.0.1$&#123;port&#125;</span><br><span class="line">Cluster-announce-port 6379</span><br><span class="line">Cluster-announce-bus-port 16379</span><br><span class="line">appendonly yes</span><br><span class="line">EOF</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -p 637<span class="variable">$&#123;port&#125;</span>:6379 -p 1637<span class="variable">$&#123;port&#125;</span>:16379 --name redis -<span class="variable">$&#123;port&#125;</span> \</span></span><br><span class="line"><span class="language-bash">-v /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/data:/data \</span></span><br><span class="line"><span class="language-bash">-v /mydata/redis/node-<span class="variable">$&#123;port&#125;</span>/conf/redis.conf:/etc/redis/redis.conf \</span></span><br><span class="line"><span class="language-bash">-d --net redis --ip 172.38.0.1<span class="variable">$&#123;port&#125;</span> redis:5.0.9-alpine3.11 redis-server /etc/redis/redis. conf; \</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">第一个，在创建5个(6处更改)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run -p 6371:6379 -p 16371:16379 --name redis-1 \</span></span><br><span class="line"><span class="language-bash">-v /mydata/redis/node-1/data:/data \</span></span><br><span class="line"><span class="language-bash">-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \</span></span><br><span class="line"><span class="language-bash">-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建集群</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">redis-cli -c</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cluster info</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cluster nodes</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">get a b</span> </span><br></pre></td></tr></table></figure>
<p>docker 搭建redis集群完成!<br><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241619830.png" alt="在这里插入图片描述"></p>
<h1 id="构建持续集成环境"><a href="#构建持续集成环境" class="headerlink" title="构建持续集成环境"></a>构建持续集成环境</h1><p><strong>docker</strong> <strong>+</strong> <strong>jenkins</strong> <strong>+</strong> <strong>git</strong> <strong>+ maven**</strong>自动化构建与部署**</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">(1)安装本次部署需要的软件</span><br><span class="line">1.清除防火墙规则和配置yum.repo</span><br><span class="line">[root@docke-all yum.repos.d]# iptables -F</span><br><span class="line">[root@docke-all yum.repos.d]# iptables -X</span><br><span class="line">[root@docke-all yum.repos.d]# iptables -Z</span><br><span class="line">[root@docke-all yum.repos.d]# /usr/sbin/iptables-save</span><br><span class="line">\# Generated by iptables-save v1.4.21 on Thu Jan 19 05:46:41 2017</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [4:280]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [3:308]</span><br><span class="line">COMMIT</span><br><span class="line">\# Completed on Thu Jan 19 05:46:41 2017</span><br><span class="line">添加yum文件</span><br><span class="line">[root@docke-all yum.repos.d]# vi /etc/yum.repos.d/docker.repo</span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/<span class="variable">$releasever</span>/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line"><span class="string">&quot;docker.repo&quot;</span> [New] 12L, 172C written</span><br><span class="line">2．安装最新的docker软件包</span><br><span class="line">[root@docke-all yum.repos.d]# <span class="built_in">sudo</span> yum install docker-engine</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">dockerrepo                                                                     | 2.9 kB  00:00:00     </span><br><span class="line">dockerrepo/7/primary_db                                                        |  28 kB  00:00:00</span><br><span class="line">Installed:</span><br><span class="line">  docker-engine.x86_64 0:1.13.0-1.el7.centos                                                          </span><br><span class="line">Dependency Installed:</span><br><span class="line">  docker-engine-selinux.noarch 0:1.13.0-1.el7.centos          libseccomp.x86_64 0:2.3.1-2.el7         </span><br><span class="line">  libtool-ltdl.x86_64 0:2.4.2-21.el7_2                       </span><br><span class="line">Complete!</span><br><span class="line">3. docker 分别pull 以下镜像 jenkins:2.0-beta-1 tomcat和mysql</span><br><span class="line">[root@docke-all yum.repos.d]# docker pull jenkins:2.0-beta-1</span><br><span class="line">2.0-beta-1: Pulling from library/jenkins</span><br><span class="line">efd26ecc9548: Pull complete </span><br><span class="line">a3ed95caeb02: Pull complete</span><br><span class="line">bf22465a61c2: Pull complete </span><br><span class="line">。。。。。。</span><br><span class="line">Digest: sha256:e315b7abd7dd86dca7e5307e1deb040b4054daeaf8d9de28749a88cccc9b960f</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> jenkins:2.0-beta-1</span><br><span class="line">[root@docke-all yum.repos.d]# docker pull tomcat</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/tomcat</span><br><span class="line">5040bd298390: Pull complete</span><br><span class="line">1638c7ffa55a: Pull complete </span><br><span class="line">Digest: sha256:c9c5e4d114cf547886a0c0956eebebcfc1d87216f09120e6b77df27f7c8053b0</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> tomcat:latest</span><br><span class="line">[root@docke-all yum.repos.d]# docker pull mysql</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">5040bd298390: Already exists </span><br><span class="line">55370df68315: Pull complete </span><br><span class="line">fad5195d69cc: Pull complete </span><br><span class="line">Digest: sha256:d433b96443b9584cdfbcc337c7ebd7cef71332c5368aba19f94177953b1fe0f6</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">4.下载apache-maven和jdk并解压到指定文件夹下</span><br><span class="line">  maven 并解压：</span><br><span class="line">[root@docke-all ~]#<span class="built_in">mkdir</span> -p /dockerworkspace/maven &amp;&amp; tar zxf apache-maven-3.3.9-bin.tar.gz -C /dockerworkspace/maven</span><br><span class="line">下载jdk 并解压：</span><br><span class="line">[root@docke-all ~]#tar -zxvf jdk*.tar.gz -C /dockerworkspace/java/ </span><br><span class="line"> [root@docke-all ~]# <span class="built_in">mv</span> /dockerworkspace/java/jdk* /dockerworkspace/java/jdk</span><br><span class="line">5.安装jenkins</span><br><span class="line">[root@docke-all dockerworkspace]# docker run -it --name jenkins -p 8080:8080 -p 50000:50000 -v /dockerworkspace/jenkins:/var/jenkins_home -v /dockerworkspace/maven/apache-maven-3.3.9:/usr/local/maven -v /dockerworkspace/java/jdk:/usr/local/jdk jenkins:latest</span><br><span class="line"><span class="built_in">touch</span>: cannot <span class="built_in">touch</span> ‘/var/jenkins_home/copy_reference_file.log’: Permission denied</span><br><span class="line">Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?</span><br><span class="line">至此出现一个错误，是因为文件权限问题导致的，具体解释如下：</span><br><span class="line">       </span><br><span class="line">       我们检查一下之前启动方式的<span class="string">&quot;/var/jenkins_home&quot;</span>目录权限，查看Jenkins容器的当前用户: 当前用户是<span class="string">&quot;jenkins&quot;</span>而且<span class="string">&quot;/var/jenkins_home&quot;</span>目录是属于jenkins用户拥有的；而当映射本地数据卷时，/var/jenkins_home目录的拥有者变成了root用户。发现问题之后，相应的解决方法也很简单：把当前目录的拥有者赋值给uid 1000，再启动<span class="string">&quot;jenkins&quot;</span>容器就一切正常了。</span><br><span class="line">[root@docke-all dockerworkspace]# <span class="built_in">sudo</span> <span class="built_in">chown</span> -R 1000 jenkins</span><br><span class="line">[root@docke-all dockerworkspace]# docker start jenkins</span><br><span class="line">Jenkins</span><br><span class="line"> </span><br><span class="line">访问jenkins:8080(jenkins改成服务器地址) ,然后输入以下查看到的密码Unlock Jenkins</span><br><span class="line">[root@docke-all dockerworkspace]# <span class="built_in">cat</span> /dockerworkspace/jenkins/secrets/initialAdminPassword  </span><br><span class="line">554cc3aee41841a49213e6da8507f087</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241619125.png" alt="在这里插入图片描述"></p>
<p>Customize Jenkins步骤时选择左边的Install suggested plugins</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241619770.png" alt="在这里插入图片描述"></p>
<p>Install suggested plugins安装<img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241619356.png" alt="在这里插入图片描述"></p>
<p>插件安装完成后界面</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241619272.png" alt="在这里插入图片描述"></p>
<p>配置Jenkins，点击“可选插件”，安装ssh插件。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241620201.png" alt="在这里插入图片描述"></p>
<p>在过滤栏搜索：ssh plugin</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241620939.png" alt="在这里插入图片描述"></p>
<p>JDK配置和Maven配置：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241620229.png" alt="在这里插入图片描述"></p>
<p>选择JDK和Maven配置路径</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241620223.png" alt="在这里插入图片描述"></p>
<p>至此持续集成环境部署完成，就可以进行项目部署了。</p>
<p><strong>新建测试项目</strong></p>
<p>本教程中git管理端用的是gogs，创建jenkins中的maven 项目</p>
<p>在jenkins首页点击新建选择构建一个maven项目 填写项目名称test_tomcat</p>
<p>(如果没有这项请安装插件Maven Integration plugin)</p>
<p>源码管理中选择git, 填写项目的git信息(Credentials点新增可以添加git的认证信息,支持帐户名密码,ssh key 等方式. 源码浏览器在构建项目时的修改记录可以直接连接到git平台)</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20230403/202310241620518.png" alt="在这里插入图片描述"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io">蓝桉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io/posts/6782be63.html">https://ktzxy.github.io/posts/6782be63.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ktzxy.github.io" target="_blank">蓝桉`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post-share"><div class="social-share" data-image="/bg/Image00017.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src="/img/wechat.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src="/img/alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/fab65d8b.html" title="Docker容器相关命令"><img class="cover" src="/bg/Image00013.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Docker容器相关命令</div></div><div class="info-2"><div class="info-item-1">本文整理在 Ubuntu 16.04.x LTS 操作系统上容器相关部署手册 容器平台  Rancher Kubernetes Helm Docker  容器服务  prometheus grafana postgresql  1.Docker1.1.apt source更换apt源大多数情况下可以加快软件下载速度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859cp /etc/apt/sources.list /etc/apt/sources.list.bak# 阿里源tee &gt; /etc/apt/sources.list &lt;&lt; EOFdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-secur...</div></div></div></a><a class="pagination-related" href="/posts/9c1cd714.html" title="Docker图形化工具Portainer介绍与安装"><img class="cover" src="/bg/Image00010.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Docker图形化工具Portainer介绍与安装</div></div><div class="info-2"><div class="info-item-1">Docker图形化工具Portainer介绍与安装介绍Portainer 是一款轻量级的图形化管理工具，通过它我们可以轻松管理不同的 Docker 环境。Portainer 部署和使用都非常简单，它提供一个可以运行在任何 Docker 引擎上的容器组成。Portainer 提供管理 Docker 的container、images、volumes、networks 等等。它兼容独立的 Docker 环境和 swarm 集群模式。基本满足中小型单位对 Docker 容器的管理工作。 官方提供的 Demo 演示环境：  地址：http://demo.portainer.io 用户名：admin 密码：tryportainer  Docker方式安装我们可以直接使用 Docker 的方式来安装 首先创建数据卷，实现数据持久化 1docker volume create portainer_db 启动 Partainer 容器 1docker run -d -p 9000:9000 -name portainer -restart always -v /var/run/docker/so...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/3290d081.html" title="Docker之镜像加速器配置"><img class="cover" src="/bg/Image00003.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-21</div><div class="info-item-2">Docker之镜像加速器配置</div></div><div class="info-2"><div class="info-item-1">1234567891011121314151617181920212223242526方法一通过shell脚本追加文本内容sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [    &quot;https://registry.docker-cn.com&quot;,    &quot;http://hub-mirror.c.163.com&quot;,    &quot;https://docker.mirrors.ustc.edu.cn&quot;  ]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker方法二通过修改daemon配置文件/etc/docker/daemon.json来使用加速器vi /etc/docker/daemon.json&#123;  &quot;registry-mirrors&qu...</div></div></div></a><a class="pagination-related" href="/posts/e1e2008c.html" title="Docker Compose入门学习"><img class="cover" src="/bg/Image00010.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Docker Compose入门学习</div></div><div class="info-2"><div class="info-item-1">Docker Compose入门学习简介我们之前操作Docker的过程是：DockerFile  build run 进行手动操作，单个容器，如果假设我们有100个微服务，并行微服务之间还存在依赖关系。这个时候，我们就可以使用Docker Compose来轻松高效的管理容器，定义运行多个容器。 官方介绍： 定义、运行多个容器 YAML file配置环境   Compose是一个用于定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用YAML文件来配置应用程序的服务。然后，使用一个命令，就可以从配置中创建并启动所有服务。要了解有关Compose的所有特性的更多信息，请参阅特性列表。 Compose可以在所有环境中工作:生产、阶段、开发、测试，以及CI工作流。您可以在常见用例中了解关于每个用例的更多信息 使用Compose基本上有三个步骤:  用 Dockerfile 定义你的应用程序的环境，这样它就可以在任何地方复制。 在 Docker-compose 中定义组成应用程序的服务。这样它们就可以在一个独立的环境中一起运行。 运行 docker-compose u...</div></div></div></a><a class="pagination-related" href="/posts/71c45576.html" title="DockerDesktop入门简介"><img class="cover" src="/bg/Image00028.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">DockerDesktop入门简介</div></div><div class="info-2"><div class="info-item-1">DockerDesktop入门简介参考参考：https://segmentfault.com/a/1190000022059895 介绍Docker Desktop是一款专门为Windows和Mac提供桌面化的容器开发环境，在Windows中，Docker Desktop使用了Windows的Hyper-V虚拟化技术，因此需要一台打开了硬件虚拟化的电脑，并且安装的是Windows10专业版以上的系统。 下载首先到官网下载对应版本的 Docker Desktop安装包 安装首先我们需要：启用或关闭Windows功能  然后勾选下面的选项  然后开始运行我们下载好的 DockerDesktop.exe，我们进行安装过程中，首先会进行一系列的检查，包括是否开启虚拟化，以及是否满足条件 运行安装完成后，点击图片Docker Desktop  这个问题是因为我们使用的wsl2版本太旧，需要我们手动更新一下，首先根据提示去微软官网下载最新版的wsl2安装包，然后进行安装：安装包点我传送 然后在重新安装，即可完成我们Docker Desktop  然后我们打开 powershell即可查看到我...</div></div></div></a><a class="pagination-related" href="/posts/9c1cd714.html" title="Docker图形化工具Portainer介绍与安装"><img class="cover" src="/bg/Image00010.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Docker图形化工具Portainer介绍与安装</div></div><div class="info-2"><div class="info-item-1">Docker图形化工具Portainer介绍与安装介绍Portainer 是一款轻量级的图形化管理工具，通过它我们可以轻松管理不同的 Docker 环境。Portainer 部署和使用都非常简单，它提供一个可以运行在任何 Docker 引擎上的容器组成。Portainer 提供管理 Docker 的container、images、volumes、networks 等等。它兼容独立的 Docker 环境和 swarm 集群模式。基本满足中小型单位对 Docker 容器的管理工作。 官方提供的 Demo 演示环境：  地址：http://demo.portainer.io 用户名：admin 密码：tryportainer  Docker方式安装我们可以直接使用 Docker 的方式来安装 首先创建数据卷，实现数据持久化 1docker volume create portainer_db 启动 Partainer 容器 1docker run -d -p 9000:9000 -name portainer -restart always -v /var/run/docker/so...</div></div></div></a><a class="pagination-related" href="/posts/fab65d8b.html" title="Docker容器相关命令"><img class="cover" src="/bg/Image00013.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Docker容器相关命令</div></div><div class="info-2"><div class="info-item-1">本文整理在 Ubuntu 16.04.x LTS 操作系统上容器相关部署手册 容器平台  Rancher Kubernetes Helm Docker  容器服务  prometheus grafana postgresql  1.Docker1.1.apt source更换apt源大多数情况下可以加快软件下载速度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859cp /etc/apt/sources.list /etc/apt/sources.list.bak# 阿里源tee &gt; /etc/apt/sources.list &lt;&lt; EOFdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-secur...</div></div></div></a><a class="pagination-related" href="/posts/6f4549bd.html" title="Docker操作系统之Alpine"><img class="cover" src="/bg/Image00030.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">Docker操作系统之Alpine</div></div><div class="info-2"><div class="info-item-1">Docker操作系统之Alpine前言这阵子我发现只要带着alpine前缀的镜像，相比于其它的镜像，体积都相对较小，例如下面这些 12java:alpinenginx:alpine 后面通过了解，发现了其实这些java镜像，或者nginx镜像都依赖于某个linux操作系统，我们常见的操作系统有  ubuntu、centos、debian。而这个alpine其实也是一个新的操作系统。但是它比其它的操作系统而言，体积更小，所以在他们的基础之上做的镜像，体积也会更小，常见的linux操作系统体积大小，如下所示 12345REPOSITORY          TAG           IMAGE ID          VIRTUAL SIZEalpine              latest        4e38e38c8ce0      4.799 MBdebian              latest        4d6ce913b130      84.98 MBubuntu              latest        b39b81afc8ca      1...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">蓝桉</div><div class="author-info-description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">生活、学习、技术</b>相关的问题和看法，还有<b style="color:#fff">文章教程</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ktzxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/ktzxy" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2251511764@qq.com" target="_blank" title="Email"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-RSS"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/496148176" target="_blank" title="BiliBili"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QX-BILIBILI"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2251511764&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Docker学习笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">Docker介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%AE%80%E4%BB%8B"><span class="toc-number">2.0.1.</span> <span class="toc-text">Docker简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">2.0.2.</span> <span class="toc-text">Docker架构与内部组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">2.0.3.</span> <span class="toc-text">Docker有什么优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">2.0.4.</span> <span class="toc-text">虚拟机与容器区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.0.5.</span> <span class="toc-text">底层原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%AE%89%E8%A3%85"><span class="toc-number">3.</span> <span class="toc-text">Docker安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Docker"><span class="toc-number">3.0.1.</span> <span class="toc-text">安装Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-number">3.0.2.</span> <span class="toc-text">阿里云镜像加速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8"><span class="toc-number">3.0.3.</span> <span class="toc-text">设置开机自动启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bdocker%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">3.0.4.</span> <span class="toc-text">查看docker服务状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bdocker%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF"><span class="toc-number">3.0.5.</span> <span class="toc-text">查看docker具体信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">镜像使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F"><span class="toc-number">4.0.1.</span> <span class="toc-text">列出镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">4.0.2.</span> <span class="toc-text">获取镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%95%9C%E5%83%8F"><span class="toc-number">4.0.3.</span> <span class="toc-text">查找镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">4.0.4.</span> <span class="toc-text">删除镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9F%90%E9%95%9C%E5%83%8F%E6%9D%A5%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8"><span class="toc-number">4.0.5.</span> <span class="toc-text">使用某镜像来启动一个容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%95%9C%E5%83%8F%EF%BC%88%E6%9B%B4%E6%96%B0%E5%89%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="toc-number">4.0.6.</span> <span class="toc-text">更新镜像（更新前需要创建一个容器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E6%A0%87%E7%AD%BE"><span class="toc-number">4.0.7.</span> <span class="toc-text">设置镜像标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-number">4.0.8.</span> <span class="toc-text">镜像的导入导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%82%AC%E9%95%9C%E5%83%8F"><span class="toc-number">4.0.9.</span> <span class="toc-text">虚悬镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-commit-%E7%90%86%E8%A7%A3%E9%95%9C%E5%83%8F%E6%9E%84%E6%88%90"><span class="toc-number">4.0.10.</span> <span class="toc-text">利用 commit 理解镜像构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E5%88%B0%E5%85%B1%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">4.0.11.</span> <span class="toc-text">上传本地镜像到共有仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA%E5%B9%B6%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F%E8%87%B3%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">4.0.12.</span> <span class="toc-text">私有仓库的搭建并上传镜像至私有仓库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">容器的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.1.</span> <span class="toc-text">运行容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.2.</span> <span class="toc-text">查看正在运行的容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97"><span class="toc-number">5.0.3.</span> <span class="toc-text">查看容器日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8"><span class="toc-number">5.0.4.</span> <span class="toc-text">进入容器的内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9%E5%88%B0%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.5.</span> <span class="toc-text">复制内容到容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%90%AF-amp-%E5%90%AF%E5%8A%A8-amp-%E5%81%9C%E6%AD%A2-amp-%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8-amp-%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.</span> <span class="toc-text">重启&amp;启动&amp;停止&amp;删除容器&amp;退出容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.1.</span> <span class="toc-text">重新启动容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.2.</span> <span class="toc-text">启动停止运行的容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AE%B9%E5%99%A8-%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8%E5%89%8D%EF%BC%8C%E9%9C%80%E8%A6%81%E5%85%88%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.3.</span> <span class="toc-text">停止指定的容器(删除容器前，需要先停止容器)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E5%85%A8%E9%83%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.4.</span> <span class="toc-text">停止全部容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.5.</span> <span class="toc-text">删除指定容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%BD%93%E5%89%8D%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.6.</span> <span class="toc-text">强制停止当前容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.7.</span> <span class="toc-text">退出容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%A8%E9%83%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.8.</span> <span class="toc-text">删除全部容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.9.</span> <span class="toc-text">导出容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">5.0.6.0.10.</span> <span class="toc-text">导入容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86website1%E5%8F%91%E5%88%B0nginx%E7%9A%84%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%8E%BB"><span class="toc-number">5.0.7.</span> <span class="toc-text">将website1发到nginx的容器中去</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.</span> <span class="toc-text">docker常用命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">Docker图形界面管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DockerUI"><span class="toc-number">7.0.1.</span> <span class="toc-text">DockerUI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shipyard"><span class="toc-number">7.0.2.</span> <span class="toc-text">Shipyard</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">可视化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">Docker镜像加载原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UnionFS%EF%BC%88%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">9.0.1.</span> <span class="toc-text">UnionFS（联合文件系统）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86-1"><span class="toc-number">9.0.2.</span> <span class="toc-text">Docker镜像加载原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%90%86%E8%A7%A3"><span class="toc-number">10.</span> <span class="toc-text">分层理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">11.</span> <span class="toc-text">数据卷</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">11.0.1.</span> <span class="toc-text">创建数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%85%A8%E9%83%A8%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">11.0.2.</span> <span class="toc-text">查看全部数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%E8%AF%A6%E6%83%85"><span class="toc-number">11.0.3.</span> <span class="toc-text">查看数据卷详情</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">11.0.4.</span> <span class="toc-text">删除数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="toc-number">11.0.5.</span> <span class="toc-text">Docker数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%98%A0%E5%B0%84%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">11.0.6.</span> <span class="toc-text">容器映射数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%89%80%E6%9C%89%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80"><span class="toc-number">11.0.7.</span> <span class="toc-text">映射所有接口地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3"><span class="toc-number">11.0.8.</span> <span class="toc-text">映射到指定地址的指定端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E5%88%B0%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BB%BB%E6%84%8F%E7%AB%AF%E5%8F%A3"><span class="toc-number">11.0.9.</span> <span class="toc-text">映射到指定地址的任意端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%98%A0%E5%B0%84%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-number">11.0.10.</span> <span class="toc-text">查看映射端口配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E5%92%8C%E5%8C%BF%E5%90%8D%E6%8C%82%E8%BD%BD"><span class="toc-number">11.0.11.</span> <span class="toc-text">具名和匿名挂载</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%8C%82%E8%BD%BD"><span class="toc-number">11.0.11.0.1.</span> <span class="toc-text">匿名挂载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8C%82%E8%BD%BD"><span class="toc-number">11.0.11.0.2.</span> <span class="toc-text">具名挂载</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dockerfile%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F"><span class="toc-number">12.</span> <span class="toc-text">Dockerfile自定义镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%B8%80"><span class="toc-number">12.0.1.</span> <span class="toc-text">实战一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%BA%8C%EF%BC%88Tomcat%EF%BC%89"><span class="toc-number">12.0.2.</span> <span class="toc-text">实战二（Tomcat）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BAPHP%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83%E9%95%9C%E5%83%8F"><span class="toc-number">12.0.3.</span> <span class="toc-text">构建PHP网站环境镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BAJAVA%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83%E9%95%9C%E5%83%8F"><span class="toc-number">12.0.4.</span> <span class="toc-text">构建JAVA网站环境镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81SSH%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">12.0.5.</span> <span class="toc-text">构建支持SSH服务的镜像</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E7%BD%91%E7%BB%9C"><span class="toc-number">13.</span> <span class="toc-text">Docker网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97"><span class="toc-number">13.0.1.</span> <span class="toc-text">快速配置指南</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E9%85%8D%E7%BD%AEDNS"><span class="toc-number">13.0.2.</span> <span class="toc-text">Docker配置DNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">13.0.3.</span> <span class="toc-text">Docker容器访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C"><span class="toc-number">13.0.4.</span> <span class="toc-text">容器访问外部网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E8%AE%BF%E9%97%AE"><span class="toc-number">13.0.5.</span> <span class="toc-text">容器之间访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%AB%AF%E5%8F%A3"><span class="toc-number">13.0.6.</span> <span class="toc-text">访问所有端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3"><span class="toc-number">13.0.7.</span> <span class="toc-text">访问指定端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.0.8.</span> <span class="toc-text">Docker端口映射实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.0.9.</span> <span class="toc-text">容器访问外部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.0.10.</span> <span class="toc-text">外部访问容器实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEdocker0%E7%BD%91%E6%A1%A5"><span class="toc-number">13.0.11.</span> <span class="toc-text">配置docker0网桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E6%A1%A5"><span class="toc-number">13.0.12.</span> <span class="toc-text">Docker自定义网桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE%E5%8E%9F%E7%90%86"><span class="toc-number">13.0.13.</span> <span class="toc-text">容器网络访问原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%94link"><span class="toc-number">13.0.14.</span> <span class="toc-text">—link</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C"><span class="toc-number">13.0.15.</span> <span class="toc-text">自定义网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%BF%9E%E9%80%9A"><span class="toc-number">13.0.16.</span> <span class="toc-text">网络连通</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E5%AE%89%E5%85%A8"><span class="toc-number">14.</span> <span class="toc-text">Docker安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="toc-number">14.0.1.</span> <span class="toc-text">内核名字空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%84"><span class="toc-number">14.0.2.</span> <span class="toc-text">控制组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E9%98%B2%E6%8A%A4"><span class="toc-number">14.0.3.</span> <span class="toc-text">Docker服务端的防护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E8%83%BD%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">14.0.4.</span> <span class="toc-text">内核能力机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7"><span class="toc-number">14.0.5.</span> <span class="toc-text">其它安全特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prometheus%E7%9B%91%E6%8E%A7Docker%E4%B8%BB%E6%9C%BA"><span class="toc-number">14.0.6.</span> <span class="toc-text">Prometheus监控Docker主机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prometheus-%E6%A6%82%E8%BF%B0"><span class="toc-number">14.0.6.1.</span> <span class="toc-text">Prometheus 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Prometheus-%E9%83%A8%E7%BD%B2"><span class="toc-number">14.0.6.2.</span> <span class="toc-text">Prometheus 部署</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F"><span class="toc-number">14.0.7.</span> <span class="toc-text">构建容器监控系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cAdvisor-InfluxDB-Grafana"><span class="toc-number">14.0.7.1.</span> <span class="toc-text">cAdvisor+InfluxDB+Grafana</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93Harbor"><span class="toc-number">15.</span> <span class="toc-text">企业级镜像仓库Harbor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Harbor%E6%A6%82%E8%BF%B0"><span class="toc-number">15.0.1.</span> <span class="toc-text">Harbor概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Harbor%E9%83%A8%E7%BD%B2"><span class="toc-number">15.0.2.</span> <span class="toc-text">Harbor部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">15.0.3.</span> <span class="toc-text">基本使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">16.</span> <span class="toc-text">Docker-Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%B9%B6%E5%AE%89%E8%A3%85Docker-Compose"><span class="toc-number">16.0.1.</span> <span class="toc-text">下载并安装Docker-Compose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%93%E9%AA%8C"><span class="toc-number">16.0.2.</span> <span class="toc-text">体验</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">16.0.2.0.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">16.0.2.0.2.</span> <span class="toc-text">为项目创建目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BAapp-py%E6%96%87%E4%BB%B6%EF%BC%8C%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B"><span class="toc-number">16.0.2.0.3.</span> <span class="toc-text">在项目目录中创建一个名为app.py文件，内容如下</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BArequirements-txt%E6%96%87%E4%BB%B6%EF%BC%8C%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B"><span class="toc-number">16.0.2.0.4.</span> <span class="toc-text">在项目目录中创建一个名为requirements.txt文件，内容如下</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BADockerfile%E6%96%87%E4%BB%B6"><span class="toc-number">16.0.2.0.5.</span> <span class="toc-text">在项目目录中创建一个名为Dockerfile文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BAdocker-compose-yml%E6%96%87%E4%BB%B6"><span class="toc-number">16.0.2.0.6.</span> <span class="toc-text">在项目目录中创建一个名为docker-compose.yml文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Compose%E6%9E%84%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%9C%A8%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87%E8%BF%90%E8%A1%8Cdocker-compose-up-%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">16.0.2.0.7.</span> <span class="toc-text">使用Compose构建和运行应用程序，在项目目录中，通过运行docker-compose up 启动应用程序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#YAML%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%8A%E7%BC%96%E5%86%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">16.0.2.0.8.</span> <span class="toc-text">YAML文件格式及编写注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Compose%E7%AE%A1%E7%90%86MySQL%E5%92%8CTomcat%E5%AE%B9%E5%99%A8"><span class="toc-number">16.0.3.</span> <span class="toc-text">Docker-Compose管理MySQL和Tomcat容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8docker-compose%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%E5%AE%B9%E5%99%A8"><span class="toc-number">16.0.4.</span> <span class="toc-text">使用docker-compose命令管理容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Edocker-compose-yml%E5%90%AF%E5%8A%A8%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">16.0.4.0.1.</span> <span class="toc-text">基于docker-compose.yml启动管理的容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E5%B9%B6%E5%88%A0%E9%99%A4%E5%AE%B9%E5%99%A8"><span class="toc-number">16.0.4.0.2.</span> <span class="toc-text">关闭并删除容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%90%AF-%E5%85%B3%E9%97%AD-%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8"><span class="toc-number">16.0.4.0.3.</span> <span class="toc-text">开启|关闭|重启容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%94%B1docker-compose%E7%AE%A1%E7%90%86%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">16.0.4.0.4.</span> <span class="toc-text">查看由docker-compose管理的容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97"><span class="toc-number">16.0.4.0.5.</span> <span class="toc-text">查看日志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose%E9%85%8D%E5%90%88Dockerfile%E4%BD%BF%E7%94%A8%EF%BC%88%E7%BB%9F%E4%B8%80%E5%9C%A8-opt%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">16.0.5.</span> <span class="toc-text">docker-compose配合Dockerfile使用（统一在&#x2F;opt目录下操作）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose%E8%AF%B4%E6%98%8E"><span class="toc-number">16.0.6.</span> <span class="toc-text">docker-compose说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%AE%B9%E5%99%A8"><span class="toc-number">16.0.6.0.1.</span> <span class="toc-text">管理控制容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E9%95%9C%E5%83%8F%EF%BC%88%E9%9C%80%E8%A6%81Dockerfile%E6%96%87%E4%BB%B6%E7%9A%84%E6%94%AF%E6%92%91%EF%BC%89"><span class="toc-number">16.0.6.0.2.</span> <span class="toc-text">管理控制镜像（需要Dockerfile文件的支撑）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE"><span class="toc-number">16.0.7.</span> <span class="toc-text">开源项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Compose%E9%A1%B9%E7%9B%AE"><span class="toc-number">16.0.8.</span> <span class="toc-text">Docker Compose项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">16.0.8.1.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">16.0.8.2.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web-%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-number">16.0.8.3.</span> <span class="toc-text">Web 子目录</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#index-py"><span class="toc-number">16.0.8.3.0.1.</span> <span class="toc-text">index.py</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#index-html"><span class="toc-number">16.0.8.3.0.2.</span> <span class="toc-text">index.html</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dockerfile"><span class="toc-number">16.0.8.4.</span> <span class="toc-text">Dockerfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#haproxy-%E7%9B%AE%E5%BD%95"><span class="toc-number">16.0.8.5.</span> <span class="toc-text">haproxy 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-compose-yml"><span class="toc-number">16.0.8.6.</span> <span class="toc-text">docker-compose.yml</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C-compose-%E9%A1%B9%E7%9B%AE"><span class="toc-number">16.0.8.7.</span> <span class="toc-text">运行 compose 项目</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-API"><span class="toc-number">17.</span> <span class="toc-text">Docker API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8DAPI"><span class="toc-number">17.0.1.</span> <span class="toc-text">三种API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8Remote-API"><span class="toc-number">17.0.2.</span> <span class="toc-text">启动Remote API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95Remote-API"><span class="toc-number">17.0.3.</span> <span class="toc-text">测试Remote API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87API%E7%AE%A1%E7%90%86Docker%E5%AE%B9%E5%99%A8"><span class="toc-number">17.0.4.</span> <span class="toc-text">通过API管理Docker容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%EF%BC%9A"><span class="toc-number">17.0.5.</span> <span class="toc-text">创建容器：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Consul"><span class="toc-number">18.</span> <span class="toc-text">Consul</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85consul"><span class="toc-number">18.0.1.</span> <span class="toc-text">安装consul</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1-consul1"><span class="toc-number">18.0.2.</span> <span class="toc-text">启动服务:consul1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-consul-server1-%E7%9A%84-ip-%E5%9C%B0%E5%9D%80"><span class="toc-number">18.0.3.</span> <span class="toc-text">获取 consul server1 的 ip 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%EF%BC%9Aconsul2"><span class="toc-number">18.0.4.</span> <span class="toc-text">启动服务：consul2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%EF%BC%9Aconsul3"><span class="toc-number">18.0.5.</span> <span class="toc-text">启动服务：consul3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AC%AC%E4%BA%94%E7%95%A5"><span class="toc-number">18.0.6.</span> <span class="toc-text">第四第五略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE"><span class="toc-number">18.0.7.</span> <span class="toc-text">访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rancher"><span class="toc-number">19.</span> <span class="toc-text">Rancher</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Rancher"><span class="toc-number">19.0.1.</span> <span class="toc-text">安装Rancher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="toc-number">19.0.2.</span> <span class="toc-text">启动容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bip%E5%9C%B0%E5%9D%80"><span class="toc-number">19.0.3.</span> <span class="toc-text">查看ip地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-1"><span class="toc-number">19.0.4.</span> <span class="toc-text">访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2"><span class="toc-number">19.0.5.</span> <span class="toc-text">案例：博客部署</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Swarm"><span class="toc-number">20.</span> <span class="toc-text">Swarm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Swarm%E4%BB%8B%E7%BB%8D"><span class="toc-number">20.0.1.</span> <span class="toc-text">Swarm介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E5%8F%8A%E8%8A%82%E7%82%B9%E7%AE%A1%E7%90%86"><span class="toc-number">20.0.2.</span> <span class="toc-text">集群部署及节点管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BF%E9%87%8C%E4%BA%91%E8%B4%AD%E4%B9%B0%E5%9B%9B%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">20.0.2.1.</span> <span class="toc-text">阿里云购买四台服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E5%8F%B0%E6%9C%BA%E5%99%A8%E5%AE%89%E8%A3%85docker"><span class="toc-number">20.0.2.2.</span> <span class="toc-text">4台机器安装docker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.0.2.3.</span> <span class="toc-text">工作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="toc-number">20.0.2.4.</span> <span class="toc-text">搭建集群</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-swarm%E9%A1%B9%E7%9B%AE"><span class="toc-number">21.</span> <span class="toc-text">Docker swarm项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0"><span class="toc-number">21.0.1.</span> <span class="toc-text">概念学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Swarm%E9%A1%B9%E7%9B%AE%E5%AE%89%E8%A3%85"><span class="toc-number">21.0.2.</span> <span class="toc-text">Docker Swarm项目安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Swarm%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8"><span class="toc-number">21.0.3.</span> <span class="toc-text">Docker Swarm项目使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-DockerHub-%E6%8F%90%E4%BE%9B%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">21.0.4.</span> <span class="toc-text">使用 DockerHub 提供的服务发现功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4-token"><span class="toc-number">21.0.5.</span> <span class="toc-text">创建集群 token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5%E9%9B%86%E7%BE%A4"><span class="toc-number">21.0.6.</span> <span class="toc-text">加入集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8swarm-manager"><span class="toc-number">21.0.7.</span> <span class="toc-text">启动swarm manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6"><span class="toc-number">21.0.8.</span> <span class="toc-text">使用文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Swarm%E9%A1%B9%E7%9B%AE%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">21.0.9.</span> <span class="toc-text">Docker Swarm项目调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spread-%E7%AD%96%E7%95%A5"><span class="toc-number">21.0.10.</span> <span class="toc-text">spread 策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binpack-%E7%AD%96%E7%95%A5"><span class="toc-number">21.0.11.</span> <span class="toc-text">binpack 策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-Swarm%E9%A1%B9%E7%9B%AE%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">21.0.12.</span> <span class="toc-text">Docker Swarm项目过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constraint-Filter"><span class="toc-number">21.0.13.</span> <span class="toc-text">Constraint Filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Affinity-Filter"><span class="toc-number">21.0.14.</span> <span class="toc-text">Affinity Filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Port-Filter"><span class="toc-number">21.0.15.</span> <span class="toc-text">Port Filter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%88%98Redis"><span class="toc-number">22.</span> <span class="toc-text">实战Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83"><span class="toc-number">23.</span> <span class="toc-text">构建持续集成环境</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img src="/bg/Image00018.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库150道高频面试题"/></a><div class="content"><a class="title" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题">MySQL数据库150道高频面试题</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术同学必会的MySQL设计规约"/></a><div class="content"><a class="title" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约">技术同学必会的MySQL设计规约</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dfdfdf4.html" title="数据库概述"><img src="/bg/Image00002.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库概述"/></a><div class="content"><a class="title" href="/posts/dfdfdf4.html" title="数据库概述">数据库概述</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/490575ab.html" title="24工厂模式俗话解释"><img src="/bg/Image00024.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24工厂模式俗话解释"/></a><div class="content"><a class="title" href="/posts/490575ab.html" title="24工厂模式俗话解释">24工厂模式俗话解释</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/364ea8cc.html" title="设计模式"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/364ea8cc.html" title="设计模式">设计模式</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2020 - 2025 By 蓝桉</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8152976493" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat/cat.js"></script><script async data-pjax src="/js/meting/music_lanan.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/day/lunar.js"></script><script defer src="/js/day/day.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '10a7db1c41b6489db9c830c668a18304';
  var gaud_map_key = '82a64bc994fb6494830f157f319f9f69';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime/runtime.min.js"></script><script async src="/js/font/ali_font_all.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>
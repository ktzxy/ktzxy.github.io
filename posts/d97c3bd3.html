<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL-索引 | 蓝桉`Blog</title><meta name="author" content="蓝桉,kt_zxh@163.com"><meta name="copyright" content="蓝桉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 索引概述1.1. 什么是索引MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的示意图所示：  **索引的本质是：一种数据结构** **索引的作用是：高效获取数据**">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-索引">
<meta property="og:url" content="https://ktzxy.github.io/posts/d97c3bd3.html">
<meta property="og:site_name" content="蓝桉&#96;Blog">
<meta property="og:description" content="1. 索引概述1.1. 什么是索引MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的示意图所示：  **索引的本质是：一种数据结构** **索引的作用是：高效获取数据**">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ktzxy.github.io/bg/Image00025.webp">
<meta property="article:published_time" content="2025-07-09T17:28:46.000Z">
<meta property="article:modified_time" content="2025-07-13T15:45:18.452Z">
<meta property="article:author" content="蓝桉">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ktzxy.github.io/bg/Image00025.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL-索引",
  "url": "https://ktzxy.github.io/posts/d97c3bd3.html",
  "image": "https://ktzxy.github.io/bg/Image00025.webp",
  "datePublished": "2025-07-09T17:28:46.000Z",
  "dateModified": "2025-07-13T15:45:18.452Z",
  "author": [
    {
      "@type": "Person",
      "name": "蓝桉",
      "url": "https://ktzxy.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ktzxy.github.io/posts/d97c3bd3.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL-索引',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/progress_bar/progress_bar.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/windmill/windmill.css"><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/meting/music_lanan.css"><div id="myscoll"></div><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="蓝桉`Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/bg.webp);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/bg/Image00025.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">蓝桉`Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL-索引</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-zhuye-"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhuye-"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-shijianzhou"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijianzhou"></use></svg><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/essay/"><i class="fa-fw icon-xiaoxi"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiaoxi"></use></svg><span> 闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw icon-music"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-music"></use></svg><span> 音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw icon-pengyouquan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-pengyouquan"></use></svg><span> 朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-xinfeng"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="javascript:randomPost();"><i class="fa-fw icon-wodezhuifan"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wodezhuifan"></use></svg><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-guanyuwomen2"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guanyuwomen2"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MySQL-索引</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-13T15:45:18.452Z" title="更新于 2025-07-13 15:45:18">2025-07-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1. 索引概述"></a>1. 索引概述</h2><h3 id="1-1-什么是索引"><a href="#1-1-什么是索引" class="headerlink" title="1.1. 什么是索引"></a>1.1. 什么是索引</h3><p>MySQL 官方对索引的定义为：索引（index）是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的<strong>数据结构</strong>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，<strong>这种数据结构就是索引</strong>。如下面的示意图所示：</p>
<ul>
<li><font color=red>**索引的本质是：一种数据结构**</font></li>
<li><font color=red>**索引的作用是：高效获取数据**</font>

</li>
</ul>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026576.png" alt=""></p>
<p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，<font color=red><strong>每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针</strong></font>，这样就可以运用二叉查找快速获取到相应数据。</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</p>
<h3 id="1-2-索引的优缺点"><a href="#1-2-索引的优缺点" class="headerlink" title="1.2. 索引的优缺点"></a>1.2. 索引的优缺点</h3><h4 id="1-2-1-索引的优势"><a href="#1-2-1-索引的优势" class="headerlink" title="1.2.1. 索引的优势"></a>1.2.1. 索引的优势</h4><ol>
<li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li>
</ol>
<h4 id="1-2-2-索引的代价（劣势）"><a href="#1-2-2-索引的代价（劣势）" class="headerlink" title="1.2.2. 索引的代价（劣势）"></a>1.2.2. 索引的代价（劣势）</h4><ol>
<li><strong>空间上的代价</strong></li>
</ol>
<p>每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成会占据很多的存储空间。</p>
<p>实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。</p>
<ol>
<li><strong>时间上的代价</strong></li>
</ol>
<p>虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>等操作。因为更新表时，MySQL 不仅要保存数据，还要保存索引文件因每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息，即需要修改各个 B+ 树索引。</p>
<p>B+ 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是非叶子内节点中的记录都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都要进行相关的维护操作，这必然会对性能造成影响。</p>
<h2 id="2-索引的基础语法"><a href="#2-索引的基础语法" class="headerlink" title="2. 索引的基础语法"></a>2. 索引的基础语法</h2><p>InnoDB 和 MyISAM 会自动为主键或者声明为<code>UNIQUE</code>的列去自动建立B+树索引。如要给表中其他列创建索引则需要通过sql语句去指定</p>
<h3 id="2-1-查看索引"><a href="#2-1-查看索引" class="headerlink" title="2.1. 查看索引"></a>2.1. 查看索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-创建-修改索引"><a href="#2-2-创建-修改索引" class="headerlink" title="2.2. 创建/修改索引"></a>2.2. 创建/修改索引</h3><h4 id="2-2-1-语法"><a href="#2-2-1-语法" class="headerlink" title="2.2.1. 语法"></a>2.2.1. 语法</h4><ul>
<li>建表同时创建索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TALBE 表名 (</span><br><span class="line">    各种列的信息 ··· ,</span><br><span class="line">    [KEY<span class="operator">|</span>INDEX] 索引名 (需要被索引的单个列或多个列)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>单独创建索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] INDEX 索引名 <span class="keyword">ON</span> 表名(字段名(length));</span><br></pre></td></tr></table></figure>
<ul>
<li>创建/修改索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] INDEX [索引名] (字段名(length));</span><br><span class="line"><span class="comment">-- 可以同时创建多个索引</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] INDEX [索引名] (字段名(length)), <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] INDEX [索引名] (字段名(length)), ...;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-示例"><a href="#2-2-2-示例" class="headerlink" title="2.2.2. 示例"></a>2.2.2. 示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通索引方式1-创建表的时候直接指定</span></span><br><span class="line"><span class="keyword">create  table</span> student(</span><br><span class="line">    sid <span class="type">int</span> <span class="keyword">primary key</span>,</span><br><span class="line">    card_id <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    gender <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="type">int</span>,</span><br><span class="line">    birth <span class="type">date</span>,</span><br><span class="line">    phone_num <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    score <span class="keyword">double</span>,</span><br><span class="line">    index index_name(name) <span class="comment">-- 给name列创建索引</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 普通索引方式2-直接创建</span></span><br><span class="line"><span class="keyword">create</span> index index_gender <span class="keyword">on</span> student(gender);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 普通索引方式3-修改表结构(添加索引)</span></span><br><span class="line"><span class="keyword">alter table</span> student <span class="keyword">add</span> index index_age(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 唯一索引方式1-创建表的时候直接指定</span></span><br><span class="line"><span class="keyword">create  table</span> student2(</span><br><span class="line">    sid <span class="type">int</span> <span class="keyword">primary key</span>,</span><br><span class="line">    card_id <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    gender <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="type">int</span>,</span><br><span class="line">    birth <span class="type">date</span>,</span><br><span class="line">    phone_num <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    score <span class="keyword">double</span>,</span><br><span class="line">    <span class="keyword">unique</span> index_card_id(card_id) <span class="comment">-- 给card_id列创建索引</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 唯一索引方式2-直接创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index index_card_id <span class="keyword">on</span> student2(card_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 唯一索引方式3-修改表结构(添加索引)</span></span><br><span class="line"><span class="keyword">alter table</span> student2 <span class="keyword">add</span> <span class="keyword">unique</span> index_phone_num(phone_num)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的基本语法</span></span><br><span class="line"><span class="keyword">create</span> index indexname <span class="keyword">on</span> table_name(column1(length),column2(length)); </span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-两种创建索引方式的区别"><a href="#2-2-3-两种创建索引方式的区别" class="headerlink" title="2.2.3. 两种创建索引方式的区别"></a>2.2.3. 两种创建索引方式的区别</h4><p>创建(修改) 索引有两种方式，分别使用 <code>CREATE</code> 与 <code>ALTER</code> 关键字。两种索引的区别：</p>
<ol>
<li><code>ALTER</code> 创建索引时可以省略索引名称，数据库会默认根据第一个索引列作为索引的名称；<code>CREATE</code> 创建索引时必须指定索引名称。</li>
<li><strong><code>CREATE</code> 不能用于创建 Primary Key 索引</strong>。</li>
<li><code>ALTER</code> 方式允许一条语句<strong>同时创建多个索引</strong>；<code>CREATE</code> 方式一次<strong>只能创建一个索引</strong>。</li>
</ol>
<h3 id="2-3-删除索引"><a href="#2-3-删除索引" class="headerlink" title="2.3. 删除索引"></a>2.3. 删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式一</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX [索引名] <span class="keyword">ON</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"><span class="keyword">ALTER TABLE</span> 表名 <span class="keyword">DROP</span> [INDEX<span class="operator">|</span>KEY] 索引名;</span><br></pre></td></tr></table></figure>
<p>值得注意的是：若删除表中涉及索引的某列，索引会受到影响。对于多列组合索引，如果删除其中的某一列，则该列会从对应的索引中被删除（即<strong>删除列，不会删除索引</strong>）；如果删除组成索引的所有列，则索引将被删除（即<strong>不仅删除列，还删除相应的索引</strong>）。</p>
<h3 id="2-4-大表添加索引的优化方案"><a href="#2-4-大表添加索引的优化方案" class="headerlink" title="2.4. 大表添加索引的优化方案"></a>2.4. 大表添加索引的优化方案</h3><p>如果一张表数据量级是千万级别以上，<strong>给表添加索引的时候，是会对表加锁的</strong>。如果不谨慎操作，有可能出现生产事故的。可以参考以下添加索引的方法进行优化：</p>
<ol>
<li>先创建一张跟原表 A 数据结构相同的新表 B。</li>
<li>在新表 B 添加需要加上的新索引。</li>
<li>把原表 A 数据导到新表 B。</li>
<li><code>rename</code> 新表 B 为原表的表名 A，原表 A 换别的表名</li>
</ol>
<h2 id="3-索引结构（从数据结构维度划分）"><a href="#3-索引结构（从数据结构维度划分）" class="headerlink" title="3. 索引结构（从数据结构维度划分）"></a>3. 索引结构（从数据结构维度划分）</h2><p>索引是在 MySQL 的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL 目前提供了以下4种索引：</p>
<ul>
<li><strong>B-TREE 索引</strong>：最常见的索引类型，大部分索引都支持 B 树索引。</li>
<li><strong>HASH 索引</strong>：只有 Memory 引擎支持，使用场景简单。</li>
<li><strong>R-tree 索引（空间索引）</strong>：空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，了解即可。</li>
<li><strong>Full-text（全文索引）</strong>：全文索引也是 MyISAM 的一个特殊索引类型，主要用于全文索引，InnoDB 从 MySQL 5.6 版本开始支持全文索引。</li>
</ul>
<center><b>MyISAM、InnoDB、Memory 三种存储引擎对各种索引类型的支持</b></center>

<div class="table-container">
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB引擎</th>
<th>MyISAM引擎</th>
<th>Memory引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td>BTREE索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>HASH 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6 版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
</div>
<p>注：平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中<strong>聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为索引</strong></p>
<h3 id="3-1-BTREE-结构"><a href="#3-1-BTREE-结构" class="headerlink" title="3.1. BTREE 结构"></a>3.1. BTREE 结构</h3><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p>
<ul>
<li>树中每个节点最多包含m个孩子。</li>
<li>除根节点与叶子节点外，每个节点至少有<code>[ceil(m/2)]</code>个孩子。</li>
<li>若根节点不是叶子节点，则至少有两个孩子。</li>
<li>所有的叶子节点都在同一层。</li>
<li>每个非叶子节点由n个key与n+1个指针组成，其中<code>[ceil(m/2)-1] &lt;= n &lt;= m-1</code></li>
</ul>
<p>以5叉BTree为例，由key的数量（即是<code>key=5</code>）根据公式<code>[ceil(m/2)-1] &lt;= n &lt;= m-1</code>推导可得知，所以<code>2 &lt;= n &lt;=4</code>。当<code>n&gt;4</code>时，中间节点分裂到父节点，两边节点分裂。</p>
<blockquote>
<p>Tips: 树的度数指的是一个节点的子节点个数。</p>
</blockquote>
<p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例，其演变过程如下：</p>
<ol>
<li>插入前4个字母 C N G A</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026577.png" alt=""></p>
<ol>
<li>插入H，<code>n&gt;4</code>，中间元素G字母向上分裂到新的节点</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026578.png" alt=""></p>
<ol>
<li>插入E，K，Q不需要分裂</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026579.png" alt=""></p>
<ol>
<li>插入M，中间元素M字母向上分裂到父节点G</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026580.png" alt=""></p>
<ol>
<li>插入F，W，L，T不需要分裂</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026581.png" alt=""></p>
<ol>
<li>插入Z，中间元素T向上分裂到父节点中</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026582.png" alt=""></p>
<ol>
<li>插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026583.png" alt=""></p>
<ol>
<li>最后插入S，NPQR节点<code>n&gt;5</code>，中间节点Q向上分裂，但分裂后父节点DGMT的<code>n&gt;5</code>，中间节点M向上分裂</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026584.png" alt=""></p>
<p>到此，该BTREE树就已经构建完成了，BTREE树和二叉树相比，查询数据的效率更高，因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</p>
<blockquote>
<p>Tips: 可通过数据结构可视化的网站来体验 BTREE 的数据结构演变过程。 <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p>
</blockquote>
<h3 id="3-2-B-TREE-结构"><a href="#3-2-B-TREE-结构" class="headerlink" title="3.2. B+TREE 结构"></a>3.2. B+TREE 结构</h3><h4 id="3-2-1-B-TREE-简介"><a href="#3-2-1-B-TREE-简介" class="headerlink" title="3.2.1. B+TREE 简介"></a>3.2.1. B+TREE 简介</h4><p>B+Tree 为 BTree 的变种，B+Tree 与 BTree 的区别为：</p>
<ol>
<li>n 叉 B+Tree 最多含有 n 个 key，而 BTree 最多含有 n-1 个 key</li>
<li>B+Tree 的叶子节点保存所有的 key 信息，依 key 大小顺序排列</li>
<li>所有的非叶子节点都可以看作是 key 的索引部分，不存储数据。只存储索引(冗余)是为了可以放更多的索引</li>
<li>叶子节点包含所有索引字段</li>
<li>所有叶子节点使用指针连接，提高区间访问的性能（MySQL 增加的特性）</li>
</ol>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026585.png" alt=""></p>
<p>由于 B+Tree 只有叶子节点保存 key 信息，查询任何 key 都要从 root 节点走到叶子节点。所以 B+Tree 的查询效率更加稳定</p>
<blockquote>
<p>Tips: MySQL 在高版本里，会优化将索引都常驻内存中，提升查询的速度</p>
</blockquote>
<h4 id="3-2-2-MySQL-中的-B-Tree"><a href="#3-2-2-MySQL-中的-B-Tree" class="headerlink" title="3.2.2. MySQL 中的 B+Tree"></a>3.2.2. MySQL 中的 B+Tree</h4><p>MySql 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，<strong>增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能</strong>。MySQL 中的 B+Tree 索引结构示意图如下：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026586.png" alt=""></p>
<blockquote>
<p>Notes: </p>
<ul>
<li><font color=red>**特别注意，一个索引对应一个B+Tree**</font></li>
<li>底层以上的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</li>
<li>最底层部分是数据存储部分，在其叶子节点中要存储具体的数据。</li>
<li>可通过数据结构可视化的网站来体验 BTREE 的数据结构演变过程。 <a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></li>
</ul>
</blockquote>
<h3 id="3-3-磁盘和B-树的关系"><a href="#3-3-磁盘和B-树的关系" class="headerlink" title="3.3. 磁盘和B+树的关系"></a>3.3. 磁盘和B+树的关系</h3><p>关系型数据库都选择了B+树数据结构，这个和磁盘的特性有着非常大的关系。</p>
<h4 id="3-3-1-磁盘结构"><a href="#3-3-1-磁盘结构" class="headerlink" title="3.3.1. 磁盘结构"></a>3.3.1. 磁盘结构</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026587.jpg" alt=""></p>
<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元也是最小读写单元。现在磁盘扇区一般是 512 个字节~4k 个字节。</p>
<p>磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、扇区号。读/写磁盘上某一指定数据需要下面步骤：</p>
<ol>
<li>首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找。</li>
<li>所有磁头都定位到磁道上后，这时根据盘面号来确定指定盘面上的具体磁道。</li>
<li>盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。</li>
</ol>
<p>经过上面步骤，指定数据的存储位置就被找到。这时就可以开始读/写操作。磁盘读取依靠的是机械运动，分为寻道时间、旋转延迟、传输时间三个部分，这三个部分耗时相加就是一次磁盘 IO 的时间，一般大概 9ms 左右。</p>
<p>为了提高效率，要尽量减少磁盘 I/O。为此，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，这个称之为<strong>预读</strong>。这样做的理论依据是计算机科学中著名的局部性原理：<strong>当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中</strong>。</p>
<p>磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间）。</p>
<ul>
<li>机械磁盘的顺序读的效率是随机读的 40 到 400 倍。顺序写是随机写的 10 到 100 倍</li>
<li>SSD 盘顺序读写的效率是随机读写的 7 到 10 倍</li>
</ul>
<h4 id="3-3-2-B-树结构在磁盘的存储"><a href="#3-3-2-B-树结构在磁盘的存储" class="headerlink" title="3.3.2. B+树结构在磁盘的存储"></a>3.3.2. B+树结构在磁盘的存储</h4><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，<strong>每个存储块称为一页</strong>，页大小通常为 4k 当然也有 16K 的，主存和磁盘以页为单位交换数据。即可以理解为，<font color=red><strong>一页就是一个磁盘块，代表一次磁 I/O</strong></font>。</p>
<p>按照磁盘的这种性质，如果是一个页存放一个 B+树的节点，自然是可以存很多的数据的，比如 <strong>InnoDB 默认定义的 B+树的节点大小是 16KB</strong>，这就是说，假如一个 Key 是 8 个字节，那么一个节点可以存放大约 1000 个 Key，意味着 B+数可以有 1000 个分叉。同时 InnoDB 每一次磁盘 I/O，读取的都是 16KB 的整数倍的数据。也就是说 InnoDB 在节点的读写上是可以充分利用磁盘顺序 IO 的高速读写特性。</p>
<p>按照 B+树逻辑结构来说，在叶子节点一层，所有记录的主键按照从小到大的顺序排列，并且形成了一个双向链表。同一层的非叶子节点也互相串联，形成了一个双向链表。那么在实际读写的时候，很大的概率相邻的节点会放在相邻的页上，又可以充分利用磁盘顺序 I/O 的高速读写特性。所以<font color=red><strong>对 MySQL 优化的一大方向就是尽可能的多让数据顺序读写，少让数据随机读写</strong></font>。</p>
<h3 id="3-4-Hash-结构"><a href="#3-4-Hash-结构" class="headerlink" title="3.4. Hash 结构"></a>3.4. Hash 结构</h3><p>MySQL 中除了支持 B+Tree 索引，还支持一种索引类型 - Hash 索引。</p>
<h4 id="3-4-1-结构"><a href="#3-4-1-结构" class="headerlink" title="3.4.1. 结构"></a>3.4.1. 结构</h4><p>哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中。如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了 hash 冲突（也称为 hash 碰撞），可以通过链表来解决。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026588.png" alt=""></p>
<p>若数据产生较少的 hash 冲突，那么查找一个数据的时间复杂度就是O(1)，因此一般多用于精确查找。</p>
<h4 id="3-4-2-Hash-索引和B-树优劣比较"><a href="#3-4-2-Hash-索引和B-树优劣比较" class="headerlink" title="3.4.2. Hash 索引和B+树优劣比较"></a>3.4.2. Hash 索引和B+树优劣比较</h4><ul>
<li>Hash 索引只能用于对等比较(<code>=</code>，<code>in</code>)，不支持范围查询（<code>between</code>，<code>&gt;</code>，<code>&lt;</code> ，…）</li>
<li>Hash 索引无法利用索引完成排序操作</li>
<li>Hash 索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为 hash 函数的不可预测。</li>
<li>hash 索引结构不会存放行数据，因此任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li>
<li>Hash 索引查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于 B+tree 索引。但性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li>
</ul>
<p>因此在大多数情况下，直接选择 B+树索引可以获得稳定且较好的查询速度，而不需要使用hash索引。</p>
<h4 id="3-4-3-存储引擎支持"><a href="#3-4-3-存储引擎支持" class="headerlink" title="3.4.3. 存储引擎支持"></a>3.4.3. 存储引擎支持</h4><p>在 MySQL 中，支持 hash 索引的是 Memory 存储引擎。而 InnoDB 中具有自适应 hash 功能，hash 索引是 InnoDB 存储引擎根据 B+Tree 索引在指定条件下自动构建的。</p>
<h3 id="3-5-B-树作用与索引总结"><a href="#3-5-B-树作用与索引总结" class="headerlink" title="3.5. B+树作用与索引总结"></a>3.5. B+树作用与索引总结</h3><ul>
<li>在块设备上，通过 B+树可以有效的存储数据；</li>
<li>所有记录都存储在叶子节点上，非叶子(non-leaf)存储索引(keys)信息；而且记录按照索引列的值由小到大排好了序。</li>
<li>B+树含有非常高的扇出（fanout），通常超过 100，在查找一个记录时，可以有效的减少 IO 操作；</li>
</ul>
<blockquote>
<p>Tips:</p>
<ul>
<li>『扇出』是每个索引节点(Non-LeafPage)指向每个叶子节点(LeafPage)的指针；</li>
<li>扇出数 = 索引节点(Non-LeafPage)可存储的最大关键字个数 + 1</li>
</ul>
</blockquote>
<h4 id="3-5-1-为什么-InnoDB-存储引擎选择使用-B-tree-索引结构"><a href="#3-5-1-为什么-InnoDB-存储引擎选择使用-B-tree-索引结构" class="headerlink" title="3.5.1. 为什么 InnoDB 存储引擎选择使用 B+tree 索引结构"></a>3.5.1. 为什么 InnoDB 存储引擎选择使用 B+tree 索引结构</h4><ol>
<li>相对于二叉树，B+tree 层级更少，搜索效率高。</li>
<li>由于 B+tree 的数据都存储在叶子结点中，叶子结点均为索引，只需要扫描一遍叶子结点即可；但是 BTree 因为其分支结点同样存储着数据，在查找具体的数据时，需要进行一次中序遍历按序来扫。所以 B+tree 更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常 B+tree 更适用于数据库索引。</li>
<li>对于 BTree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；而 B+tree 的节点只存储索引 key 值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点，减少更多的I/O支出。</li>
<li>B+tree 的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，让每一个数据的查询效率相当。</li>
<li>相对 Hash 索引，B+tree 支持范围匹配及排序操作</li>
</ol>
<h2 id="4-索引分类（从应用维度划分）"><a href="#4-索引分类（从应用维度划分）" class="headerlink" title="4. 索引分类（从应用维度划分）"></a>4. 索引分类（从应用维度划分）</h2><ul>
<li><strong>普通索引</strong></li>
<li><strong>唯一索引</strong></li>
<li><strong>主键索引</strong>，默认自动创建，一张表只能存在一个。</li>
<li><strong>复合（组合、联合）索引</strong></li>
<li><strong>前缀索引</strong></li>
<li><strong>全文索引</strong></li>
<li><strong>空间索引</strong></li>
</ul>
<p>MySQL 8.x 中实现的索引新特性：</p>
<ul>
<li><strong>隐藏索引</strong>：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li>
<li><strong>降序索引</strong>：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li>
<li><strong>函数索引</strong>：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>
</ul>
<h3 id="4-1-普通索引"><a href="#4-1-普通索引" class="headerlink" title="4.1. 普通索引"></a>4.1. 普通索引</h3><p>MySQL 中基本索引类型，没有什么限制，一张表允许创建多个普通索引，并且允许在定义索引的列中插入重复值和空值，唯一作用就是为了快速查询数据。</p>
<h3 id="4-2-唯一索引"><a href="#4-2-唯一索引" class="headerlink" title="4.2. 唯一索引"></a>4.2. 唯一索引</h3><p>唯一索引与普通索引类似，不同点是：<strong>索引列的值必须唯一，但允许有空值（Null）</strong>。</p>
<p>唯一索引也是一种约束。唯一索引的<strong>索引列不能出现重复的数据，但是允许数据为空值（NULL）</strong>，一张表允许创建多个唯一索引。如果是组合唯一索引，则列值的组合必须唯一。</p>
<p>建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</p>
<h3 id="4-3-主键索引"><a href="#4-3-主键索引" class="headerlink" title="4.3. 主键索引"></a>4.3. 主键索引</h3><p>在 MySQL 的 InnoDB 的表中，每张表都会有主键。在创建表时，如果没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。而 MySQL 会自动在主键列上建立一个索引，这就是<strong>主键索引</strong>。</p>
<p>主键是具有唯一性并且不允许为 NULL，所以<font color=red><strong>主键索引是一种特殊的唯一索引</strong></font>。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026589.png" alt=""></p>
<h4 id="4-3-1-复合主键-联合主键"><a href="#4-3-1-复合主键-联合主键" class="headerlink" title="4.3.1. 复合主键/联合主键"></a>4.3.1. 复合主键/联合主键</h4><p>复合主键（联合主键）是指表的主键含有一个以上的字段的组合，不使用无业务含义的自增id作为主键。复合（联合）主键的意义：用多个字段来确定一条记录，但这些字段都不是唯一的，可以分别重复。但<strong>多个字段联合的主键是唯一的</strong>。</p>
<p>举个例子，在表中创建了一个ID字段，自动增长，并设为主键，这个是没有问题的，因为“主键是唯一的索引”，ID自动增长保证了唯一性，所以可以。此时，再创建一个字段name，类型为varchar，也设置为主键，就会发现，在表的多行中是可以填写相同的name值的</p>
<p>总结：<font color=red><strong>当表中只有一个主键时，它是唯一的索引；当表中有多个主键时，称为复合主键，复合主键联合保证唯一索引。某几个主键字段值可以分别出现重复，只要不是有多条记录的所有主键值完全一样，就不算重复。</strong></font></p>
<h4 id="4-3-2-主键索引与唯一索引的区别"><a href="#4-3-2-主键索引与唯一索引的区别" class="headerlink" title="4.3.2. 主键索引与唯一索引的区别"></a>4.3.2. 主键索引与唯一索引的区别</h4><ul>
<li>主键索引是不允许为 Null 值并且唯一。</li>
<li>唯一约束的列可以在允许为 null 值（<em>因为 MySQL 定义所有的 Null 均不是同一个值</em>），唯一索引主要是用来防止数据重复插入。</li>
</ul>
<h3 id="4-4-组合（复合、联合）索引"><a href="#4-4-组合（复合、联合）索引" class="headerlink" title="4.4. 组合（复合、联合）索引"></a>4.4. 组合（复合、联合）索引</h3><p>组合索引也叫复合索引，指的是在建立索引的时候使用多个字段（<em>例如同时使用身份证和手机号建立索引</em>），同样的可以建立为普通索引或者是唯一索引。</p>
<blockquote>
<p>Tips: 使用组合索引时需遵循最左前缀原则。任何标准表最多可以创建 16 个索引列。（<em>待验证是否正确</em>）</p>
</blockquote>
<h3 id="4-5-前缀索引"><a href="#4-5-前缀索引" class="headerlink" title="4.5. 前缀索引"></a>4.5. 前缀索引</h3><p>前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，因为只取前几个字符，所以相比普通索引建立的数据更小，。</p>
<h3 id="4-6-全文索引"><a href="#4-6-全文索引" class="headerlink" title="4.6. 全文索引"></a>4.6. 全文索引</h3><h4 id="4-6-1-概述"><a href="#4-6-1-概述" class="headerlink" title="4.6.1. 概述"></a>4.6.1. 概述</h4><p>全文索引的关键字是 <code>fulltext</code>。全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较，它更像是一个搜索引擎，基于相似度的查询，而不是简单的<code>where</code>语句的参数匹配。</p>
<p>用 <code>like + %</code> 就可以实现模糊匹配了，为什么还要全文索引？<code>like + %</code> 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 <code>like + %</code> 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</p>
<h4 id="4-6-2-注意事项"><a href="#4-6-2-注意事项" class="headerlink" title="4.6.2. 注意事项"></a>4.6.2. 注意事项</h4><ul>
<li>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引</li>
<li>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引</li>
<li>只有字段的数据类型为 <code>char</code>、<code>varchar</code>、<code>text</code> 及其系列才可以建全文索引</li>
<li>在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用 <code>create index</code> 创建 <code>fulltext</code> 索引，要比先为一张表建立 <code>fulltext</code> 然后再将数据写入的速度快很多；</li>
</ul>
<h4 id="4-6-3-最小搜索长度和最大搜索长度"><a href="#4-6-3-最小搜索长度和最大搜索长度" class="headerlink" title="4.6.3. 最小搜索长度和最大搜索长度"></a>4.6.3. 最小搜索长度和最大搜索长度</h4><p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。这两个的默认值可以使用以下命令查看:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%ft%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>部分参数解析</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数名称</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">最小值</th>
<th style="text-align:center">最大值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ft_min_word_len</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3600</td>
<td>MyISAM  引擎表全文索引包含的最小词长度</td>
</tr>
<tr>
<td style="text-align:center">ft_query_expansion_limit</td>
<td style="text-align:center">20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1000</td>
<td>MyISAM引擎表使用  with  query expansion 进行全文搜索的最大匹配数</td>
</tr>
<tr>
<td style="text-align:center">innodb_ft_min_token_size</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">16</td>
<td>InnoDB  引擎表全文索引包含的最小词长度</td>
</tr>
<tr>
<td style="text-align:center">innodb_ft_max_token_size</td>
<td style="text-align:center">84</td>
<td style="text-align:center">10</td>
<td style="text-align:center">84</td>
<td>InnoDB  引擎表全文索引包含的最大词长度</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-6-4-全文索引创建语法"><a href="#4-6-4-全文索引创建语法" class="headerlink" title="4.6.4. 全文索引创建语法"></a>4.6.4. 全文索引创建语法</h4><p>语法格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表的时候添加全文索引</span></span><br><span class="line"><span class="keyword">create table</span> 表名 (</span><br><span class="line">     ...</span><br><span class="line">     fulltext (字段名) <span class="comment">-- 创建全文检索</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构添加全文索引</span></span><br><span class="line"><span class="keyword">alter table</span> 表名 <span class="keyword">add</span> fulltext index_content(字段名);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接添加全文索引</span></span><br><span class="line"><span class="keyword">create</span> fulltext index index_content <span class="keyword">on</span> 表名(字段名);</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> t_article (</span><br><span class="line">     id <span class="type">int</span> <span class="keyword">primary key</span> auto_increment ,</span><br><span class="line">     title <span class="type">varchar</span>(<span class="number">255</span>) ,</span><br><span class="line">     content <span class="type">varchar</span>(<span class="number">1000</span>) ,</span><br><span class="line">     writing_date <span class="type">date</span>,</span><br><span class="line">     fulltext (content) <span class="comment">-- 创建全文检索</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter table</span> t_article <span class="keyword">add</span> fulltext index_content(content);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> fulltext index index_content <span class="keyword">on</span> t_article(content);</span><br></pre></td></tr></table></figure>
<h4 id="4-6-5-使用全文索引"><a href="#4-6-5-使用全文索引" class="headerlink" title="4.6.5. 使用全文索引"></a>4.6.5. 使用全文索引</h4><p>使用全文索引和常用的模糊匹配使用 <code>like + %</code> 不同，全文索引有自己的语法格式，使用 <code>match</code> 和 <code>against</code> 关键字，格式:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> (col1,col2,...)  against(expr [search_modifier])</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_article <span class="keyword">where</span> <span class="keyword">match</span>(content) against(<span class="string">&#x27;yo&#x27;</span>); <span class="comment">-- 没有结果 单词数需要大于等于3 </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_article <span class="keyword">where</span> <span class="keyword">match</span>(content) against(<span class="string">&#x27;you&#x27;</span>); <span class="comment">-- 有结果</span></span><br></pre></td></tr></table></figure>
<h3 id="4-7-空间索引-少用，了解"><a href="#4-7-空间索引-少用，了解" class="headerlink" title="4.7. 空间索引(少用，了解)"></a>4.7. 空间索引(少用，了解)</h3><p>MySQL 在 5.7 之后的版本支持了空间索引，而且支持 OpenGIS 几何数据模型。空间索引是对空间数据类型的字段建立的索引，MYSQL 中的空间数据类型有4种，分别是 GEOMETRY、POINT、LINESTRING、POLYGON。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Geometry</td>
<td>空间数据</td>
<td>任何一种空间类型</td>
</tr>
<tr>
<td>Point</td>
<td>点</td>
<td>坐标值</td>
</tr>
<tr>
<td>LineString</td>
<td>线</td>
<td>有一系列点连接而成</td>
</tr>
<tr>
<td>Polygon</td>
<td>多边形</td>
<td>由多条线组成</td>
</tr>
</tbody>
</table>
</div>
<p>MYSQL 使用 SPATIAL 关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> 表名 (</span><br><span class="line">  ...</span><br><span class="line">  spatial key geom_index(列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Notes: 创建空间索引的列，必须将其声明为 NOT NULL。</p>
</blockquote>
<h2 id="5-InnoDB-中的索引（按照底层存储方式划分）"><a href="#5-InnoDB-中的索引（按照底层存储方式划分）" class="headerlink" title="5. InnoDB 中的索引（按照底层存储方式划分）"></a>5. InnoDB 中的索引（按照底层存储方式划分）</h2><p>MySQL 的 InnoDB 引擎中的索引也是按照 B+树来组织的。最终会在磁盘中保存为 <code>.ibd</code> 格式的文件，里面包含了该表的索引和数据。以物理存储维度主要分为两种：<strong>聚集索引</strong>和<strong>二级索引（辅助索引、非聚簇索引）</strong>。</p>
<h3 id="5-1-聚集索引-聚簇索引（Clustered-Index）"><a href="#5-1-聚集索引-聚簇索引（Clustered-Index）" class="headerlink" title="5.1. 聚集索引/聚簇索引（Clustered Index）"></a>5.1. 聚集索引/聚簇索引（Clustered Index）</h3><h4 id="5-1-1-聚簇索引介绍"><a href="#5-1-1-聚簇索引介绍" class="headerlink" title="5.1.1. 聚簇索引介绍"></a>5.1.1. 聚簇索引介绍</h4><p>聚簇索引（Clustered Index）是以主键创建的索引，在叶子节点存储的是表中的数据。即索引结构和数据一起存放的索引，并不是一种单独的索引类型。如果表没有定义主键，MySQL 会选择一个不允许为 NULL 的唯一性索引建立聚集索引。如果也没有合适的唯一性索引，MySQL 也会创建一个隐含列 RowID 来做主键（此隐藏的主键长度为6个字节，值会随着数据的插入自增），然后用这个主键来建立聚集索引。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026590.png" alt=""></p>
<p>InnoDB 中的主键索引就属于聚簇索引。MySQL 会将表的主键用来构造一棵 B+树，每个非叶子节点存储索引（主键），并且将整张表的行记录数据存放在该 B+树的叶子节点（叶子节点就是数据页，数据页上存放的是完整的每行记录）中。</p>
<p>聚簇索引特点是：<font color=red><strong>索引即数据，数据即索引。由于聚集索引是利用表的主键构建的，因此每张表只能拥有一个聚集索引</strong></font>。</p>
<h4 id="5-1-2-聚簇索引的优缺点"><a href="#5-1-2-聚簇索引的优缺点" class="headerlink" title="5.1.2. 聚簇索引的优缺点"></a>5.1.2. 聚簇索引的优缺点</h4><p>优点：</p>
<ul>
<li><strong>查询速度快</strong>：因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。因为聚集索引能获取完整的整行数据，相比于非聚簇索引，聚簇索引少了一次读取数据的 IO 操作。</li>
<li><strong>对排序查找和范围查找优化</strong>：对于主键的排序查找和范围查找速度非常快。因为聚集索引叶子节点的存储是逻辑上连续的，使用双向链表连接，叶子节点按照主键的顺序排序。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度会比较慢。</li>
<li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<h3 id="5-2-非聚簇索引"><a href="#5-2-非聚簇索引" class="headerlink" title="5.2. 非聚簇索引"></a>5.2. 非聚簇索引</h3><h4 id="5-2-1-非聚簇索引简介"><a href="#5-2-1-非聚簇索引简介" class="headerlink" title="5.2.1. 非聚簇索引简介"></a>5.2.1. 非聚簇索引简介</h4><p>非聚集索引就是以非主键创建的索引，在叶子节点存储的是主键和索引列。</p>
<h4 id="5-2-2-非聚簇索引的优缺点"><a href="#5-2-2-非聚簇索引的优缺点" class="headerlink" title="5.2.2. 非聚簇索引的优缺点"></a>5.2.2. 非聚簇索引的优缺点</h4><p>优点：</p>
<ul>
<li><strong>更新代价比聚簇索引要小</strong>：非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong>：这应该是非聚簇索引最大的缺点了。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<h4 id="5-2-3-聚集索引和非聚集索引的结构对比"><a href="#5-2-3-聚集索引和非聚集索引的结构对比" class="headerlink" title="5.2.3. 聚集索引和非聚集索引的结构对比"></a>5.2.3. 聚集索引和非聚集索引的结构对比</h4><p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026591.png" alt=""></p>
<ul>
<li>聚集索引的叶子节点下挂的是这一行的数据 。</li>
<li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li>
</ul>
<h4 id="5-2-4-回表"><a href="#5-2-4-回表" class="headerlink" title="5.2.4. 回表"></a>5.2.4. 回表</h4><p>当通过辅助索引来寻找数据时，InnoDB 存储引擎会遍历辅助索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键索引（聚集索引）来找到一个完整的行记录。这个过程也被称为回表。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026592.png" alt=""></p>
<blockquote>
<p>根据辅助索引的值查询一条完整的用户记录需要使用到 2 棵 B+树 -&gt; 一次辅助索引，一次聚集索引。</p>
</blockquote>
<p>辅助索引叶子节点不会像聚集索引一样，不会将完整的行记录放到叶子节点中。虽然如果将完整行记录放到叶子节点是可以不用回表，但相当于每建立一棵 B+树都需要把所有的记录再都拷贝一份，太过占用存储空间。而且每次对数据的变化要在所有包含数据的索引中全部都修改一次，性能也非常低下。</p>
<p>回表查询会增加额外的磁盘访问开销和数据传输开销，降低查询的性能。回表的记录越少，性能提升就越高，需要回表的记录越多，使用二级索引的性能就越低，甚至让某些查询宁愿使用全表扫描也不使用二级索引。</p>
<p>至于采取何种扫描方式是由查询优化器决定。查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引+回表的方式。</p>
<p>下面分析一下，执行如下的SQL语句时，具体的查找的过程：</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026593.png" alt=""></p>
<ol>
<li>由于是根据 name 字段进行查询，所以先根据 <code>name=&#39;Arm&#39;</code> 到 name 字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li>
<li>由于查询返回的是整行的数据，因此还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。</li>
<li>最终拿到这一行的数据，直接返回即可。</li>
</ol>
<h4 id="5-2-5-辅助索引-二级索引（Secondary-Index）"><a href="#5-2-5-辅助索引-二级索引（Secondary-Index）" class="headerlink" title="5.2.5. 辅助索引/二级索引（Secondary Index）"></a>5.2.5. 辅助索引/二级索引（Secondary Index）</h4><p>聚簇索引只能在搜索条件是主键值时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。如果以别的列作为搜索条件时，通常会给这些列建立索引，这些索引被称为辅助索引/二级索引。唯一索引，普通索引，前缀索引等索引均属于二级索引。</p>
<p>辅助索引(Secondary Index，也称二级索引、非聚集索引)，叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签(bookmark)。该书签用来告诉 InnoDB 存储引擎哪里可以找到与索引相对应的行数据。因此 InnoDB 存储引擎的辅助索引的书签就是相应行数据的聚集索引键。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026594.png" alt=""></p>
<p>辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引。</p>
<h4 id="5-2-6-联合索引-复合索引"><a href="#5-2-6-联合索引-复合索引" class="headerlink" title="5.2.6. 联合索引/复合索引"></a>5.2.6. 联合索引/复合索引</h4><p>构建索引可以包含多个字段，将表上的多个列组合起来进行索引，称之为联合索引或者复合索引。</p>
<font color=red>**值得注意的是：联合索引只会建立1棵B+树；而对多个列分别建立索引（辅助索引）则会分别以每个列则建立B+树，有几个列就有几个B+树**</font>。

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026595.png)

联合索引的结构是按定义时的列的顺序，逐个排序建立索引。如`index(note,b)`在索引构建如下：

1. 先把各个记录按照 note 列进行排序
2. 在记录的 note 列相同的情况下，采用 b 列进行排序
3. 最终叶子节点存储聚集索引的主键列

### 5.3. 覆盖索引/索引覆盖

InnoDB 存储引擎支持覆盖索引(covering index，或称索引覆盖)，即从辅助索引中字段包含了需要查询的字段，那可以直接得到查询的记录，而不需要**回表**查询聚集索引中的记录。使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的 IO 操作。

> <font color=red>**注意：覆盖索引并不是索引类型的一种**</font>。

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026596.png)

不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以 MySQL 使用 b+树索引做覆盖索引。

### 5.4. 自适应哈希索引

B+树的查找次数，取决于 B+树的高度，在生产环境中，B+树的高度一般为 3~4 层，故需要 3~4 次的 IO 查询。

InnoDB 存储引擎内部自己去监控索引表，如果监控到某个索引经常用，那么就认为是热数据，然后内部自己创建一个 hash 索引，称之为自适应哈希索引( Adaptive Hash Index,AHI)，创建以后，如果下次又查询到这个索引，那么直接通过 hash 算法推导出记录的地址，直接一次就能查到数据，比重复去B+tree 索引中查询三四次节点的效率高了不少。

InnoDB 存储引擎使用的哈希函数采用除法散列方式，其冲突机制采用链表方式。注意，对于自适应哈希索引仅是数据库自身创建并使用的，用户并不能对其进行干预。查询当前自适应哈希索引的使用状况的命令如下：

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engine innodb status\G;</span><br></pre></td></tr></table></figure>

![](https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026597.png)

哈希索引只能用来搜索等值的查询，如`SELECT* FROM table WHERE indexcol=xxx`。而对于其他查找类型，如范围查找，是不能使用哈希索引。

> 由于 AHI 是由 InnoDB 存储引擎控制的，因此这里的信息只供我们参考。不过我们可以通过观察 SHOW ENGINE INNODB STATUS 的结果及参数 innodb_adaptive_hash_index 来考虑是禁用或启动此特性，默认 AHI 为开启状态。
>
> 什么时候需要禁用呢？如果发现监视索引查找和维护哈希索引结构的额外开销远远超过了自适应哈希索引带来的性能提升就需要关闭这个功能。
>
> 同时在 MySQL 5.7 中，自适应哈希索引搜索系统被分区。每个索引都绑定到一个特定的分区，每个分区都由一个单独的 latch 锁保护。分区由innodb_adaptive_hash_index_parts 配置选项控制 。在早期版本中，自适应哈希索引搜索系统受到单个 latch 锁的保护，这可能成为繁重工作负载下的争用点。innodb_adaptive_hash_index_parts 默认情况下，该 选项设置为 8。最大设置为 512。禁用或启动此特性和调整分区个数是 DBA 的工作，我们了解即可。

### 5.5. 全文检索之倒排索引

全文检索（Full-Text Search）：是将存储于数据库中的整本书或整篇文章中的任意内容信息查找出来的技术。它可以根据需要获得全文中有关章、节、段、句、词等信息，也可以进行各种统计和分析。比较熟知的如 Elasticsearch、Solr 等就是全文检索引擎，底层都是基于 Apache Lucene 的。

倒排索引就是，将文档中包含的关键字全部提取处理，然后再将关键字和文档之间的对应关系保存起来，最后再对关键字本身做索引排序。用户在检索某一个关键字是，先对关键字的索引进行查找，再通过关键字与文档的对应关系找到所在文档。

> *注：具体如何使用 InnoDB 存储引擎的全文检索，查阅相关官方文档或者书籍*

### 5.6. InnoDB 索引的限制

> 参考官方文档：https://dev.mysql.com/doc/refman/8.0/en/innodb-limits.html

- 一个表最多可包含 1017 列。虚拟生成的列也包含在此限制内。
- <font color=red>**一个表最多可包含 64 个二级索引**</font>。
- 索引键前缀长度限制为 3072 字节。尝试使用超过限制的索引键前缀长度会返回错误。
    - 对于使用 REDUNDANT 或 COMPACT 行格式的 InnoDB 表，索引键前缀长度限制为 767 字节。假设使用 utf8mb4 字符集，每个字符最多 4 字节，那么 TEXT 或 VARCHAR 列的列前缀索引长度超过 191 个字符时，就可能会达到此限制。
    - 如果在创建 MySQL 实例时通过指定 innodb_page_size 选项将 InnoDB 页面大小减小到 8KB 或 4KB，那么索引键的最大长度会根据 16KB 页面大小的 3072 字节限制按比例降低。也就是说，当页面大小为 8KB 时，索引键的最大长度为 1536 字节；当页面大小为 4KB 时，索引键的最大长度为 768 字节。
- <font color=red>**多列索引最多允许 16 列**</font>。超过限制将返回错误。

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="number">1070</span> (<span class="number">42000</span>): Too many key parts specified; max <span class="number">16</span> parts allowed</span><br></pre></td></tr></table></figure>

## 6. 索引在查询中使用的原理

1. <font color=red>**一个索引对应一个B+树，索引让查询可以快速定位和扫描到需要的数据记录上，加快查询的速度。**</font>
2. <font color=red>**一个`select`查询语句在执行过程中一般最多能使用一个二级索引，即使在`where`条件中用了多个二级索引。**</font>

<h3 id="6-1-扫描区间"><a href="#6-1-扫描区间" class="headerlink" title="6.1. 扫描区间"></a>6.1. 扫描区间</h3><p>对于某个查询来说，最简单粗暴的执行方案就是扫描表中的所有记录，判断每一条记录是否符合搜索条件。如果符合，就将其发送到客户端，否则就跳过该记录。这就是<strong>全表扫描</strong>。</p>
<p>对于使用 InnoDB 存储引擎的表来说，全表扫描意味着从聚簇索引第一个叶子节点的第一条记录开始，沿着记录所在的单向链表向后扫描，直到最后一个叶子节点的最后一条记录。虽然全表扫描是一种很笨的执行方案，但却是一种万能的执行方案，所有的查询都可以使用这种方案来执行，只是效率不高。</p>
<p>有了索引，利用 B+树查找索引列值等于某个值的记录，这样可以明显减少需要扫描的记录数量。由于 B+树叶子节点中的记录是按照索引列值由小到大的顺序排序的，所以即使只扫描某个区间或者某些区间中的记录也可以明显减少需要扫描的记录数量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> id <span class="operator">&gt;=</span> <span class="number">3</span> <span class="keyword">AND</span> id<span class="operator">&lt;=</span> <span class="number">99</span>;</span><br></pre></td></tr></table></figure>
<p>以上语句是查找 id 值在<code>[3,99]</code>区间中的所有聚簇索引记录。以通过聚簇索引对应的 B+树快速地定位到 id 值为 3 的那条聚簇索引记录，然后沿着记录所在的单向链表向后扫描,直到某条聚簇索引记录的 id 值不在<code>[3,99]</code>区间中为止。</p>
<p>与全表扫描相比，扫描 id 值在[3,99]区间中的记录已经很大程度地减少了需要扫描的记录数量，所以提升了查询效率。其实所谓的全表扫描，可以理解为扫描的区间是[负无穷，正无穷]或者[第一条记录，最后一条记录]。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">&lt;</span> <span class="string">&#x27;DD00_10S&#x27;</span> <span class="keyword">AND</span> expire_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-03-22 18:28:28&#x27;</span> <span class="keyword">AND</span> order_note <span class="operator">&gt;</span> <span class="string">&#x27;7 排&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上述语句中，order_no 和 expire_time 都有索引，order_note 没有索引。这个不会出现两个扫描区间。一个<code>select</code>查询语句在执行过程中一般最多能使用一个二级索引。</p>
<p>无论用哪个索引执行查询，都需要获取到索引中的记录后，进行回表，获取到完整的用户记录后再根据判定条件判断这条记录是否满足 SQL 语句的要求。</p>
<h3 id="6-2-范围区间扫描"><a href="#6-2-范围区间扫描" class="headerlink" title="6.2. 范围区间扫描"></a>6.2. 范围区间扫描</h3><p>对于B+树索引来说，只要索引列和常数使用<code>=</code>、<code>&lt;=&gt;</code>、<code>IN</code>、<code>NOT IN</code>、<code>IS NULL</code>、<code>IS NOT NULL</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>、<code>!=</code>（不等于也可以写成<code>&lt;&gt;</code>）或者 <code>LIKE</code> 操作符连接起来，就可以产生一个区间。</p>
<ol>
<li><code>IN</code> 操作符的效果和若干个等值匹配操作符<code>=</code>之间用<code>OR</code>连接起来是一样的，也就是说会产生多个单点区间，比如下边这两个语句的效果是一样的：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="keyword">IN</span> (<span class="number">2021</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">42</span>, yyyy);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time<span class="operator">=</span> <span class="number">2021</span><span class="number">-03</span><span class="number">-22</span> <span class="number">18</span>:<span class="number">23</span>:<span class="number">42</span> <span class="keyword">OR</span> insert_time <span class="operator">=</span> yyyy;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>!=</code> 一般会产生的两个扫描区间，即[第一条记录, 不等于表达式的值]和[不等于表达式的值, 最后一条记录]</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">!=</span> <span class="string">&#x27;DD00_9S&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>LIKE</code> 操作符比较特殊，只有在匹配完整的字符串或者匹配字符串前缀时才产生合适的扫描区间。</li>
</ol>
<p>对于某个索引列来说，字符串前缀相同的记录在由记录组成的单向链表中肯定是相邻的。比如有一个搜索条件是 <code>note LIKE &#39;b%&#39;</code>，对于二级索引 idx_note 来说，所有字符串前缀为<code>&#39;b&#39;</code>的二级索引记录肯定是相邻的。这也就意味着只要定位到 idx_note 值的字符串前缀为<code>&#39;b&#39;</code>的第一条记录，就可以沿着记录所在的单向链表向后扫描，直到某条二级索引记录的字符串前缀不为<code>&#39;b&#39;</code>为止。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026598.png" alt=""></p>
<h3 id="6-3-所有搜索条件都可以使用某个索引的情况"><a href="#6-3-所有搜索条件都可以使用某个索引的情况" class="headerlink" title="6.3. 所有搜索条件都可以使用某个索引的情况"></a>6.3. 所有搜索条件都可以使用某个索引的情况</h3><p>每个搜索条件都可以使用到某个索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- AND 的方式连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_6S&#x27;</span> <span class="keyword">AND</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span>;</span><br><span class="line"><span class="comment">-- OR 的方式连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_6S&#x27;</span> <span class="keyword">OR</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><code>AND</code>连接搜索条件时，取交集；<code>OR</code>连接搜索条件时，取并集；</p>
<h3 id="6-4-有的搜索条件无法使用索引的情况"><a href="#6-4-有的搜索条件无法使用索引的情况" class="headerlink" title="6.4. 有的搜索条件无法使用索引的情况"></a>6.4. 有的搜索条件无法使用索引的情况</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> expire_time<span class="operator">&gt;</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span> <span class="keyword">AND</span> order_note <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面示例这个查询语句中能利用的索引只有 idx_expire_time 一个，而 idx_expire_time 这个二级索引的记录中又不包含 order_note 这个字段，所以在使用二级索引 idx_expire_time 定位记录的阶段用不到 <code>order_note = &#39;abc&#39;</code>这个条件，而范围区间是为了到索引中取记录中提出的概念，所以在确定范围区间的时候不需要考虑 <code>order_note = &#39;abc&#39;</code>这个条件。即可以将语句简化成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> expire_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>or</code>连接搜索条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> expire_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span> <span class="keyword">OR</span> order_note <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>一个使用到索引的搜索条件和没有使用该索引的搜索条件使用<code>OR</code>连接起来后是无法使用该索引的。因为索引expire_time列不包含非索引的order_note字段，所以无法判断非索引的order_note字段是否满足搜索条件，又因为是<code>OR</code>条件连接，所以必须要在主键索引中从第一条记录到最后一条记录逐条判定非索引的order_note字段是否满足条件。即可以将语句简化成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp ;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-复杂搜索条件下找出范围匹配的区间"><a href="#6-5-复杂搜索条件下找出范围匹配的区间" class="headerlink" title="6.5. 复杂搜索条件下找出范围匹配的区间"></a>6.5. 复杂搜索条件下找出范围匹配的区间</h3><p>当搜索条件可能特别复杂时。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp</span><br><span class="line"><span class="keyword">WHERE</span> (order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span> <span class="keyword">AND</span> expire_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span> )</span><br><span class="line">    <span class="keyword">OR</span> (order_no <span class="operator">&lt;</span> <span class="string">&#x27;DD00_6S&#x27;</span> <span class="keyword">AND</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span>)</span><br><span class="line">    <span class="keyword">OR</span> (order_no <span class="keyword">LIKE</span> <span class="string">&#x27;%0S&#x27;</span> <span class="keyword">AND</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_12S&#x27;</span> <span class="keyword">AND</span> (expire_time <span class="operator">&lt;</span> <span class="string">&#x27;2021-03-22 18:28:28&#x27;</span> <span class="keyword">OR</span> order_note <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>)) ;</span><br></pre></td></tr></table></figure>
<p>首先查看 WHERE 子句中的搜索条件都涉及到了哪些列，哪些列可能使用到索引。这个查询的搜索条件涉及到了 order_no、expire_time、order_note 这 3 个列，然后 order_no 列有二级索引 idx_order_no，expire_time 列有二级索引idx_expire_time。对于那些可能用到的索引，分析它们的范围区间。</p>
<ul>
<li><strong>使用 idx_order_no 执行查询</strong></li>
</ul>
<p>分析时可以先那些用不到该索引的搜索条件暂时移除掉。把所有用不到的搜索条件视为True来进行中间替换，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用true代替无使用索引的搜索条件</span></span><br><span class="line">(order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span> <span class="keyword">AND</span> <span class="literal">TRUE</span> ) <span class="keyword">OR</span></span><br><span class="line">(order_no <span class="operator">&lt;</span> <span class="string">&#x27;DD00_6S&#x27;</span> <span class="keyword">AND</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span>) <span class="keyword">OR</span></span><br><span class="line">(<span class="literal">TRUE</span> <span class="keyword">AND</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_12S&#x27;</span> <span class="keyword">AND</span> (<span class="literal">TRUE</span> <span class="keyword">OR</span> <span class="literal">TRUE</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次化简</span></span><br><span class="line">(order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span>) <span class="keyword">OR</span></span><br><span class="line">(order_no <span class="operator">&lt;</span> <span class="string">&#x27;DD00_6S&#x27;</span> <span class="keyword">AND</span> order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span>) <span class="keyword">OR</span></span><br><span class="line">(order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_12S&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 替换掉永远为 TRUE 或 FALSE 的条件</span></span><br><span class="line">(order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_9S&#x27;</span>) <span class="keyword">OR</span> (order_no <span class="operator">&gt;</span> <span class="string">&#x27;DD00_12S&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>最后搜索条件是使用<code>OR</code>操作符连接起来的，意味着要取并集，所以最终的结果化简的到的区间就是：<code>order_no &gt; &#39;DD00_12S&#39;</code>。也就是说：上边那个复杂搜索条件的查询语句如果使用 idx_order_no 索引执行查询的话，需要把满足<code>order_no &gt; &#39;DD00_12S&#39;</code>的二级索引记录都取出来，然后拿着这些记录的 id 再进行回表，得到完整的用户记录之后再使用其他的搜索条件进行过滤。记住，说的是如果使用 idx_order_no 索引执行查询，不代表 MySQL 一定会使用，因为MySQL 需要做整体评估，才能确定是否使用这个索引还是别的索引，或者是干脆全表扫描。</p>
<ul>
<li><strong>使用 idx_expire_time 执行查询</strong></li>
</ul>
<p>把那些用不到该索引的搜索条件暂时使用 TRUE 条件替换掉，其中有关 order_no 和 order_note 的搜索条件都需要被替换掉，替换结果就是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="literal">TRUE</span> <span class="keyword">AND</span> expire_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span> ) <span class="keyword">OR</span></span><br><span class="line">(<span class="literal">TRUE</span> <span class="keyword">AND</span> <span class="literal">TRUE</span>) <span class="keyword">OR</span></span><br><span class="line">(<span class="literal">TRUE</span> <span class="keyword">AND</span> <span class="literal">TRUE</span> <span class="keyword">AND</span> (expire_time <span class="operator">&lt;</span> <span class="string">&#x27;2021-03-22 18:28:28&#x27;</span> <span class="keyword">OR</span> <span class="literal">TRUE</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 替换掉永远为 TRUE 或 FALSE 的条件</span></span><br><span class="line">expire_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:35:09&#x27;</span> <span class="keyword">OR</span> <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 最终结果</span></span><br><span class="line"><span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>
<p>这个结果也就意味着如果我们要使用 idx_expire_time 索引执行查询语句的话，需要扫描 idx_expire_time 二级索引的所有记录，然后再回表，这种情况下为啥 MySQL 不直接全表扫描呢？所以一定不会使用 idx_expire_time 索引的。</p>
<h3 id="6-6-使用联合索引执行查询时对应的扫描区间"><a href="#6-6-使用联合索引执行查询时对应的扫描区间" class="headerlink" title="6.6. 使用联合索引执行查询时对应的扫描区间"></a>6.6. 使用联合索引执行查询时对应的扫描区间</h3><p>联合索引的索引列包含多个列，B+树每一层页面以及每个页面中的记录采用的排序规则较为复杂，以 order_exp 表的 u_idx_day_status 联合索引为例，它采用的排序规则如下所示：</p>
<ul>
<li>先按照 insert_time 列的值进行排序</li>
<li>在 insert_time 列的值相同的情况下，再按照 order_status 列的值进行排序</li>
<li>在 insert_time 和 order_status 列的值都相同的情况下，再按照 expire_time 列的值进行排序</li>
</ul>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026599.png" alt=""></p>
<p>以下用几个查询示例来说明：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:34:55&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于二级索引记录是先按照 insert_time 列的值进行排序的，所以所有符合<code>insert_time = &#39;2021-03-22 18:34:55&#39;</code>条件的记录肯定是相邻的，可以定位到第一条符合<code>insert_time = &#39;2021-03-22 18:34:55&#39;</code>条件的记录，然后沿着记录所在的单向链表向后扫描，直到某条记录不符合<code>insert_time = &#39;2021-03-22 18:34:55&#39;</code>条件为止(当然，对于获取到的每一条二级索引记录都要执行回表操作)。</p>
<p>扫描区间就是<code>[&#39;2021-03-22 18:34:55&#39;, &#39;2021-03-22 18:34:55&#39;]</code>，形成这个扫描区间的条件就是 <code>insert_time = &#39;2021-03-22 18:34:55&#39;</code>。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">AND</span> order_status <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于二级索引记录是先按照 insert_time 列的值进行排序的；在 insert_time 列的值相等的情况下，再按照 order_status 列进行排序。所以符合 <code>insert_time = &#39;2021-03-22 18:34:55&#39; AND order_status = 0</code> 条件的二级索引记录肯定是相邻的，我们可以定位到第一条符合 <code>insert_time=&#39;2021-03-22 18:34:55&#39; AND order_status=0</code> 条件的记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合<code>insert_time=&#39;2021-03-22 18:34:55&#39;</code>条件或者<code>order_status=0</code>条件为止。</p>
<p>形成扫描区间<code>[(&#39;2021-03-22 18:34:55&#39;, 0), (&#39;2021-03-22 18:34:55&#39;, 0)]</code>，形成这个扫描区间的条件就是 <code>insert_time = &#39;2021-03-22 18:34:55&#39; AND order_status = 0</code>。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">AND</span> order_status <span class="operator">=</span> <span class="number">0</span> <span class="keyword">AND</span> expire_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:35:13&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于二级索引记录是先按照 insert_time 列的值进行排序的；在 insert_time 列的值相等的情况下，再按照 order_status 列进行排序；在 insert_time 和order_status 列的值都相等的情况下，再按照 expire_time 列进行排序。所以符合insert_time = ‘2021-03-22 18:34:55’ AND order_status = 0 AND expire_time = ‘2021-03-22 18:35:13’条件的二级索引记录肯定是相邻的，我们可以定位到第一条符合 insert_time=’2021-03-22 18:34:55’ AND order_status=0 AND expire_time=’2021-03-22 18:35:13’条件的记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 insert_time=’2021-03-22 18:34:55’条件或者order_status=0 条件或者 expire_time=’2021-03-22 18:35:13’条件为止。</p>
<p>如果使用 u_idx_day_status 索引执行查询时，可以形成扫描区间<code>[(&#39;2021-03-22 18:34:55&#39;, 0, &#39;2021-03-22 18:35:13&#39;), (&#39;2021-03-22 18:34:55&#39;, 0, &#39;2021-03-22 18:35:13&#39;)]</code>，形成这个扫描区间的条件就是<code>insert_time = &#39;2021-03-22 18:34:55&#39; AND order_status = 0 AND expire_time = &#39;2021-03-22 18:35:13&#39;</code>。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">&lt;</span> <span class="string">&#x27;2021-03-22 18:34:55&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于二级索引记录是先按照 insert_time 列的值进行排序的，所以所有符合<code>insert_time &lt; &#39;2021-03-22 18:34:55&#39;</code>条件的记录肯定是相邻的，我们可以定位到第一条符合<code>insert_time &lt; &#39;2021-03-22 18:34:55&#39;</code>条件的记录(其实就是u_idx_day_status 索引第一个叶子节点的第一条记录)，然后沿着记录所在的链表向前扫描，直到某条记录不符合 <code>insert_time &lt; &#39;2021-03-22 18:34:55&#39;</code>为止。</p>
<p>使用 u_idx_day_status 索引执行查询时，形成扫描区间<code>(第一条记录, &#39;2021-03-22 18:34:55&#39;)</code>，形成这个扫描区间的条件就是<code>insert_time &lt; &#39;2021-03-22 18:34:55&#39;</code>。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">AND</span> order_status <span class="operator">&gt;=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于二级索引记录是先按照 insert_time 列的值进行排序的；在 insert_time 列的值相等的情况下，再按照 order_status 列进行排序。也就是说在符合 insert_time = ‘2021-03-22 18:34:55’条件的二级索引记录中，是按照 order_status 列的值进行排序的，那么此时符合 <code>insert_time = &#39;2021-03-22 18:34:55&#39; AND order_status &gt;= 0;</code>条件的二级索引记录肯定是相邻的。我们可以定位到第一条符合 <code>insert_time = &#39;2021-03-22 18:34:55&#39; AND order_status &gt;= 0;</code>条件的记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 <code>insert_time=&#39;2021-03-22 18:34:55&#39;</code>条件或者<code>order_status &gt;= 0</code>条件为止。</p>
<p>使用 u_idx_day_status 索引执行查询时，形成扫描区间，条件就是<code>insert_time = &#39;2021-03-22 18:34:55&#39; AND order_status &gt;= 0;</code></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> order_status <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于二级索引记录不是直接按照 order_status 列的值排序的，所以符合<code>order_status = 1</code>的二级索引记录可能并不相邻，也就意味着不能通过这个<code>order_status = 1</code>搜索条件来减少需要扫描的记录数量。在这种情况下，是不会使用 u_idx_day_status 索引执行查询的。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:34:55&#x27;</span> <span class="keyword">AND</span> expire_time <span class="operator">=</span> <span class="string">&#x27;2021-03-22 18:35:12&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于二级索引记录是先按照 insert_time 列的值进行排序的，所以符合<code>insert_time = &#39;2021-03-22 18:34:55&#39;</code>条件的二级索引记录肯定是相邻的，但是对于符合 <code>insert_time = &#39;2021-03-22 18:34:55&#39;</code>条件的二级索引记录来说，并不是直接按照 expire_time 列进行排序的，也就是说我们不能根据搜索条件<code>expire_time = &#39;2021-03-22 18:35:12&#39;</code>来进一步减少需要扫描的记录数量。那么如果使用u_idx_day_status索引执行查询的话，可以定位到第一条符合<code>insert_time=&#39;2021-03-22 18:34:55&#39;</code>条件的记录，然后沿着记录所在的单向链表向后扫描，直到某条记录不符合<code>insert_time = &#39;2021-03-22 18:34:55&#39;</code>条件为止。</p>
<p>使用 u_idx_day_status 索引执行查询时，对应的扫描区间其实是<code>[&#39;2021-03-22 18:34:55&#39;, &#39;2021-03-22 18:34:55&#39;]</code>，形成该扫描区间的搜索条件是<code>insert_time = &#39;2021-03-22 18:34:55&#39;</code>，与<code>expire_time = &#39;2021-03-22 18:35:12&#39;</code>无关。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> order_exp <span class="keyword">WHERE</span> insert_time <span class="operator">&lt;</span> <span class="string">&#x27;2021-03-22 18:34:57&#x27;</span> <span class="keyword">AND</span> order_status <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于二级索引记录是先按照 insert_time 列的值进行排序的，所以符合<code>insert_time &lt; &#39;2021-03-22 18:34:57&#39;</code>条件的二级索引记录肯定是相邻的，但是对于符合<code>insert_time &lt; &#39;2021-03-22 18:34:57&#39;</code>条件的二级索引记录来说，并不是直接按照order_status列进行排序的，也就是说我们不能根据搜索条件<code>order_status = 0</code>来进一步减少需要扫描的记录数量。</p>
<p>使用 u_idx_day_status 索引执行查询的话，可以定位到第一条符合 insert_time 的记录，其实就是u_idx_day_status索引第一个叶子节点的第一条记录，所以在使用u_idx_day_status索引执行查询的过程中，对应的扫描区间其实是<code>[第一条记录,&#39;2021-03-22 18:34:57&#39;)</code>。</p>
</blockquote>
<h2 id="7-MyISAM-中的索引（了解）"><a href="#7-MyISAM-中的索引（了解）" class="headerlink" title="7. MyISAM 中的索引（了解）"></a>7. MyISAM 中的索引（了解）</h2><h3 id="7-1-简介"><a href="#7-1-简介" class="headerlink" title="7.1. 简介"></a>7.1. 简介</h3><p>MyISAM 存储引擎中的索引方案，虽然也使用树形结构，但是却将索引和数据分开存储的。</p>
<p><img src="https://gitee.com/Bluetom/img2/raw/master/img20240905/202410251026600.png" alt=""></p>
<p>MyISAM 将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个数据页，有多少记录就往这个文件中存多少条记录。可以通过行号而快速访问到一条记录。</p>
<p>由于在插入数据的时候并没有刻意按照主键大小排序，所以并不能在这些数据上使用二分法进行查找。</p>
<p>使用 MyISAM 存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中。MyISAM 会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值+行号的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录。<em>这一点和 InnoDB 是完全不相同的，在 InnoDB 存储引擎中，只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录</em>，而<strong>在 MyISAM 中却需要进行一次回表操作，意味着 MyISAM 中建立的索引相当于全部都是二级索引</strong>。</p>
<p>如有需要，也可以对其它的列分别建立索引或者建立联合索引，原理和 InnoDB 中的索引差不多，不过在叶子节点处存储的是相应的列+行号。这些索引也全部都是二级索引。</p>
<h3 id="7-2-MyISAM-索引与-InnoDB-索引的区别"><a href="#7-2-MyISAM-索引与-InnoDB-索引的区别" class="headerlink" title="7.2. MyISAM 索引与 InnoDB 索引的区别"></a>7.2. MyISAM 索引与 InnoDB 索引的区别</h3><ul>
<li>InnoDB 索引是聚簇索引；MyISAM 索引是非聚簇索引。</li>
<li>InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效；MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。即在 InnoDB 存储引擎中，根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在 MyISAM 则需要进行一次回表操作，意味着 MyISAM 中建立的索引相当于全部都是二级索引（非聚簇索引）。</li>
<li>InnoDB 的非聚簇索引的叶子节点存储的是主键和其他带索引的列数据；而 MyISAM 索引记录的是地址 。换句话说，InnoDB 的所有非聚簇索引都引用主键作为 data 域，因此查询时做到覆盖索引会非常高效。</li>
<li>InnoDB 的数据文件本身就是索引文件；而 MyISAM 索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址。<ul>
<li>MyISAM 的表在磁盘上存储的文件中：<code>*.sdi</code>（描述表结构）、<code>*.MYD</code>（数据），<code>*.MYI</code>（索引）</li>
<li>InnoDB 的表在磁盘上存储的文件中：<code>.ibd</code>（表结构、索引和数据都存在一起）</li>
</ul>
</li>
<li>MyISAM 的回表操作十分快速，因为是通过地址偏移量直接到文件中取数据的；而 InnoDB 是通过获取主键之后再去聚簇索引里找记录，速度比不上直接用地址去访问。</li>
<li>InnoDB 要求表必须有主键。如果没有显式指定，则 MySQL 系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型；而 MyISAM 可以没有主键。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io">蓝桉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ktzxy.github.io/posts/d97c3bd3.html">https://ktzxy.github.io/posts/d97c3bd3.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ktzxy.github.io" target="_blank">蓝桉`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post-share"><div class="social-share" data-image="/bg/Image00025.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><link rel="stylesheet" href="/css/coin/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">不给糖果就捣蛋</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.webp" target="_blank"><img class="post-qr-code-img" src="/img/wechat.webp" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.webp" target="_blank"><img class="post-qr-code-img" src="/img/alipay.webp" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></button></div><audio id="coinAudio" src="https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin/coin.js"></script><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/884c668c.html" title="MySQL-进阶"><img class="cover" src="/bg/Image00015.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MySQL-进阶</div></div><div class="info-2"><div class="info-item-1">1. MySQL 的视图1.1. 简述视图（view）是一个虚拟表，非真实存在，其本质是根据 SQL 语句获取动态的数据集，并为其命名，用户使用时只需使用视图名称即可获取结果集，并可以将其当作表来使用。 数据库中只存放了视图的定义，而并没有存放视图中的数据（即只保存了查询的 SQL 逻辑，不保存查询结果）。这些数据存放在原来的表中。 使用视图查询数据时，数据库系统会从原来的表中取出对应的数据。因此，视图中的数据是依赖于原来的表中的数据的。一旦表中的数据发生改变，显示在视图中的数据也会发生改变。 1.2. 视图的语法1.2.1. 创建视图1234create [or replace] [algorithm = &#123;undefined | merge | temptable&#125;]view view_name [(column_list)]as select_statement[with [cascaded | local] check option] 参数说明：  algorithm：可选项，表示视图选择的算法。 view_name：表示要创建的视图名称。 colum...</div></div></div></a><a class="pagination-related" href="/posts/e582bf51.html" title="MySQL-性能优化"><img class="cover" src="/bg/Image00013.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MySQL-性能优化</div></div><div class="info-2"><div class="info-item-1">1. 性能优化总论 上图显示，越往上走，难度越来越高，收益却是越来越小的。 比如硬件和 OS 调优，需要对硬件和 OS 有着非常深刻的了解，仅仅就磁盘一项来说，一般非 DBA 能想到的调整就是 SSD 盘比用机械硬盘更好，但其实它至少包括了，使用什么样的磁盘阵列（RAID）级别、是否可以分散磁盘 IO、是否使用裸设备存放数据，使用哪种文件系统（目前比较推荐的是 XFS），操作系统的磁盘调度算法（目前比较推荐 deadline，对机械硬盘和 SSD 都比较合适。从内核 2.5开始，默认的 I/O 调度算法是 Deadline，之后默认 I/O 调度算法为 Anticipatory，直到内核 2.6.17 为止，从内核 2.6.18 开始，CFQ 成为默认的 IO 调度算法，但CFQ 并不推荐作为数据库服务器的磁盘调度算法。）选择，是否需要调整操作系统文件管理方面比如 atime 属性等等。  TIPS：裸设备(raw device)，也叫裸分区（原始分区），是一种没有经过格式化，不被 Unix 通过文件系统来读取的特殊块设备文件。由应用程序负责对它进行读写操作。不经过文件系统的缓冲...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img class="cover" src="/bg/Image00018.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">MySQL数据库150道高频面试题</div></div><div class="info-2"><div class="info-item-1">[toc] 1. Mysql 索引1.1. Mysql如何实现的索引机制？MySQL中索引分三类：B+树索引、Hash索引、全文索引 1.1.1. InnoDB索引与MyISAM索引实现的区别是什么？ MyISAM的索引方式都是非聚簇的，与InnoDB包含1个聚簇索引是不同的。 在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录，而在MyISAM中却需要进行一次回表操作，意味着MyISAM中建立的索引相当于全部都是二级索引。 InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是分离的 ，索引文件仅保存数据记录的地址。 MyISAM的表在磁盘上存储在以下文件中：  *.sdi（描述表结构）、*.MYD（数据），*.MYI（索引） InnoDB的表在磁盘上存储在以下文件中： .ibd（表结构、索引和数据都存在一起）   InnoDB的非聚簇索引data域存储相应记录主键的值 ，而MyISAM索引记录的是地址 。换句话说，InnoDB的所有非聚簇索引都引用主键作为data域。 MyISAM的回表操作是十分快速的，因为是拿着地址偏...</div></div></div></a><a class="pagination-related" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img class="cover" src="/bg/Image00014.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">技术同学必会的MySQL设计规约</div></div><div class="info-2"><div class="info-item-1">在我们对数据库技术方案设计的时候，我们是否有自己的设计理念或者原则，还是更多的依据自己的直觉去设计，是否曾经懊悔线上发生过的一次低级故障，可能稍微注意点就可以避免，是否想过怎么才能很好的避免，下面规范的价值正是我们工作的检查清单，需要我们不断从错误中积累有效经验来指导未来的工作。以下规范在大型互联网公司经过了充分的验证，尤其适用于并发量大、数据量大的业务场景。先介绍的是安全规范，因为安全无小事，很多公司都曾经因为自己的数据泄露导致用户的惨痛损失，所以将安全规范放到了第一位。﻿ 一、安全规范1.【强制】禁止在数据库中存储明文密码，需把密码加密后存储 说明：对于加密操作建议由公司的中间件团队基于如mybatis的扩展，提供统一的加密算法及密钥管理，避免每个业务线单独开发一套，同时也与具体的业务进行了解耦 2.【强制】禁止在数据库中明文存储用户敏感信息，如手机号等 说明：对于手机号建议公司搭建统一的手机号查询服务，避免在每个业务线单独存储 3.【强制】禁止开发直接给业务同学导出或者查询涉及到用户敏感信息的数据，如需要需上级领导审批 4.【强制】涉及到导出数据功能的操作，如包含敏感字段都...</div></div></div></a><a class="pagination-related" href="/posts/dfdfdf4.html" title="数据库概述"><img class="cover" src="/bg/Image00002.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">数据库概述</div></div><div class="info-2"><div class="info-item-1">1. 数据库技术1.1. 概述数据库（DB）是一个以某种组织方式存储在磁盘上的数据的集合。简单理解就是用来存储数据的仓库。  数据库 DataBase（DB）：存储数据的仓库，数据是有组织的进行存储。 数据库管理系统 DataBase Management System (DBMS)：操纵和管理数据库的大型软件。  1.2. 数据库的分类  1.3. 不同的数据存储方式数据存储在集合（内存）中  优点：读写速度快 缺点：不能永久存储  数据存储在文件中  优点：可以永久存储 缺点：频繁的IO操作效率低，查询数据很不方便。  数据存储在数据库中  优点：可以永久存储。查询速度快，查询数据很方便 缺点：要使用 SQL 语言执行增删改查操作  2. 关系型数据库 关系型数据库 - 百度百科  2.1. 概念关系型数据库，是指采用了关系模型来组织数据的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。用户通过查询来检索数据库中的数据，而查询是一个用于限定数据库中某些区域的执行代码。关系模型可以简单理解为二维表格模型，而一个关系型数...</div></div></div></a><a class="pagination-related" href="/posts/75522c08.html" title="第4节-布隆过滤器"><img class="cover" src="/bg/Image00003.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">第4节-布隆过滤器</div></div><div class="info-2"><div class="info-item-1">第4节-布隆过滤器BloomFilter面试题： 现有50亿个电话号码，选定其中10w个电话号码，如何要快速准确的判断这些号码是否已经存在？ 思路：  1、通过数据库查询———-实现快速有点难。  2、数据预放到内存集合中：50亿*8字节大约40G，内存太大了。 1、布隆过滤器是什么？它实际上==是一个很长的二进制数组+一系列随机hash算法映射函数，主要用于判断一个元素是否在集合中==。 通常我们会遇到很多要判断一个元素是否在某个集合中的业务场景，一般想到的是将集合中所有元素保存起来，然后通过比较确定。 链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。 但是随着集合中元素的增加，我们需要的存储空间也会呈现线性增长，最终达到瓶颈。 同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为O(n),O(logn),O(1)。这个时候，布隆过滤器（Bloom Filter）就应运而生  一句话概述：由一个初值为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在。 本质就是判断具体元素存不存在一个大的集合中。 布隆过滤器是一种类似set的数据...</div></div></div></a><a class="pagination-related" href="/posts/e4cd3c5b.html" title="第5节-缓存预热+缓存雪崩+缓存击穿+缓存穿透"><img class="cover" src="/bg/Image00008.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">第5节-缓存预热+缓存雪崩+缓存击穿+缓存穿透</div></div><div class="info-2"><div class="info-item-1">第5节-缓存预热+缓存雪崩+缓存击穿+缓存穿透1、缓存雪崩发生情况： ​    redis主机挂了，redis全盘崩溃，比如缓存中有大量数据同时过期。 解决方案：  redis缓存集群实现高可用，主从+哨兵|| redis cluster ehcache本地缓存 + hystrix 或者 阿里sentinel限流&amp;降级 开启Redis持久化机制/aof+rdb，尽快恢复缓存集群 2、缓存穿透 什么是缓存穿透  请求去查询一条记录，先redis后mysql发现，都查不到该条记录，但是每次请求都会打到数据库上面去，导致后台数据库压力暴增，这种现象我们称为缓存穿透，redis成为了一个摆设。 简单说就是，本来无一物，即不再redis中，也不在mysql中。  危害  数据库可能会被打崩。导致服务不可用。 第一次来查询后，一般我们会有回写redis机制， 第二次来查询的时候redis就有了，偶尔出现穿透现象一般情况无关紧要。  解决方案   1、返回空对象缓存或者缺省值 一般OK  但是存在黑客和恶意攻击情况 黑客会对你的系统进行攻击，拿到一个不存在的id，去查询数据，会产生大量...</div></div></div></a><a class="pagination-related" href="/posts/41ae0132.html" title="MongoDB-基础"><img class="cover" src="/bg/Image00026.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-09</div><div class="info-item-2">MongoDB-基础</div></div><div class="info-2"><div class="info-item-1">1. MongoDb 概述MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。 1.1. MongoDB 特点MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。它是一个面向集合的，模式自由的文档型数据库，具体特点总结如下：  面向集合存储，易于存储对象类型的数据 模式自由 支持动态查询 支持完全索引，包含内部对象 支持复制和故障恢复 使用高效的二进制数据存储，包括大型对象（如视频等） 自动处理碎片，以支持云计算层次的扩展性 支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，社区中也提供了对 Erlang 及.NET 等平台的驱动程序 文件存储格式为 BSON（一种 JSON 的...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">蓝桉</div><div class="author-info-description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">生活、学习、技术</b>相关的问题和看法，还有<b style="color:#fff">文章教程</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">264</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ktzxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/ktzxy" target="_blank" title="Github"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2251511764@qq.com" target="_blank" title="Email"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-RSS"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/496148176" target="_blank" title="BiliBili"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QX-BILIBILI"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2251511764&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" target="_blank" title="QQ"><svg class="social_icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1. 索引概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. 什么是索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 索引的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1. 索引的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7%EF%BC%88%E5%8A%A3%E5%8A%BF%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2. 索引的代价（劣势）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">2. 索引的基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 查看索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%88%9B%E5%BB%BA-%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 创建&#x2F;修改索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1. 语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2. 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3. 两种创建索引方式的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 删除索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%A4%A7%E8%A1%A8%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. 大表添加索引的优化方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%EF%BC%88%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%B4%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">3. 索引结构（从数据结构维度划分）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-BTREE-%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. BTREE 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-B-TREE-%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. B+TREE 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-B-TREE-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. B+TREE 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-MySQL-%E4%B8%AD%E7%9A%84-B-Tree"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. MySQL 中的 B+Tree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%A3%81%E7%9B%98%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 磁盘和B+树的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1. 磁盘结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-B-%E6%A0%91%E7%BB%93%E6%9E%84%E5%9C%A8%E7%A3%81%E7%9B%98%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2. B+树结构在磁盘的存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Hash-%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. Hash 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-Hash-%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E4%BC%98%E5%8A%A3%E6%AF%94%E8%BE%83"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2. Hash 索引和B+树优劣比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3. 存储引擎支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-B-%E6%A0%91%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93"><span class="toc-number">3.5.</span> <span class="toc-text">3.5. B+树作用与索引总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E4%B8%BA%E4%BB%80%E4%B9%88-InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8-B-tree-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1. 为什么 InnoDB 存储引擎选择使用 B+tree 索引结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB%EF%BC%88%E4%BB%8E%E5%BA%94%E7%94%A8%E7%BB%B4%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">4. 索引分类（从应用维度划分）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 普通索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 唯一索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 主键索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%A4%8D%E5%90%88%E4%B8%BB%E9%94%AE-%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1. 复合主键&#x2F;联合主键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2. 主键索引与唯一索引的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%BB%84%E5%90%88%EF%BC%88%E5%A4%8D%E5%90%88%E3%80%81%E8%81%94%E5%90%88%EF%BC%89%E7%B4%A2%E5%BC%95"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. 组合（复合、联合）索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. 前缀索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">4.6.</span> <span class="toc-text">4.6. 全文索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.6.1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-2-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.6.2. 注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-3-%E6%9C%80%E5%B0%8F%E6%90%9C%E7%B4%A2%E9%95%BF%E5%BA%A6%E5%92%8C%E6%9C%80%E5%A4%A7%E6%90%9C%E7%B4%A2%E9%95%BF%E5%BA%A6"><span class="toc-number">4.6.3.</span> <span class="toc-text">4.6.3. 最小搜索长度和最大搜索长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-4-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E8%AF%AD%E6%B3%95"><span class="toc-number">4.6.4.</span> <span class="toc-text">4.6.4. 全文索引创建语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-5-%E4%BD%BF%E7%94%A8%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="toc-number">4.6.5.</span> <span class="toc-text">4.6.5. 使用全文索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95-%E5%B0%91%E7%94%A8%EF%BC%8C%E4%BA%86%E8%A7%A3"><span class="toc-number">4.7.</span> <span class="toc-text">4.7. 空间索引(少用，了解)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-InnoDB-%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%88%E6%8C%89%E7%85%A7%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">5. InnoDB 中的索引（按照底层存储方式划分）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%EF%BC%88Clustered-Index%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 聚集索引&#x2F;聚簇索引（Clustered Index）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1. 聚簇索引介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2. 聚簇索引的优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 非聚簇索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1. 非聚簇索引简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2. 非聚簇索引的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3. 聚集索引和非聚集索引的结构对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-%E5%9B%9E%E8%A1%A8"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4. 回表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%88Secondary-Index%EF%BC%89"><span class="toc-number">5.2.5.</span> <span class="toc-text">5.2.5. 辅助索引&#x2F;二级索引（Secondary Index）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-6-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">5.2.6.</span> <span class="toc-text">5.2.6. 联合索引&#x2F;复合索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4"><span class="toc-number">5.3.</span> <span class="toc-text">6.1. 扫描区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E8%8C%83%E5%9B%B4%E5%8C%BA%E9%97%B4%E6%89%AB%E6%8F%8F"><span class="toc-number">5.4.</span> <span class="toc-text">6.2. 范围区间扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%89%80%E6%9C%89%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E6%9F%90%E4%B8%AA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">5.5.</span> <span class="toc-text">6.3. 所有搜索条件都可以使用某个索引的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%9C%89%E7%9A%84%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">5.6.</span> <span class="toc-text">6.4. 有的搜索条件无法使用索引的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%A4%8D%E6%9D%82%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%89%BE%E5%87%BA%E8%8C%83%E5%9B%B4%E5%8C%B9%E9%85%8D%E7%9A%84%E5%8C%BA%E9%97%B4"><span class="toc-number">5.7.</span> <span class="toc-text">6.5. 复杂搜索条件下找出范围匹配的区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E6%97%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E6%89%AB%E6%8F%8F%E5%8C%BA%E9%97%B4"><span class="toc-number">5.8.</span> <span class="toc-text">6.6. 使用联合索引执行查询时对应的扫描区间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-MyISAM-%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">7. MyISAM 中的索引（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">7.1. 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-MyISAM-%E7%B4%A2%E5%BC%95%E4%B8%8E-InnoDB-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">7.2. MyISAM 索引与 InnoDB 索引的区别</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题"><img src="/bg/Image00018.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL数据库150道高频面试题"/></a><div class="content"><a class="title" href="/posts/a318ca1f.html" title="MySQL数据库150道高频面试题">MySQL数据库150道高频面试题</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术同学必会的MySQL设计规约"/></a><div class="content"><a class="title" href="/posts/8f9b37aa.html" title="技术同学必会的MySQL设计规约">技术同学必会的MySQL设计规约</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dfdfdf4.html" title="数据库概述"><img src="/bg/Image00002.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库概述"/></a><div class="content"><a class="title" href="/posts/dfdfdf4.html" title="数据库概述">数据库概述</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/490575ab.html" title="24工厂模式俗话解释"><img src="/bg/Image00024.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24工厂模式俗话解释"/></a><div class="content"><a class="title" href="/posts/490575ab.html" title="24工厂模式俗话解释">24工厂模式俗话解释</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/364ea8cc.html" title="设计模式"><img src="/bg/Image00014.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式"/></a><div class="content"><a class="title" href="/posts/364ea8cc.html" title="设计模式">设计模式</a><time datetime="2025-07-09T17:28:46.000Z" title="发表于 2025-07-09 17:28:46">2025-07-09</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2020 - 2025 By 蓝桉</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8152976493" data-server="netease" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><script async src="//at.alicdn.com/t/c/font_4379924_273fk05h86zi.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat/cat.js"></script><script async data-pjax src="/js/meting/music_lanan.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/day/lunar.js"></script><script defer src="/js/day/day.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '10a7db1c41b6489db9c830c668a18304';
  var gaud_map_key = '82a64bc994fb6494830f157f319f9f69';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime/runtime.min.js"></script><script async src="/js/font/ali_font_all.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>